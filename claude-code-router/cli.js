#!/usr/bin/env node
"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __esm = (fn, res) => function __init() {
  return fn && (res = (0, fn[__getOwnPropNames(fn)[0]])(fn = 0)), res;
};
var __commonJS = (cb, mod) => function __require() {
  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));

// node_modules/json5/lib/unicode.js
var require_unicode = __commonJS({
  "node_modules/json5/lib/unicode.js"(exports2, module2) {
    module2.exports.Space_Separator = /[\u1680\u2000-\u200A\u202F\u205F\u3000]/;
    module2.exports.ID_Start = /[\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u05D0-\u05EA\u05F0-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u0860-\u086A\u08A0-\u08B4\u08B6-\u08BD\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u09FC\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0AF9\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C58-\u0C5A\u0C60\u0C61\u0C80\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D54-\u0D56\u0D5F-\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1877\u1880-\u1884\u1887-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4B\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1C80-\u1C88\u1CE9-\u1CEC\u1CEE-\u1CF1\u1CF5\u1CF6\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u212F-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2E2F\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303C\u3041-\u3096\u309D-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312E\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FEA\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA69D\uA6A0-\uA6EF\uA717-\uA71F\uA722-\uA788\uA78B-\uA7AE\uA7B0-\uA7B7\uA7F7-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA8FD\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uA9E0-\uA9E4\uA9E6-\uA9EF\uA9FA-\uA9FE\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA7E-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB65\uAB70-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]|\uD800[\uDC00-\uDC0B\uDC0D-\uDC26\uDC28-\uDC3A\uDC3C\uDC3D\uDC3F-\uDC4D\uDC50-\uDC5D\uDC80-\uDCFA\uDD40-\uDD74\uDE80-\uDE9C\uDEA0-\uDED0\uDF00-\uDF1F\uDF2D-\uDF4A\uDF50-\uDF75\uDF80-\uDF9D\uDFA0-\uDFC3\uDFC8-\uDFCF\uDFD1-\uDFD5]|\uD801[\uDC00-\uDC9D\uDCB0-\uDCD3\uDCD8-\uDCFB\uDD00-\uDD27\uDD30-\uDD63\uDE00-\uDF36\uDF40-\uDF55\uDF60-\uDF67]|\uD802[\uDC00-\uDC05\uDC08\uDC0A-\uDC35\uDC37\uDC38\uDC3C\uDC3F-\uDC55\uDC60-\uDC76\uDC80-\uDC9E\uDCE0-\uDCF2\uDCF4\uDCF5\uDD00-\uDD15\uDD20-\uDD39\uDD80-\uDDB7\uDDBE\uDDBF\uDE00\uDE10-\uDE13\uDE15-\uDE17\uDE19-\uDE33\uDE60-\uDE7C\uDE80-\uDE9C\uDEC0-\uDEC7\uDEC9-\uDEE4\uDF00-\uDF35\uDF40-\uDF55\uDF60-\uDF72\uDF80-\uDF91]|\uD803[\uDC00-\uDC48\uDC80-\uDCB2\uDCC0-\uDCF2]|\uD804[\uDC03-\uDC37\uDC83-\uDCAF\uDCD0-\uDCE8\uDD03-\uDD26\uDD50-\uDD72\uDD76\uDD83-\uDDB2\uDDC1-\uDDC4\uDDDA\uDDDC\uDE00-\uDE11\uDE13-\uDE2B\uDE80-\uDE86\uDE88\uDE8A-\uDE8D\uDE8F-\uDE9D\uDE9F-\uDEA8\uDEB0-\uDEDE\uDF05-\uDF0C\uDF0F\uDF10\uDF13-\uDF28\uDF2A-\uDF30\uDF32\uDF33\uDF35-\uDF39\uDF3D\uDF50\uDF5D-\uDF61]|\uD805[\uDC00-\uDC34\uDC47-\uDC4A\uDC80-\uDCAF\uDCC4\uDCC5\uDCC7\uDD80-\uDDAE\uDDD8-\uDDDB\uDE00-\uDE2F\uDE44\uDE80-\uDEAA\uDF00-\uDF19]|\uD806[\uDCA0-\uDCDF\uDCFF\uDE00\uDE0B-\uDE32\uDE3A\uDE50\uDE5C-\uDE83\uDE86-\uDE89\uDEC0-\uDEF8]|\uD807[\uDC00-\uDC08\uDC0A-\uDC2E\uDC40\uDC72-\uDC8F\uDD00-\uDD06\uDD08\uDD09\uDD0B-\uDD30\uDD46]|\uD808[\uDC00-\uDF99]|\uD809[\uDC00-\uDC6E\uDC80-\uDD43]|[\uD80C\uD81C-\uD820\uD840-\uD868\uD86A-\uD86C\uD86F-\uD872\uD874-\uD879][\uDC00-\uDFFF]|\uD80D[\uDC00-\uDC2E]|\uD811[\uDC00-\uDE46]|\uD81A[\uDC00-\uDE38\uDE40-\uDE5E\uDED0-\uDEED\uDF00-\uDF2F\uDF40-\uDF43\uDF63-\uDF77\uDF7D-\uDF8F]|\uD81B[\uDF00-\uDF44\uDF50\uDF93-\uDF9F\uDFE0\uDFE1]|\uD821[\uDC00-\uDFEC]|\uD822[\uDC00-\uDEF2]|\uD82C[\uDC00-\uDD1E\uDD70-\uDEFB]|\uD82F[\uDC00-\uDC6A\uDC70-\uDC7C\uDC80-\uDC88\uDC90-\uDC99]|\uD835[\uDC00-\uDC54\uDC56-\uDC9C\uDC9E\uDC9F\uDCA2\uDCA5\uDCA6\uDCA9-\uDCAC\uDCAE-\uDCB9\uDCBB\uDCBD-\uDCC3\uDCC5-\uDD05\uDD07-\uDD0A\uDD0D-\uDD14\uDD16-\uDD1C\uDD1E-\uDD39\uDD3B-\uDD3E\uDD40-\uDD44\uDD46\uDD4A-\uDD50\uDD52-\uDEA5\uDEA8-\uDEC0\uDEC2-\uDEDA\uDEDC-\uDEFA\uDEFC-\uDF14\uDF16-\uDF34\uDF36-\uDF4E\uDF50-\uDF6E\uDF70-\uDF88\uDF8A-\uDFA8\uDFAA-\uDFC2\uDFC4-\uDFCB]|\uD83A[\uDC00-\uDCC4\uDD00-\uDD43]|\uD83B[\uDE00-\uDE03\uDE05-\uDE1F\uDE21\uDE22\uDE24\uDE27\uDE29-\uDE32\uDE34-\uDE37\uDE39\uDE3B\uDE42\uDE47\uDE49\uDE4B\uDE4D-\uDE4F\uDE51\uDE52\uDE54\uDE57\uDE59\uDE5B\uDE5D\uDE5F\uDE61\uDE62\uDE64\uDE67-\uDE6A\uDE6C-\uDE72\uDE74-\uDE77\uDE79-\uDE7C\uDE7E\uDE80-\uDE89\uDE8B-\uDE9B\uDEA1-\uDEA3\uDEA5-\uDEA9\uDEAB-\uDEBB]|\uD869[\uDC00-\uDED6\uDF00-\uDFFF]|\uD86D[\uDC00-\uDF34\uDF40-\uDFFF]|\uD86E[\uDC00-\uDC1D\uDC20-\uDFFF]|\uD873[\uDC00-\uDEA1\uDEB0-\uDFFF]|\uD87A[\uDC00-\uDFE0]|\uD87E[\uDC00-\uDE1D]/;
    module2.exports.ID_Continue = /[\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0300-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u0483-\u0487\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u05D0-\u05EA\u05F0-\u05F2\u0610-\u061A\u0620-\u0669\u066E-\u06D3\u06D5-\u06DC\u06DF-\u06E8\u06EA-\u06FC\u06FF\u0710-\u074A\u074D-\u07B1\u07C0-\u07F5\u07FA\u0800-\u082D\u0840-\u085B\u0860-\u086A\u08A0-\u08B4\u08B6-\u08BD\u08D4-\u08E1\u08E3-\u0963\u0966-\u096F\u0971-\u0983\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BC-\u09C4\u09C7\u09C8\u09CB-\u09CE\u09D7\u09DC\u09DD\u09DF-\u09E3\u09E6-\u09F1\u09FC\u0A01-\u0A03\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A3C\u0A3E-\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A59-\u0A5C\u0A5E\u0A66-\u0A75\u0A81-\u0A83\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABC-\u0AC5\u0AC7-\u0AC9\u0ACB-\u0ACD\u0AD0\u0AE0-\u0AE3\u0AE6-\u0AEF\u0AF9-\u0AFF\u0B01-\u0B03\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3C-\u0B44\u0B47\u0B48\u0B4B-\u0B4D\u0B56\u0B57\u0B5C\u0B5D\u0B5F-\u0B63\u0B66-\u0B6F\u0B71\u0B82\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BBE-\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCD\u0BD0\u0BD7\u0BE6-\u0BEF\u0C00-\u0C03\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D-\u0C44\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C58-\u0C5A\u0C60-\u0C63\u0C66-\u0C6F\u0C80-\u0C83\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBC-\u0CC4\u0CC6-\u0CC8\u0CCA-\u0CCD\u0CD5\u0CD6\u0CDE\u0CE0-\u0CE3\u0CE6-\u0CEF\u0CF1\u0CF2\u0D00-\u0D03\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D44\u0D46-\u0D48\u0D4A-\u0D4E\u0D54-\u0D57\u0D5F-\u0D63\u0D66-\u0D6F\u0D7A-\u0D7F\u0D82\u0D83\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0DCA\u0DCF-\u0DD4\u0DD6\u0DD8-\u0DDF\u0DE6-\u0DEF\u0DF2\u0DF3\u0E01-\u0E3A\u0E40-\u0E4E\u0E50-\u0E59\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB9\u0EBB-\u0EBD\u0EC0-\u0EC4\u0EC6\u0EC8-\u0ECD\u0ED0-\u0ED9\u0EDC-\u0EDF\u0F00\u0F18\u0F19\u0F20-\u0F29\u0F35\u0F37\u0F39\u0F3E-\u0F47\u0F49-\u0F6C\u0F71-\u0F84\u0F86-\u0F97\u0F99-\u0FBC\u0FC6\u1000-\u1049\u1050-\u109D\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u135D-\u135F\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1714\u1720-\u1734\u1740-\u1753\u1760-\u176C\u176E-\u1770\u1772\u1773\u1780-\u17D3\u17D7\u17DC\u17DD\u17E0-\u17E9\u180B-\u180D\u1810-\u1819\u1820-\u1877\u1880-\u18AA\u18B0-\u18F5\u1900-\u191E\u1920-\u192B\u1930-\u193B\u1946-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u19D0-\u19D9\u1A00-\u1A1B\u1A20-\u1A5E\u1A60-\u1A7C\u1A7F-\u1A89\u1A90-\u1A99\u1AA7\u1AB0-\u1ABD\u1B00-\u1B4B\u1B50-\u1B59\u1B6B-\u1B73\u1B80-\u1BF3\u1C00-\u1C37\u1C40-\u1C49\u1C4D-\u1C7D\u1C80-\u1C88\u1CD0-\u1CD2\u1CD4-\u1CF9\u1D00-\u1DF9\u1DFB-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u203F\u2040\u2054\u2071\u207F\u2090-\u209C\u20D0-\u20DC\u20E1\u20E5-\u20F0\u2102\u2107\u210A-\u2113\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u212F-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D7F-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2DE0-\u2DFF\u2E2F\u3005-\u3007\u3021-\u302F\u3031-\u3035\u3038-\u303C\u3041-\u3096\u3099\u309A\u309D-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312E\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FEA\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA62B\uA640-\uA66F\uA674-\uA67D\uA67F-\uA6F1\uA717-\uA71F\uA722-\uA788\uA78B-\uA7AE\uA7B0-\uA7B7\uA7F7-\uA827\uA840-\uA873\uA880-\uA8C5\uA8D0-\uA8D9\uA8E0-\uA8F7\uA8FB\uA8FD\uA900-\uA92D\uA930-\uA953\uA960-\uA97C\uA980-\uA9C0\uA9CF-\uA9D9\uA9E0-\uA9FE\uAA00-\uAA36\uAA40-\uAA4D\uAA50-\uAA59\uAA60-\uAA76\uAA7A-\uAAC2\uAADB-\uAADD\uAAE0-\uAAEF\uAAF2-\uAAF6\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB65\uAB70-\uABEA\uABEC\uABED\uABF0-\uABF9\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE00-\uFE0F\uFE20-\uFE2F\uFE33\uFE34\uFE4D-\uFE4F\uFE70-\uFE74\uFE76-\uFEFC\uFF10-\uFF19\uFF21-\uFF3A\uFF3F\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]|\uD800[\uDC00-\uDC0B\uDC0D-\uDC26\uDC28-\uDC3A\uDC3C\uDC3D\uDC3F-\uDC4D\uDC50-\uDC5D\uDC80-\uDCFA\uDD40-\uDD74\uDDFD\uDE80-\uDE9C\uDEA0-\uDED0\uDEE0\uDF00-\uDF1F\uDF2D-\uDF4A\uDF50-\uDF7A\uDF80-\uDF9D\uDFA0-\uDFC3\uDFC8-\uDFCF\uDFD1-\uDFD5]|\uD801[\uDC00-\uDC9D\uDCA0-\uDCA9\uDCB0-\uDCD3\uDCD8-\uDCFB\uDD00-\uDD27\uDD30-\uDD63\uDE00-\uDF36\uDF40-\uDF55\uDF60-\uDF67]|\uD802[\uDC00-\uDC05\uDC08\uDC0A-\uDC35\uDC37\uDC38\uDC3C\uDC3F-\uDC55\uDC60-\uDC76\uDC80-\uDC9E\uDCE0-\uDCF2\uDCF4\uDCF5\uDD00-\uDD15\uDD20-\uDD39\uDD80-\uDDB7\uDDBE\uDDBF\uDE00-\uDE03\uDE05\uDE06\uDE0C-\uDE13\uDE15-\uDE17\uDE19-\uDE33\uDE38-\uDE3A\uDE3F\uDE60-\uDE7C\uDE80-\uDE9C\uDEC0-\uDEC7\uDEC9-\uDEE6\uDF00-\uDF35\uDF40-\uDF55\uDF60-\uDF72\uDF80-\uDF91]|\uD803[\uDC00-\uDC48\uDC80-\uDCB2\uDCC0-\uDCF2]|\uD804[\uDC00-\uDC46\uDC66-\uDC6F\uDC7F-\uDCBA\uDCD0-\uDCE8\uDCF0-\uDCF9\uDD00-\uDD34\uDD36-\uDD3F\uDD50-\uDD73\uDD76\uDD80-\uDDC4\uDDCA-\uDDCC\uDDD0-\uDDDA\uDDDC\uDE00-\uDE11\uDE13-\uDE37\uDE3E\uDE80-\uDE86\uDE88\uDE8A-\uDE8D\uDE8F-\uDE9D\uDE9F-\uDEA8\uDEB0-\uDEEA\uDEF0-\uDEF9\uDF00-\uDF03\uDF05-\uDF0C\uDF0F\uDF10\uDF13-\uDF28\uDF2A-\uDF30\uDF32\uDF33\uDF35-\uDF39\uDF3C-\uDF44\uDF47\uDF48\uDF4B-\uDF4D\uDF50\uDF57\uDF5D-\uDF63\uDF66-\uDF6C\uDF70-\uDF74]|\uD805[\uDC00-\uDC4A\uDC50-\uDC59\uDC80-\uDCC5\uDCC7\uDCD0-\uDCD9\uDD80-\uDDB5\uDDB8-\uDDC0\uDDD8-\uDDDD\uDE00-\uDE40\uDE44\uDE50-\uDE59\uDE80-\uDEB7\uDEC0-\uDEC9\uDF00-\uDF19\uDF1D-\uDF2B\uDF30-\uDF39]|\uD806[\uDCA0-\uDCE9\uDCFF\uDE00-\uDE3E\uDE47\uDE50-\uDE83\uDE86-\uDE99\uDEC0-\uDEF8]|\uD807[\uDC00-\uDC08\uDC0A-\uDC36\uDC38-\uDC40\uDC50-\uDC59\uDC72-\uDC8F\uDC92-\uDCA7\uDCA9-\uDCB6\uDD00-\uDD06\uDD08\uDD09\uDD0B-\uDD36\uDD3A\uDD3C\uDD3D\uDD3F-\uDD47\uDD50-\uDD59]|\uD808[\uDC00-\uDF99]|\uD809[\uDC00-\uDC6E\uDC80-\uDD43]|[\uD80C\uD81C-\uD820\uD840-\uD868\uD86A-\uD86C\uD86F-\uD872\uD874-\uD879][\uDC00-\uDFFF]|\uD80D[\uDC00-\uDC2E]|\uD811[\uDC00-\uDE46]|\uD81A[\uDC00-\uDE38\uDE40-\uDE5E\uDE60-\uDE69\uDED0-\uDEED\uDEF0-\uDEF4\uDF00-\uDF36\uDF40-\uDF43\uDF50-\uDF59\uDF63-\uDF77\uDF7D-\uDF8F]|\uD81B[\uDF00-\uDF44\uDF50-\uDF7E\uDF8F-\uDF9F\uDFE0\uDFE1]|\uD821[\uDC00-\uDFEC]|\uD822[\uDC00-\uDEF2]|\uD82C[\uDC00-\uDD1E\uDD70-\uDEFB]|\uD82F[\uDC00-\uDC6A\uDC70-\uDC7C\uDC80-\uDC88\uDC90-\uDC99\uDC9D\uDC9E]|\uD834[\uDD65-\uDD69\uDD6D-\uDD72\uDD7B-\uDD82\uDD85-\uDD8B\uDDAA-\uDDAD\uDE42-\uDE44]|\uD835[\uDC00-\uDC54\uDC56-\uDC9C\uDC9E\uDC9F\uDCA2\uDCA5\uDCA6\uDCA9-\uDCAC\uDCAE-\uDCB9\uDCBB\uDCBD-\uDCC3\uDCC5-\uDD05\uDD07-\uDD0A\uDD0D-\uDD14\uDD16-\uDD1C\uDD1E-\uDD39\uDD3B-\uDD3E\uDD40-\uDD44\uDD46\uDD4A-\uDD50\uDD52-\uDEA5\uDEA8-\uDEC0\uDEC2-\uDEDA\uDEDC-\uDEFA\uDEFC-\uDF14\uDF16-\uDF34\uDF36-\uDF4E\uDF50-\uDF6E\uDF70-\uDF88\uDF8A-\uDFA8\uDFAA-\uDFC2\uDFC4-\uDFCB\uDFCE-\uDFFF]|\uD836[\uDE00-\uDE36\uDE3B-\uDE6C\uDE75\uDE84\uDE9B-\uDE9F\uDEA1-\uDEAF]|\uD838[\uDC00-\uDC06\uDC08-\uDC18\uDC1B-\uDC21\uDC23\uDC24\uDC26-\uDC2A]|\uD83A[\uDC00-\uDCC4\uDCD0-\uDCD6\uDD00-\uDD4A\uDD50-\uDD59]|\uD83B[\uDE00-\uDE03\uDE05-\uDE1F\uDE21\uDE22\uDE24\uDE27\uDE29-\uDE32\uDE34-\uDE37\uDE39\uDE3B\uDE42\uDE47\uDE49\uDE4B\uDE4D-\uDE4F\uDE51\uDE52\uDE54\uDE57\uDE59\uDE5B\uDE5D\uDE5F\uDE61\uDE62\uDE64\uDE67-\uDE6A\uDE6C-\uDE72\uDE74-\uDE77\uDE79-\uDE7C\uDE7E\uDE80-\uDE89\uDE8B-\uDE9B\uDEA1-\uDEA3\uDEA5-\uDEA9\uDEAB-\uDEBB]|\uD869[\uDC00-\uDED6\uDF00-\uDFFF]|\uD86D[\uDC00-\uDF34\uDF40-\uDFFF]|\uD86E[\uDC00-\uDC1D\uDC20-\uDFFF]|\uD873[\uDC00-\uDEA1\uDEB0-\uDFFF]|\uD87A[\uDC00-\uDFE0]|\uD87E[\uDC00-\uDE1D]|\uDB40[\uDD00-\uDDEF]/;
  }
});

// node_modules/json5/lib/util.js
var require_util = __commonJS({
  "node_modules/json5/lib/util.js"(exports2, module2) {
    var unicode = require_unicode();
    module2.exports = {
      isSpaceSeparator(c) {
        return typeof c === "string" && unicode.Space_Separator.test(c);
      },
      isIdStartChar(c) {
        return typeof c === "string" && (c >= "a" && c <= "z" || c >= "A" && c <= "Z" || c === "$" || c === "_" || unicode.ID_Start.test(c));
      },
      isIdContinueChar(c) {
        return typeof c === "string" && (c >= "a" && c <= "z" || c >= "A" && c <= "Z" || c >= "0" && c <= "9" || c === "$" || c === "_" || c === "\u200C" || c === "\u200D" || unicode.ID_Continue.test(c));
      },
      isDigit(c) {
        return typeof c === "string" && /[0-9]/.test(c);
      },
      isHexDigit(c) {
        return typeof c === "string" && /[0-9A-Fa-f]/.test(c);
      }
    };
  }
});

// node_modules/json5/lib/parse.js
var require_parse = __commonJS({
  "node_modules/json5/lib/parse.js"(exports2, module2) {
    var util = require_util();
    var source;
    var parseState;
    var stack;
    var pos;
    var line;
    var column;
    var token;
    var key;
    var root;
    module2.exports = function parse(text, reviver) {
      source = String(text);
      parseState = "start";
      stack = [];
      pos = 0;
      line = 1;
      column = 0;
      token = void 0;
      key = void 0;
      root = void 0;
      do {
        token = lex();
        parseStates[parseState]();
      } while (token.type !== "eof");
      if (typeof reviver === "function") {
        return internalize({ "": root }, "", reviver);
      }
      return root;
    };
    function internalize(holder, name, reviver) {
      const value = holder[name];
      if (value != null && typeof value === "object") {
        if (Array.isArray(value)) {
          for (let i = 0; i < value.length; i++) {
            const key2 = String(i);
            const replacement = internalize(value, key2, reviver);
            if (replacement === void 0) {
              delete value[key2];
            } else {
              Object.defineProperty(value, key2, {
                value: replacement,
                writable: true,
                enumerable: true,
                configurable: true
              });
            }
          }
        } else {
          for (const key2 in value) {
            const replacement = internalize(value, key2, reviver);
            if (replacement === void 0) {
              delete value[key2];
            } else {
              Object.defineProperty(value, key2, {
                value: replacement,
                writable: true,
                enumerable: true,
                configurable: true
              });
            }
          }
        }
      }
      return reviver.call(holder, name, value);
    }
    var lexState;
    var buffer;
    var doubleQuote;
    var sign;
    var c;
    function lex() {
      lexState = "default";
      buffer = "";
      doubleQuote = false;
      sign = 1;
      for (; ; ) {
        c = peek();
        const token2 = lexStates[lexState]();
        if (token2) {
          return token2;
        }
      }
    }
    function peek() {
      if (source[pos]) {
        return String.fromCodePoint(source.codePointAt(pos));
      }
    }
    function read() {
      const c2 = peek();
      if (c2 === "\n") {
        line++;
        column = 0;
      } else if (c2) {
        column += c2.length;
      } else {
        column++;
      }
      if (c2) {
        pos += c2.length;
      }
      return c2;
    }
    var lexStates = {
      default() {
        switch (c) {
          case "	":
          case "\v":
          case "\f":
          case " ":
          case "\xA0":
          case "\uFEFF":
          case "\n":
          case "\r":
          case "\u2028":
          case "\u2029":
            read();
            return;
          case "/":
            read();
            lexState = "comment";
            return;
          case void 0:
            read();
            return newToken("eof");
        }
        if (util.isSpaceSeparator(c)) {
          read();
          return;
        }
        return lexStates[parseState]();
      },
      comment() {
        switch (c) {
          case "*":
            read();
            lexState = "multiLineComment";
            return;
          case "/":
            read();
            lexState = "singleLineComment";
            return;
        }
        throw invalidChar(read());
      },
      multiLineComment() {
        switch (c) {
          case "*":
            read();
            lexState = "multiLineCommentAsterisk";
            return;
          case void 0:
            throw invalidChar(read());
        }
        read();
      },
      multiLineCommentAsterisk() {
        switch (c) {
          case "*":
            read();
            return;
          case "/":
            read();
            lexState = "default";
            return;
          case void 0:
            throw invalidChar(read());
        }
        read();
        lexState = "multiLineComment";
      },
      singleLineComment() {
        switch (c) {
          case "\n":
          case "\r":
          case "\u2028":
          case "\u2029":
            read();
            lexState = "default";
            return;
          case void 0:
            read();
            return newToken("eof");
        }
        read();
      },
      value() {
        switch (c) {
          case "{":
          case "[":
            return newToken("punctuator", read());
          case "n":
            read();
            literal("ull");
            return newToken("null", null);
          case "t":
            read();
            literal("rue");
            return newToken("boolean", true);
          case "f":
            read();
            literal("alse");
            return newToken("boolean", false);
          case "-":
          case "+":
            if (read() === "-") {
              sign = -1;
            }
            lexState = "sign";
            return;
          case ".":
            buffer = read();
            lexState = "decimalPointLeading";
            return;
          case "0":
            buffer = read();
            lexState = "zero";
            return;
          case "1":
          case "2":
          case "3":
          case "4":
          case "5":
          case "6":
          case "7":
          case "8":
          case "9":
            buffer = read();
            lexState = "decimalInteger";
            return;
          case "I":
            read();
            literal("nfinity");
            return newToken("numeric", Infinity);
          case "N":
            read();
            literal("aN");
            return newToken("numeric", NaN);
          case '"':
          case "'":
            doubleQuote = read() === '"';
            buffer = "";
            lexState = "string";
            return;
        }
        throw invalidChar(read());
      },
      identifierNameStartEscape() {
        if (c !== "u") {
          throw invalidChar(read());
        }
        read();
        const u = unicodeEscape();
        switch (u) {
          case "$":
          case "_":
            break;
          default:
            if (!util.isIdStartChar(u)) {
              throw invalidIdentifier();
            }
            break;
        }
        buffer += u;
        lexState = "identifierName";
      },
      identifierName() {
        switch (c) {
          case "$":
          case "_":
          case "\u200C":
          case "\u200D":
            buffer += read();
            return;
          case "\\":
            read();
            lexState = "identifierNameEscape";
            return;
        }
        if (util.isIdContinueChar(c)) {
          buffer += read();
          return;
        }
        return newToken("identifier", buffer);
      },
      identifierNameEscape() {
        if (c !== "u") {
          throw invalidChar(read());
        }
        read();
        const u = unicodeEscape();
        switch (u) {
          case "$":
          case "_":
          case "\u200C":
          case "\u200D":
            break;
          default:
            if (!util.isIdContinueChar(u)) {
              throw invalidIdentifier();
            }
            break;
        }
        buffer += u;
        lexState = "identifierName";
      },
      sign() {
        switch (c) {
          case ".":
            buffer = read();
            lexState = "decimalPointLeading";
            return;
          case "0":
            buffer = read();
            lexState = "zero";
            return;
          case "1":
          case "2":
          case "3":
          case "4":
          case "5":
          case "6":
          case "7":
          case "8":
          case "9":
            buffer = read();
            lexState = "decimalInteger";
            return;
          case "I":
            read();
            literal("nfinity");
            return newToken("numeric", sign * Infinity);
          case "N":
            read();
            literal("aN");
            return newToken("numeric", NaN);
        }
        throw invalidChar(read());
      },
      zero() {
        switch (c) {
          case ".":
            buffer += read();
            lexState = "decimalPoint";
            return;
          case "e":
          case "E":
            buffer += read();
            lexState = "decimalExponent";
            return;
          case "x":
          case "X":
            buffer += read();
            lexState = "hexadecimal";
            return;
        }
        return newToken("numeric", sign * 0);
      },
      decimalInteger() {
        switch (c) {
          case ".":
            buffer += read();
            lexState = "decimalPoint";
            return;
          case "e":
          case "E":
            buffer += read();
            lexState = "decimalExponent";
            return;
        }
        if (util.isDigit(c)) {
          buffer += read();
          return;
        }
        return newToken("numeric", sign * Number(buffer));
      },
      decimalPointLeading() {
        if (util.isDigit(c)) {
          buffer += read();
          lexState = "decimalFraction";
          return;
        }
        throw invalidChar(read());
      },
      decimalPoint() {
        switch (c) {
          case "e":
          case "E":
            buffer += read();
            lexState = "decimalExponent";
            return;
        }
        if (util.isDigit(c)) {
          buffer += read();
          lexState = "decimalFraction";
          return;
        }
        return newToken("numeric", sign * Number(buffer));
      },
      decimalFraction() {
        switch (c) {
          case "e":
          case "E":
            buffer += read();
            lexState = "decimalExponent";
            return;
        }
        if (util.isDigit(c)) {
          buffer += read();
          return;
        }
        return newToken("numeric", sign * Number(buffer));
      },
      decimalExponent() {
        switch (c) {
          case "+":
          case "-":
            buffer += read();
            lexState = "decimalExponentSign";
            return;
        }
        if (util.isDigit(c)) {
          buffer += read();
          lexState = "decimalExponentInteger";
          return;
        }
        throw invalidChar(read());
      },
      decimalExponentSign() {
        if (util.isDigit(c)) {
          buffer += read();
          lexState = "decimalExponentInteger";
          return;
        }
        throw invalidChar(read());
      },
      decimalExponentInteger() {
        if (util.isDigit(c)) {
          buffer += read();
          return;
        }
        return newToken("numeric", sign * Number(buffer));
      },
      hexadecimal() {
        if (util.isHexDigit(c)) {
          buffer += read();
          lexState = "hexadecimalInteger";
          return;
        }
        throw invalidChar(read());
      },
      hexadecimalInteger() {
        if (util.isHexDigit(c)) {
          buffer += read();
          return;
        }
        return newToken("numeric", sign * Number(buffer));
      },
      string() {
        switch (c) {
          case "\\":
            read();
            buffer += escape2();
            return;
          case '"':
            if (doubleQuote) {
              read();
              return newToken("string", buffer);
            }
            buffer += read();
            return;
          case "'":
            if (!doubleQuote) {
              read();
              return newToken("string", buffer);
            }
            buffer += read();
            return;
          case "\n":
          case "\r":
            throw invalidChar(read());
          case "\u2028":
          case "\u2029":
            separatorChar(c);
            break;
          case void 0:
            throw invalidChar(read());
        }
        buffer += read();
      },
      start() {
        switch (c) {
          case "{":
          case "[":
            return newToken("punctuator", read());
        }
        lexState = "value";
      },
      beforePropertyName() {
        switch (c) {
          case "$":
          case "_":
            buffer = read();
            lexState = "identifierName";
            return;
          case "\\":
            read();
            lexState = "identifierNameStartEscape";
            return;
          case "}":
            return newToken("punctuator", read());
          case '"':
          case "'":
            doubleQuote = read() === '"';
            lexState = "string";
            return;
        }
        if (util.isIdStartChar(c)) {
          buffer += read();
          lexState = "identifierName";
          return;
        }
        throw invalidChar(read());
      },
      afterPropertyName() {
        if (c === ":") {
          return newToken("punctuator", read());
        }
        throw invalidChar(read());
      },
      beforePropertyValue() {
        lexState = "value";
      },
      afterPropertyValue() {
        switch (c) {
          case ",":
          case "}":
            return newToken("punctuator", read());
        }
        throw invalidChar(read());
      },
      beforeArrayValue() {
        if (c === "]") {
          return newToken("punctuator", read());
        }
        lexState = "value";
      },
      afterArrayValue() {
        switch (c) {
          case ",":
          case "]":
            return newToken("punctuator", read());
        }
        throw invalidChar(read());
      },
      end() {
        throw invalidChar(read());
      }
    };
    function newToken(type, value) {
      return {
        type,
        value,
        line,
        column
      };
    }
    function literal(s) {
      for (const c2 of s) {
        const p = peek();
        if (p !== c2) {
          throw invalidChar(read());
        }
        read();
      }
    }
    function escape2() {
      const c2 = peek();
      switch (c2) {
        case "b":
          read();
          return "\b";
        case "f":
          read();
          return "\f";
        case "n":
          read();
          return "\n";
        case "r":
          read();
          return "\r";
        case "t":
          read();
          return "	";
        case "v":
          read();
          return "\v";
        case "0":
          read();
          if (util.isDigit(peek())) {
            throw invalidChar(read());
          }
          return "\0";
        case "x":
          read();
          return hexEscape();
        case "u":
          read();
          return unicodeEscape();
        case "\n":
        case "\u2028":
        case "\u2029":
          read();
          return "";
        case "\r":
          read();
          if (peek() === "\n") {
            read();
          }
          return "";
        case "1":
        case "2":
        case "3":
        case "4":
        case "5":
        case "6":
        case "7":
        case "8":
        case "9":
          throw invalidChar(read());
        case void 0:
          throw invalidChar(read());
      }
      return read();
    }
    function hexEscape() {
      let buffer2 = "";
      let c2 = peek();
      if (!util.isHexDigit(c2)) {
        throw invalidChar(read());
      }
      buffer2 += read();
      c2 = peek();
      if (!util.isHexDigit(c2)) {
        throw invalidChar(read());
      }
      buffer2 += read();
      return String.fromCodePoint(parseInt(buffer2, 16));
    }
    function unicodeEscape() {
      let buffer2 = "";
      let count = 4;
      while (count-- > 0) {
        const c2 = peek();
        if (!util.isHexDigit(c2)) {
          throw invalidChar(read());
        }
        buffer2 += read();
      }
      return String.fromCodePoint(parseInt(buffer2, 16));
    }
    var parseStates = {
      start() {
        if (token.type === "eof") {
          throw invalidEOF();
        }
        push();
      },
      beforePropertyName() {
        switch (token.type) {
          case "identifier":
          case "string":
            key = token.value;
            parseState = "afterPropertyName";
            return;
          case "punctuator":
            pop();
            return;
          case "eof":
            throw invalidEOF();
        }
      },
      afterPropertyName() {
        if (token.type === "eof") {
          throw invalidEOF();
        }
        parseState = "beforePropertyValue";
      },
      beforePropertyValue() {
        if (token.type === "eof") {
          throw invalidEOF();
        }
        push();
      },
      beforeArrayValue() {
        if (token.type === "eof") {
          throw invalidEOF();
        }
        if (token.type === "punctuator" && token.value === "]") {
          pop();
          return;
        }
        push();
      },
      afterPropertyValue() {
        if (token.type === "eof") {
          throw invalidEOF();
        }
        switch (token.value) {
          case ",":
            parseState = "beforePropertyName";
            return;
          case "}":
            pop();
        }
      },
      afterArrayValue() {
        if (token.type === "eof") {
          throw invalidEOF();
        }
        switch (token.value) {
          case ",":
            parseState = "beforeArrayValue";
            return;
          case "]":
            pop();
        }
      },
      end() {
      }
    };
    function push() {
      let value;
      switch (token.type) {
        case "punctuator":
          switch (token.value) {
            case "{":
              value = {};
              break;
            case "[":
              value = [];
              break;
          }
          break;
        case "null":
        case "boolean":
        case "numeric":
        case "string":
          value = token.value;
          break;
      }
      if (root === void 0) {
        root = value;
      } else {
        const parent = stack[stack.length - 1];
        if (Array.isArray(parent)) {
          parent.push(value);
        } else {
          Object.defineProperty(parent, key, {
            value,
            writable: true,
            enumerable: true,
            configurable: true
          });
        }
      }
      if (value !== null && typeof value === "object") {
        stack.push(value);
        if (Array.isArray(value)) {
          parseState = "beforeArrayValue";
        } else {
          parseState = "beforePropertyName";
        }
      } else {
        const current = stack[stack.length - 1];
        if (current == null) {
          parseState = "end";
        } else if (Array.isArray(current)) {
          parseState = "afterArrayValue";
        } else {
          parseState = "afterPropertyValue";
        }
      }
    }
    function pop() {
      stack.pop();
      const current = stack[stack.length - 1];
      if (current == null) {
        parseState = "end";
      } else if (Array.isArray(current)) {
        parseState = "afterArrayValue";
      } else {
        parseState = "afterPropertyValue";
      }
    }
    function invalidChar(c2) {
      if (c2 === void 0) {
        return syntaxError(`JSON5: invalid end of input at ${line}:${column}`);
      }
      return syntaxError(`JSON5: invalid character '${formatChar(c2)}' at ${line}:${column}`);
    }
    function invalidEOF() {
      return syntaxError(`JSON5: invalid end of input at ${line}:${column}`);
    }
    function invalidIdentifier() {
      column -= 5;
      return syntaxError(`JSON5: invalid identifier character at ${line}:${column}`);
    }
    function separatorChar(c2) {
      console.warn(`JSON5: '${formatChar(c2)}' in strings is not valid ECMAScript; consider escaping`);
    }
    function formatChar(c2) {
      const replacements = {
        "'": "\\'",
        '"': '\\"',
        "\\": "\\\\",
        "\b": "\\b",
        "\f": "\\f",
        "\n": "\\n",
        "\r": "\\r",
        "	": "\\t",
        "\v": "\\v",
        "\0": "\\0",
        "\u2028": "\\u2028",
        "\u2029": "\\u2029"
      };
      if (replacements[c2]) {
        return replacements[c2];
      }
      if (c2 < " ") {
        const hexString = c2.charCodeAt(0).toString(16);
        return "\\x" + ("00" + hexString).substring(hexString.length);
      }
      return c2;
    }
    function syntaxError(message) {
      const err = new SyntaxError(message);
      err.lineNumber = line;
      err.columnNumber = column;
      return err;
    }
  }
});

// node_modules/json5/lib/stringify.js
var require_stringify = __commonJS({
  "node_modules/json5/lib/stringify.js"(exports2, module2) {
    var util = require_util();
    module2.exports = function stringify(value, replacer, space) {
      const stack = [];
      let indent = "";
      let propertyList;
      let replacerFunc;
      let gap = "";
      let quote;
      if (replacer != null && typeof replacer === "object" && !Array.isArray(replacer)) {
        space = replacer.space;
        quote = replacer.quote;
        replacer = replacer.replacer;
      }
      if (typeof replacer === "function") {
        replacerFunc = replacer;
      } else if (Array.isArray(replacer)) {
        propertyList = [];
        for (const v of replacer) {
          let item;
          if (typeof v === "string") {
            item = v;
          } else if (typeof v === "number" || v instanceof String || v instanceof Number) {
            item = String(v);
          }
          if (item !== void 0 && propertyList.indexOf(item) < 0) {
            propertyList.push(item);
          }
        }
      }
      if (space instanceof Number) {
        space = Number(space);
      } else if (space instanceof String) {
        space = String(space);
      }
      if (typeof space === "number") {
        if (space > 0) {
          space = Math.min(10, Math.floor(space));
          gap = "          ".substr(0, space);
        }
      } else if (typeof space === "string") {
        gap = space.substr(0, 10);
      }
      return serializeProperty("", { "": value });
      function serializeProperty(key, holder) {
        let value2 = holder[key];
        if (value2 != null) {
          if (typeof value2.toJSON5 === "function") {
            value2 = value2.toJSON5(key);
          } else if (typeof value2.toJSON === "function") {
            value2 = value2.toJSON(key);
          }
        }
        if (replacerFunc) {
          value2 = replacerFunc.call(holder, key, value2);
        }
        if (value2 instanceof Number) {
          value2 = Number(value2);
        } else if (value2 instanceof String) {
          value2 = String(value2);
        } else if (value2 instanceof Boolean) {
          value2 = value2.valueOf();
        }
        switch (value2) {
          case null:
            return "null";
          case true:
            return "true";
          case false:
            return "false";
        }
        if (typeof value2 === "string") {
          return quoteString(value2, false);
        }
        if (typeof value2 === "number") {
          return String(value2);
        }
        if (typeof value2 === "object") {
          return Array.isArray(value2) ? serializeArray(value2) : serializeObject(value2);
        }
        return void 0;
      }
      function quoteString(value2) {
        const quotes = {
          "'": 0.1,
          '"': 0.2
        };
        const replacements = {
          "'": "\\'",
          '"': '\\"',
          "\\": "\\\\",
          "\b": "\\b",
          "\f": "\\f",
          "\n": "\\n",
          "\r": "\\r",
          "	": "\\t",
          "\v": "\\v",
          "\0": "\\0",
          "\u2028": "\\u2028",
          "\u2029": "\\u2029"
        };
        let product = "";
        for (let i = 0; i < value2.length; i++) {
          const c = value2[i];
          switch (c) {
            case "'":
            case '"':
              quotes[c]++;
              product += c;
              continue;
            case "\0":
              if (util.isDigit(value2[i + 1])) {
                product += "\\x00";
                continue;
              }
          }
          if (replacements[c]) {
            product += replacements[c];
            continue;
          }
          if (c < " ") {
            let hexString = c.charCodeAt(0).toString(16);
            product += "\\x" + ("00" + hexString).substring(hexString.length);
            continue;
          }
          product += c;
        }
        const quoteChar = quote || Object.keys(quotes).reduce((a, b) => quotes[a] < quotes[b] ? a : b);
        product = product.replace(new RegExp(quoteChar, "g"), replacements[quoteChar]);
        return quoteChar + product + quoteChar;
      }
      function serializeObject(value2) {
        if (stack.indexOf(value2) >= 0) {
          throw TypeError("Converting circular structure to JSON5");
        }
        stack.push(value2);
        let stepback = indent;
        indent = indent + gap;
        let keys = propertyList || Object.keys(value2);
        let partial = [];
        for (const key of keys) {
          const propertyString = serializeProperty(key, value2);
          if (propertyString !== void 0) {
            let member = serializeKey(key) + ":";
            if (gap !== "") {
              member += " ";
            }
            member += propertyString;
            partial.push(member);
          }
        }
        let final;
        if (partial.length === 0) {
          final = "{}";
        } else {
          let properties;
          if (gap === "") {
            properties = partial.join(",");
            final = "{" + properties + "}";
          } else {
            let separator = ",\n" + indent;
            properties = partial.join(separator);
            final = "{\n" + indent + properties + ",\n" + stepback + "}";
          }
        }
        stack.pop();
        indent = stepback;
        return final;
      }
      function serializeKey(key) {
        if (key.length === 0) {
          return quoteString(key, true);
        }
        const firstChar = String.fromCodePoint(key.codePointAt(0));
        if (!util.isIdStartChar(firstChar)) {
          return quoteString(key, true);
        }
        for (let i = firstChar.length; i < key.length; i++) {
          if (!util.isIdContinueChar(String.fromCodePoint(key.codePointAt(i)))) {
            return quoteString(key, true);
          }
        }
        return key;
      }
      function serializeArray(value2) {
        if (stack.indexOf(value2) >= 0) {
          throw TypeError("Converting circular structure to JSON5");
        }
        stack.push(value2);
        let stepback = indent;
        indent = indent + gap;
        let partial = [];
        for (let i = 0; i < value2.length; i++) {
          const propertyString = serializeProperty(String(i), value2);
          partial.push(propertyString !== void 0 ? propertyString : "null");
        }
        let final;
        if (partial.length === 0) {
          final = "[]";
        } else {
          if (gap === "") {
            let properties = partial.join(",");
            final = "[" + properties + "]";
          } else {
            let separator = ",\n" + indent;
            let properties = partial.join(separator);
            final = "[\n" + indent + properties + ",\n" + stepback + "]";
          }
        }
        stack.pop();
        indent = stepback;
        return final;
      }
    };
  }
});

// node_modules/json5/lib/index.js
var require_lib = __commonJS({
  "node_modules/json5/lib/index.js"(exports2, module2) {
    var parse = require_parse();
    var stringify = require_stringify();
    var JSON52 = {
      parse,
      stringify
    };
    module2.exports = JSON52;
  }
});

// src/constants.ts
var import_node_path, import_node_os, HOME_DIR, CONFIG_FILE, PLUGINS_DIR, PID_FILE, REFERENCE_COUNT_FILE, DEFAULT_CONFIG;
var init_constants = __esm({
  "src/constants.ts"() {
    "use strict";
    import_node_path = __toESM(require("node:path"));
    import_node_os = __toESM(require("node:os"));
    HOME_DIR = import_node_path.default.join(import_node_os.default.homedir(), "claude-code");
    CONFIG_FILE = import_node_path.default.join(HOME_DIR, "config.json");
    PLUGINS_DIR = import_node_path.default.join(HOME_DIR, "plugins");
    PID_FILE = import_node_path.default.join(HOME_DIR, ".claude-code-router.pid");
    REFERENCE_COUNT_FILE = import_node_path.default.join(import_node_os.default.tmpdir(), "claude-code-reference-count.txt");
    DEFAULT_CONFIG = {
      LOG: false,
      OPENAI_API_KEY: "",
      OPENAI_BASE_URL: "",
      OPENAI_MODEL: ""
    };
  }
});

// src/utils/index.ts
var utils_exports = {};
__export(utils_exports, {
  backupConfigFile: () => backupConfigFile,
  initConfig: () => initConfig,
  initDir: () => initDir,
  readConfigFile: () => readConfigFile,
  writeConfigFile: () => writeConfigFile
});
var import_promises, import_node_readline, import_json5, import_node_path2, ensureDir, initDir, createReadline, question, readConfigFile, backupConfigFile, writeConfigFile, initConfig;
var init_utils = __esm({
  "src/utils/index.ts"() {
    "use strict";
    import_promises = __toESM(require("node:fs/promises"));
    import_node_readline = __toESM(require("node:readline"));
    import_json5 = __toESM(require_lib());
    import_node_path2 = __toESM(require("node:path"));
    init_constants();
    ensureDir = async (dir_path) => {
      try {
        await import_promises.default.access(dir_path);
      } catch {
        await import_promises.default.mkdir(dir_path, { recursive: true });
      }
    };
    initDir = async () => {
      await ensureDir(HOME_DIR);
      await ensureDir(PLUGINS_DIR);
    };
    createReadline = () => {
      return import_node_readline.default.createInterface({
        input: process.stdin,
        output: process.stdout
      });
    };
    question = (query) => {
      return new Promise((resolve) => {
        const rl = createReadline();
        rl.question(query, (answer) => {
          rl.close();
          resolve(answer);
        });
      });
    };
    readConfigFile = async () => {
      try {
        const config = await import_promises.default.readFile(CONFIG_FILE, "utf-8");
        try {
          return import_json5.default.parse(config);
        } catch (parseError) {
          console.error(`Failed to parse config file at ${CONFIG_FILE}`);
          console.error("Error details:", parseError.message);
          console.error("Please check your config file syntax.");
          process.exit(1);
        }
      } catch (readError) {
        if (readError.code === "ENOENT") {
          const name = await question("Enter Provider Name: ");
          const APIKEY = await question("Enter Provider API KEY: ");
          const baseUrl = await question("Enter Provider URL: ");
          const model = await question("Enter MODEL Name: ");
          const config = Object.assign({}, DEFAULT_CONFIG, {
            Providers: [
              {
                name,
                api_base_url: baseUrl,
                api_key: APIKEY,
                models: [model]
              }
            ],
            Router: {
              default: `${name},${model}`
            }
          });
          await writeConfigFile(config);
          return config;
        } else {
          console.error(`Failed to read config file at ${CONFIG_FILE}`);
          console.error("Error details:", readError.message);
          process.exit(1);
        }
      }
    };
    backupConfigFile = async () => {
      try {
        if (await import_promises.default.access(CONFIG_FILE).then(() => true).catch(() => false)) {
          const timestamp = (/* @__PURE__ */ new Date()).toISOString().replace(/[:.]/g, "-");
          const backupPath = `${CONFIG_FILE}.${timestamp}.bak`;
          await import_promises.default.copyFile(CONFIG_FILE, backupPath);
          try {
            const configDir = import_node_path2.default.dirname(CONFIG_FILE);
            const configFileName = import_node_path2.default.basename(CONFIG_FILE);
            const files = await import_promises.default.readdir(configDir);
            const backupFiles = files.filter((file) => file.startsWith(configFileName) && file.endsWith(".bak")).sort().reverse();
            if (backupFiles.length > 3) {
              for (let i = 3; i < backupFiles.length; i++) {
                const oldBackupPath = import_node_path2.default.join(configDir, backupFiles[i]);
                await import_promises.default.unlink(oldBackupPath);
              }
            }
          } catch (cleanupError) {
            console.warn("Failed to clean up old backups:", cleanupError);
          }
          return backupPath;
        }
      } catch (error) {
        console.error("Failed to backup config file:", error);
      }
      return null;
    };
    writeConfigFile = async (config) => {
      await ensureDir(HOME_DIR);
      const configWithComment = `${JSON.stringify(config, null, 2)}`;
      await import_promises.default.writeFile(CONFIG_FILE, configWithComment);
    };
    initConfig = async () => {
      const config = await readConfigFile();
      Object.assign(process.env, config);
      return config;
    };
  }
});

// node_modules/reusify/reusify.js
var require_reusify = __commonJS({
  "node_modules/reusify/reusify.js"(exports2, module2) {
    "use strict";
    function reusify(Constructor) {
      var head = new Constructor();
      var tail = head;
      function get() {
        var current = head;
        if (current.next) {
          head = current.next;
        } else {
          head = new Constructor();
          tail = head;
        }
        current.next = null;
        return current;
      }
      function release(obj) {
        tail.next = obj;
        tail = obj;
      }
      return {
        get,
        release
      };
    }
    module2.exports = reusify;
  }
});

// node_modules/fastq/queue.js
var require_queue = __commonJS({
  "node_modules/fastq/queue.js"(exports2, module2) {
    "use strict";
    var reusify = require_reusify();
    function fastqueue(context, worker, _concurrency) {
      if (typeof context === "function") {
        _concurrency = worker;
        worker = context;
        context = null;
      }
      if (!(_concurrency >= 1)) {
        throw new Error("fastqueue concurrency must be equal to or greater than 1");
      }
      var cache = reusify(Task);
      var queueHead = null;
      var queueTail = null;
      var _running = 0;
      var errorHandler = null;
      var self2 = {
        push,
        drain: noop,
        saturated: noop,
        pause,
        paused: false,
        get concurrency() {
          return _concurrency;
        },
        set concurrency(value) {
          if (!(value >= 1)) {
            throw new Error("fastqueue concurrency must be equal to or greater than 1");
          }
          _concurrency = value;
          if (self2.paused) return;
          for (; queueHead && _running < _concurrency; ) {
            _running++;
            release();
          }
        },
        running,
        resume,
        idle,
        length,
        getQueue,
        unshift,
        empty: noop,
        kill,
        killAndDrain,
        error
      };
      return self2;
      function running() {
        return _running;
      }
      function pause() {
        self2.paused = true;
      }
      function length() {
        var current = queueHead;
        var counter = 0;
        while (current) {
          current = current.next;
          counter++;
        }
        return counter;
      }
      function getQueue() {
        var current = queueHead;
        var tasks = [];
        while (current) {
          tasks.push(current.value);
          current = current.next;
        }
        return tasks;
      }
      function resume() {
        if (!self2.paused) return;
        self2.paused = false;
        if (queueHead === null) {
          _running++;
          release();
          return;
        }
        for (; queueHead && _running < _concurrency; ) {
          _running++;
          release();
        }
      }
      function idle() {
        return _running === 0 && self2.length() === 0;
      }
      function push(value, done) {
        var current = cache.get();
        current.context = context;
        current.release = release;
        current.value = value;
        current.callback = done || noop;
        current.errorHandler = errorHandler;
        if (_running >= _concurrency || self2.paused) {
          if (queueTail) {
            queueTail.next = current;
            queueTail = current;
          } else {
            queueHead = current;
            queueTail = current;
            self2.saturated();
          }
        } else {
          _running++;
          worker.call(context, current.value, current.worked);
        }
      }
      function unshift(value, done) {
        var current = cache.get();
        current.context = context;
        current.release = release;
        current.value = value;
        current.callback = done || noop;
        current.errorHandler = errorHandler;
        if (_running >= _concurrency || self2.paused) {
          if (queueHead) {
            current.next = queueHead;
            queueHead = current;
          } else {
            queueHead = current;
            queueTail = current;
            self2.saturated();
          }
        } else {
          _running++;
          worker.call(context, current.value, current.worked);
        }
      }
      function release(holder) {
        if (holder) {
          cache.release(holder);
        }
        var next = queueHead;
        if (next && _running <= _concurrency) {
          if (!self2.paused) {
            if (queueTail === queueHead) {
              queueTail = null;
            }
            queueHead = next.next;
            next.next = null;
            worker.call(context, next.value, next.worked);
            if (queueTail === null) {
              self2.empty();
            }
          } else {
            _running--;
          }
        } else if (--_running === 0) {
          self2.drain();
        }
      }
      function kill() {
        queueHead = null;
        queueTail = null;
        self2.drain = noop;
      }
      function killAndDrain() {
        queueHead = null;
        queueTail = null;
        self2.drain();
        self2.drain = noop;
      }
      function error(handler) {
        errorHandler = handler;
      }
    }
    function noop() {
    }
    function Task() {
      this.value = null;
      this.callback = noop;
      this.next = null;
      this.release = noop;
      this.context = null;
      this.errorHandler = null;
      var self2 = this;
      this.worked = function worked(err, result) {
        var callback = self2.callback;
        var errorHandler = self2.errorHandler;
        var val = self2.value;
        self2.value = null;
        self2.callback = noop;
        if (self2.errorHandler) {
          errorHandler(err, val);
        }
        callback.call(self2.context, err, result);
        self2.release(self2);
      };
    }
    function queueAsPromised(context, worker, _concurrency) {
      if (typeof context === "function") {
        _concurrency = worker;
        worker = context;
        context = null;
      }
      function asyncWrapper(arg, cb) {
        worker.call(this, arg).then(function(res) {
          cb(null, res);
        }, cb);
      }
      var queue = fastqueue(context, asyncWrapper, _concurrency);
      var pushCb = queue.push;
      var unshiftCb = queue.unshift;
      queue.push = push;
      queue.unshift = unshift;
      queue.drained = drained;
      return queue;
      function push(value) {
        var p = new Promise(function(resolve, reject) {
          pushCb(value, function(err, result) {
            if (err) {
              reject(err);
              return;
            }
            resolve(result);
          });
        });
        p.catch(noop);
        return p;
      }
      function unshift(value) {
        var p = new Promise(function(resolve, reject) {
          unshiftCb(value, function(err, result) {
            if (err) {
              reject(err);
              return;
            }
            resolve(result);
          });
        });
        p.catch(noop);
        return p;
      }
      function drained() {
        var p = new Promise(function(resolve) {
          process.nextTick(function() {
            if (queue.idle()) {
              resolve();
            } else {
              var previousDrain = queue.drain;
              queue.drain = function() {
                if (typeof previousDrain === "function") previousDrain();
                resolve();
                queue.drain = previousDrain;
              };
            }
          });
        });
        return p;
      }
    }
    module2.exports = fastqueue;
    module2.exports.promise = queueAsPromised;
  }
});

// node_modules/@fastify/error/index.js
var require_error = __commonJS({
  "node_modules/@fastify/error/index.js"(exports2, module2) {
    "use strict";
    var { format } = require("node:util");
    function toString() {
      return `${this.name} [${this.code}]: ${this.message}`;
    }
    var FastifyGenericErrorSymbol = Symbol.for("fastify-error-generic");
    function createError(code, message, statusCode = 500, Base = Error, captureStackTrace = createError.captureStackTrace) {
      const shouldCreateFastifyGenericError = code === FastifyGenericErrorSymbol;
      if (shouldCreateFastifyGenericError) {
        code = "FST_ERR";
      }
      if (!code) throw new Error("Fastify error code must not be empty");
      if (!message) throw new Error("Fastify error message must not be empty");
      code = code.toUpperCase();
      !statusCode && (statusCode = void 0);
      const FastifySpecificErrorSymbol = Symbol.for(`fastify-error ${code}`);
      function FastifyError(...args) {
        if (!new.target) {
          return new FastifyError(...args);
        }
        this.code = code;
        this.name = "FastifyError";
        this.statusCode = statusCode;
        const lastElement = args.length - 1;
        if (lastElement !== -1 && args[lastElement] && typeof args[lastElement] === "object" && "cause" in args[lastElement]) {
          this.cause = args.pop().cause;
        }
        this.message = format(message, ...args);
        Error.stackTraceLimit && captureStackTrace && Error.captureStackTrace(this, FastifyError);
      }
      FastifyError.prototype = Object.create(Base.prototype, {
        constructor: {
          value: FastifyError,
          enumerable: false,
          writable: true,
          configurable: true
        },
        [FastifyGenericErrorSymbol]: {
          value: true,
          enumerable: false,
          writable: false,
          configurable: false
        },
        [FastifySpecificErrorSymbol]: {
          value: true,
          enumerable: false,
          writable: false,
          configurable: false
        }
      });
      if (shouldCreateFastifyGenericError) {
        Object.defineProperty(FastifyError, Symbol.hasInstance, {
          value(instance) {
            return instance && instance[FastifyGenericErrorSymbol];
          },
          configurable: false,
          writable: false,
          enumerable: false
        });
      } else {
        Object.defineProperty(FastifyError, Symbol.hasInstance, {
          value(instance) {
            return instance && instance[FastifySpecificErrorSymbol];
          },
          configurable: false,
          writable: false,
          enumerable: false
        });
      }
      FastifyError.prototype[Symbol.toStringTag] = "Error";
      FastifyError.prototype.toString = toString;
      return FastifyError;
    }
    createError.captureStackTrace = true;
    var FastifyErrorConstructor = createError(FastifyGenericErrorSymbol, "Fastify Error", 500, Error);
    module2.exports = createError;
    module2.exports.FastifyError = FastifyErrorConstructor;
    module2.exports.default = createError;
    module2.exports.createError = createError;
  }
});

// node_modules/avvio/lib/errors.js
var require_errors = __commonJS({
  "node_modules/avvio/lib/errors.js"(exports2, module2) {
    "use strict";
    var { createError } = require_error();
    module2.exports = {
      AVV_ERR_EXPOSE_ALREADY_DEFINED: createError(
        "AVV_ERR_EXPOSE_ALREADY_DEFINED",
        "'%s' is already defined, specify an expose option for '%s'"
      ),
      AVV_ERR_ATTRIBUTE_ALREADY_DEFINED: createError(
        "AVV_ERR_ATTRIBUTE_ALREADY_DEFINED",
        "'%s' is already defined"
      ),
      AVV_ERR_CALLBACK_NOT_FN: createError(
        "AVV_ERR_CALLBACK_NOT_FN",
        "Callback for '%s' hook is not a function. Received: '%s'"
      ),
      AVV_ERR_PLUGIN_NOT_VALID: createError(
        "AVV_ERR_PLUGIN_NOT_VALID",
        "Plugin must be a function or a promise. Received: '%s'"
      ),
      AVV_ERR_ROOT_PLG_BOOTED: createError(
        "AVV_ERR_ROOT_PLG_BOOTED",
        "Root plugin has already booted"
      ),
      AVV_ERR_PARENT_PLG_LOADED: createError(
        "AVV_ERR_PARENT_PLG_LOADED",
        "Impossible to load '%s' plugin because the parent '%s' was already loaded"
      ),
      AVV_ERR_READY_TIMEOUT: createError(
        "AVV_ERR_READY_TIMEOUT",
        "Plugin did not start in time: '%s'. You may have forgotten to call 'done' function or to resolve a Promise"
      ),
      AVV_ERR_PLUGIN_EXEC_TIMEOUT: createError(
        "AVV_ERR_PLUGIN_EXEC_TIMEOUT",
        "Plugin did not start in time: '%s'. You may have forgotten to call 'done' function or to resolve a Promise"
      )
    };
  }
});

// node_modules/avvio/lib/symbols.js
var require_symbols = __commonJS({
  "node_modules/avvio/lib/symbols.js"(exports2, module2) {
    "use strict";
    var kAvvio = Symbol("avvio.Boot");
    var kIsOnCloseHandler = Symbol("isOnCloseHandler");
    var kThenifyDoNotWrap = Symbol("avvio.ThenifyDoNotWrap");
    var kUntrackNode = Symbol("avvio.TimeTree.untrackNode");
    var kTrackNode = Symbol("avvio.TimeTree.trackNode");
    var kGetParent = Symbol("avvio.TimeTree.getParent");
    var kGetNode = Symbol("avvio.TimeTree.getNode");
    var kAddNode = Symbol("avvio.TimeTree.addNode");
    var kPluginMeta = Symbol.for("plugin-meta");
    module2.exports = {
      kAvvio,
      kIsOnCloseHandler,
      kThenifyDoNotWrap,
      kUntrackNode,
      kTrackNode,
      kGetParent,
      kGetNode,
      kAddNode,
      kPluginMeta
    };
  }
});

// node_modules/avvio/lib/time-tree.js
var require_time_tree = __commonJS({
  "node_modules/avvio/lib/time-tree.js"(exports2, module2) {
    "use strict";
    var {
      kUntrackNode,
      kTrackNode,
      kGetParent,
      kGetNode,
      kAddNode
    } = require_symbols();
    var TimeTree = class {
      constructor() {
        this.root = null;
        this.tableId = /* @__PURE__ */ new Map();
        this.tableLabel = /* @__PURE__ */ new Map();
      }
      /**
       * @param {TimeTreeNode} node
       */
      [kTrackNode](node) {
        this.tableId.set(node.id, node);
        if (this.tableLabel.has(node.label)) {
          this.tableLabel.get(node.label).push(node);
        } else {
          this.tableLabel.set(node.label, [node]);
        }
      }
      /**
       * @param {TimeTreeNode} node
       */
      [kUntrackNode](node) {
        this.tableId.delete(node.id);
        const labelNode = this.tableLabel.get(node.label);
        labelNode.pop();
        if (labelNode.length === 0) {
          this.tableLabel.delete(node.label);
        }
      }
      /**
       * @param {string} parent
       * @returns {TimeTreeNode}
       */
      [kGetParent](parent) {
        if (parent === null) {
          return null;
        } else if (this.tableLabel.has(parent)) {
          const parentNode = this.tableLabel.get(parent);
          return parentNode[parentNode.length - 1];
        } else {
          return null;
        }
      }
      /**
       *
       * @param {string} nodeId
       * @returns {TimeTreeNode}
       */
      [kGetNode](nodeId) {
        return this.tableId.get(nodeId);
      }
      /**
       * @param {string} parent
       * @param {string} label
       * @param {number} start
       * @returns {TimeTreeNode["id"]}
       */
      [kAddNode](parent, label, start) {
        const parentNode = this[kGetParent](parent);
        const isRoot = parentNode === null;
        if (isRoot) {
          this.root = {
            parent: null,
            id: "root",
            label,
            nodes: [],
            start,
            stop: null,
            diff: -1
          };
          this[kTrackNode](this.root);
          return this.root.id;
        }
        const nodeId = `${label}-${Math.random()}`;
        const childNode = {
          parent,
          id: nodeId,
          label,
          nodes: [],
          start,
          stop: null,
          diff: -1
        };
        parentNode.nodes.push(childNode);
        this[kTrackNode](childNode);
        return nodeId;
      }
      /**
       * @param {string} parent
       * @param {string} label
       * @param {number|undefined} start
       * @returns {TimeTreeNode["id"]}
       */
      start(parent, label, start = Date.now()) {
        return this[kAddNode](parent, label, start);
      }
      /**
       * @param {string} nodeId
       * @param {number|undefined} stop
       */
      stop(nodeId, stop = Date.now()) {
        const node = this[kGetNode](nodeId);
        if (node) {
          node.stop = stop;
          node.diff = node.stop - node.start || 0;
          this[kUntrackNode](node);
        }
      }
      /**
       * @returns {TimeTreeNode}
       */
      toJSON() {
        return Object.assign({}, this.root);
      }
      /**
       * @returns {string}
       */
      prettyPrint() {
        return prettyPrintTimeTree(this.toJSON());
      }
    };
    function prettyPrintTimeTree(obj, prefix = "") {
      let result = prefix;
      const nodesCount = obj.nodes.length;
      const lastIndex = nodesCount - 1;
      result += `${obj.label} ${obj.diff} ms
`;
      for (let i = 0; i < nodesCount; ++i) {
        const node = obj.nodes[i];
        const prefix_ = prefix + (i === lastIndex ? "  " : "\u2502 ");
        result += prefix;
        result += i === lastIndex ? "\u2514\u2500" : "\u251C\u2500";
        result += node.nodes.length === 0 ? "\u2500 " : "\u252C ";
        result += prettyPrintTimeTree(node, prefix_).slice(prefix.length + 2);
      }
      return result;
    }
    module2.exports = {
      TimeTree
    };
  }
});

// node_modules/avvio/lib/debug.js
var require_debug = __commonJS({
  "node_modules/avvio/lib/debug.js"(exports2, module2) {
    "use strict";
    var { debuglog } = require("node:util");
    var debug = debuglog("avvio");
    module2.exports = {
      debug
    };
  }
});

// node_modules/avvio/lib/create-promise.js
var require_create_promise = __commonJS({
  "node_modules/avvio/lib/create-promise.js"(exports2, module2) {
    "use strict";
    function createPromise() {
      const obj = {
        resolve: null,
        reject: null,
        promise: null
      };
      obj.promise = new Promise((resolve, reject) => {
        obj.resolve = resolve;
        obj.reject = reject;
      });
      return obj;
    }
    module2.exports = {
      createPromise
    };
  }
});

// node_modules/avvio/lib/get-plugin-name.js
var require_get_plugin_name = __commonJS({
  "node_modules/avvio/lib/get-plugin-name.js"(exports2, module2) {
    "use strict";
    var { kPluginMeta } = require_symbols();
    function getPluginName(plugin, options) {
      if (plugin[kPluginMeta] && plugin[kPluginMeta].name) {
        return plugin[kPluginMeta].name;
      }
      if (options && options.name) {
        return options.name;
      }
      if (plugin.name) {
        return plugin.name;
      } else {
        return plugin.toString().split("\n").slice(0, 2).map((s) => s.trim()).join(" -- ");
      }
    }
    module2.exports = {
      getPluginName
    };
  }
});

// node_modules/avvio/lib/is-promise-like.js
var require_is_promise_like = __commonJS({
  "node_modules/avvio/lib/is-promise-like.js"(exports2, module2) {
    "use strict";
    function isPromiseLike(maybePromiseLike) {
      return maybePromiseLike !== null && typeof maybePromiseLike === "object" && typeof maybePromiseLike.then === "function";
    }
    module2.exports = {
      isPromiseLike
    };
  }
});

// node_modules/avvio/lib/plugin.js
var require_plugin = __commonJS({
  "node_modules/avvio/lib/plugin.js"(exports2, module2) {
    "use strict";
    var { EventEmitter } = require("node:events");
    var { inherits } = require("node:util");
    var { debug } = require_debug();
    var { createPromise } = require_create_promise();
    var { AVV_ERR_PLUGIN_EXEC_TIMEOUT } = require_errors();
    var { getPluginName } = require_get_plugin_name();
    var { isPromiseLike } = require_is_promise_like();
    function Plugin(queue, func, options, isAfter, timeout) {
      this.queue = queue;
      this.func = func;
      this.options = options;
      this.isAfter = isAfter;
      this.timeout = timeout;
      this.started = false;
      this.name = getPluginName(func, options);
      this.queue.pause();
      this._error = null;
      this.loaded = false;
      this._promise = null;
      this.startTime = null;
    }
    inherits(Plugin, EventEmitter);
    Plugin.prototype.exec = function(server, callback) {
      debug("exec", this.name);
      this.server = server;
      const func = this.func;
      const name = this.name;
      let completed = false;
      this.options = typeof this.options === "function" ? this.options(this.server) : this.options;
      let timer = null;
      const done = (execErr) => {
        if (completed) {
          debug("loading complete", name);
          return;
        }
        this._error = execErr;
        if (execErr) {
          debug("exec errored", name);
        } else {
          debug("exec completed", name);
        }
        completed = true;
        if (timer) {
          clearTimeout(timer);
        }
        callback(execErr);
      };
      if (this.timeout > 0) {
        debug("setting up timeout", name, this.timeout);
        timer = setTimeout(function() {
          debug("timed out", name);
          timer = null;
          const readyTimeoutErr = new AVV_ERR_PLUGIN_EXEC_TIMEOUT(name);
          readyTimeoutErr.fn = func;
          done(readyTimeoutErr);
        }, this.timeout);
      }
      this.started = true;
      this.startTime = Date.now();
      this.emit("start", this.server ? this.server.name : null, this.name, Date.now());
      const maybePromiseLike = func(this.server, this.options, done);
      if (isPromiseLike(maybePromiseLike)) {
        debug("exec: resolving promise", name);
        maybePromiseLike.then(
          () => process.nextTick(done),
          (e) => process.nextTick(done, e)
        );
      } else if (func.length < 3) {
        done();
      }
    };
    Plugin.prototype.loadedSoFar = function() {
      debug("loadedSoFar", this.name);
      if (this.loaded) {
        return Promise.resolve();
      }
      const setup = () => {
        this.server.after((afterErr, callback) => {
          this._error = afterErr;
          this.queue.pause();
          if (this._promise) {
            if (afterErr) {
              debug("rejecting promise", this.name, afterErr);
              this._promise.reject(afterErr);
            } else {
              debug("resolving promise", this.name);
              this._promise.resolve();
            }
            this._promise = null;
          }
          process.nextTick(callback, afterErr);
        });
        this.queue.resume();
      };
      let res;
      if (!this._promise) {
        this._promise = createPromise();
        res = this._promise.promise;
        if (!this.server) {
          this.on("start", setup);
        } else {
          setup();
        }
      } else {
        res = Promise.resolve();
      }
      return res;
    };
    Plugin.prototype.enqueue = function(plugin, callback) {
      debug("enqueue", this.name, plugin.name);
      this.emit("enqueue", this.server ? this.server.name : null, this.name, Date.now());
      this.queue.push(plugin, callback);
    };
    Plugin.prototype.finish = function(err, callback) {
      debug("finish", this.name, err);
      const done = () => {
        if (this.loaded) {
          return;
        }
        debug("loaded", this.name);
        this.emit("loaded", this.server ? this.server.name : null, this.name, Date.now());
        this.loaded = true;
        callback(err);
      };
      if (err) {
        if (this._promise) {
          this._promise.reject(err);
          this._promise = null;
        }
        done();
        return;
      }
      const check = () => {
        debug("check", this.name, this.queue.length(), this.queue.running(), this._promise);
        if (this.queue.length() === 0 && this.queue.running() === 0) {
          if (this._promise) {
            const wrap = () => {
              debug("wrap");
              queueMicrotask(check);
            };
            this._promise.resolve();
            this._promise.promise.then(wrap, wrap);
            this._promise = null;
          } else {
            done();
          }
        } else {
          debug("delayed", this.name);
          this.queue.drain = () => {
            debug("drain", this.name);
            this.queue.drain = noop;
            queueMicrotask(check);
          };
        }
      };
      queueMicrotask(check);
      this.queue.resume();
    };
    function noop() {
    }
    module2.exports = {
      Plugin
    };
  }
});

// node_modules/avvio/lib/validate-plugin.js
var require_validate_plugin = __commonJS({
  "node_modules/avvio/lib/validate-plugin.js"(exports2, module2) {
    "use strict";
    var { AVV_ERR_PLUGIN_NOT_VALID } = require_errors();
    function validatePlugin(maybePlugin) {
      if (!(maybePlugin && (typeof maybePlugin === "function" || typeof maybePlugin.then === "function"))) {
        if (Array.isArray(maybePlugin)) {
          throw new AVV_ERR_PLUGIN_NOT_VALID("array");
        } else if (maybePlugin === null) {
          throw new AVV_ERR_PLUGIN_NOT_VALID("null");
        } else {
          throw new AVV_ERR_PLUGIN_NOT_VALID(typeof maybePlugin);
        }
      }
    }
    module2.exports = {
      validatePlugin
    };
  }
});

// node_modules/avvio/lib/is-bundled-or-typescript-plugin.js
var require_is_bundled_or_typescript_plugin = __commonJS({
  "node_modules/avvio/lib/is-bundled-or-typescript-plugin.js"(exports2, module2) {
    "use strict";
    function isBundledOrTypescriptPlugin(maybeBundledOrTypescriptPlugin) {
      return maybeBundledOrTypescriptPlugin !== null && typeof maybeBundledOrTypescriptPlugin === "object" && typeof maybeBundledOrTypescriptPlugin.default === "function";
    }
    module2.exports = {
      isBundledOrTypescriptPlugin
    };
  }
});

// node_modules/avvio/lib/thenify.js
var require_thenify = __commonJS({
  "node_modules/avvio/lib/thenify.js"(exports2, module2) {
    "use strict";
    var { debug } = require_debug();
    var { kThenifyDoNotWrap } = require_symbols();
    function thenify() {
      if (this.booted) {
        debug("thenify returning undefined because we are already booted");
        return;
      }
      if (this[kThenifyDoNotWrap]) {
        this[kThenifyDoNotWrap] = false;
        return;
      }
      debug("thenify");
      return (resolve, reject) => {
        const p = this._loadRegistered();
        return p.then(() => {
          this[kThenifyDoNotWrap] = true;
          return resolve(this._server);
        }, reject);
      };
    }
    module2.exports = {
      thenify
    };
  }
});

// node_modules/avvio/lib/execute-with-thenable.js
var require_execute_with_thenable = __commonJS({
  "node_modules/avvio/lib/execute-with-thenable.js"(exports2, module2) {
    "use strict";
    var { isPromiseLike } = require_is_promise_like();
    var { kAvvio } = require_symbols();
    function executeWithThenable(func, args, callback) {
      const result = func.apply(func, args);
      if (isPromiseLike(result) && !result[kAvvio]) {
        result.then(() => process.nextTick(callback), (error) => process.nextTick(callback, error));
      } else if (callback) {
        process.nextTick(callback);
      }
    }
    module2.exports = {
      executeWithThenable
    };
  }
});

// node_modules/avvio/boot.js
var require_boot = __commonJS({
  "node_modules/avvio/boot.js"(exports2, module2) {
    "use strict";
    var fastq = require_queue();
    var EE = require("node:events").EventEmitter;
    var inherits = require("node:util").inherits;
    var {
      AVV_ERR_EXPOSE_ALREADY_DEFINED,
      AVV_ERR_CALLBACK_NOT_FN,
      AVV_ERR_ROOT_PLG_BOOTED,
      AVV_ERR_READY_TIMEOUT,
      AVV_ERR_ATTRIBUTE_ALREADY_DEFINED
    } = require_errors();
    var {
      kAvvio,
      kIsOnCloseHandler
    } = require_symbols();
    var { TimeTree } = require_time_tree();
    var { Plugin } = require_plugin();
    var { debug } = require_debug();
    var { validatePlugin } = require_validate_plugin();
    var { isBundledOrTypescriptPlugin } = require_is_bundled_or_typescript_plugin();
    var { isPromiseLike } = require_is_promise_like();
    var { thenify } = require_thenify();
    var { executeWithThenable } = require_execute_with_thenable();
    function Boot(server, opts, done) {
      if (typeof server === "function" && arguments.length === 1) {
        done = server;
        opts = {};
        server = null;
      }
      if (typeof opts === "function") {
        done = opts;
        opts = {};
      }
      opts = opts || {};
      opts.autostart = opts.autostart !== false;
      opts.timeout = Number(opts.timeout) || 0;
      opts.expose = opts.expose || {};
      if (!new.target) {
        return new Boot(server, opts, done);
      }
      this._server = server || this;
      this._opts = opts;
      if (server) {
        this._expose();
      }
      this._current = [];
      this._error = null;
      this._lastUsed = null;
      this.setMaxListeners(0);
      if (done) {
        this.once("start", done);
      }
      this.started = false;
      this.booted = false;
      this.pluginTree = new TimeTree();
      this._readyQ = fastq(this, callWithCbOrNextTick, 1);
      this._readyQ.pause();
      this._readyQ.drain = () => {
        this.emit("start");
        this._readyQ.drain = noop;
      };
      this._closeQ = fastq(this, closeWithCbOrNextTick, 1);
      this._closeQ.pause();
      this._closeQ.drain = () => {
        this.emit("close");
        this._closeQ.drain = noop;
      };
      this._doStart = null;
      const instance = this;
      this._root = new Plugin(fastq(this, this._loadPluginNextTick, 1), function root(server2, opts2, done2) {
        instance._doStart = done2;
        opts2.autostart && instance.start();
      }, opts, false, 0);
      this._trackPluginLoading(this._root);
      this._loadPlugin(this._root, (err) => {
        debug("root plugin ready");
        try {
          this.emit("preReady");
          this._root = null;
        } catch (preReadyError) {
          err = err || this._error || preReadyError;
        }
        if (err) {
          this._error = err;
          if (this._readyQ.length() === 0) {
            throw err;
          }
        } else {
          this.booted = true;
        }
        this._readyQ.resume();
      });
    }
    inherits(Boot, EE);
    Boot.prototype.start = function() {
      this.started = true;
      process.nextTick(this._doStart);
      return this;
    };
    Boot.prototype.override = function(server, func, opts) {
      return server;
    };
    Boot.prototype[kAvvio] = true;
    Boot.prototype.use = function(plugin, opts) {
      this._lastUsed = this._addPlugin(plugin, opts, false);
      return this;
    };
    Boot.prototype._loadRegistered = function() {
      const plugin = this._current[0];
      const weNeedToStart = !this.started && !this.booted;
      if (weNeedToStart) {
        process.nextTick(() => this._root.queue.resume());
      }
      if (!plugin) {
        return Promise.resolve();
      }
      return plugin.loadedSoFar();
    };
    Object.defineProperty(Boot.prototype, "then", { get: thenify });
    Boot.prototype._addPlugin = function(pluginFn, opts, isAfter) {
      if (isBundledOrTypescriptPlugin(pluginFn)) {
        pluginFn = pluginFn.default;
      }
      validatePlugin(pluginFn);
      opts = opts || {};
      if (this.booted) {
        throw new AVV_ERR_ROOT_PLG_BOOTED();
      }
      const current = this._current[0];
      let timeout = this._opts.timeout;
      if (!current.loaded && current.timeout > 0) {
        const delta = Date.now() - current.startTime;
        timeout = current.timeout - (delta + 3);
      }
      const plugin = new Plugin(fastq(this, this._loadPluginNextTick, 1), pluginFn, opts, isAfter, timeout);
      this._trackPluginLoading(plugin);
      if (current.loaded) {
        throw new Error(plugin.name, current.name);
      }
      current.enqueue(plugin, (err) => {
        err && (this._error = err);
      });
      return plugin;
    };
    Boot.prototype._expose = function _expose() {
      const instance = this;
      const server = instance._server;
      const {
        use: useKey = "use",
        after: afterKey = "after",
        ready: readyKey = "ready",
        onClose: onCloseKey = "onClose",
        close: closeKey = "close"
      } = this._opts.expose;
      if (server[useKey]) {
        throw new AVV_ERR_EXPOSE_ALREADY_DEFINED(useKey, "use");
      }
      server[useKey] = function(fn, opts) {
        instance.use(fn, opts);
        return this;
      };
      if (server[afterKey]) {
        throw new AVV_ERR_EXPOSE_ALREADY_DEFINED(afterKey, "after");
      }
      server[afterKey] = function(func) {
        if (typeof func !== "function") {
          return instance._loadRegistered();
        }
        instance.after(encapsulateThreeParam(func, this));
        return this;
      };
      if (server[readyKey]) {
        throw new AVV_ERR_EXPOSE_ALREADY_DEFINED(readyKey, "ready");
      }
      server[readyKey] = function(func) {
        if (func && typeof func !== "function") {
          throw new AVV_ERR_CALLBACK_NOT_FN(readyKey, typeof func);
        }
        return instance.ready(func ? encapsulateThreeParam(func, this) : void 0);
      };
      if (server[onCloseKey]) {
        throw new AVV_ERR_EXPOSE_ALREADY_DEFINED(onCloseKey, "onClose");
      }
      server[onCloseKey] = function(func) {
        if (typeof func !== "function") {
          throw new AVV_ERR_CALLBACK_NOT_FN(onCloseKey, typeof func);
        }
        instance.onClose(encapsulateTwoParam(func, this));
        return this;
      };
      if (server[closeKey]) {
        throw new AVV_ERR_EXPOSE_ALREADY_DEFINED(closeKey, "close");
      }
      server[closeKey] = function(func) {
        if (func && typeof func !== "function") {
          throw new AVV_ERR_CALLBACK_NOT_FN(closeKey, typeof func);
        }
        if (func) {
          instance.close(encapsulateThreeParam(func, this));
          return this;
        }
        return instance.close();
      };
      if (server.then) {
        throw new AVV_ERR_ATTRIBUTE_ALREADY_DEFINED("then");
      }
      Object.defineProperty(server, "then", { get: thenify.bind(instance) });
      server[kAvvio] = true;
    };
    Boot.prototype.after = function(func) {
      if (!func) {
        return this._loadRegistered();
      }
      this._addPlugin(_after.bind(this), {}, true);
      function _after(s, opts, done) {
        callWithCbOrNextTick.call(this, func, done);
      }
      return this;
    };
    Boot.prototype.onClose = function(func) {
      if (typeof func !== "function") {
        throw new AVV_ERR_CALLBACK_NOT_FN("onClose", typeof func);
      }
      func[kIsOnCloseHandler] = true;
      this._closeQ.unshift(func, (err) => {
        err && (this._error = err);
      });
      return this;
    };
    Boot.prototype.close = function(func) {
      let promise;
      if (func) {
        if (typeof func !== "function") {
          throw new AVV_ERR_CALLBACK_NOT_FN("close", typeof func);
        }
      } else {
        promise = new Promise(function(resolve, reject) {
          func = function(err) {
            if (err) {
              return reject(err);
            }
            resolve();
          };
        });
      }
      this.ready(() => {
        this._error = null;
        this._closeQ.push(func);
        process.nextTick(this._closeQ.resume.bind(this._closeQ));
      });
      return promise;
    };
    Boot.prototype.ready = function(func) {
      if (func) {
        if (typeof func !== "function") {
          throw new AVV_ERR_CALLBACK_NOT_FN("ready", typeof func);
        }
        this._readyQ.push(func);
        queueMicrotask(this.start.bind(this));
        return;
      }
      return new Promise((resolve, reject) => {
        this._readyQ.push(readyPromiseCB);
        this.start();
        const relativeContext = this._current[0].server;
        function readyPromiseCB(err, context, done) {
          if (err) {
            reject(err);
          } else {
            resolve(relativeContext);
          }
          process.nextTick(done);
        }
      });
    };
    Boot.prototype._trackPluginLoading = function(plugin) {
      const parentName = this._current[0]?.name || null;
      plugin.once("start", (serverName, funcName, time) => {
        const nodeId = this.pluginTree.start(parentName || null, funcName, time);
        plugin.once("loaded", (serverName2, funcName2, time2) => {
          this.pluginTree.stop(nodeId, time2);
        });
      });
    };
    Boot.prototype.prettyPrint = function() {
      return this.pluginTree.prettyPrint();
    };
    Boot.prototype.toJSON = function() {
      return this.pluginTree.toJSON();
    };
    Boot.prototype._loadPlugin = function(plugin, callback) {
      const instance = this;
      if (isPromiseLike(plugin.func)) {
        plugin.func.then((fn) => {
          if (typeof fn.default === "function") {
            fn = fn.default;
          }
          plugin.func = fn;
          this._loadPlugin(plugin, callback);
        }, callback);
        return;
      }
      const last = instance._current[0];
      instance._current.unshift(plugin);
      if (instance._error && !plugin.isAfter) {
        debug("skipping loading of plugin as instance errored and it is not an after", plugin.name);
        process.nextTick(execCallback);
        return;
      }
      let server = last && last.server || instance._server;
      if (!plugin.isAfter) {
        try {
          server = instance.override(server, plugin.func, plugin.options);
        } catch (overrideErr) {
          debug("override errored", plugin.name);
          return execCallback(overrideErr);
        }
      }
      plugin.exec(server, execCallback);
      function execCallback(err) {
        plugin.finish(err, (err2) => {
          instance._current.shift();
          callback(err2);
        });
      }
    };
    Boot.prototype._loadPluginNextTick = function(plugin, callback) {
      process.nextTick(this._loadPlugin.bind(this), plugin, callback);
    };
    function noop() {
    }
    function callWithCbOrNextTick(func, cb) {
      const context = this._server;
      const err = this._error;
      this._error = null;
      if (func.length === 0) {
        this._error = err;
        executeWithThenable(func, [], cb);
      } else if (func.length === 1) {
        executeWithThenable(func, [err], cb);
      } else {
        if (this._opts.timeout === 0) {
          const wrapCb = (err2) => {
            this._error = err2;
            cb(this._error);
          };
          if (func.length === 2) {
            func(err, wrapCb);
          } else {
            func(err, context, wrapCb);
          }
        } else {
          timeoutCall.call(this, func, err, context, cb);
        }
      }
    }
    function timeoutCall(func, rootErr, context, cb) {
      const name = func.unwrappedName ?? func.name;
      debug("setting up ready timeout", name, this._opts.timeout);
      let timer = setTimeout(() => {
        debug("timed out", name);
        timer = null;
        const toutErr = new AVV_ERR_READY_TIMEOUT(name);
        toutErr.fn = func;
        this._error = toutErr;
        cb(toutErr);
      }, this._opts.timeout);
      if (func.length === 2) {
        func(rootErr, timeoutCb.bind(this));
      } else {
        func(rootErr, context, timeoutCb.bind(this));
      }
      function timeoutCb(err) {
        if (timer) {
          clearTimeout(timer);
          this._error = err;
          cb(this._error);
        } else {
        }
      }
    }
    function closeWithCbOrNextTick(func, cb) {
      const context = this._server;
      const isOnCloseHandler = func[kIsOnCloseHandler];
      if (func.length === 0 || func.length === 1) {
        let promise;
        if (isOnCloseHandler) {
          promise = func(context);
        } else {
          promise = func(this._error);
        }
        if (promise && typeof promise.then === "function") {
          debug("resolving close/onClose promise");
          promise.then(
            () => process.nextTick(cb),
            (e) => process.nextTick(cb, e)
          );
        } else {
          process.nextTick(cb);
        }
      } else if (func.length === 2) {
        if (isOnCloseHandler) {
          func(context, cb);
        } else {
          func(this._error, cb);
        }
      } else {
        if (isOnCloseHandler) {
          func(context, cb);
        } else {
          func(this._error, context, cb);
        }
      }
    }
    function encapsulateTwoParam(func, that) {
      return _encapsulateTwoParam.bind(that);
      function _encapsulateTwoParam(context, cb) {
        let res;
        if (func.length === 0) {
          res = func();
          if (res && res.then) {
            res.then(function() {
              process.nextTick(cb);
            }, cb);
          } else {
            process.nextTick(cb);
          }
        } else if (func.length === 1) {
          res = func(this);
          if (res && res.then) {
            res.then(function() {
              process.nextTick(cb);
            }, cb);
          } else {
            process.nextTick(cb);
          }
        } else {
          func(this, cb);
        }
      }
    }
    function encapsulateThreeParam(func, that) {
      const wrapped = _encapsulateThreeParam.bind(that);
      wrapped.unwrappedName = func.name;
      return wrapped;
      function _encapsulateThreeParam(err, cb) {
        let res;
        if (!func) {
          process.nextTick(cb);
        } else if (func.length === 0) {
          res = func();
          if (res && res.then) {
            res.then(function() {
              process.nextTick(cb, err);
            }, cb);
          } else {
            process.nextTick(cb, err);
          }
        } else if (func.length === 1) {
          res = func(err);
          if (res && res.then) {
            res.then(function() {
              process.nextTick(cb);
            }, cb);
          } else {
            process.nextTick(cb);
          }
        } else if (func.length === 2) {
          func(err, cb);
        } else {
          func(err, this, cb);
        }
      }
    }
    module2.exports = Boot;
  }
});

// node_modules/fastify/lib/symbols.js
var require_symbols2 = __commonJS({
  "node_modules/fastify/lib/symbols.js"(exports2, module2) {
    "use strict";
    var keys = {
      kAvvioBoot: Symbol("fastify.avvioBoot"),
      kChildren: Symbol("fastify.children"),
      kServerBindings: Symbol("fastify.serverBindings"),
      kBodyLimit: Symbol("fastify.bodyLimit"),
      kSupportedHTTPMethods: Symbol("fastify.acceptedHTTPMethods"),
      kRoutePrefix: Symbol("fastify.routePrefix"),
      kLogLevel: Symbol("fastify.logLevel"),
      kLogSerializers: Symbol("fastify.logSerializers"),
      kHooks: Symbol("fastify.hooks"),
      kContentTypeParser: Symbol("fastify.contentTypeParser"),
      kState: Symbol("fastify.state"),
      kOptions: Symbol("fastify.options"),
      kDisableRequestLogging: Symbol("fastify.disableRequestLogging"),
      kPluginNameChain: Symbol("fastify.pluginNameChain"),
      kRouteContext: Symbol("fastify.context"),
      kGenReqId: Symbol("fastify.genReqId"),
      // Schema
      kSchemaController: Symbol("fastify.schemaController"),
      kSchemaHeaders: Symbol("headers-schema"),
      kSchemaParams: Symbol("params-schema"),
      kSchemaQuerystring: Symbol("querystring-schema"),
      kSchemaBody: Symbol("body-schema"),
      kSchemaResponse: Symbol("response-schema"),
      kSchemaErrorFormatter: Symbol("fastify.schemaErrorFormatter"),
      kSchemaVisited: Symbol("fastify.schemas.visited"),
      // Request
      kRequest: Symbol("fastify.Request"),
      kRequestPayloadStream: Symbol("fastify.RequestPayloadStream"),
      kRequestAcceptVersion: Symbol("fastify.RequestAcceptVersion"),
      kRequestCacheValidateFns: Symbol("fastify.request.cache.validateFns"),
      kRequestOriginalUrl: Symbol("fastify.request.originalUrl"),
      // 404
      kFourOhFour: Symbol("fastify.404"),
      kCanSetNotFoundHandler: Symbol("fastify.canSetNotFoundHandler"),
      kFourOhFourLevelInstance: Symbol("fastify.404LogLevelInstance"),
      kFourOhFourContext: Symbol("fastify.404ContextKey"),
      kDefaultJsonParse: Symbol("fastify.defaultJSONParse"),
      // Reply
      kReply: Symbol("fastify.Reply"),
      kReplySerializer: Symbol("fastify.reply.serializer"),
      kReplyIsError: Symbol("fastify.reply.isError"),
      kReplyHeaders: Symbol("fastify.reply.headers"),
      kReplyTrailers: Symbol("fastify.reply.trailers"),
      kReplyHasStatusCode: Symbol("fastify.reply.hasStatusCode"),
      kReplyHijacked: Symbol("fastify.reply.hijacked"),
      kReplyStartTime: Symbol("fastify.reply.startTime"),
      kReplyNextErrorHandler: Symbol("fastify.reply.nextErrorHandler"),
      kReplyEndTime: Symbol("fastify.reply.endTime"),
      kReplyErrorHandlerCalled: Symbol("fastify.reply.errorHandlerCalled"),
      kReplyIsRunningOnErrorHook: Symbol("fastify.reply.isRunningOnErrorHook"),
      kReplySerializerDefault: Symbol("fastify.replySerializerDefault"),
      kReplyCacheSerializeFns: Symbol("fastify.reply.cache.serializeFns"),
      // This symbol is only meant to be used for fastify tests and should not be used for any other purpose
      kTestInternals: Symbol("fastify.testInternals"),
      kErrorHandler: Symbol("fastify.errorHandler"),
      kErrorHandlerAlreadySet: Symbol("fastify.errorHandlerAlreadySet"),
      kChildLoggerFactory: Symbol("fastify.childLoggerFactory"),
      kHasBeenDecorated: Symbol("fastify.hasBeenDecorated"),
      kKeepAliveConnections: Symbol("fastify.keepAliveConnections"),
      kRouteByFastify: Symbol("fastify.routeByFastify")
    };
    module2.exports = keys;
  }
});

// node_modules/process-warning/index.js
var require_process_warning = __commonJS({
  "node_modules/process-warning/index.js"(exports2, module2) {
    "use strict";
    var { format } = require("node:util");
    function createDeprecation(params) {
      return createWarning({ ...params, name: "DeprecationWarning" });
    }
    function createWarning({ name, code, message, unlimited = false } = {}) {
      if (!name) throw new Error("Warning name must not be empty");
      if (!code) throw new Error("Warning code must not be empty");
      if (!message) throw new Error("Warning message must not be empty");
      if (typeof unlimited !== "boolean") throw new Error("Warning opts.unlimited must be a boolean");
      code = code.toUpperCase();
      let warningContainer = {
        [name]: function(a, b, c) {
          if (warning.emitted === true && warning.unlimited !== true) {
            return;
          }
          warning.emitted = true;
          process.emitWarning(warning.format(a, b, c), warning.name, warning.code);
        }
      };
      if (unlimited) {
        warningContainer = {
          [name]: function(a, b, c) {
            warning.emitted = true;
            process.emitWarning(warning.format(a, b, c), warning.name, warning.code);
          }
        };
      }
      const warning = warningContainer[name];
      warning.emitted = false;
      warning.message = message;
      warning.unlimited = unlimited;
      warning.code = code;
      warning.format = function(a, b, c) {
        let formatted;
        if (a && b && c) {
          formatted = format(message, a, b, c);
        } else if (a && b) {
          formatted = format(message, a, b);
        } else if (a) {
          formatted = format(message, a);
        } else {
          formatted = message;
        }
        return formatted;
      };
      return warning;
    }
    var out = { createWarning, createDeprecation };
    module2.exports = out;
    module2.exports.default = out;
    module2.exports.processWarning = out;
  }
});

// node_modules/fastify/lib/warnings.js
var require_warnings = __commonJS({
  "node_modules/fastify/lib/warnings.js"(exports2, module2) {
    "use strict";
    var { createWarning } = require_process_warning();
    var FSTWRN001 = createWarning({
      name: "FastifyWarning",
      code: "FSTWRN001",
      message: "The %s schema for %s: %s is missing. This may indicate the schema is not well specified.",
      unlimited: true
    });
    var FSTWRN003 = createWarning({
      name: "FastifyWarning",
      code: "FSTWRN003",
      message: "The %s mixes async and callback styles that may lead to unhandled rejections. Please use only one of them.",
      unlimited: true
    });
    var FSTWRN004 = createWarning({
      name: "FastifyWarning",
      code: "FSTWRN004",
      message: "It seems that you are overriding an errorHandler in the same scope, which can lead to subtle bugs.",
      unlimited: true
    });
    var FSTSEC001 = createWarning({
      name: "FastifySecurity",
      code: "FSTSEC001",
      message: 'You are using /%s/ Content-Type which may be vulnerable to CORS attack. Please make sure your RegExp start with "^" or include ";?" to proper detection of the essence MIME type.',
      unlimited: true
    });
    module2.exports = {
      FSTWRN001,
      FSTWRN003,
      FSTWRN004,
      FSTSEC001
    };
  }
});

// node_modules/fastify/lib/errors.js
var require_errors2 = __commonJS({
  "node_modules/fastify/lib/errors.js"(exports2, module2) {
    "use strict";
    var createError = require_error();
    var codes = {
      /**
       * Basic
       */
      FST_ERR_NOT_FOUND: createError(
        "FST_ERR_NOT_FOUND",
        "Not Found",
        404
      ),
      FST_ERR_OPTIONS_NOT_OBJ: createError(
        "FST_ERR_OPTIONS_NOT_OBJ",
        "Options must be an object",
        500,
        TypeError
      ),
      FST_ERR_QSP_NOT_FN: createError(
        "FST_ERR_QSP_NOT_FN",
        "querystringParser option should be a function, instead got '%s'",
        500,
        TypeError
      ),
      FST_ERR_SCHEMA_CONTROLLER_BUCKET_OPT_NOT_FN: createError(
        "FST_ERR_SCHEMA_CONTROLLER_BUCKET_OPT_NOT_FN",
        "schemaController.bucket option should be a function, instead got '%s'",
        500,
        TypeError
      ),
      FST_ERR_SCHEMA_ERROR_FORMATTER_NOT_FN: createError(
        "FST_ERR_SCHEMA_ERROR_FORMATTER_NOT_FN",
        "schemaErrorFormatter option should be a non async function. Instead got '%s'.",
        500,
        TypeError
      ),
      FST_ERR_AJV_CUSTOM_OPTIONS_OPT_NOT_OBJ: createError(
        "FST_ERR_AJV_CUSTOM_OPTIONS_OPT_NOT_OBJ",
        "ajv.customOptions option should be an object, instead got '%s'",
        500,
        TypeError
      ),
      FST_ERR_AJV_CUSTOM_OPTIONS_OPT_NOT_ARR: createError(
        "FST_ERR_AJV_CUSTOM_OPTIONS_OPT_NOT_ARR",
        "ajv.plugins option should be an array, instead got '%s'",
        500,
        TypeError
      ),
      FST_ERR_VALIDATION: createError(
        "FST_ERR_VALIDATION",
        "%s",
        400
      ),
      FST_ERR_LISTEN_OPTIONS_INVALID: createError(
        "FST_ERR_LISTEN_OPTIONS_INVALID",
        "Invalid listen options: '%s'",
        500,
        TypeError
      ),
      FST_ERR_ERROR_HANDLER_NOT_FN: createError(
        "FST_ERR_ERROR_HANDLER_NOT_FN",
        "Error Handler must be a function",
        500,
        TypeError
      ),
      FST_ERR_ERROR_HANDLER_ALREADY_SET: createError(
        "FST_ERR_ERROR_HANDLER_ALREADY_SET",
        "Error Handler already set in this scope. Set 'allowErrorHandlerOverride: true' to allow overriding.",
        500,
        TypeError
      ),
      /**
       * ContentTypeParser
      */
      FST_ERR_CTP_ALREADY_PRESENT: createError(
        "FST_ERR_CTP_ALREADY_PRESENT",
        "Content type parser '%s' already present."
      ),
      FST_ERR_CTP_INVALID_TYPE: createError(
        "FST_ERR_CTP_INVALID_TYPE",
        "The content type should be a string or a RegExp",
        500,
        TypeError
      ),
      FST_ERR_CTP_EMPTY_TYPE: createError(
        "FST_ERR_CTP_EMPTY_TYPE",
        "The content type cannot be an empty string",
        500,
        TypeError
      ),
      FST_ERR_CTP_INVALID_HANDLER: createError(
        "FST_ERR_CTP_INVALID_HANDLER",
        "The content type handler should be a function",
        500,
        TypeError
      ),
      FST_ERR_CTP_INVALID_PARSE_TYPE: createError(
        "FST_ERR_CTP_INVALID_PARSE_TYPE",
        "The body parser can only parse your data as 'string' or 'buffer', you asked '%s' which is not supported.",
        500,
        TypeError
      ),
      FST_ERR_CTP_BODY_TOO_LARGE: createError(
        "FST_ERR_CTP_BODY_TOO_LARGE",
        "Request body is too large",
        413,
        RangeError
      ),
      FST_ERR_CTP_INVALID_MEDIA_TYPE: createError(
        "FST_ERR_CTP_INVALID_MEDIA_TYPE",
        "Unsupported Media Type: %s",
        415
      ),
      FST_ERR_CTP_INVALID_CONTENT_LENGTH: createError(
        "FST_ERR_CTP_INVALID_CONTENT_LENGTH",
        "Request body size did not match Content-Length",
        400,
        RangeError
      ),
      FST_ERR_CTP_EMPTY_JSON_BODY: createError(
        "FST_ERR_CTP_EMPTY_JSON_BODY",
        "Body cannot be empty when content-type is set to 'application/json'",
        400
      ),
      FST_ERR_CTP_INSTANCE_ALREADY_STARTED: createError(
        "FST_ERR_CTP_INSTANCE_ALREADY_STARTED",
        'Cannot call "%s" when fastify instance is already started!',
        400
      ),
      /**
       * decorate
      */
      FST_ERR_DEC_ALREADY_PRESENT: createError(
        "FST_ERR_DEC_ALREADY_PRESENT",
        "The decorator '%s' has already been added!"
      ),
      FST_ERR_DEC_DEPENDENCY_INVALID_TYPE: createError(
        "FST_ERR_DEC_DEPENDENCY_INVALID_TYPE",
        "The dependencies of decorator '%s' must be of type Array.",
        500,
        TypeError
      ),
      FST_ERR_DEC_MISSING_DEPENDENCY: createError(
        "FST_ERR_DEC_MISSING_DEPENDENCY",
        "The decorator is missing dependency '%s'."
      ),
      FST_ERR_DEC_AFTER_START: createError(
        "FST_ERR_DEC_AFTER_START",
        "The decorator '%s' has been added after start!"
      ),
      FST_ERR_DEC_REFERENCE_TYPE: createError(
        "FST_ERR_DEC_REFERENCE_TYPE",
        "The decorator '%s' of type '%s' is a reference type. Use the { getter, setter } interface instead."
      ),
      FST_ERR_DEC_UNDECLARED: createError(
        "FST_ERR_DEC_UNDECLARED",
        "No decorator '%s' has been declared on %s."
      ),
      /**
       * hooks
      */
      FST_ERR_HOOK_INVALID_TYPE: createError(
        "FST_ERR_HOOK_INVALID_TYPE",
        "The hook name must be a string",
        500,
        TypeError
      ),
      FST_ERR_HOOK_INVALID_HANDLER: createError(
        "FST_ERR_HOOK_INVALID_HANDLER",
        "%s hook should be a function, instead got %s",
        500,
        TypeError
      ),
      FST_ERR_HOOK_INVALID_ASYNC_HANDLER: createError(
        "FST_ERR_HOOK_INVALID_ASYNC_HANDLER",
        "Async function has too many arguments. Async hooks should not use the 'done' argument.",
        500,
        TypeError
      ),
      FST_ERR_HOOK_NOT_SUPPORTED: createError(
        "FST_ERR_HOOK_NOT_SUPPORTED",
        "%s hook not supported!",
        500,
        TypeError
      ),
      /**
       * Middlewares
       */
      FST_ERR_MISSING_MIDDLEWARE: createError(
        "FST_ERR_MISSING_MIDDLEWARE",
        "You must register a plugin for handling middlewares, visit fastify.dev/docs/latest/Reference/Middleware/ for more info.",
        500
      ),
      FST_ERR_HOOK_TIMEOUT: createError(
        "FST_ERR_HOOK_TIMEOUT",
        "A callback for '%s' hook%s timed out. You may have forgotten to call 'done' function or to resolve a Promise"
      ),
      /**
       * logger
      */
      FST_ERR_LOG_INVALID_DESTINATION: createError(
        "FST_ERR_LOG_INVALID_DESTINATION",
        "Cannot specify both logger.stream and logger.file options"
      ),
      FST_ERR_LOG_INVALID_LOGGER: createError(
        "FST_ERR_LOG_INVALID_LOGGER",
        "Invalid logger object provided. The logger instance should have these functions(s): '%s'.",
        500,
        TypeError
      ),
      FST_ERR_LOG_INVALID_LOGGER_INSTANCE: createError(
        "FST_ERR_LOG_INVALID_LOGGER_INSTANCE",
        "loggerInstance only accepts a logger instance.",
        500,
        TypeError
      ),
      FST_ERR_LOG_INVALID_LOGGER_CONFIG: createError(
        "FST_ERR_LOG_INVALID_LOGGER_CONFIG",
        "logger options only accepts a configuration object.",
        500,
        TypeError
      ),
      FST_ERR_LOG_LOGGER_AND_LOGGER_INSTANCE_PROVIDED: createError(
        "FST_ERR_LOG_LOGGER_AND_LOGGER_INSTANCE_PROVIDED",
        "You cannot provide both logger and loggerInstance. Please provide only one.",
        500,
        TypeError
      ),
      /**
       * reply
      */
      FST_ERR_REP_INVALID_PAYLOAD_TYPE: createError(
        "FST_ERR_REP_INVALID_PAYLOAD_TYPE",
        "Attempted to send payload of invalid type '%s'. Expected a string or Buffer.",
        500,
        TypeError
      ),
      FST_ERR_REP_RESPONSE_BODY_CONSUMED: createError(
        "FST_ERR_REP_RESPONSE_BODY_CONSUMED",
        "Response.body is already consumed."
      ),
      FST_ERR_REP_READABLE_STREAM_LOCKED: createError(
        "FST_ERR_REP_READABLE_STREAM_LOCKED",
        "ReadableStream was locked. You should call releaseLock() method on reader before sending."
      ),
      FST_ERR_REP_ALREADY_SENT: createError(
        "FST_ERR_REP_ALREADY_SENT",
        'Reply was already sent, did you forget to "return reply" in "%s" (%s)?'
      ),
      FST_ERR_REP_SENT_VALUE: createError(
        "FST_ERR_REP_SENT_VALUE",
        "The only possible value for reply.sent is true.",
        500,
        TypeError
      ),
      FST_ERR_SEND_INSIDE_ONERR: createError(
        "FST_ERR_SEND_INSIDE_ONERR",
        "You cannot use `send` inside the `onError` hook"
      ),
      FST_ERR_SEND_UNDEFINED_ERR: createError(
        "FST_ERR_SEND_UNDEFINED_ERR",
        "Undefined error has occurred"
      ),
      FST_ERR_BAD_STATUS_CODE: createError(
        "FST_ERR_BAD_STATUS_CODE",
        "Called reply with an invalid status code: %s"
      ),
      FST_ERR_BAD_TRAILER_NAME: createError(
        "FST_ERR_BAD_TRAILER_NAME",
        "Called reply.trailer with an invalid header name: %s"
      ),
      FST_ERR_BAD_TRAILER_VALUE: createError(
        "FST_ERR_BAD_TRAILER_VALUE",
        "Called reply.trailer('%s', fn) with an invalid type: %s. Expected a function."
      ),
      FST_ERR_FAILED_ERROR_SERIALIZATION: createError(
        "FST_ERR_FAILED_ERROR_SERIALIZATION",
        "Failed to serialize an error. Error: %s. Original error: %s"
      ),
      FST_ERR_MISSING_SERIALIZATION_FN: createError(
        "FST_ERR_MISSING_SERIALIZATION_FN",
        'Missing serialization function. Key "%s"'
      ),
      FST_ERR_MISSING_CONTENTTYPE_SERIALIZATION_FN: createError(
        "FST_ERR_MISSING_CONTENTTYPE_SERIALIZATION_FN",
        'Missing serialization function. Key "%s:%s"'
      ),
      FST_ERR_REQ_INVALID_VALIDATION_INVOCATION: createError(
        "FST_ERR_REQ_INVALID_VALIDATION_INVOCATION",
        'Invalid validation invocation. Missing validation function for HTTP part "%s" nor schema provided.'
      ),
      /**
       * schemas
      */
      FST_ERR_SCH_MISSING_ID: createError(
        "FST_ERR_SCH_MISSING_ID",
        "Missing schema $id property"
      ),
      FST_ERR_SCH_ALREADY_PRESENT: createError(
        "FST_ERR_SCH_ALREADY_PRESENT",
        "Schema with id '%s' already declared!"
      ),
      FST_ERR_SCH_CONTENT_MISSING_SCHEMA: createError(
        "FST_ERR_SCH_CONTENT_MISSING_SCHEMA",
        "Schema is missing for the content type '%s'"
      ),
      FST_ERR_SCH_DUPLICATE: createError(
        "FST_ERR_SCH_DUPLICATE",
        "Schema with '%s' already present!"
      ),
      FST_ERR_SCH_VALIDATION_BUILD: createError(
        "FST_ERR_SCH_VALIDATION_BUILD",
        "Failed building the validation schema for %s: %s, due to error %s"
      ),
      FST_ERR_SCH_SERIALIZATION_BUILD: createError(
        "FST_ERR_SCH_SERIALIZATION_BUILD",
        "Failed building the serialization schema for %s: %s, due to error %s"
      ),
      FST_ERR_SCH_RESPONSE_SCHEMA_NOT_NESTED_2XX: createError(
        "FST_ERR_SCH_RESPONSE_SCHEMA_NOT_NESTED_2XX",
        'response schemas should be nested under a valid status code, e.g { 2xx: { type: "object" } }'
      ),
      /**
       * initialConfig
       */
      FST_ERR_INIT_OPTS_INVALID: createError(
        "FST_ERR_INIT_OPTS_INVALID",
        "Invalid initialization options: '%s'"
      ),
      FST_ERR_FORCE_CLOSE_CONNECTIONS_IDLE_NOT_AVAILABLE: createError(
        "FST_ERR_FORCE_CLOSE_CONNECTIONS_IDLE_NOT_AVAILABLE",
        "Cannot set forceCloseConnections to 'idle' as your HTTP server does not support closeIdleConnections method"
      ),
      /**
       * router
       */
      FST_ERR_DUPLICATED_ROUTE: createError(
        "FST_ERR_DUPLICATED_ROUTE",
        "Method '%s' already declared for route '%s'"
      ),
      FST_ERR_BAD_URL: createError(
        "FST_ERR_BAD_URL",
        "'%s' is not a valid url component",
        400,
        URIError
      ),
      FST_ERR_ASYNC_CONSTRAINT: createError(
        "FST_ERR_ASYNC_CONSTRAINT",
        "Unexpected error from async constraint",
        500
      ),
      FST_ERR_INVALID_URL: createError(
        "FST_ERR_INVALID_URL",
        "URL must be a string. Received '%s'",
        400,
        TypeError
      ),
      FST_ERR_ROUTE_OPTIONS_NOT_OBJ: createError(
        "FST_ERR_ROUTE_OPTIONS_NOT_OBJ",
        'Options for "%s:%s" route must be an object',
        500,
        TypeError
      ),
      FST_ERR_ROUTE_DUPLICATED_HANDLER: createError(
        "FST_ERR_ROUTE_DUPLICATED_HANDLER",
        'Duplicate handler for "%s:%s" route is not allowed!',
        500
      ),
      FST_ERR_ROUTE_HANDLER_NOT_FN: createError(
        "FST_ERR_ROUTE_HANDLER_NOT_FN",
        "Error Handler for %s:%s route, if defined, must be a function",
        500,
        TypeError
      ),
      FST_ERR_ROUTE_MISSING_HANDLER: createError(
        "FST_ERR_ROUTE_MISSING_HANDLER",
        'Missing handler function for "%s:%s" route.',
        500
      ),
      FST_ERR_ROUTE_METHOD_INVALID: createError(
        "FST_ERR_ROUTE_METHOD_INVALID",
        "Provided method is invalid!",
        500,
        TypeError
      ),
      FST_ERR_ROUTE_METHOD_NOT_SUPPORTED: createError(
        "FST_ERR_ROUTE_METHOD_NOT_SUPPORTED",
        "%s method is not supported.",
        500
      ),
      FST_ERR_ROUTE_BODY_VALIDATION_SCHEMA_NOT_SUPPORTED: createError(
        "FST_ERR_ROUTE_BODY_VALIDATION_SCHEMA_NOT_SUPPORTED",
        "Body validation schema for %s:%s route is not supported!",
        500
      ),
      FST_ERR_ROUTE_BODY_LIMIT_OPTION_NOT_INT: createError(
        "FST_ERR_ROUTE_BODY_LIMIT_OPTION_NOT_INT",
        "'bodyLimit' option must be an integer > 0. Got '%s'",
        500,
        TypeError
      ),
      FST_ERR_ROUTE_REWRITE_NOT_STR: createError(
        "FST_ERR_ROUTE_REWRITE_NOT_STR",
        'Rewrite url for "%s" needs to be of type "string" but received "%s"',
        500,
        TypeError
      ),
      /**
       *  again listen when close server
       */
      FST_ERR_REOPENED_CLOSE_SERVER: createError(
        "FST_ERR_REOPENED_CLOSE_SERVER",
        "Fastify has already been closed and cannot be reopened"
      ),
      FST_ERR_REOPENED_SERVER: createError(
        "FST_ERR_REOPENED_SERVER",
        "Fastify is already listening"
      ),
      FST_ERR_INSTANCE_ALREADY_LISTENING: createError(
        "FST_ERR_INSTANCE_ALREADY_LISTENING",
        "Fastify instance is already listening. %s"
      ),
      /**
       * plugin
       */
      FST_ERR_PLUGIN_VERSION_MISMATCH: createError(
        "FST_ERR_PLUGIN_VERSION_MISMATCH",
        "fastify-plugin: %s - expected '%s' fastify version, '%s' is installed"
      ),
      FST_ERR_PLUGIN_NOT_PRESENT_IN_INSTANCE: createError(
        "FST_ERR_PLUGIN_NOT_PRESENT_IN_INSTANCE",
        "The decorator '%s'%s is not present in %s"
      ),
      FST_ERR_PLUGIN_INVALID_ASYNC_HANDLER: createError(
        "FST_ERR_PLUGIN_INVALID_ASYNC_HANDLER",
        "The %s plugin being registered mixes async and callback styles. Async plugin should not mix async and callback style.",
        500,
        TypeError
      ),
      /**
       *  Avvio Errors
       */
      FST_ERR_PLUGIN_CALLBACK_NOT_FN: createError(
        "FST_ERR_PLUGIN_CALLBACK_NOT_FN",
        "fastify-plugin: %s",
        500,
        TypeError
      ),
      FST_ERR_PLUGIN_NOT_VALID: createError(
        "FST_ERR_PLUGIN_NOT_VALID",
        "fastify-plugin: %s"
      ),
      FST_ERR_ROOT_PLG_BOOTED: createError(
        "FST_ERR_ROOT_PLG_BOOTED",
        "fastify-plugin: %s"
      ),
      FST_ERR_PARENT_PLUGIN_BOOTED: createError(
        "FST_ERR_PARENT_PLUGIN_BOOTED",
        "fastify-plugin: %s"
      ),
      FST_ERR_PLUGIN_TIMEOUT: createError(
        "FST_ERR_PLUGIN_TIMEOUT",
        "fastify-plugin: %s"
      )
    };
    function appendStackTrace(oldErr, newErr) {
      newErr.cause = oldErr;
      return newErr;
    }
    module2.exports = codes;
    module2.exports.appendStackTrace = appendStackTrace;
    module2.exports.AVVIO_ERRORS_MAP = {
      AVV_ERR_CALLBACK_NOT_FN: codes.FST_ERR_PLUGIN_CALLBACK_NOT_FN,
      AVV_ERR_PLUGIN_NOT_VALID: codes.FST_ERR_PLUGIN_NOT_VALID,
      AVV_ERR_ROOT_PLG_BOOTED: codes.FST_ERR_ROOT_PLG_BOOTED,
      AVV_ERR_PARENT_PLG_LOADED: codes.FST_ERR_PARENT_PLUGIN_BOOTED,
      AVV_ERR_READY_TIMEOUT: codes.FST_ERR_PLUGIN_TIMEOUT,
      AVV_ERR_PLUGIN_EXEC_TIMEOUT: codes.FST_ERR_PLUGIN_TIMEOUT
    };
  }
});

// node_modules/fastify/lib/hooks.js
var require_hooks = __commonJS({
  "node_modules/fastify/lib/hooks.js"(exports2, module2) {
    "use strict";
    var applicationHooks = [
      "onRoute",
      "onRegister",
      "onReady",
      "onListen",
      "preClose",
      "onClose"
    ];
    var lifecycleHooks = [
      "onTimeout",
      "onRequest",
      "preParsing",
      "preValidation",
      "preSerialization",
      "preHandler",
      "onSend",
      "onResponse",
      "onError",
      "onRequestAbort"
    ];
    var supportedHooks = lifecycleHooks.concat(applicationHooks);
    var {
      FST_ERR_HOOK_INVALID_TYPE,
      FST_ERR_HOOK_INVALID_HANDLER,
      FST_ERR_SEND_UNDEFINED_ERR,
      FST_ERR_HOOK_TIMEOUT,
      FST_ERR_HOOK_NOT_SUPPORTED,
      AVVIO_ERRORS_MAP,
      appendStackTrace
    } = require_errors2();
    var {
      kChildren,
      kHooks,
      kRequestPayloadStream
    } = require_symbols2();
    function Hooks() {
      this.onRequest = [];
      this.preParsing = [];
      this.preValidation = [];
      this.preSerialization = [];
      this.preHandler = [];
      this.onResponse = [];
      this.onSend = [];
      this.onError = [];
      this.onRoute = [];
      this.onRegister = [];
      this.onReady = [];
      this.onListen = [];
      this.onTimeout = [];
      this.onRequestAbort = [];
      this.preClose = [];
    }
    Hooks.prototype = /* @__PURE__ */ Object.create(null);
    Hooks.prototype.validate = function(hook, fn) {
      if (typeof hook !== "string") throw new FST_ERR_HOOK_INVALID_TYPE();
      if (Array.isArray(this[hook]) === false) {
        throw new FST_ERR_HOOK_NOT_SUPPORTED(hook);
      }
      if (typeof fn !== "function") throw new FST_ERR_HOOK_INVALID_HANDLER(hook, Object.prototype.toString.call(fn));
    };
    Hooks.prototype.add = function(hook, fn) {
      this.validate(hook, fn);
      this[hook].push(fn);
    };
    function buildHooks(h) {
      const hooks = new Hooks();
      hooks.onRequest = h.onRequest.slice();
      hooks.preParsing = h.preParsing.slice();
      hooks.preValidation = h.preValidation.slice();
      hooks.preSerialization = h.preSerialization.slice();
      hooks.preHandler = h.preHandler.slice();
      hooks.onSend = h.onSend.slice();
      hooks.onResponse = h.onResponse.slice();
      hooks.onError = h.onError.slice();
      hooks.onRoute = h.onRoute.slice();
      hooks.onRegister = h.onRegister.slice();
      hooks.onTimeout = h.onTimeout.slice();
      hooks.onRequestAbort = h.onRequestAbort.slice();
      hooks.onReady = [];
      hooks.onListen = [];
      hooks.preClose = [];
      return hooks;
    }
    function hookRunnerApplication(hookName, boot, server, cb) {
      const hooks = server[kHooks][hookName];
      let i = 0;
      let c = 0;
      next();
      function exit(err) {
        const hookFnName = hooks[i - 1]?.name;
        const hookFnFragment = hookFnName ? ` "${hookFnName}"` : "";
        if (err) {
          if (err.code === "AVV_ERR_READY_TIMEOUT") {
            err = appendStackTrace(err, new FST_ERR_HOOK_TIMEOUT(hookName, hookFnFragment));
          } else {
            err = AVVIO_ERRORS_MAP[err.code] != null ? appendStackTrace(err, new AVVIO_ERRORS_MAP[err.code](err.message)) : err;
          }
          cb(err);
          return;
        }
        cb();
      }
      function next(err) {
        if (err) {
          exit(err);
          return;
        }
        if (i === hooks.length && c === server[kChildren].length) {
          if (i === 0 && c === 0) {
            exit();
          } else {
            boot(function manageTimeout(err2, done) {
              exit(err2);
              done(err2);
            });
          }
          return;
        }
        if (i === hooks.length && c < server[kChildren].length) {
          const child = server[kChildren][c++];
          hookRunnerApplication(hookName, boot, child, next);
          return;
        }
        boot(wrap(hooks[i++], server));
        next();
      }
      function wrap(fn, server2) {
        return function(err, done) {
          if (err) {
            done(err);
            return;
          }
          if (fn.length === 1) {
            try {
              fn.call(server2, done);
            } catch (error) {
              done(error);
            }
            return;
          }
          try {
            const ret = fn.call(server2);
            if (ret && typeof ret.then === "function") {
              ret.then(done, done);
              return;
            }
          } catch (error) {
            err = error;
          }
          done(err);
        };
      }
    }
    function onListenHookRunner(server) {
      const hooks = server[kHooks].onListen;
      const hooksLen = hooks.length;
      let i = 0;
      let c = 0;
      next();
      function next(err) {
        err && server.log.error(err);
        if (i === hooksLen) {
          while (c < server[kChildren].length) {
            const child = server[kChildren][c++];
            onListenHookRunner(child);
          }
          return;
        }
        wrap(hooks[i++], server, next);
      }
      async function wrap(fn, server2, done) {
        if (fn.length === 1) {
          try {
            fn.call(server2, done);
          } catch (e) {
            done(e);
          }
          return;
        }
        try {
          const ret = fn.call(server2);
          if (ret && typeof ret.then === "function") {
            ret.then(done, done);
            return;
          }
          done();
        } catch (error) {
          done(error);
        }
      }
    }
    function hookRunnerGenerator(iterator) {
      return function hookRunner(functions, request, reply, cb) {
        let i = 0;
        function next(err) {
          if (err || i === functions.length) {
            cb(err, request, reply);
            return;
          }
          let result;
          try {
            result = iterator(functions[i++], request, reply, next);
          } catch (error) {
            cb(error, request, reply);
            return;
          }
          if (result && typeof result.then === "function") {
            result.then(handleResolve, handleReject);
          }
        }
        function handleResolve() {
          next();
        }
        function handleReject(err) {
          if (!err) {
            err = new FST_ERR_SEND_UNDEFINED_ERR();
          }
          cb(err, request, reply);
        }
        next();
      };
    }
    function onResponseHookIterator(fn, request, reply, next) {
      return fn(request, reply, next);
    }
    var onResponseHookRunner = hookRunnerGenerator(onResponseHookIterator);
    var preValidationHookRunner = hookRunnerGenerator(hookIterator);
    var preHandlerHookRunner = hookRunnerGenerator(hookIterator);
    var onTimeoutHookRunner = hookRunnerGenerator(hookIterator);
    var onRequestHookRunner = hookRunnerGenerator(hookIterator);
    function onSendHookRunner(functions, request, reply, payload, cb) {
      let i = 0;
      function next(err, newPayload) {
        if (err) {
          cb(err, request, reply, payload);
          return;
        }
        if (newPayload !== void 0) {
          payload = newPayload;
        }
        if (i === functions.length) {
          cb(null, request, reply, payload);
          return;
        }
        let result;
        try {
          result = functions[i++](request, reply, payload, next);
        } catch (error) {
          cb(error, request, reply);
          return;
        }
        if (result && typeof result.then === "function") {
          result.then(handleResolve, handleReject);
        }
      }
      function handleResolve(newPayload) {
        next(null, newPayload);
      }
      function handleReject(err) {
        if (!err) {
          err = new FST_ERR_SEND_UNDEFINED_ERR();
        }
        cb(err, request, reply, payload);
      }
      next();
    }
    var preSerializationHookRunner = onSendHookRunner;
    function preParsingHookRunner(functions, request, reply, cb) {
      let i = 0;
      function next(err, newPayload) {
        if (reply.sent) {
          return;
        }
        if (newPayload !== void 0) {
          request[kRequestPayloadStream] = newPayload;
        }
        if (err || i === functions.length) {
          cb(err, request, reply);
          return;
        }
        let result;
        try {
          result = functions[i++](request, reply, request[kRequestPayloadStream], next);
        } catch (error) {
          cb(error, request, reply);
          return;
        }
        if (result && typeof result.then === "function") {
          result.then(handleResolve, handleReject);
        }
      }
      function handleResolve(newPayload) {
        next(null, newPayload);
      }
      function handleReject(err) {
        if (!err) {
          err = new FST_ERR_SEND_UNDEFINED_ERR();
        }
        cb(err, request, reply);
      }
      next();
    }
    function onRequestAbortHookRunner(functions, request, cb) {
      let i = 0;
      function next(err) {
        if (err || i === functions.length) {
          cb(err, request);
          return;
        }
        let result;
        try {
          result = functions[i++](request, next);
        } catch (error) {
          cb(error, request);
          return;
        }
        if (result && typeof result.then === "function") {
          result.then(handleResolve, handleReject);
        }
      }
      function handleResolve() {
        next();
      }
      function handleReject(err) {
        if (!err) {
          err = new FST_ERR_SEND_UNDEFINED_ERR();
        }
        cb(err, request);
      }
      next();
    }
    function hookIterator(fn, request, reply, next) {
      if (reply.sent === true) return void 0;
      return fn(request, reply, next);
    }
    module2.exports = {
      Hooks,
      buildHooks,
      hookRunnerGenerator,
      preParsingHookRunner,
      onResponseHookRunner,
      onSendHookRunner,
      preSerializationHookRunner,
      onRequestAbortHookRunner,
      hookIterator,
      hookRunnerApplication,
      onListenHookRunner,
      preHandlerHookRunner,
      preValidationHookRunner,
      onRequestHookRunner,
      onTimeoutHookRunner,
      lifecycleHooks,
      supportedHooks
    };
  }
});

// node_modules/fastify/lib/server.js
var require_server = __commonJS({
  "node_modules/fastify/lib/server.js"(exports2, module2) {
    "use strict";
    var http = require("node:http");
    var https = require("node:https");
    var http2 = require("node:http2");
    var dns = require("node:dns");
    var os2 = require("node:os");
    var { kState, kOptions, kServerBindings } = require_symbols2();
    var { FSTWRN003 } = require_warnings();
    var { onListenHookRunner } = require_hooks();
    var {
      FST_ERR_REOPENED_CLOSE_SERVER,
      FST_ERR_REOPENED_SERVER,
      FST_ERR_LISTEN_OPTIONS_INVALID
    } = require_errors2();
    module2.exports.createServer = createServer2;
    function defaultResolveServerListeningText(address) {
      return `Server listening at ${address}`;
    }
    function createServer2(options, httpHandler) {
      const server = getServerInstance(options, httpHandler);
      function listen(listenOptions = { port: 0, host: "localhost" }, cb = void 0) {
        if (typeof cb === "function") {
          if (cb.constructor.name === "AsyncFunction") {
            FSTWRN003("listen method");
          }
          listenOptions.cb = cb;
        }
        if (listenOptions.signal) {
          if (typeof listenOptions.signal.on !== "function" && typeof listenOptions.signal.addEventListener !== "function") {
            throw new FST_ERR_LISTEN_OPTIONS_INVALID("Invalid options.signal");
          }
          if (listenOptions.signal.aborted) {
            this.close();
          } else {
            const onAborted = () => {
              this.close();
            };
            listenOptions.signal.addEventListener("abort", onAborted, { once: true });
          }
        }
        let host;
        if (listenOptions.path == null) {
          host = listenOptions.host ?? "localhost";
        } else {
          host = listenOptions.host;
        }
        if (!Object.hasOwn(listenOptions, "host") || listenOptions.host == null) {
          listenOptions.host = host;
        }
        if (host === "localhost") {
          listenOptions.cb = (err, address) => {
            if (err) {
              cb(err, address);
              return;
            }
            multipleBindings.call(this, server, httpHandler, options, listenOptions, () => {
              this[kState].listening = true;
              cb(null, address);
              onListenHookRunner(this);
            });
          };
        } else {
          listenOptions.cb = (err, address) => {
            if (err) {
              cb(err, address);
              return;
            }
            this[kState].listening = true;
            cb(null, address);
            onListenHookRunner(this);
          };
        }
        if (cb === void 0) {
          const listening = listenPromise.call(this, server, listenOptions);
          return listening.then((address) => {
            return new Promise((resolve, reject) => {
              if (host === "localhost") {
                multipleBindings.call(this, server, httpHandler, options, listenOptions, () => {
                  this[kState].listening = true;
                  resolve(address);
                  onListenHookRunner(this);
                });
              } else {
                resolve(address);
                onListenHookRunner(this);
              }
            });
          });
        }
        this.ready(listenCallback.call(this, server, listenOptions));
      }
      return { server, listen };
    }
    function multipleBindings(mainServer, httpHandler, serverOpts, listenOptions, onListen) {
      this[kState].listening = false;
      dns.lookup(listenOptions.host, { all: true }, (dnsErr, addresses) => {
        if (dnsErr) {
          onListen();
          return;
        }
        const isMainServerListening = mainServer.listening && serverOpts.serverFactory;
        let binding = 0;
        let bound = 0;
        if (!isMainServerListening) {
          const primaryAddress = mainServer.address();
          for (const adr of addresses) {
            if (adr.address !== primaryAddress.address) {
              binding++;
              const secondaryOpts = Object.assign({}, listenOptions, {
                host: adr.address,
                port: primaryAddress.port,
                cb: (_ignoreErr) => {
                  bound++;
                  if (!_ignoreErr) {
                    this[kServerBindings].push(secondaryServer);
                  }
                  if (bound === binding) {
                    onListen();
                  }
                }
              });
              const secondaryServer = getServerInstance(serverOpts, httpHandler);
              const closeSecondary = () => {
                secondaryServer.close(() => {
                });
                if (typeof secondaryServer.closeAllConnections === "function" && serverOpts.forceCloseConnections === true) {
                  secondaryServer.closeAllConnections();
                }
              };
              secondaryServer.on("upgrade", mainServer.emit.bind(mainServer, "upgrade"));
              mainServer.on("unref", closeSecondary);
              mainServer.on("close", closeSecondary);
              mainServer.on("error", closeSecondary);
              this[kState].listening = false;
              listenCallback.call(this, secondaryServer, secondaryOpts)();
            }
          }
        }
        if (binding === 0) {
          onListen();
          return;
        }
        const originUnref = mainServer.unref;
        mainServer.unref = function() {
          originUnref.call(mainServer);
          mainServer.emit("unref");
        };
      });
    }
    function listenCallback(server, listenOptions) {
      const wrap = (err) => {
        server.removeListener("error", wrap);
        server.removeListener("listening", wrap);
        if (!err) {
          const address = logServerAddress.call(this, server, listenOptions.listenTextResolver || defaultResolveServerListeningText);
          listenOptions.cb(null, address);
        } else {
          this[kState].listening = false;
          listenOptions.cb(err, null);
        }
      };
      return (err) => {
        if (err != null) return listenOptions.cb(err);
        if (this[kState].listening && this[kState].closing) {
          return listenOptions.cb(new FST_ERR_REOPENED_CLOSE_SERVER(), null);
        }
        if (this[kState].listening) {
          return listenOptions.cb(new FST_ERR_REOPENED_SERVER(), null);
        }
        server.once("error", wrap);
        if (!this[kState].closing) {
          server.once("listening", wrap);
          server.listen(listenOptions);
          this[kState].listening = true;
        }
      };
    }
    function listenPromise(server, listenOptions) {
      if (this[kState].listening && this[kState].closing) {
        return Promise.reject(new FST_ERR_REOPENED_CLOSE_SERVER());
      }
      if (this[kState].listening) {
        return Promise.reject(new FST_ERR_REOPENED_SERVER());
      }
      return this.ready().then(() => {
        let errEventHandler;
        let listeningEventHandler;
        function cleanup() {
          server.removeListener("error", errEventHandler);
          server.removeListener("listening", listeningEventHandler);
        }
        const errEvent = new Promise((resolve, reject) => {
          errEventHandler = (err) => {
            cleanup();
            this[kState].listening = false;
            reject(err);
          };
          server.once("error", errEventHandler);
        });
        const listeningEvent = new Promise((resolve, reject) => {
          listeningEventHandler = () => {
            cleanup();
            this[kState].listening = true;
            resolve(logServerAddress.call(this, server, listenOptions.listenTextResolver || defaultResolveServerListeningText));
          };
          server.once("listening", listeningEventHandler);
        });
        server.listen(listenOptions);
        return Promise.race([
          errEvent,
          // e.g invalid port range error is always emitted before the server listening
          listeningEvent
        ]);
      });
    }
    function getServerInstance(options, httpHandler) {
      if (options.serverFactory) {
        return options.serverFactory(httpHandler, options);
      }
      const httpsOptions = options.https === true ? {} : options.https;
      if (options.http2) {
        const server2 = typeof httpsOptions === "object" ? http2.createSecureServer(httpsOptions, httpHandler) : http2.createServer(options.http, httpHandler);
        server2.on("session", (session) => session.setTimeout(options.http2SessionTimeout, function closeSession() {
          this.close();
        }));
        server2.setTimeout(options.connectionTimeout);
        return server2;
      }
      const server = httpsOptions ? https.createServer(httpsOptions, httpHandler) : http.createServer(options.http, httpHandler);
      server.keepAliveTimeout = options.keepAliveTimeout;
      server.requestTimeout = options.requestTimeout;
      server.setTimeout(options.connectionTimeout);
      if (options.maxRequestsPerSocket > 0) {
        server.maxRequestsPerSocket = options.maxRequestsPerSocket;
      }
      return server;
    }
    function getAddresses(address) {
      if (address.address === "0.0.0.0") {
        return Object.values(os2.networkInterfaces()).flatMap((iface) => {
          return iface.filter((iface2) => iface2.family === "IPv4");
        }).sort((iface) => {
          return iface.internal ? -1 : 1;
        }).map((iface) => {
          return iface.address;
        });
      }
      return [address.address];
    }
    function logServerAddress(server, listenTextResolver) {
      let addresses;
      const isUnixSocket = typeof server.address() === "string";
      if (!isUnixSocket) {
        if (server.address().address.indexOf(":") === -1) {
          addresses = getAddresses(server.address()).map((address) => address + ":" + server.address().port);
        } else {
          addresses = ["[" + server.address().address + "]:" + server.address().port];
        }
        addresses = addresses.map((address) => "http" + (this[kOptions].https ? "s" : "") + "://" + address);
      } else {
        addresses = [server.address()];
      }
      for (const address of addresses) {
        this.log.info(listenTextResolver(address));
      }
      return addresses[0];
    }
  }
});

// node_modules/fastify/lib/validation.js
var require_validation = __commonJS({
  "node_modules/fastify/lib/validation.js"(exports2, module2) {
    "use strict";
    var {
      kSchemaHeaders: headersSchema,
      kSchemaParams: paramsSchema,
      kSchemaQuerystring: querystringSchema,
      kSchemaBody: bodySchema,
      kSchemaResponse: responseSchema
    } = require_symbols2();
    var scChecker = /^[1-5](?:\d{2}|xx)$|^default$/;
    var {
      FST_ERR_SCH_RESPONSE_SCHEMA_NOT_NESTED_2XX
    } = require_errors2();
    var { FSTWRN001 } = require_warnings();
    function compileSchemasForSerialization(context, compile) {
      if (!context.schema || !context.schema.response) {
        return;
      }
      const { method, url } = context.config || {};
      context[responseSchema] = Object.keys(context.schema.response).reduce(function(acc, statusCode) {
        const schema = context.schema.response[statusCode];
        statusCode = statusCode.toLowerCase();
        if (!scChecker.test(statusCode)) {
          throw new FST_ERR_SCH_RESPONSE_SCHEMA_NOT_NESTED_2XX();
        }
        if (schema.content) {
          const contentTypesSchemas = {};
          for (const mediaName of Object.keys(schema.content)) {
            const contentSchema = schema.content[mediaName].schema;
            contentTypesSchemas[mediaName] = compile({
              schema: contentSchema,
              url,
              method,
              httpStatus: statusCode,
              contentType: mediaName
            });
          }
          acc[statusCode] = contentTypesSchemas;
        } else {
          acc[statusCode] = compile({
            schema,
            url,
            method,
            httpStatus: statusCode
          });
        }
        return acc;
      }, {});
    }
    function compileSchemasForValidation(context, compile, isCustom) {
      const { schema } = context;
      if (!schema) {
        return;
      }
      const { method, url } = context.config || {};
      const headers = schema.headers;
      if (headers && (isCustom || Object.getPrototypeOf(headers) !== Object.prototype)) {
        context[headersSchema] = compile({ schema: headers, method, url, httpPart: "headers" });
      } else if (headers) {
        const headersSchemaLowerCase = {};
        Object.keys(headers).forEach((k) => {
          headersSchemaLowerCase[k] = headers[k];
        });
        if (headersSchemaLowerCase.required instanceof Array) {
          headersSchemaLowerCase.required = headersSchemaLowerCase.required.map((h) => h.toLowerCase());
        }
        if (headers.properties) {
          headersSchemaLowerCase.properties = {};
          Object.keys(headers.properties).forEach((k) => {
            headersSchemaLowerCase.properties[k.toLowerCase()] = headers.properties[k];
          });
        }
        context[headersSchema] = compile({ schema: headersSchemaLowerCase, method, url, httpPart: "headers" });
      } else if (Object.hasOwn(schema, "headers")) {
        FSTWRN001("headers", method, url);
      }
      if (schema.body) {
        const contentProperty = schema.body.content;
        if (contentProperty) {
          const contentTypeSchemas = {};
          for (const contentType of Object.keys(contentProperty)) {
            const contentSchema = contentProperty[contentType].schema;
            contentTypeSchemas[contentType] = compile({ schema: contentSchema, method, url, httpPart: "body", contentType });
          }
          context[bodySchema] = contentTypeSchemas;
        } else {
          context[bodySchema] = compile({ schema: schema.body, method, url, httpPart: "body" });
        }
      } else if (Object.hasOwn(schema, "body")) {
        FSTWRN001("body", method, url);
      }
      if (schema.querystring) {
        context[querystringSchema] = compile({ schema: schema.querystring, method, url, httpPart: "querystring" });
      } else if (Object.hasOwn(schema, "querystring")) {
        FSTWRN001("querystring", method, url);
      }
      if (schema.params) {
        context[paramsSchema] = compile({ schema: schema.params, method, url, httpPart: "params" });
      } else if (Object.hasOwn(schema, "params")) {
        FSTWRN001("params", method, url);
      }
    }
    function validateParam(validatorFunction, request, paramName) {
      const isUndefined = request[paramName] === void 0;
      const ret = validatorFunction && validatorFunction(isUndefined ? null : request[paramName]);
      if (ret && typeof ret.then === "function") {
        return ret.then((res) => {
          return answer(res);
        }).catch((err) => {
          return err;
        });
      }
      return answer(ret);
      function answer(ret2) {
        if (ret2 === false) return validatorFunction.errors;
        if (ret2 && ret2.error) return ret2.error;
        if (ret2 && ret2.value) request[paramName] = ret2.value;
        return false;
      }
    }
    function validate(context, request, execution) {
      const runExecution = execution === void 0;
      if (runExecution || !execution.skipParams) {
        const params = validateParam(context[paramsSchema], request, "params");
        if (params) {
          if (typeof params.then !== "function") {
            return wrapValidationError(params, "params", context.schemaErrorFormatter);
          } else {
            return validateAsyncParams(params, context, request);
          }
        }
      }
      if (runExecution || !execution.skipBody) {
        let validatorFunction = null;
        if (typeof context[bodySchema] === "function") {
          validatorFunction = context[bodySchema];
        } else if (context[bodySchema]) {
          const contentType = getEssenceMediaType(request.headers["content-type"]);
          const contentSchema = context[bodySchema][contentType];
          if (contentSchema) {
            validatorFunction = contentSchema;
          }
        }
        const body = validateParam(validatorFunction, request, "body");
        if (body) {
          if (typeof body.then !== "function") {
            return wrapValidationError(body, "body", context.schemaErrorFormatter);
          } else {
            return validateAsyncBody(body, context, request);
          }
        }
      }
      if (runExecution || !execution.skipQuery) {
        const query = validateParam(context[querystringSchema], request, "query");
        if (query) {
          if (typeof query.then !== "function") {
            return wrapValidationError(query, "querystring", context.schemaErrorFormatter);
          } else {
            return validateAsyncQuery(query, context, request);
          }
        }
      }
      const headers = validateParam(context[headersSchema], request, "headers");
      if (headers) {
        if (typeof headers.then !== "function") {
          return wrapValidationError(headers, "headers", context.schemaErrorFormatter);
        } else {
          return validateAsyncHeaders(headers, context, request);
        }
      }
      return false;
    }
    function validateAsyncParams(validatePromise, context, request) {
      return validatePromise.then((paramsResult) => {
        if (paramsResult) {
          return wrapValidationError(paramsResult, "params", context.schemaErrorFormatter);
        }
        return validate(context, request, { skipParams: true });
      });
    }
    function validateAsyncBody(validatePromise, context, request) {
      return validatePromise.then((bodyResult) => {
        if (bodyResult) {
          return wrapValidationError(bodyResult, "body", context.schemaErrorFormatter);
        }
        return validate(context, request, { skipParams: true, skipBody: true });
      });
    }
    function validateAsyncQuery(validatePromise, context, request) {
      return validatePromise.then((queryResult) => {
        if (queryResult) {
          return wrapValidationError(queryResult, "querystring", context.schemaErrorFormatter);
        }
        return validate(context, request, { skipParams: true, skipBody: true, skipQuery: true });
      });
    }
    function validateAsyncHeaders(validatePromise, context, request) {
      return validatePromise.then((headersResult) => {
        if (headersResult) {
          return wrapValidationError(headersResult, "headers", context.schemaErrorFormatter);
        }
        return false;
      });
    }
    function wrapValidationError(result, dataVar, schemaErrorFormatter) {
      if (result instanceof Error) {
        result.statusCode = result.statusCode || 400;
        result.code = result.code || "FST_ERR_VALIDATION";
        result.validationContext = result.validationContext || dataVar;
        return result;
      }
      const error = schemaErrorFormatter(result, dataVar);
      error.statusCode = error.statusCode || 400;
      error.code = error.code || "FST_ERR_VALIDATION";
      error.validation = result;
      error.validationContext = dataVar;
      return error;
    }
    function getEssenceMediaType(header) {
      if (!header) return "";
      return header.split(/[ ;]/, 1)[0].trim().toLowerCase();
    }
    module2.exports = {
      symbols: { bodySchema, querystringSchema, responseSchema, paramsSchema, headersSchema },
      compileSchemasForValidation,
      compileSchemasForSerialization,
      validate
    };
  }
});

// node_modules/fastify/lib/wrapThenable.js
var require_wrapThenable = __commonJS({
  "node_modules/fastify/lib/wrapThenable.js"(exports2, module2) {
    "use strict";
    var {
      kReplyIsError,
      kReplyHijacked
    } = require_symbols2();
    var diagnostics = require("node:diagnostics_channel");
    var channels = diagnostics.tracingChannel("fastify.request.handler");
    function wrapThenable(thenable, reply, store) {
      if (store) store.async = true;
      thenable.then(function(payload) {
        if (reply[kReplyHijacked] === true) {
          return;
        }
        if (store) {
          channels.asyncStart.publish(store);
        }
        try {
          if (payload !== void 0 || //
          reply.sent === false && //
          reply.raw.headersSent === false && reply.request.raw.aborted === false && reply.request.socket && !reply.request.socket.destroyed) {
            try {
              reply.send(payload);
            } catch (err) {
              reply[kReplyIsError] = true;
              reply.send(err);
            }
          }
        } finally {
          if (store) {
            channels.asyncEnd.publish(store);
          }
        }
      }, function(err) {
        if (store) {
          store.error = err;
          channels.error.publish(store);
          channels.asyncStart.publish(store);
        }
        try {
          if (reply.sent === true) {
            reply.log.error({ err }, "Promise errored, but reply.sent = true was set");
            return;
          }
          reply[kReplyIsError] = true;
          reply.send(err);
        } catch (err2) {
          reply.send(err2);
        } finally {
          if (store) {
            channels.asyncEnd.publish(store);
          }
        }
      });
    }
    module2.exports = wrapThenable;
  }
});

// node_modules/fastify/lib/handleRequest.js
var require_handleRequest = __commonJS({
  "node_modules/fastify/lib/handleRequest.js"(exports2, module2) {
    "use strict";
    var diagnostics = require("node:diagnostics_channel");
    var { validate: validateSchema } = require_validation();
    var { preValidationHookRunner, preHandlerHookRunner } = require_hooks();
    var wrapThenable = require_wrapThenable();
    var {
      kReplyIsError,
      kRouteContext,
      kFourOhFourContext,
      kSupportedHTTPMethods
    } = require_symbols2();
    var channels = diagnostics.tracingChannel("fastify.request.handler");
    function handleRequest(err, request, reply) {
      if (reply.sent === true) return;
      if (err != null) {
        reply[kReplyIsError] = true;
        reply.send(err);
        return;
      }
      const method = request.raw.method;
      const headers = request.headers;
      const context = request[kRouteContext];
      if (this[kSupportedHTTPMethods].bodyless.has(method)) {
        handler(request, reply);
        return;
      }
      if (this[kSupportedHTTPMethods].bodywith.has(method)) {
        const contentType = headers["content-type"];
        const contentLength = headers["content-length"];
        const transferEncoding = headers["transfer-encoding"];
        if (contentType === void 0) {
          if ((contentLength === void 0 || contentLength === "0") && transferEncoding === void 0) {
            handler(request, reply);
          } else {
            context.contentTypeParser.run("", handler, request, reply);
          }
        } else {
          if (contentLength === void 0 && transferEncoding === void 0 && method === "OPTIONS") {
            handler(request, reply);
            return;
          }
          context.contentTypeParser.run(contentType, handler, request, reply);
        }
        return;
      }
      handler(request, reply);
    }
    function handler(request, reply) {
      try {
        if (request[kRouteContext].preValidation !== null) {
          preValidationHookRunner(
            request[kRouteContext].preValidation,
            request,
            reply,
            preValidationCallback
          );
        } else {
          preValidationCallback(null, request, reply);
        }
      } catch (err) {
        preValidationCallback(err, request, reply);
      }
    }
    function preValidationCallback(err, request, reply) {
      if (reply.sent === true) return;
      if (err != null) {
        reply[kReplyIsError] = true;
        reply.send(err);
        return;
      }
      const validationErr = validateSchema(reply[kRouteContext], request);
      const isAsync = validationErr && typeof validationErr.then === "function" || false;
      if (isAsync) {
        const cb = validationCompleted.bind(null, request, reply);
        validationErr.then(cb, cb);
      } else {
        validationCompleted(request, reply, validationErr);
      }
    }
    function validationCompleted(request, reply, validationErr) {
      if (validationErr) {
        if (reply[kRouteContext].attachValidation === false) {
          reply.send(validationErr);
          return;
        }
        reply.request.validationError = validationErr;
      }
      if (request[kRouteContext].preHandler !== null) {
        preHandlerHookRunner(
          request[kRouteContext].preHandler,
          request,
          reply,
          preHandlerCallback
        );
      } else {
        preHandlerCallback(null, request, reply);
      }
    }
    function preHandlerCallback(err, request, reply) {
      if (reply.sent) return;
      const context = request[kRouteContext];
      if (!channels.hasSubscribers || context[kFourOhFourContext] === null) {
        preHandlerCallbackInner(err, request, reply);
      } else {
        const store = {
          request,
          reply,
          async: false,
          route: {
            url: context.config.url,
            method: context.config.method
          }
        };
        channels.start.runStores(store, preHandlerCallbackInner, void 0, err, request, reply, store);
      }
    }
    function preHandlerCallbackInner(err, request, reply, store) {
      const context = request[kRouteContext];
      try {
        if (err != null) {
          reply[kReplyIsError] = true;
          reply.send(err);
          if (store) {
            store.error = err;
            channels.error.publish(store);
          }
          return;
        }
        let result;
        try {
          result = context.handler(request, reply);
        } catch (err2) {
          if (store) {
            store.error = err2;
            channels.error.publish(store);
          }
          reply[kReplyIsError] = true;
          reply.send(err2);
          return;
        }
        if (result !== void 0) {
          if (result !== null && typeof result.then === "function") {
            wrapThenable(result, reply, store);
          } else {
            reply.send(result);
          }
        }
      } finally {
        if (store) channels.end.publish(store);
      }
    }
    module2.exports = handleRequest;
    module2.exports[Symbol.for("internals")] = { handler, preHandlerCallback };
  }
});

// node_modules/abstract-logging/index.js
var require_abstract_logging = __commonJS({
  "node_modules/abstract-logging/index.js"(exports2, module2) {
    "use strict";
    function noop() {
    }
    var proto = {
      fatal: noop,
      error: noop,
      warn: noop,
      info: noop,
      debug: noop,
      trace: noop
    };
    Object.defineProperty(module2, "exports", {
      get() {
        return Object.create(proto);
      }
    });
  }
});

// node_modules/pino-std-serializers/lib/err-helpers.js
var require_err_helpers = __commonJS({
  "node_modules/pino-std-serializers/lib/err-helpers.js"(exports2, module2) {
    "use strict";
    var isErrorLike = (err) => {
      return err && typeof err.message === "string";
    };
    var getErrorCause = (err) => {
      if (!err) return;
      const cause = err.cause;
      if (typeof cause === "function") {
        const causeResult = err.cause();
        return isErrorLike(causeResult) ? causeResult : void 0;
      } else {
        return isErrorLike(cause) ? cause : void 0;
      }
    };
    var _stackWithCauses = (err, seen) => {
      if (!isErrorLike(err)) return "";
      const stack = err.stack || "";
      if (seen.has(err)) {
        return stack + "\ncauses have become circular...";
      }
      const cause = getErrorCause(err);
      if (cause) {
        seen.add(err);
        return stack + "\ncaused by: " + _stackWithCauses(cause, seen);
      } else {
        return stack;
      }
    };
    var stackWithCauses = (err) => _stackWithCauses(err, /* @__PURE__ */ new Set());
    var _messageWithCauses = (err, seen, skip) => {
      if (!isErrorLike(err)) return "";
      const message = skip ? "" : err.message || "";
      if (seen.has(err)) {
        return message + ": ...";
      }
      const cause = getErrorCause(err);
      if (cause) {
        seen.add(err);
        const skipIfVErrorStyleCause = typeof err.cause === "function";
        return message + (skipIfVErrorStyleCause ? "" : ": ") + _messageWithCauses(cause, seen, skipIfVErrorStyleCause);
      } else {
        return message;
      }
    };
    var messageWithCauses = (err) => _messageWithCauses(err, /* @__PURE__ */ new Set());
    module2.exports = {
      isErrorLike,
      getErrorCause,
      stackWithCauses,
      messageWithCauses
    };
  }
});

// node_modules/pino-std-serializers/lib/err-proto.js
var require_err_proto = __commonJS({
  "node_modules/pino-std-serializers/lib/err-proto.js"(exports2, module2) {
    "use strict";
    var seen = Symbol("circular-ref-tag");
    var rawSymbol = Symbol("pino-raw-err-ref");
    var pinoErrProto = Object.create({}, {
      type: {
        enumerable: true,
        writable: true,
        value: void 0
      },
      message: {
        enumerable: true,
        writable: true,
        value: void 0
      },
      stack: {
        enumerable: true,
        writable: true,
        value: void 0
      },
      aggregateErrors: {
        enumerable: true,
        writable: true,
        value: void 0
      },
      raw: {
        enumerable: false,
        get: function() {
          return this[rawSymbol];
        },
        set: function(val) {
          this[rawSymbol] = val;
        }
      }
    });
    Object.defineProperty(pinoErrProto, rawSymbol, {
      writable: true,
      value: {}
    });
    module2.exports = {
      pinoErrProto,
      pinoErrorSymbols: {
        seen,
        rawSymbol
      }
    };
  }
});

// node_modules/pino-std-serializers/lib/err.js
var require_err = __commonJS({
  "node_modules/pino-std-serializers/lib/err.js"(exports2, module2) {
    "use strict";
    module2.exports = errSerializer;
    var { messageWithCauses, stackWithCauses, isErrorLike } = require_err_helpers();
    var { pinoErrProto, pinoErrorSymbols } = require_err_proto();
    var { seen } = pinoErrorSymbols;
    var { toString } = Object.prototype;
    function errSerializer(err) {
      if (!isErrorLike(err)) {
        return err;
      }
      err[seen] = void 0;
      const _err = Object.create(pinoErrProto);
      _err.type = toString.call(err.constructor) === "[object Function]" ? err.constructor.name : err.name;
      _err.message = messageWithCauses(err);
      _err.stack = stackWithCauses(err);
      if (Array.isArray(err.errors)) {
        _err.aggregateErrors = err.errors.map((err2) => errSerializer(err2));
      }
      for (const key in err) {
        if (_err[key] === void 0) {
          const val = err[key];
          if (isErrorLike(val)) {
            if (key !== "cause" && !Object.prototype.hasOwnProperty.call(val, seen)) {
              _err[key] = errSerializer(val);
            }
          } else {
            _err[key] = val;
          }
        }
      }
      delete err[seen];
      _err.raw = err;
      return _err;
    }
  }
});

// node_modules/pino-std-serializers/lib/err-with-cause.js
var require_err_with_cause = __commonJS({
  "node_modules/pino-std-serializers/lib/err-with-cause.js"(exports2, module2) {
    "use strict";
    module2.exports = errWithCauseSerializer;
    var { isErrorLike } = require_err_helpers();
    var { pinoErrProto, pinoErrorSymbols } = require_err_proto();
    var { seen } = pinoErrorSymbols;
    var { toString } = Object.prototype;
    function errWithCauseSerializer(err) {
      if (!isErrorLike(err)) {
        return err;
      }
      err[seen] = void 0;
      const _err = Object.create(pinoErrProto);
      _err.type = toString.call(err.constructor) === "[object Function]" ? err.constructor.name : err.name;
      _err.message = err.message;
      _err.stack = err.stack;
      if (Array.isArray(err.errors)) {
        _err.aggregateErrors = err.errors.map((err2) => errWithCauseSerializer(err2));
      }
      if (isErrorLike(err.cause) && !Object.prototype.hasOwnProperty.call(err.cause, seen)) {
        _err.cause = errWithCauseSerializer(err.cause);
      }
      for (const key in err) {
        if (_err[key] === void 0) {
          const val = err[key];
          if (isErrorLike(val)) {
            if (!Object.prototype.hasOwnProperty.call(val, seen)) {
              _err[key] = errWithCauseSerializer(val);
            }
          } else {
            _err[key] = val;
          }
        }
      }
      delete err[seen];
      _err.raw = err;
      return _err;
    }
  }
});

// node_modules/pino-std-serializers/lib/req.js
var require_req = __commonJS({
  "node_modules/pino-std-serializers/lib/req.js"(exports2, module2) {
    "use strict";
    module2.exports = {
      mapHttpRequest,
      reqSerializer
    };
    var rawSymbol = Symbol("pino-raw-req-ref");
    var pinoReqProto = Object.create({}, {
      id: {
        enumerable: true,
        writable: true,
        value: ""
      },
      method: {
        enumerable: true,
        writable: true,
        value: ""
      },
      url: {
        enumerable: true,
        writable: true,
        value: ""
      },
      query: {
        enumerable: true,
        writable: true,
        value: ""
      },
      params: {
        enumerable: true,
        writable: true,
        value: ""
      },
      headers: {
        enumerable: true,
        writable: true,
        value: {}
      },
      remoteAddress: {
        enumerable: true,
        writable: true,
        value: ""
      },
      remotePort: {
        enumerable: true,
        writable: true,
        value: ""
      },
      raw: {
        enumerable: false,
        get: function() {
          return this[rawSymbol];
        },
        set: function(val) {
          this[rawSymbol] = val;
        }
      }
    });
    Object.defineProperty(pinoReqProto, rawSymbol, {
      writable: true,
      value: {}
    });
    function reqSerializer(req) {
      const connection = req.info || req.socket;
      const _req = Object.create(pinoReqProto);
      _req.id = typeof req.id === "function" ? req.id() : req.id || (req.info ? req.info.id : void 0);
      _req.method = req.method;
      if (req.originalUrl) {
        _req.url = req.originalUrl;
      } else {
        const path4 = req.path;
        _req.url = typeof path4 === "string" ? path4 : req.url ? req.url.path || req.url : void 0;
      }
      if (req.query) {
        _req.query = req.query;
      }
      if (req.params) {
        _req.params = req.params;
      }
      _req.headers = req.headers;
      _req.remoteAddress = connection && connection.remoteAddress;
      _req.remotePort = connection && connection.remotePort;
      _req.raw = req.raw || req;
      return _req;
    }
    function mapHttpRequest(req) {
      return {
        req: reqSerializer(req)
      };
    }
  }
});

// node_modules/pino-std-serializers/lib/res.js
var require_res = __commonJS({
  "node_modules/pino-std-serializers/lib/res.js"(exports2, module2) {
    "use strict";
    module2.exports = {
      mapHttpResponse,
      resSerializer
    };
    var rawSymbol = Symbol("pino-raw-res-ref");
    var pinoResProto = Object.create({}, {
      statusCode: {
        enumerable: true,
        writable: true,
        value: 0
      },
      headers: {
        enumerable: true,
        writable: true,
        value: ""
      },
      raw: {
        enumerable: false,
        get: function() {
          return this[rawSymbol];
        },
        set: function(val) {
          this[rawSymbol] = val;
        }
      }
    });
    Object.defineProperty(pinoResProto, rawSymbol, {
      writable: true,
      value: {}
    });
    function resSerializer(res) {
      const _res = Object.create(pinoResProto);
      _res.statusCode = res.headersSent ? res.statusCode : null;
      _res.headers = res.getHeaders ? res.getHeaders() : res._headers;
      _res.raw = res;
      return _res;
    }
    function mapHttpResponse(res) {
      return {
        res: resSerializer(res)
      };
    }
  }
});

// node_modules/pino-std-serializers/index.js
var require_pino_std_serializers = __commonJS({
  "node_modules/pino-std-serializers/index.js"(exports2, module2) {
    "use strict";
    var errSerializer = require_err();
    var errWithCauseSerializer = require_err_with_cause();
    var reqSerializers = require_req();
    var resSerializers = require_res();
    module2.exports = {
      err: errSerializer,
      errWithCause: errWithCauseSerializer,
      mapHttpRequest: reqSerializers.mapHttpRequest,
      mapHttpResponse: resSerializers.mapHttpResponse,
      req: reqSerializers.reqSerializer,
      res: resSerializers.resSerializer,
      wrapErrorSerializer: function wrapErrorSerializer(customSerializer) {
        if (customSerializer === errSerializer) return customSerializer;
        return function wrapErrSerializer(err) {
          return customSerializer(errSerializer(err));
        };
      },
      wrapRequestSerializer: function wrapRequestSerializer(customSerializer) {
        if (customSerializer === reqSerializers.reqSerializer) return customSerializer;
        return function wrappedReqSerializer(req) {
          return customSerializer(reqSerializers.reqSerializer(req));
        };
      },
      wrapResponseSerializer: function wrapResponseSerializer(customSerializer) {
        if (customSerializer === resSerializers.resSerializer) return customSerializer;
        return function wrappedResSerializer(res) {
          return customSerializer(resSerializers.resSerializer(res));
        };
      }
    };
  }
});

// node_modules/pino/lib/caller.js
var require_caller = __commonJS({
  "node_modules/pino/lib/caller.js"(exports2, module2) {
    "use strict";
    function noOpPrepareStackTrace(_, stack) {
      return stack;
    }
    module2.exports = function getCallers() {
      const originalPrepare = Error.prepareStackTrace;
      Error.prepareStackTrace = noOpPrepareStackTrace;
      const stack = new Error().stack;
      Error.prepareStackTrace = originalPrepare;
      if (!Array.isArray(stack)) {
        return void 0;
      }
      const entries = stack.slice(2);
      const fileNames = [];
      for (const entry of entries) {
        if (!entry) {
          continue;
        }
        fileNames.push(entry.getFileName());
      }
      return fileNames;
    };
  }
});

// node_modules/fast-redact/lib/validator.js
var require_validator = __commonJS({
  "node_modules/fast-redact/lib/validator.js"(exports2, module2) {
    "use strict";
    module2.exports = validator;
    function validator(opts = {}) {
      const {
        ERR_PATHS_MUST_BE_STRINGS = () => "fast-redact - Paths must be (non-empty) strings",
        ERR_INVALID_PATH = (s) => `fast-redact \u2013 Invalid path (${s})`
      } = opts;
      return function validate({ paths }) {
        paths.forEach((s) => {
          if (typeof s !== "string") {
            throw Error(ERR_PATHS_MUST_BE_STRINGS());
          }
          try {
            if (//.test(s)) throw Error();
            const expr = (s[0] === "[" ? "" : ".") + s.replace(/^\*/, "\u3007").replace(/\.\*/g, ".\u3007").replace(/\[\*\]/g, "[\u3007]");
            if (/\n|\r|;/.test(expr)) throw Error();
            if (/\/\*/.test(expr)) throw Error();
            Function(`
            'use strict'
            const o = new Proxy({}, { get: () => o, set: () => { throw Error() } });
            const \u3007 = null;
            o${expr}
            if ([o${expr}].length !== 1) throw Error()`)();
          } catch (e) {
            throw Error(ERR_INVALID_PATH(s));
          }
        });
      };
    }
  }
});

// node_modules/fast-redact/lib/rx.js
var require_rx = __commonJS({
  "node_modules/fast-redact/lib/rx.js"(exports2, module2) {
    "use strict";
    module2.exports = /[^.[\]]+|\[((?:.)*?)\]/g;
  }
});

// node_modules/fast-redact/lib/parse.js
var require_parse2 = __commonJS({
  "node_modules/fast-redact/lib/parse.js"(exports2, module2) {
    "use strict";
    var rx = require_rx();
    module2.exports = parse;
    function parse({ paths }) {
      const wildcards = [];
      var wcLen = 0;
      const secret = paths.reduce(function(o, strPath, ix) {
        var path4 = strPath.match(rx).map((p) => p.replace(/'|"|`/g, ""));
        const leadingBracket = strPath[0] === "[";
        path4 = path4.map((p) => {
          if (p[0] === "[") return p.substr(1, p.length - 2);
          else return p;
        });
        const star = path4.indexOf("*");
        if (star > -1) {
          const before = path4.slice(0, star);
          const beforeStr = before.join(".");
          const after = path4.slice(star + 1, path4.length);
          const nested = after.length > 0;
          wcLen++;
          wildcards.push({
            before,
            beforeStr,
            after,
            nested
          });
        } else {
          o[strPath] = {
            path: path4,
            val: void 0,
            precensored: false,
            circle: "",
            escPath: JSON.stringify(strPath),
            leadingBracket
          };
        }
        return o;
      }, {});
      return { wildcards, wcLen, secret };
    }
  }
});

// node_modules/fast-redact/lib/redactor.js
var require_redactor = __commonJS({
  "node_modules/fast-redact/lib/redactor.js"(exports2, module2) {
    "use strict";
    var rx = require_rx();
    module2.exports = redactor;
    function redactor({ secret, serialize, wcLen, strict, isCensorFct, censorFctTakesPath }, state) {
      const redact = Function("o", `
    if (typeof o !== 'object' || o == null) {
      ${strictImpl(strict, serialize)}
    }
    const { censor, secret } = this
    const originalSecret = {}
    const secretKeys = Object.keys(secret)
    for (var i = 0; i < secretKeys.length; i++) {
      originalSecret[secretKeys[i]] = secret[secretKeys[i]]
    }

    ${redactTmpl(secret, isCensorFct, censorFctTakesPath)}
    this.compileRestore()
    ${dynamicRedactTmpl(wcLen > 0, isCensorFct, censorFctTakesPath)}
    this.secret = originalSecret
    ${resultTmpl(serialize)}
  `).bind(state);
      redact.state = state;
      if (serialize === false) {
        redact.restore = (o) => state.restore(o);
      }
      return redact;
    }
    function redactTmpl(secret, isCensorFct, censorFctTakesPath) {
      return Object.keys(secret).map((path4) => {
        const { escPath, leadingBracket, path: arrPath } = secret[path4];
        const skip = leadingBracket ? 1 : 0;
        const delim = leadingBracket ? "" : ".";
        const hops = [];
        var match;
        while ((match = rx.exec(path4)) !== null) {
          const [, ix] = match;
          const { index, input } = match;
          if (index > skip) hops.push(input.substring(0, index - (ix ? 0 : 1)));
        }
        var existence = hops.map((p) => `o${delim}${p}`).join(" && ");
        if (existence.length === 0) existence += `o${delim}${path4} != null`;
        else existence += ` && o${delim}${path4} != null`;
        const circularDetection = `
      switch (true) {
        ${hops.reverse().map((p) => `
          case o${delim}${p} === censor:
            secret[${escPath}].circle = ${JSON.stringify(p)}
            break
        `).join("\n")}
      }
    `;
        const censorArgs = censorFctTakesPath ? `val, ${JSON.stringify(arrPath)}` : `val`;
        return `
      if (${existence}) {
        const val = o${delim}${path4}
        if (val === censor) {
          secret[${escPath}].precensored = true
        } else {
          secret[${escPath}].val = val
          o${delim}${path4} = ${isCensorFct ? `censor(${censorArgs})` : "censor"}
          ${circularDetection}
        }
      }
    `;
      }).join("\n");
    }
    function dynamicRedactTmpl(hasWildcards, isCensorFct, censorFctTakesPath) {
      return hasWildcards === true ? `
    {
      const { wildcards, wcLen, groupRedact, nestedRedact } = this
      for (var i = 0; i < wcLen; i++) {
        const { before, beforeStr, after, nested } = wildcards[i]
        if (nested === true) {
          secret[beforeStr] = secret[beforeStr] || []
          nestedRedact(secret[beforeStr], o, before, after, censor, ${isCensorFct}, ${censorFctTakesPath})
        } else secret[beforeStr] = groupRedact(o, before, censor, ${isCensorFct}, ${censorFctTakesPath})
      }
    }
  ` : "";
    }
    function resultTmpl(serialize) {
      return serialize === false ? `return o` : `
    var s = this.serialize(o)
    this.restore(o)
    return s
  `;
    }
    function strictImpl(strict, serialize) {
      return strict === true ? `throw Error('fast-redact: primitives cannot be redacted')` : serialize === false ? `return o` : `return this.serialize(o)`;
    }
  }
});

// node_modules/fast-redact/lib/modifiers.js
var require_modifiers = __commonJS({
  "node_modules/fast-redact/lib/modifiers.js"(exports2, module2) {
    "use strict";
    module2.exports = {
      groupRedact,
      groupRestore,
      nestedRedact,
      nestedRestore
    };
    function groupRestore({ keys, values, target }) {
      if (target == null || typeof target === "string") return;
      const length = keys.length;
      for (var i = 0; i < length; i++) {
        const k = keys[i];
        target[k] = values[i];
      }
    }
    function groupRedact(o, path4, censor, isCensorFct, censorFctTakesPath) {
      const target = get(o, path4);
      if (target == null || typeof target === "string") return { keys: null, values: null, target, flat: true };
      const keys = Object.keys(target);
      const keysLength = keys.length;
      const pathLength = path4.length;
      const pathWithKey = censorFctTakesPath ? [...path4] : void 0;
      const values = new Array(keysLength);
      for (var i = 0; i < keysLength; i++) {
        const key = keys[i];
        values[i] = target[key];
        if (censorFctTakesPath) {
          pathWithKey[pathLength] = key;
          target[key] = censor(target[key], pathWithKey);
        } else if (isCensorFct) {
          target[key] = censor(target[key]);
        } else {
          target[key] = censor;
        }
      }
      return { keys, values, target, flat: true };
    }
    function nestedRestore(instructions) {
      for (let i = 0; i < instructions.length; i++) {
        const { target, path: path4, value } = instructions[i];
        let current = target;
        for (let i2 = path4.length - 1; i2 > 0; i2--) {
          current = current[path4[i2]];
        }
        current[path4[0]] = value;
      }
    }
    function nestedRedact(store, o, path4, ns, censor, isCensorFct, censorFctTakesPath) {
      const target = get(o, path4);
      if (target == null) return;
      const keys = Object.keys(target);
      const keysLength = keys.length;
      for (var i = 0; i < keysLength; i++) {
        const key = keys[i];
        specialSet(store, target, key, path4, ns, censor, isCensorFct, censorFctTakesPath);
      }
      return store;
    }
    function has(obj, prop) {
      return obj !== void 0 && obj !== null ? "hasOwn" in Object ? Object.hasOwn(obj, prop) : Object.prototype.hasOwnProperty.call(obj, prop) : false;
    }
    function specialSet(store, o, k, path4, afterPath, censor, isCensorFct, censorFctTakesPath) {
      const afterPathLen = afterPath.length;
      const lastPathIndex = afterPathLen - 1;
      const originalKey = k;
      var i = -1;
      var n;
      var nv;
      var ov;
      var oov = null;
      var wc = null;
      var kIsWc;
      var wcov;
      var consecutive = false;
      var level = 0;
      var depth = 0;
      var redactPathCurrent = tree();
      ov = n = o[k];
      if (typeof n !== "object") return;
      while (n != null && ++i < afterPathLen) {
        depth += 1;
        k = afterPath[i];
        oov = ov;
        if (k !== "*" && !wc && !(typeof n === "object" && k in n)) {
          break;
        }
        if (k === "*") {
          if (wc === "*") {
            consecutive = true;
          }
          wc = k;
          if (i !== lastPathIndex) {
            continue;
          }
        }
        if (wc) {
          const wcKeys = Object.keys(n);
          for (var j = 0; j < wcKeys.length; j++) {
            const wck = wcKeys[j];
            wcov = n[wck];
            kIsWc = k === "*";
            if (consecutive) {
              redactPathCurrent = node(redactPathCurrent, wck, depth);
              level = i;
              ov = iterateNthLevel(wcov, level - 1, k, path4, afterPath, censor, isCensorFct, censorFctTakesPath, originalKey, n, nv, ov, kIsWc, wck, i, lastPathIndex, redactPathCurrent, store, o[originalKey], depth + 1);
            } else {
              if (kIsWc || typeof wcov === "object" && wcov !== null && k in wcov) {
                if (kIsWc) {
                  ov = wcov;
                } else {
                  ov = wcov[k];
                }
                nv = i !== lastPathIndex ? ov : isCensorFct ? censorFctTakesPath ? censor(ov, [...path4, originalKey, ...afterPath]) : censor(ov) : censor;
                if (kIsWc) {
                  const rv = restoreInstr(node(redactPathCurrent, wck, depth), ov, o[originalKey]);
                  store.push(rv);
                  n[wck] = nv;
                } else {
                  if (wcov[k] === nv) {
                  } else if (nv === void 0 && censor !== void 0 || has(wcov, k) && nv === ov) {
                    redactPathCurrent = node(redactPathCurrent, wck, depth);
                  } else {
                    redactPathCurrent = node(redactPathCurrent, wck, depth);
                    const rv = restoreInstr(node(redactPathCurrent, k, depth + 1), ov, o[originalKey]);
                    store.push(rv);
                    wcov[k] = nv;
                  }
                }
              }
            }
          }
          wc = null;
        } else {
          ov = n[k];
          redactPathCurrent = node(redactPathCurrent, k, depth);
          nv = i !== lastPathIndex ? ov : isCensorFct ? censorFctTakesPath ? censor(ov, [...path4, originalKey, ...afterPath]) : censor(ov) : censor;
          if (has(n, k) && nv === ov || nv === void 0 && censor !== void 0) {
          } else {
            const rv = restoreInstr(redactPathCurrent, ov, o[originalKey]);
            store.push(rv);
            n[k] = nv;
          }
          n = n[k];
        }
        if (typeof n !== "object") break;
        if (ov === oov || typeof ov === "undefined") {
        }
      }
    }
    function get(o, p) {
      var i = -1;
      var l = p.length;
      var n = o;
      while (n != null && ++i < l) {
        n = n[p[i]];
      }
      return n;
    }
    function iterateNthLevel(wcov, level, k, path4, afterPath, censor, isCensorFct, censorFctTakesPath, originalKey, n, nv, ov, kIsWc, wck, i, lastPathIndex, redactPathCurrent, store, parent, depth) {
      if (level === 0) {
        if (kIsWc || typeof wcov === "object" && wcov !== null && k in wcov) {
          if (kIsWc) {
            ov = wcov;
          } else {
            ov = wcov[k];
          }
          nv = i !== lastPathIndex ? ov : isCensorFct ? censorFctTakesPath ? censor(ov, [...path4, originalKey, ...afterPath]) : censor(ov) : censor;
          if (kIsWc) {
            const rv = restoreInstr(redactPathCurrent, ov, parent);
            store.push(rv);
            n[wck] = nv;
          } else {
            if (wcov[k] === nv) {
            } else if (nv === void 0 && censor !== void 0 || has(wcov, k) && nv === ov) {
            } else {
              const rv = restoreInstr(node(redactPathCurrent, k, depth + 1), ov, parent);
              store.push(rv);
              wcov[k] = nv;
            }
          }
        }
      }
      for (const key in wcov) {
        if (typeof wcov[key] === "object") {
          redactPathCurrent = node(redactPathCurrent, key, depth);
          iterateNthLevel(wcov[key], level - 1, k, path4, afterPath, censor, isCensorFct, censorFctTakesPath, originalKey, n, nv, ov, kIsWc, wck, i, lastPathIndex, redactPathCurrent, store, parent, depth + 1);
        }
      }
    }
    function tree() {
      return { parent: null, key: null, children: [], depth: 0 };
    }
    function node(parent, key, depth) {
      if (parent.depth === depth) {
        return node(parent.parent, key, depth);
      }
      var child = {
        parent,
        key,
        depth,
        children: []
      };
      parent.children.push(child);
      return child;
    }
    function restoreInstr(node2, value, target) {
      let current = node2;
      const path4 = [];
      do {
        path4.push(current.key);
        current = current.parent;
      } while (current.parent != null);
      return { path: path4, value, target };
    }
  }
});

// node_modules/fast-redact/lib/restorer.js
var require_restorer = __commonJS({
  "node_modules/fast-redact/lib/restorer.js"(exports2, module2) {
    "use strict";
    var { groupRestore, nestedRestore } = require_modifiers();
    module2.exports = restorer;
    function restorer() {
      return function compileRestore() {
        if (this.restore) {
          this.restore.state.secret = this.secret;
          return;
        }
        const { secret, wcLen } = this;
        const paths = Object.keys(secret);
        const resetters = resetTmpl(secret, paths);
        const hasWildcards = wcLen > 0;
        const state = hasWildcards ? { secret, groupRestore, nestedRestore } : { secret };
        this.restore = Function(
          "o",
          restoreTmpl(resetters, paths, hasWildcards)
        ).bind(state);
        this.restore.state = state;
      };
    }
    function resetTmpl(secret, paths) {
      return paths.map((path4) => {
        const { circle, escPath, leadingBracket } = secret[path4];
        const delim = leadingBracket ? "" : ".";
        const reset = circle ? `o.${circle} = secret[${escPath}].val` : `o${delim}${path4} = secret[${escPath}].val`;
        const clear = `secret[${escPath}].val = undefined`;
        return `
      if (secret[${escPath}].val !== undefined) {
        try { ${reset} } catch (e) {}
        ${clear}
      }
    `;
      }).join("");
    }
    function restoreTmpl(resetters, paths, hasWildcards) {
      const dynamicReset = hasWildcards === true ? `
    const keys = Object.keys(secret)
    const len = keys.length
    for (var i = len - 1; i >= ${paths.length}; i--) {
      const k = keys[i]
      const o = secret[k]
      if (o) {
        if (o.flat === true) this.groupRestore(o)
        else this.nestedRestore(o)
        secret[k] = null
      }
    }
  ` : "";
      return `
    const secret = this.secret
    ${dynamicReset}
    ${resetters}
    return o
  `;
    }
  }
});

// node_modules/fast-redact/lib/state.js
var require_state = __commonJS({
  "node_modules/fast-redact/lib/state.js"(exports2, module2) {
    "use strict";
    module2.exports = state;
    function state(o) {
      const {
        secret,
        censor,
        compileRestore,
        serialize,
        groupRedact,
        nestedRedact,
        wildcards,
        wcLen
      } = o;
      const builder = [{ secret, censor, compileRestore }];
      if (serialize !== false) builder.push({ serialize });
      if (wcLen > 0) builder.push({ groupRedact, nestedRedact, wildcards, wcLen });
      return Object.assign(...builder);
    }
  }
});

// node_modules/fast-redact/index.js
var require_fast_redact = __commonJS({
  "node_modules/fast-redact/index.js"(exports2, module2) {
    "use strict";
    var validator = require_validator();
    var parse = require_parse2();
    var redactor = require_redactor();
    var restorer = require_restorer();
    var { groupRedact, nestedRedact } = require_modifiers();
    var state = require_state();
    var rx = require_rx();
    var validate = validator();
    var noop = (o) => o;
    noop.restore = noop;
    var DEFAULT_CENSOR = "[REDACTED]";
    fastRedact.rx = rx;
    fastRedact.validator = validator;
    module2.exports = fastRedact;
    function fastRedact(opts = {}) {
      const paths = Array.from(new Set(opts.paths || []));
      const serialize = "serialize" in opts ? opts.serialize === false ? opts.serialize : typeof opts.serialize === "function" ? opts.serialize : JSON.stringify : JSON.stringify;
      const remove = opts.remove;
      if (remove === true && serialize !== JSON.stringify) {
        throw Error("fast-redact \u2013 remove option may only be set when serializer is JSON.stringify");
      }
      const censor = remove === true ? void 0 : "censor" in opts ? opts.censor : DEFAULT_CENSOR;
      const isCensorFct = typeof censor === "function";
      const censorFctTakesPath = isCensorFct && censor.length > 1;
      if (paths.length === 0) return serialize || noop;
      validate({ paths, serialize, censor });
      const { wildcards, wcLen, secret } = parse({ paths, censor });
      const compileRestore = restorer();
      const strict = "strict" in opts ? opts.strict : true;
      return redactor({ secret, wcLen, serialize, strict, isCensorFct, censorFctTakesPath }, state({
        secret,
        censor,
        compileRestore,
        serialize,
        groupRedact,
        nestedRedact,
        wildcards,
        wcLen
      }));
    }
  }
});

// node_modules/pino/lib/symbols.js
var require_symbols3 = __commonJS({
  "node_modules/pino/lib/symbols.js"(exports2, module2) {
    "use strict";
    var setLevelSym = Symbol("pino.setLevel");
    var getLevelSym = Symbol("pino.getLevel");
    var levelValSym = Symbol("pino.levelVal");
    var levelCompSym = Symbol("pino.levelComp");
    var useLevelLabelsSym = Symbol("pino.useLevelLabels");
    var useOnlyCustomLevelsSym = Symbol("pino.useOnlyCustomLevels");
    var mixinSym = Symbol("pino.mixin");
    var lsCacheSym = Symbol("pino.lsCache");
    var chindingsSym = Symbol("pino.chindings");
    var asJsonSym = Symbol("pino.asJson");
    var writeSym = Symbol("pino.write");
    var redactFmtSym = Symbol("pino.redactFmt");
    var timeSym = Symbol("pino.time");
    var timeSliceIndexSym = Symbol("pino.timeSliceIndex");
    var streamSym = Symbol("pino.stream");
    var stringifySym = Symbol("pino.stringify");
    var stringifySafeSym = Symbol("pino.stringifySafe");
    var stringifiersSym = Symbol("pino.stringifiers");
    var endSym = Symbol("pino.end");
    var formatOptsSym = Symbol("pino.formatOpts");
    var messageKeySym = Symbol("pino.messageKey");
    var errorKeySym = Symbol("pino.errorKey");
    var nestedKeySym = Symbol("pino.nestedKey");
    var nestedKeyStrSym = Symbol("pino.nestedKeyStr");
    var mixinMergeStrategySym = Symbol("pino.mixinMergeStrategy");
    var msgPrefixSym = Symbol("pino.msgPrefix");
    var wildcardFirstSym = Symbol("pino.wildcardFirst");
    var serializersSym = Symbol.for("pino.serializers");
    var formattersSym = Symbol.for("pino.formatters");
    var hooksSym = Symbol.for("pino.hooks");
    var needsMetadataGsym = Symbol.for("pino.metadata");
    module2.exports = {
      setLevelSym,
      getLevelSym,
      levelValSym,
      levelCompSym,
      useLevelLabelsSym,
      mixinSym,
      lsCacheSym,
      chindingsSym,
      asJsonSym,
      writeSym,
      serializersSym,
      redactFmtSym,
      timeSym,
      timeSliceIndexSym,
      streamSym,
      stringifySym,
      stringifySafeSym,
      stringifiersSym,
      endSym,
      formatOptsSym,
      messageKeySym,
      errorKeySym,
      nestedKeySym,
      wildcardFirstSym,
      needsMetadataGsym,
      useOnlyCustomLevelsSym,
      formattersSym,
      hooksSym,
      nestedKeyStrSym,
      mixinMergeStrategySym,
      msgPrefixSym
    };
  }
});

// node_modules/pino/lib/redaction.js
var require_redaction = __commonJS({
  "node_modules/pino/lib/redaction.js"(exports2, module2) {
    "use strict";
    var fastRedact = require_fast_redact();
    var { redactFmtSym, wildcardFirstSym } = require_symbols3();
    var { rx, validator } = fastRedact;
    var validate = validator({
      ERR_PATHS_MUST_BE_STRINGS: () => "pino \u2013 redacted paths must be strings",
      ERR_INVALID_PATH: (s) => `pino \u2013 redact paths array contains an invalid path (${s})`
    });
    var CENSOR = "[Redacted]";
    var strict = false;
    function redaction(opts, serialize) {
      const { paths, censor } = handle(opts);
      const shape = paths.reduce((o, str) => {
        rx.lastIndex = 0;
        const first = rx.exec(str);
        const next = rx.exec(str);
        let ns = first[1] !== void 0 ? first[1].replace(/^(?:"|'|`)(.*)(?:"|'|`)$/, "$1") : first[0];
        if (ns === "*") {
          ns = wildcardFirstSym;
        }
        if (next === null) {
          o[ns] = null;
          return o;
        }
        if (o[ns] === null) {
          return o;
        }
        const { index } = next;
        const nextPath = `${str.substr(index, str.length - 1)}`;
        o[ns] = o[ns] || [];
        if (ns !== wildcardFirstSym && o[ns].length === 0) {
          o[ns].push(...o[wildcardFirstSym] || []);
        }
        if (ns === wildcardFirstSym) {
          Object.keys(o).forEach(function(k) {
            if (o[k]) {
              o[k].push(nextPath);
            }
          });
        }
        o[ns].push(nextPath);
        return o;
      }, {});
      const result = {
        [redactFmtSym]: fastRedact({ paths, censor, serialize, strict })
      };
      const topCensor = (...args) => {
        return typeof censor === "function" ? serialize(censor(...args)) : serialize(censor);
      };
      return [...Object.keys(shape), ...Object.getOwnPropertySymbols(shape)].reduce((o, k) => {
        if (shape[k] === null) {
          o[k] = (value) => topCensor(value, [k]);
        } else {
          const wrappedCensor = typeof censor === "function" ? (value, path4) => {
            return censor(value, [k, ...path4]);
          } : censor;
          o[k] = fastRedact({
            paths: shape[k],
            censor: wrappedCensor,
            serialize,
            strict
          });
        }
        return o;
      }, result);
    }
    function handle(opts) {
      if (Array.isArray(opts)) {
        opts = { paths: opts, censor: CENSOR };
        validate(opts);
        return opts;
      }
      let { paths, censor = CENSOR, remove } = opts;
      if (Array.isArray(paths) === false) {
        throw Error("pino \u2013 redact must contain an array of strings");
      }
      if (remove === true) censor = void 0;
      validate({ paths, censor });
      return { paths, censor };
    }
    module2.exports = redaction;
  }
});

// node_modules/pino/lib/time.js
var require_time = __commonJS({
  "node_modules/pino/lib/time.js"(exports2, module2) {
    "use strict";
    var nullTime = () => "";
    var epochTime = () => `,"time":${Date.now()}`;
    var unixTime = () => `,"time":${Math.round(Date.now() / 1e3)}`;
    var isoTime = () => `,"time":"${new Date(Date.now()).toISOString()}"`;
    module2.exports = { nullTime, epochTime, unixTime, isoTime };
  }
});

// node_modules/quick-format-unescaped/index.js
var require_quick_format_unescaped = __commonJS({
  "node_modules/quick-format-unescaped/index.js"(exports2, module2) {
    "use strict";
    function tryStringify(o) {
      try {
        return JSON.stringify(o);
      } catch (e) {
        return '"[Circular]"';
      }
    }
    module2.exports = format;
    function format(f, args, opts) {
      var ss = opts && opts.stringify || tryStringify;
      var offset = 1;
      if (typeof f === "object" && f !== null) {
        var len = args.length + offset;
        if (len === 1) return f;
        var objects = new Array(len);
        objects[0] = ss(f);
        for (var index = 1; index < len; index++) {
          objects[index] = ss(args[index]);
        }
        return objects.join(" ");
      }
      if (typeof f !== "string") {
        return f;
      }
      var argLen = args.length;
      if (argLen === 0) return f;
      var str = "";
      var a = 1 - offset;
      var lastPos = -1;
      var flen = f && f.length || 0;
      for (var i = 0; i < flen; ) {
        if (f.charCodeAt(i) === 37 && i + 1 < flen) {
          lastPos = lastPos > -1 ? lastPos : 0;
          switch (f.charCodeAt(i + 1)) {
            case 100:
            // 'd'
            case 102:
              if (a >= argLen)
                break;
              if (args[a] == null) break;
              if (lastPos < i)
                str += f.slice(lastPos, i);
              str += Number(args[a]);
              lastPos = i + 2;
              i++;
              break;
            case 105:
              if (a >= argLen)
                break;
              if (args[a] == null) break;
              if (lastPos < i)
                str += f.slice(lastPos, i);
              str += Math.floor(Number(args[a]));
              lastPos = i + 2;
              i++;
              break;
            case 79:
            // 'O'
            case 111:
            // 'o'
            case 106:
              if (a >= argLen)
                break;
              if (args[a] === void 0) break;
              if (lastPos < i)
                str += f.slice(lastPos, i);
              var type = typeof args[a];
              if (type === "string") {
                str += "'" + args[a] + "'";
                lastPos = i + 2;
                i++;
                break;
              }
              if (type === "function") {
                str += args[a].name || "<anonymous>";
                lastPos = i + 2;
                i++;
                break;
              }
              str += ss(args[a]);
              lastPos = i + 2;
              i++;
              break;
            case 115:
              if (a >= argLen)
                break;
              if (lastPos < i)
                str += f.slice(lastPos, i);
              str += String(args[a]);
              lastPos = i + 2;
              i++;
              break;
            case 37:
              if (lastPos < i)
                str += f.slice(lastPos, i);
              str += "%";
              lastPos = i + 2;
              i++;
              a--;
              break;
          }
          ++a;
        }
        ++i;
      }
      if (lastPos === -1)
        return f;
      else if (lastPos < flen) {
        str += f.slice(lastPos);
      }
      return str;
    }
  }
});

// node_modules/atomic-sleep/index.js
var require_atomic_sleep = __commonJS({
  "node_modules/atomic-sleep/index.js"(exports2, module2) {
    "use strict";
    if (typeof SharedArrayBuffer !== "undefined" && typeof Atomics !== "undefined") {
      let sleep = function(ms) {
        const valid = ms > 0 && ms < Infinity;
        if (valid === false) {
          if (typeof ms !== "number" && typeof ms !== "bigint") {
            throw TypeError("sleep: ms must be a number");
          }
          throw RangeError("sleep: ms must be a number that is greater than 0 but less than Infinity");
        }
        Atomics.wait(nil, 0, 0, Number(ms));
      };
      const nil = new Int32Array(new SharedArrayBuffer(4));
      module2.exports = sleep;
    } else {
      let sleep = function(ms) {
        const valid = ms > 0 && ms < Infinity;
        if (valid === false) {
          if (typeof ms !== "number" && typeof ms !== "bigint") {
            throw TypeError("sleep: ms must be a number");
          }
          throw RangeError("sleep: ms must be a number that is greater than 0 but less than Infinity");
        }
        const target = Date.now() + Number(ms);
        while (target > Date.now()) {
        }
      };
      module2.exports = sleep;
    }
  }
});

// node_modules/sonic-boom/index.js
var require_sonic_boom = __commonJS({
  "node_modules/sonic-boom/index.js"(exports2, module2) {
    "use strict";
    var fs5 = require("fs");
    var EventEmitter = require("events");
    var inherits = require("util").inherits;
    var path4 = require("path");
    var sleep = require_atomic_sleep();
    var assert = require("assert");
    var BUSY_WRITE_TIMEOUT = 100;
    var kEmptyBuffer = Buffer.allocUnsafe(0);
    var MAX_WRITE = 16 * 1024;
    var kContentModeBuffer = "buffer";
    var kContentModeUtf8 = "utf8";
    var [major, minor] = (process.versions.node || "0.0").split(".").map(Number);
    var kCopyBuffer = major >= 22 && minor >= 7;
    function openFile(file, sonic) {
      sonic._opening = true;
      sonic._writing = true;
      sonic._asyncDrainScheduled = false;
      function fileOpened(err, fd) {
        if (err) {
          sonic._reopening = false;
          sonic._writing = false;
          sonic._opening = false;
          if (sonic.sync) {
            process.nextTick(() => {
              if (sonic.listenerCount("error") > 0) {
                sonic.emit("error", err);
              }
            });
          } else {
            sonic.emit("error", err);
          }
          return;
        }
        const reopening = sonic._reopening;
        sonic.fd = fd;
        sonic.file = file;
        sonic._reopening = false;
        sonic._opening = false;
        sonic._writing = false;
        if (sonic.sync) {
          process.nextTick(() => sonic.emit("ready"));
        } else {
          sonic.emit("ready");
        }
        if (sonic.destroyed) {
          return;
        }
        if (!sonic._writing && sonic._len > sonic.minLength || sonic._flushPending) {
          sonic._actualWrite();
        } else if (reopening) {
          process.nextTick(() => sonic.emit("drain"));
        }
      }
      const flags = sonic.append ? "a" : "w";
      const mode = sonic.mode;
      if (sonic.sync) {
        try {
          if (sonic.mkdir) fs5.mkdirSync(path4.dirname(file), { recursive: true });
          const fd = fs5.openSync(file, flags, mode);
          fileOpened(null, fd);
        } catch (err) {
          fileOpened(err);
          throw err;
        }
      } else if (sonic.mkdir) {
        fs5.mkdir(path4.dirname(file), { recursive: true }, (err) => {
          if (err) return fileOpened(err);
          fs5.open(file, flags, mode, fileOpened);
        });
      } else {
        fs5.open(file, flags, mode, fileOpened);
      }
    }
    function SonicBoom(opts) {
      if (!(this instanceof SonicBoom)) {
        return new SonicBoom(opts);
      }
      let { fd, dest, minLength, maxLength, maxWrite, periodicFlush, sync, append = true, mkdir, retryEAGAIN, fsync, contentMode, mode } = opts || {};
      fd = fd || dest;
      this._len = 0;
      this.fd = -1;
      this._bufs = [];
      this._lens = [];
      this._writing = false;
      this._ending = false;
      this._reopening = false;
      this._asyncDrainScheduled = false;
      this._flushPending = false;
      this._hwm = Math.max(minLength || 0, 16387);
      this.file = null;
      this.destroyed = false;
      this.minLength = minLength || 0;
      this.maxLength = maxLength || 0;
      this.maxWrite = maxWrite || MAX_WRITE;
      this._periodicFlush = periodicFlush || 0;
      this._periodicFlushTimer = void 0;
      this.sync = sync || false;
      this.writable = true;
      this._fsync = fsync || false;
      this.append = append || false;
      this.mode = mode;
      this.retryEAGAIN = retryEAGAIN || (() => true);
      this.mkdir = mkdir || false;
      let fsWriteSync;
      let fsWrite;
      if (contentMode === kContentModeBuffer) {
        this._writingBuf = kEmptyBuffer;
        this.write = writeBuffer;
        this.flush = flushBuffer;
        this.flushSync = flushBufferSync;
        this._actualWrite = actualWriteBuffer;
        fsWriteSync = () => fs5.writeSync(this.fd, this._writingBuf);
        fsWrite = () => fs5.write(this.fd, this._writingBuf, this.release);
      } else if (contentMode === void 0 || contentMode === kContentModeUtf8) {
        this._writingBuf = "";
        this.write = write;
        this.flush = flush;
        this.flushSync = flushSync;
        this._actualWrite = actualWrite;
        fsWriteSync = () => fs5.writeSync(this.fd, this._writingBuf, "utf8");
        fsWrite = () => fs5.write(this.fd, this._writingBuf, "utf8", this.release);
      } else {
        throw new Error(`SonicBoom supports "${kContentModeUtf8}" and "${kContentModeBuffer}", but passed ${contentMode}`);
      }
      if (typeof fd === "number") {
        this.fd = fd;
        process.nextTick(() => this.emit("ready"));
      } else if (typeof fd === "string") {
        openFile(fd, this);
      } else {
        throw new Error("SonicBoom supports only file descriptors and files");
      }
      if (this.minLength >= this.maxWrite) {
        throw new Error(`minLength should be smaller than maxWrite (${this.maxWrite})`);
      }
      this.release = (err, n) => {
        if (err) {
          if ((err.code === "EAGAIN" || err.code === "EBUSY") && this.retryEAGAIN(err, this._writingBuf.length, this._len - this._writingBuf.length)) {
            if (this.sync) {
              try {
                sleep(BUSY_WRITE_TIMEOUT);
                this.release(void 0, 0);
              } catch (err2) {
                this.release(err2);
              }
            } else {
              setTimeout(fsWrite, BUSY_WRITE_TIMEOUT);
            }
          } else {
            this._writing = false;
            this.emit("error", err);
          }
          return;
        }
        this.emit("write", n);
        const releasedBufObj = releaseWritingBuf(this._writingBuf, this._len, n);
        this._len = releasedBufObj.len;
        this._writingBuf = releasedBufObj.writingBuf;
        if (this._writingBuf.length) {
          if (!this.sync) {
            fsWrite();
            return;
          }
          try {
            do {
              const n2 = fsWriteSync();
              const releasedBufObj2 = releaseWritingBuf(this._writingBuf, this._len, n2);
              this._len = releasedBufObj2.len;
              this._writingBuf = releasedBufObj2.writingBuf;
            } while (this._writingBuf.length);
          } catch (err2) {
            this.release(err2);
            return;
          }
        }
        if (this._fsync) {
          fs5.fsyncSync(this.fd);
        }
        const len = this._len;
        if (this._reopening) {
          this._writing = false;
          this._reopening = false;
          this.reopen();
        } else if (len > this.minLength) {
          this._actualWrite();
        } else if (this._ending) {
          if (len > 0) {
            this._actualWrite();
          } else {
            this._writing = false;
            actualClose(this);
          }
        } else {
          this._writing = false;
          if (this.sync) {
            if (!this._asyncDrainScheduled) {
              this._asyncDrainScheduled = true;
              process.nextTick(emitDrain, this);
            }
          } else {
            this.emit("drain");
          }
        }
      };
      this.on("newListener", function(name) {
        if (name === "drain") {
          this._asyncDrainScheduled = false;
        }
      });
      if (this._periodicFlush !== 0) {
        this._periodicFlushTimer = setInterval(() => this.flush(null), this._periodicFlush);
        this._periodicFlushTimer.unref();
      }
    }
    function releaseWritingBuf(writingBuf, len, n) {
      if (typeof writingBuf === "string" && Buffer.byteLength(writingBuf) !== n) {
        n = Buffer.from(writingBuf).subarray(0, n).toString().length;
      }
      len = Math.max(len - n, 0);
      writingBuf = writingBuf.slice(n);
      return { writingBuf, len };
    }
    function emitDrain(sonic) {
      const hasListeners = sonic.listenerCount("drain") > 0;
      if (!hasListeners) return;
      sonic._asyncDrainScheduled = false;
      sonic.emit("drain");
    }
    inherits(SonicBoom, EventEmitter);
    function mergeBuf(bufs, len) {
      if (bufs.length === 0) {
        return kEmptyBuffer;
      }
      if (bufs.length === 1) {
        return bufs[0];
      }
      return Buffer.concat(bufs, len);
    }
    function write(data) {
      if (this.destroyed) {
        throw new Error("SonicBoom destroyed");
      }
      const len = this._len + data.length;
      const bufs = this._bufs;
      if (this.maxLength && len > this.maxLength) {
        this.emit("drop", data);
        return this._len < this._hwm;
      }
      if (bufs.length === 0 || bufs[bufs.length - 1].length + data.length > this.maxWrite) {
        bufs.push("" + data);
      } else {
        bufs[bufs.length - 1] += data;
      }
      this._len = len;
      if (!this._writing && this._len >= this.minLength) {
        this._actualWrite();
      }
      return this._len < this._hwm;
    }
    function writeBuffer(data) {
      if (this.destroyed) {
        throw new Error("SonicBoom destroyed");
      }
      const len = this._len + data.length;
      const bufs = this._bufs;
      const lens = this._lens;
      if (this.maxLength && len > this.maxLength) {
        this.emit("drop", data);
        return this._len < this._hwm;
      }
      if (bufs.length === 0 || lens[lens.length - 1] + data.length > this.maxWrite) {
        bufs.push([data]);
        lens.push(data.length);
      } else {
        bufs[bufs.length - 1].push(data);
        lens[lens.length - 1] += data.length;
      }
      this._len = len;
      if (!this._writing && this._len >= this.minLength) {
        this._actualWrite();
      }
      return this._len < this._hwm;
    }
    function callFlushCallbackOnDrain(cb) {
      this._flushPending = true;
      const onDrain = () => {
        if (!this._fsync) {
          try {
            fs5.fsync(this.fd, (err) => {
              this._flushPending = false;
              cb(err);
            });
          } catch (err) {
            cb(err);
          }
        } else {
          this._flushPending = false;
          cb();
        }
        this.off("error", onError);
      };
      const onError = (err) => {
        this._flushPending = false;
        cb(err);
        this.off("drain", onDrain);
      };
      this.once("drain", onDrain);
      this.once("error", onError);
    }
    function flush(cb) {
      if (cb != null && typeof cb !== "function") {
        throw new Error("flush cb must be a function");
      }
      if (this.destroyed) {
        const error = new Error("SonicBoom destroyed");
        if (cb) {
          cb(error);
          return;
        }
        throw error;
      }
      if (this.minLength <= 0) {
        cb?.();
        return;
      }
      if (cb) {
        callFlushCallbackOnDrain.call(this, cb);
      }
      if (this._writing) {
        return;
      }
      if (this._bufs.length === 0) {
        this._bufs.push("");
      }
      this._actualWrite();
    }
    function flushBuffer(cb) {
      if (cb != null && typeof cb !== "function") {
        throw new Error("flush cb must be a function");
      }
      if (this.destroyed) {
        const error = new Error("SonicBoom destroyed");
        if (cb) {
          cb(error);
          return;
        }
        throw error;
      }
      if (this.minLength <= 0) {
        cb?.();
        return;
      }
      if (cb) {
        callFlushCallbackOnDrain.call(this, cb);
      }
      if (this._writing) {
        return;
      }
      if (this._bufs.length === 0) {
        this._bufs.push([]);
        this._lens.push(0);
      }
      this._actualWrite();
    }
    SonicBoom.prototype.reopen = function(file) {
      if (this.destroyed) {
        throw new Error("SonicBoom destroyed");
      }
      if (this._opening) {
        this.once("ready", () => {
          this.reopen(file);
        });
        return;
      }
      if (this._ending) {
        return;
      }
      if (!this.file) {
        throw new Error("Unable to reopen a file descriptor, you must pass a file to SonicBoom");
      }
      if (file) {
        this.file = file;
      }
      this._reopening = true;
      if (this._writing) {
        return;
      }
      const fd = this.fd;
      this.once("ready", () => {
        if (fd !== this.fd) {
          fs5.close(fd, (err) => {
            if (err) {
              return this.emit("error", err);
            }
          });
        }
      });
      openFile(this.file, this);
    };
    SonicBoom.prototype.end = function() {
      if (this.destroyed) {
        throw new Error("SonicBoom destroyed");
      }
      if (this._opening) {
        this.once("ready", () => {
          this.end();
        });
        return;
      }
      if (this._ending) {
        return;
      }
      this._ending = true;
      if (this._writing) {
        return;
      }
      if (this._len > 0 && this.fd >= 0) {
        this._actualWrite();
      } else {
        actualClose(this);
      }
    };
    function flushSync() {
      if (this.destroyed) {
        throw new Error("SonicBoom destroyed");
      }
      if (this.fd < 0) {
        throw new Error("sonic boom is not ready yet");
      }
      if (!this._writing && this._writingBuf.length > 0) {
        this._bufs.unshift(this._writingBuf);
        this._writingBuf = "";
      }
      let buf = "";
      while (this._bufs.length || buf) {
        if (buf.length <= 0) {
          buf = this._bufs[0];
        }
        try {
          const n = fs5.writeSync(this.fd, buf, "utf8");
          const releasedBufObj = releaseWritingBuf(buf, this._len, n);
          buf = releasedBufObj.writingBuf;
          this._len = releasedBufObj.len;
          if (buf.length <= 0) {
            this._bufs.shift();
          }
        } catch (err) {
          const shouldRetry = err.code === "EAGAIN" || err.code === "EBUSY";
          if (shouldRetry && !this.retryEAGAIN(err, buf.length, this._len - buf.length)) {
            throw err;
          }
          sleep(BUSY_WRITE_TIMEOUT);
        }
      }
      try {
        fs5.fsyncSync(this.fd);
      } catch {
      }
    }
    function flushBufferSync() {
      if (this.destroyed) {
        throw new Error("SonicBoom destroyed");
      }
      if (this.fd < 0) {
        throw new Error("sonic boom is not ready yet");
      }
      if (!this._writing && this._writingBuf.length > 0) {
        this._bufs.unshift([this._writingBuf]);
        this._writingBuf = kEmptyBuffer;
      }
      let buf = kEmptyBuffer;
      while (this._bufs.length || buf.length) {
        if (buf.length <= 0) {
          buf = mergeBuf(this._bufs[0], this._lens[0]);
        }
        try {
          const n = fs5.writeSync(this.fd, buf);
          buf = buf.subarray(n);
          this._len = Math.max(this._len - n, 0);
          if (buf.length <= 0) {
            this._bufs.shift();
            this._lens.shift();
          }
        } catch (err) {
          const shouldRetry = err.code === "EAGAIN" || err.code === "EBUSY";
          if (shouldRetry && !this.retryEAGAIN(err, buf.length, this._len - buf.length)) {
            throw err;
          }
          sleep(BUSY_WRITE_TIMEOUT);
        }
      }
    }
    SonicBoom.prototype.destroy = function() {
      if (this.destroyed) {
        return;
      }
      actualClose(this);
    };
    function actualWrite() {
      const release = this.release;
      this._writing = true;
      this._writingBuf = this._writingBuf || this._bufs.shift() || "";
      if (this.sync) {
        try {
          const written = fs5.writeSync(this.fd, this._writingBuf, "utf8");
          release(null, written);
        } catch (err) {
          release(err);
        }
      } else {
        fs5.write(this.fd, this._writingBuf, "utf8", release);
      }
    }
    function actualWriteBuffer() {
      const release = this.release;
      this._writing = true;
      this._writingBuf = this._writingBuf.length ? this._writingBuf : mergeBuf(this._bufs.shift(), this._lens.shift());
      if (this.sync) {
        try {
          const written = fs5.writeSync(this.fd, this._writingBuf);
          release(null, written);
        } catch (err) {
          release(err);
        }
      } else {
        if (kCopyBuffer) {
          this._writingBuf = Buffer.from(this._writingBuf);
        }
        fs5.write(this.fd, this._writingBuf, release);
      }
    }
    function actualClose(sonic) {
      if (sonic.fd === -1) {
        sonic.once("ready", actualClose.bind(null, sonic));
        return;
      }
      if (sonic._periodicFlushTimer !== void 0) {
        clearInterval(sonic._periodicFlushTimer);
      }
      sonic.destroyed = true;
      sonic._bufs = [];
      sonic._lens = [];
      assert(typeof sonic.fd === "number", `sonic.fd must be a number, got ${typeof sonic.fd}`);
      try {
        fs5.fsync(sonic.fd, closeWrapped);
      } catch {
      }
      function closeWrapped() {
        if (sonic.fd !== 1 && sonic.fd !== 2) {
          fs5.close(sonic.fd, done);
        } else {
          done();
        }
      }
      function done(err) {
        if (err) {
          sonic.emit("error", err);
          return;
        }
        if (sonic._ending && !sonic._writing) {
          sonic.emit("finish");
        }
        sonic.emit("close");
      }
    }
    SonicBoom.SonicBoom = SonicBoom;
    SonicBoom.default = SonicBoom;
    module2.exports = SonicBoom;
  }
});

// node_modules/on-exit-leak-free/index.js
var require_on_exit_leak_free = __commonJS({
  "node_modules/on-exit-leak-free/index.js"(exports2, module2) {
    "use strict";
    var refs = {
      exit: [],
      beforeExit: []
    };
    var functions = {
      exit: onExit,
      beforeExit: onBeforeExit
    };
    var registry;
    function ensureRegistry() {
      if (registry === void 0) {
        registry = new FinalizationRegistry(clear);
      }
    }
    function install(event) {
      if (refs[event].length > 0) {
        return;
      }
      process.on(event, functions[event]);
    }
    function uninstall(event) {
      if (refs[event].length > 0) {
        return;
      }
      process.removeListener(event, functions[event]);
      if (refs.exit.length === 0 && refs.beforeExit.length === 0) {
        registry = void 0;
      }
    }
    function onExit() {
      callRefs("exit");
    }
    function onBeforeExit() {
      callRefs("beforeExit");
    }
    function callRefs(event) {
      for (const ref of refs[event]) {
        const obj = ref.deref();
        const fn = ref.fn;
        if (obj !== void 0) {
          fn(obj, event);
        }
      }
      refs[event] = [];
    }
    function clear(ref) {
      for (const event of ["exit", "beforeExit"]) {
        const index = refs[event].indexOf(ref);
        refs[event].splice(index, index + 1);
        uninstall(event);
      }
    }
    function _register(event, obj, fn) {
      if (obj === void 0) {
        throw new Error("the object can't be undefined");
      }
      install(event);
      const ref = new WeakRef(obj);
      ref.fn = fn;
      ensureRegistry();
      registry.register(obj, ref);
      refs[event].push(ref);
    }
    function register(obj, fn) {
      _register("exit", obj, fn);
    }
    function registerBeforeExit(obj, fn) {
      _register("beforeExit", obj, fn);
    }
    function unregister(obj) {
      if (registry === void 0) {
        return;
      }
      registry.unregister(obj);
      for (const event of ["exit", "beforeExit"]) {
        refs[event] = refs[event].filter((ref) => {
          const _obj = ref.deref();
          return _obj && _obj !== obj;
        });
        uninstall(event);
      }
    }
    module2.exports = {
      register,
      registerBeforeExit,
      unregister
    };
  }
});

// node_modules/thread-stream/package.json
var require_package = __commonJS({
  "node_modules/thread-stream/package.json"(exports2, module2) {
    module2.exports = {
      name: "thread-stream",
      version: "3.1.0",
      description: "A streaming way to send data to a Node.js Worker Thread",
      main: "index.js",
      types: "index.d.ts",
      dependencies: {
        "real-require": "^0.2.0"
      },
      devDependencies: {
        "@types/node": "^20.1.0",
        "@types/tap": "^15.0.0",
        "@yao-pkg/pkg": "^5.11.5",
        desm: "^1.3.0",
        fastbench: "^1.0.1",
        husky: "^9.0.6",
        "pino-elasticsearch": "^8.0.0",
        "sonic-boom": "^4.0.1",
        standard: "^17.0.0",
        tap: "^16.2.0",
        "ts-node": "^10.8.0",
        typescript: "^5.3.2",
        "why-is-node-running": "^2.2.2"
      },
      scripts: {
        build: "tsc --noEmit",
        test: 'standard && npm run build && npm run transpile && tap "test/**/*.test.*js" && tap --ts test/*.test.*ts',
        "test:ci": "standard && npm run transpile && npm run test:ci:js && npm run test:ci:ts",
        "test:ci:js": 'tap --no-check-coverage --timeout=120 --coverage-report=lcovonly "test/**/*.test.*js"',
        "test:ci:ts": 'tap --ts --no-check-coverage --coverage-report=lcovonly "test/**/*.test.*ts"',
        "test:yarn": 'npm run transpile && tap "test/**/*.test.js" --no-check-coverage',
        transpile: "sh ./test/ts/transpile.sh",
        prepare: "husky install"
      },
      standard: {
        ignore: [
          "test/ts/**/*",
          "test/syntax-error.mjs"
        ]
      },
      repository: {
        type: "git",
        url: "git+https://github.com/mcollina/thread-stream.git"
      },
      keywords: [
        "worker",
        "thread",
        "threads",
        "stream"
      ],
      author: "Matteo Collina <hello@matteocollina.com>",
      license: "MIT",
      bugs: {
        url: "https://github.com/mcollina/thread-stream/issues"
      },
      homepage: "https://github.com/mcollina/thread-stream#readme"
    };
  }
});

// node_modules/thread-stream/lib/wait.js
var require_wait = __commonJS({
  "node_modules/thread-stream/lib/wait.js"(exports2, module2) {
    "use strict";
    var MAX_TIMEOUT = 1e3;
    function wait(state, index, expected, timeout, done) {
      const max = Date.now() + timeout;
      let current = Atomics.load(state, index);
      if (current === expected) {
        done(null, "ok");
        return;
      }
      let prior = current;
      const check = (backoff) => {
        if (Date.now() > max) {
          done(null, "timed-out");
        } else {
          setTimeout(() => {
            prior = current;
            current = Atomics.load(state, index);
            if (current === prior) {
              check(backoff >= MAX_TIMEOUT ? MAX_TIMEOUT : backoff * 2);
            } else {
              if (current === expected) done(null, "ok");
              else done(null, "not-equal");
            }
          }, backoff);
        }
      };
      check(1);
    }
    function waitDiff(state, index, expected, timeout, done) {
      const max = Date.now() + timeout;
      let current = Atomics.load(state, index);
      if (current !== expected) {
        done(null, "ok");
        return;
      }
      const check = (backoff) => {
        if (Date.now() > max) {
          done(null, "timed-out");
        } else {
          setTimeout(() => {
            current = Atomics.load(state, index);
            if (current !== expected) {
              done(null, "ok");
            } else {
              check(backoff >= MAX_TIMEOUT ? MAX_TIMEOUT : backoff * 2);
            }
          }, backoff);
        }
      };
      check(1);
    }
    module2.exports = { wait, waitDiff };
  }
});

// node_modules/thread-stream/lib/indexes.js
var require_indexes = __commonJS({
  "node_modules/thread-stream/lib/indexes.js"(exports2, module2) {
    "use strict";
    var WRITE_INDEX = 4;
    var READ_INDEX = 8;
    module2.exports = {
      WRITE_INDEX,
      READ_INDEX
    };
  }
});

// node_modules/thread-stream/index.js
var require_thread_stream = __commonJS({
  "node_modules/thread-stream/index.js"(exports2, module2) {
    "use strict";
    var { version: version2 } = require_package();
    var { EventEmitter } = require("events");
    var { Worker } = require("worker_threads");
    var { join: join5 } = require("path");
    var { pathToFileURL } = require("url");
    var { wait } = require_wait();
    var {
      WRITE_INDEX,
      READ_INDEX
    } = require_indexes();
    var buffer = require("buffer");
    var assert = require("assert");
    var kImpl = Symbol("kImpl");
    var MAX_STRING = buffer.constants.MAX_STRING_LENGTH;
    var FakeWeakRef = class {
      constructor(value) {
        this._value = value;
      }
      deref() {
        return this._value;
      }
    };
    var FakeFinalizationRegistry = class {
      register() {
      }
      unregister() {
      }
    };
    var FinalizationRegistry2 = process.env.NODE_V8_COVERAGE ? FakeFinalizationRegistry : global.FinalizationRegistry || FakeFinalizationRegistry;
    var WeakRef2 = process.env.NODE_V8_COVERAGE ? FakeWeakRef : global.WeakRef || FakeWeakRef;
    var registry = new FinalizationRegistry2((worker) => {
      if (worker.exited) {
        return;
      }
      worker.terminate();
    });
    function createWorker(stream, opts) {
      const { filename, workerData } = opts;
      const bundlerOverrides = "__bundlerPathsOverrides" in globalThis ? globalThis.__bundlerPathsOverrides : {};
      const toExecute = bundlerOverrides["thread-stream-worker"] || join5(__dirname, "lib", "worker.js");
      const worker = new Worker(toExecute, {
        ...opts.workerOpts,
        trackUnmanagedFds: false,
        workerData: {
          filename: filename.indexOf("file://") === 0 ? filename : pathToFileURL(filename).href,
          dataBuf: stream[kImpl].dataBuf,
          stateBuf: stream[kImpl].stateBuf,
          workerData: {
            $context: {
              threadStreamVersion: version2
            },
            ...workerData
          }
        }
      });
      worker.stream = new FakeWeakRef(stream);
      worker.on("message", onWorkerMessage);
      worker.on("exit", onWorkerExit);
      registry.register(stream, worker);
      return worker;
    }
    function drain(stream) {
      assert(!stream[kImpl].sync);
      if (stream[kImpl].needDrain) {
        stream[kImpl].needDrain = false;
        stream.emit("drain");
      }
    }
    function nextFlush(stream) {
      const writeIndex = Atomics.load(stream[kImpl].state, WRITE_INDEX);
      let leftover = stream[kImpl].data.length - writeIndex;
      if (leftover > 0) {
        if (stream[kImpl].buf.length === 0) {
          stream[kImpl].flushing = false;
          if (stream[kImpl].ending) {
            end(stream);
          } else if (stream[kImpl].needDrain) {
            process.nextTick(drain, stream);
          }
          return;
        }
        let toWrite = stream[kImpl].buf.slice(0, leftover);
        let toWriteBytes = Buffer.byteLength(toWrite);
        if (toWriteBytes <= leftover) {
          stream[kImpl].buf = stream[kImpl].buf.slice(leftover);
          write(stream, toWrite, nextFlush.bind(null, stream));
        } else {
          stream.flush(() => {
            if (stream.destroyed) {
              return;
            }
            Atomics.store(stream[kImpl].state, READ_INDEX, 0);
            Atomics.store(stream[kImpl].state, WRITE_INDEX, 0);
            while (toWriteBytes > stream[kImpl].data.length) {
              leftover = leftover / 2;
              toWrite = stream[kImpl].buf.slice(0, leftover);
              toWriteBytes = Buffer.byteLength(toWrite);
            }
            stream[kImpl].buf = stream[kImpl].buf.slice(leftover);
            write(stream, toWrite, nextFlush.bind(null, stream));
          });
        }
      } else if (leftover === 0) {
        if (writeIndex === 0 && stream[kImpl].buf.length === 0) {
          return;
        }
        stream.flush(() => {
          Atomics.store(stream[kImpl].state, READ_INDEX, 0);
          Atomics.store(stream[kImpl].state, WRITE_INDEX, 0);
          nextFlush(stream);
        });
      } else {
        destroy(stream, new Error("overwritten"));
      }
    }
    function onWorkerMessage(msg) {
      const stream = this.stream.deref();
      if (stream === void 0) {
        this.exited = true;
        this.terminate();
        return;
      }
      switch (msg.code) {
        case "READY":
          this.stream = new WeakRef2(stream);
          stream.flush(() => {
            stream[kImpl].ready = true;
            stream.emit("ready");
          });
          break;
        case "ERROR":
          destroy(stream, msg.err);
          break;
        case "EVENT":
          if (Array.isArray(msg.args)) {
            stream.emit(msg.name, ...msg.args);
          } else {
            stream.emit(msg.name, msg.args);
          }
          break;
        case "WARNING":
          process.emitWarning(msg.err);
          break;
        default:
          destroy(stream, new Error("this should not happen: " + msg.code));
      }
    }
    function onWorkerExit(code) {
      const stream = this.stream.deref();
      if (stream === void 0) {
        return;
      }
      registry.unregister(stream);
      stream.worker.exited = true;
      stream.worker.off("exit", onWorkerExit);
      destroy(stream, code !== 0 ? new Error("the worker thread exited") : null);
    }
    var ThreadStream = class extends EventEmitter {
      constructor(opts = {}) {
        super();
        if (opts.bufferSize < 4) {
          throw new Error("bufferSize must at least fit a 4-byte utf-8 char");
        }
        this[kImpl] = {};
        this[kImpl].stateBuf = new SharedArrayBuffer(128);
        this[kImpl].state = new Int32Array(this[kImpl].stateBuf);
        this[kImpl].dataBuf = new SharedArrayBuffer(opts.bufferSize || 4 * 1024 * 1024);
        this[kImpl].data = Buffer.from(this[kImpl].dataBuf);
        this[kImpl].sync = opts.sync || false;
        this[kImpl].ending = false;
        this[kImpl].ended = false;
        this[kImpl].needDrain = false;
        this[kImpl].destroyed = false;
        this[kImpl].flushing = false;
        this[kImpl].ready = false;
        this[kImpl].finished = false;
        this[kImpl].errored = null;
        this[kImpl].closed = false;
        this[kImpl].buf = "";
        this.worker = createWorker(this, opts);
        this.on("message", (message, transferList) => {
          this.worker.postMessage(message, transferList);
        });
      }
      write(data) {
        if (this[kImpl].destroyed) {
          error(this, new Error("the worker has exited"));
          return false;
        }
        if (this[kImpl].ending) {
          error(this, new Error("the worker is ending"));
          return false;
        }
        if (this[kImpl].flushing && this[kImpl].buf.length + data.length >= MAX_STRING) {
          try {
            writeSync(this);
            this[kImpl].flushing = true;
          } catch (err) {
            destroy(this, err);
            return false;
          }
        }
        this[kImpl].buf += data;
        if (this[kImpl].sync) {
          try {
            writeSync(this);
            return true;
          } catch (err) {
            destroy(this, err);
            return false;
          }
        }
        if (!this[kImpl].flushing) {
          this[kImpl].flushing = true;
          setImmediate(nextFlush, this);
        }
        this[kImpl].needDrain = this[kImpl].data.length - this[kImpl].buf.length - Atomics.load(this[kImpl].state, WRITE_INDEX) <= 0;
        return !this[kImpl].needDrain;
      }
      end() {
        if (this[kImpl].destroyed) {
          return;
        }
        this[kImpl].ending = true;
        end(this);
      }
      flush(cb) {
        if (this[kImpl].destroyed) {
          if (typeof cb === "function") {
            process.nextTick(cb, new Error("the worker has exited"));
          }
          return;
        }
        const writeIndex = Atomics.load(this[kImpl].state, WRITE_INDEX);
        wait(this[kImpl].state, READ_INDEX, writeIndex, Infinity, (err, res) => {
          if (err) {
            destroy(this, err);
            process.nextTick(cb, err);
            return;
          }
          if (res === "not-equal") {
            this.flush(cb);
            return;
          }
          process.nextTick(cb);
        });
      }
      flushSync() {
        if (this[kImpl].destroyed) {
          return;
        }
        writeSync(this);
        flushSync(this);
      }
      unref() {
        this.worker.unref();
      }
      ref() {
        this.worker.ref();
      }
      get ready() {
        return this[kImpl].ready;
      }
      get destroyed() {
        return this[kImpl].destroyed;
      }
      get closed() {
        return this[kImpl].closed;
      }
      get writable() {
        return !this[kImpl].destroyed && !this[kImpl].ending;
      }
      get writableEnded() {
        return this[kImpl].ending;
      }
      get writableFinished() {
        return this[kImpl].finished;
      }
      get writableNeedDrain() {
        return this[kImpl].needDrain;
      }
      get writableObjectMode() {
        return false;
      }
      get writableErrored() {
        return this[kImpl].errored;
      }
    };
    function error(stream, err) {
      setImmediate(() => {
        stream.emit("error", err);
      });
    }
    function destroy(stream, err) {
      if (stream[kImpl].destroyed) {
        return;
      }
      stream[kImpl].destroyed = true;
      if (err) {
        stream[kImpl].errored = err;
        error(stream, err);
      }
      if (!stream.worker.exited) {
        stream.worker.terminate().catch(() => {
        }).then(() => {
          stream[kImpl].closed = true;
          stream.emit("close");
        });
      } else {
        setImmediate(() => {
          stream[kImpl].closed = true;
          stream.emit("close");
        });
      }
    }
    function write(stream, data, cb) {
      const current = Atomics.load(stream[kImpl].state, WRITE_INDEX);
      const length = Buffer.byteLength(data);
      stream[kImpl].data.write(data, current);
      Atomics.store(stream[kImpl].state, WRITE_INDEX, current + length);
      Atomics.notify(stream[kImpl].state, WRITE_INDEX);
      cb();
      return true;
    }
    function end(stream) {
      if (stream[kImpl].ended || !stream[kImpl].ending || stream[kImpl].flushing) {
        return;
      }
      stream[kImpl].ended = true;
      try {
        stream.flushSync();
        let readIndex = Atomics.load(stream[kImpl].state, READ_INDEX);
        Atomics.store(stream[kImpl].state, WRITE_INDEX, -1);
        Atomics.notify(stream[kImpl].state, WRITE_INDEX);
        let spins = 0;
        while (readIndex !== -1) {
          Atomics.wait(stream[kImpl].state, READ_INDEX, readIndex, 1e3);
          readIndex = Atomics.load(stream[kImpl].state, READ_INDEX);
          if (readIndex === -2) {
            destroy(stream, new Error("end() failed"));
            return;
          }
          if (++spins === 10) {
            destroy(stream, new Error("end() took too long (10s)"));
            return;
          }
        }
        process.nextTick(() => {
          stream[kImpl].finished = true;
          stream.emit("finish");
        });
      } catch (err) {
        destroy(stream, err);
      }
    }
    function writeSync(stream) {
      const cb = () => {
        if (stream[kImpl].ending) {
          end(stream);
        } else if (stream[kImpl].needDrain) {
          process.nextTick(drain, stream);
        }
      };
      stream[kImpl].flushing = false;
      while (stream[kImpl].buf.length !== 0) {
        const writeIndex = Atomics.load(stream[kImpl].state, WRITE_INDEX);
        let leftover = stream[kImpl].data.length - writeIndex;
        if (leftover === 0) {
          flushSync(stream);
          Atomics.store(stream[kImpl].state, READ_INDEX, 0);
          Atomics.store(stream[kImpl].state, WRITE_INDEX, 0);
          continue;
        } else if (leftover < 0) {
          throw new Error("overwritten");
        }
        let toWrite = stream[kImpl].buf.slice(0, leftover);
        let toWriteBytes = Buffer.byteLength(toWrite);
        if (toWriteBytes <= leftover) {
          stream[kImpl].buf = stream[kImpl].buf.slice(leftover);
          write(stream, toWrite, cb);
        } else {
          flushSync(stream);
          Atomics.store(stream[kImpl].state, READ_INDEX, 0);
          Atomics.store(stream[kImpl].state, WRITE_INDEX, 0);
          while (toWriteBytes > stream[kImpl].buf.length) {
            leftover = leftover / 2;
            toWrite = stream[kImpl].buf.slice(0, leftover);
            toWriteBytes = Buffer.byteLength(toWrite);
          }
          stream[kImpl].buf = stream[kImpl].buf.slice(leftover);
          write(stream, toWrite, cb);
        }
      }
    }
    function flushSync(stream) {
      if (stream[kImpl].flushing) {
        throw new Error("unable to flush while flushing");
      }
      const writeIndex = Atomics.load(stream[kImpl].state, WRITE_INDEX);
      let spins = 0;
      while (true) {
        const readIndex = Atomics.load(stream[kImpl].state, READ_INDEX);
        if (readIndex === -2) {
          throw Error("_flushSync failed");
        }
        if (readIndex !== writeIndex) {
          Atomics.wait(stream[kImpl].state, READ_INDEX, readIndex, 1e3);
        } else {
          break;
        }
        if (++spins === 10) {
          throw new Error("_flushSync took too long (10s)");
        }
      }
    }
    module2.exports = ThreadStream;
  }
});

// node_modules/pino/lib/transport.js
var require_transport = __commonJS({
  "node_modules/pino/lib/transport.js"(exports2, module2) {
    "use strict";
    var { createRequire } = require("module");
    var getCallers = require_caller();
    var { join: join5, isAbsolute, sep } = require("node:path");
    var sleep = require_atomic_sleep();
    var onExit = require_on_exit_leak_free();
    var ThreadStream = require_thread_stream();
    function setupOnExit(stream) {
      onExit.register(stream, autoEnd);
      onExit.registerBeforeExit(stream, flush);
      stream.on("close", function() {
        onExit.unregister(stream);
      });
    }
    function buildStream(filename, workerData, workerOpts, sync) {
      const stream = new ThreadStream({
        filename,
        workerData,
        workerOpts,
        sync
      });
      stream.on("ready", onReady);
      stream.on("close", function() {
        process.removeListener("exit", onExit2);
      });
      process.on("exit", onExit2);
      function onReady() {
        process.removeListener("exit", onExit2);
        stream.unref();
        if (workerOpts.autoEnd !== false) {
          setupOnExit(stream);
        }
      }
      function onExit2() {
        if (stream.closed) {
          return;
        }
        stream.flushSync();
        sleep(100);
        stream.end();
      }
      return stream;
    }
    function autoEnd(stream) {
      stream.ref();
      stream.flushSync();
      stream.end();
      stream.once("close", function() {
        stream.unref();
      });
    }
    function flush(stream) {
      stream.flushSync();
    }
    function transport(fullOptions) {
      const { pipeline, targets, levels, dedupe, worker = {}, caller = getCallers(), sync = false } = fullOptions;
      const options = {
        ...fullOptions.options
      };
      const callers = typeof caller === "string" ? [caller] : caller;
      const bundlerOverrides = "__bundlerPathsOverrides" in globalThis ? globalThis.__bundlerPathsOverrides : {};
      let target = fullOptions.target;
      if (target && targets) {
        throw new Error("only one of target or targets can be specified");
      }
      if (targets) {
        target = bundlerOverrides["pino-worker"] || join5(__dirname, "worker.js");
        options.targets = targets.filter((dest) => dest.target).map((dest) => {
          return {
            ...dest,
            target: fixTarget(dest.target)
          };
        });
        options.pipelines = targets.filter((dest) => dest.pipeline).map((dest) => {
          return dest.pipeline.map((t) => {
            return {
              ...t,
              level: dest.level,
              // duplicate the pipeline `level` property defined in the upper level
              target: fixTarget(t.target)
            };
          });
        });
      } else if (pipeline) {
        target = bundlerOverrides["pino-worker"] || join5(__dirname, "worker.js");
        options.pipelines = [pipeline.map((dest) => {
          return {
            ...dest,
            target: fixTarget(dest.target)
          };
        })];
      }
      if (levels) {
        options.levels = levels;
      }
      if (dedupe) {
        options.dedupe = dedupe;
      }
      options.pinoWillSendConfig = true;
      return buildStream(fixTarget(target), options, worker, sync);
      function fixTarget(origin) {
        origin = bundlerOverrides[origin] || origin;
        if (isAbsolute(origin) || origin.indexOf("file://") === 0) {
          return origin;
        }
        if (origin === "pino/file") {
          return join5(__dirname, "..", "file.js");
        }
        let fixTarget2;
        for (const filePath of callers) {
          try {
            const context = filePath === "node:repl" ? process.cwd() + sep : filePath;
            fixTarget2 = createRequire(context).resolve(origin);
            break;
          } catch (err) {
            continue;
          }
        }
        if (!fixTarget2) {
          throw new Error(`unable to determine transport target for "${origin}"`);
        }
        return fixTarget2;
      }
    }
    module2.exports = transport;
  }
});

// node_modules/pino/lib/tools.js
var require_tools = __commonJS({
  "node_modules/pino/lib/tools.js"(exports2, module2) {
    "use strict";
    var format = require_quick_format_unescaped();
    var { mapHttpRequest, mapHttpResponse } = require_pino_std_serializers();
    var SonicBoom = require_sonic_boom();
    var onExit = require_on_exit_leak_free();
    var {
      lsCacheSym,
      chindingsSym,
      writeSym,
      serializersSym,
      formatOptsSym,
      endSym,
      stringifiersSym,
      stringifySym,
      stringifySafeSym,
      wildcardFirstSym,
      nestedKeySym,
      formattersSym,
      messageKeySym,
      errorKeySym,
      nestedKeyStrSym,
      msgPrefixSym
    } = require_symbols3();
    var { isMainThread } = require("worker_threads");
    var transport = require_transport();
    function noop() {
    }
    function genLog(level, hook) {
      if (!hook) return LOG;
      return function hookWrappedLog(...args) {
        hook.call(this, args, LOG, level);
      };
      function LOG(o, ...n) {
        if (typeof o === "object") {
          let msg = o;
          if (o !== null) {
            if (o.method && o.headers && o.socket) {
              o = mapHttpRequest(o);
            } else if (typeof o.setHeader === "function") {
              o = mapHttpResponse(o);
            }
          }
          let formatParams;
          if (msg === null && n.length === 0) {
            formatParams = [null];
          } else {
            msg = n.shift();
            formatParams = n;
          }
          if (typeof this[msgPrefixSym] === "string" && msg !== void 0 && msg !== null) {
            msg = this[msgPrefixSym] + msg;
          }
          this[writeSym](o, format(msg, formatParams, this[formatOptsSym]), level);
        } else {
          let msg = o === void 0 ? n.shift() : o;
          if (typeof this[msgPrefixSym] === "string" && msg !== void 0 && msg !== null) {
            msg = this[msgPrefixSym] + msg;
          }
          this[writeSym](null, format(msg, n, this[formatOptsSym]), level);
        }
      }
    }
    function asString(str) {
      let result = "";
      let last = 0;
      let found = false;
      let point = 255;
      const l = str.length;
      if (l > 100) {
        return JSON.stringify(str);
      }
      for (var i = 0; i < l && point >= 32; i++) {
        point = str.charCodeAt(i);
        if (point === 34 || point === 92) {
          result += str.slice(last, i) + "\\";
          last = i;
          found = true;
        }
      }
      if (!found) {
        result = str;
      } else {
        result += str.slice(last);
      }
      return point < 32 ? JSON.stringify(str) : '"' + result + '"';
    }
    function asJson(obj, msg, num, time) {
      const stringify2 = this[stringifySym];
      const stringifySafe = this[stringifySafeSym];
      const stringifiers = this[stringifiersSym];
      const end = this[endSym];
      const chindings = this[chindingsSym];
      const serializers = this[serializersSym];
      const formatters = this[formattersSym];
      const messageKey = this[messageKeySym];
      const errorKey = this[errorKeySym];
      let data = this[lsCacheSym][num] + time;
      data = data + chindings;
      let value;
      if (formatters.log) {
        obj = formatters.log(obj);
      }
      const wildcardStringifier = stringifiers[wildcardFirstSym];
      let propStr = "";
      for (const key in obj) {
        value = obj[key];
        if (Object.prototype.hasOwnProperty.call(obj, key) && value !== void 0) {
          if (serializers[key]) {
            value = serializers[key](value);
          } else if (key === errorKey && serializers.err) {
            value = serializers.err(value);
          }
          const stringifier = stringifiers[key] || wildcardStringifier;
          switch (typeof value) {
            case "undefined":
            case "function":
              continue;
            case "number":
              if (Number.isFinite(value) === false) {
                value = null;
              }
            // this case explicitly falls through to the next one
            case "boolean":
              if (stringifier) value = stringifier(value);
              break;
            case "string":
              value = (stringifier || asString)(value);
              break;
            default:
              value = (stringifier || stringify2)(value, stringifySafe);
          }
          if (value === void 0) continue;
          const strKey = asString(key);
          propStr += "," + strKey + ":" + value;
        }
      }
      let msgStr = "";
      if (msg !== void 0) {
        value = serializers[messageKey] ? serializers[messageKey](msg) : msg;
        const stringifier = stringifiers[messageKey] || wildcardStringifier;
        switch (typeof value) {
          case "function":
            break;
          case "number":
            if (Number.isFinite(value) === false) {
              value = null;
            }
          // this case explicitly falls through to the next one
          case "boolean":
            if (stringifier) value = stringifier(value);
            msgStr = ',"' + messageKey + '":' + value;
            break;
          case "string":
            value = (stringifier || asString)(value);
            msgStr = ',"' + messageKey + '":' + value;
            break;
          default:
            value = (stringifier || stringify2)(value, stringifySafe);
            msgStr = ',"' + messageKey + '":' + value;
        }
      }
      if (this[nestedKeySym] && propStr) {
        return data + this[nestedKeyStrSym] + propStr.slice(1) + "}" + msgStr + end;
      } else {
        return data + propStr + msgStr + end;
      }
    }
    function asChindings(instance, bindings) {
      let value;
      let data = instance[chindingsSym];
      const stringify2 = instance[stringifySym];
      const stringifySafe = instance[stringifySafeSym];
      const stringifiers = instance[stringifiersSym];
      const wildcardStringifier = stringifiers[wildcardFirstSym];
      const serializers = instance[serializersSym];
      const formatter = instance[formattersSym].bindings;
      bindings = formatter(bindings);
      for (const key in bindings) {
        value = bindings[key];
        const valid = key !== "level" && key !== "serializers" && key !== "formatters" && key !== "customLevels" && bindings.hasOwnProperty(key) && value !== void 0;
        if (valid === true) {
          value = serializers[key] ? serializers[key](value) : value;
          value = (stringifiers[key] || wildcardStringifier || stringify2)(value, stringifySafe);
          if (value === void 0) continue;
          data += ',"' + key + '":' + value;
        }
      }
      return data;
    }
    function hasBeenTampered(stream) {
      return stream.write !== stream.constructor.prototype.write;
    }
    function buildSafeSonicBoom(opts) {
      const stream = new SonicBoom(opts);
      stream.on("error", filterBrokenPipe);
      if (!opts.sync && isMainThread) {
        onExit.register(stream, autoEnd);
        stream.on("close", function() {
          onExit.unregister(stream);
        });
      }
      return stream;
      function filterBrokenPipe(err) {
        if (err.code === "EPIPE") {
          stream.write = noop;
          stream.end = noop;
          stream.flushSync = noop;
          stream.destroy = noop;
          return;
        }
        stream.removeListener("error", filterBrokenPipe);
        stream.emit("error", err);
      }
    }
    function autoEnd(stream, eventName) {
      if (stream.destroyed) {
        return;
      }
      if (eventName === "beforeExit") {
        stream.flush();
        stream.on("drain", function() {
          stream.end();
        });
      } else {
        stream.flushSync();
      }
    }
    function createArgsNormalizer(defaultOptions) {
      return function normalizeArgs(instance, caller, opts = {}, stream) {
        if (typeof opts === "string") {
          stream = buildSafeSonicBoom({ dest: opts });
          opts = {};
        } else if (typeof stream === "string") {
          if (opts && opts.transport) {
            throw Error("only one of option.transport or stream can be specified");
          }
          stream = buildSafeSonicBoom({ dest: stream });
        } else if (opts instanceof SonicBoom || opts.writable || opts._writableState) {
          stream = opts;
          opts = {};
        } else if (opts.transport) {
          if (opts.transport instanceof SonicBoom || opts.transport.writable || opts.transport._writableState) {
            throw Error("option.transport do not allow stream, please pass to option directly. e.g. pino(transport)");
          }
          if (opts.transport.targets && opts.transport.targets.length && opts.formatters && typeof opts.formatters.level === "function") {
            throw Error("option.transport.targets do not allow custom level formatters");
          }
          let customLevels;
          if (opts.customLevels) {
            customLevels = opts.useOnlyCustomLevels ? opts.customLevels : Object.assign({}, opts.levels, opts.customLevels);
          }
          stream = transport({ caller, ...opts.transport, levels: customLevels });
        }
        opts = Object.assign({}, defaultOptions, opts);
        opts.serializers = Object.assign({}, defaultOptions.serializers, opts.serializers);
        opts.formatters = Object.assign({}, defaultOptions.formatters, opts.formatters);
        if (opts.prettyPrint) {
          throw new Error("prettyPrint option is no longer supported, see the pino-pretty package (https://github.com/pinojs/pino-pretty)");
        }
        const { enabled, onChild } = opts;
        if (enabled === false) opts.level = "silent";
        if (!onChild) opts.onChild = noop;
        if (!stream) {
          if (!hasBeenTampered(process.stdout)) {
            stream = buildSafeSonicBoom({ fd: process.stdout.fd || 1 });
          } else {
            stream = process.stdout;
          }
        }
        return { opts, stream };
      };
    }
    function stringify(obj, stringifySafeFn) {
      try {
        return JSON.stringify(obj);
      } catch (_) {
        try {
          const stringify2 = stringifySafeFn || this[stringifySafeSym];
          return stringify2(obj);
        } catch (_2) {
          return '"[unable to serialize, circular reference is too complex to analyze]"';
        }
      }
    }
    function buildFormatters(level, bindings, log2) {
      return {
        level,
        bindings,
        log: log2
      };
    }
    function normalizeDestFileDescriptor(destination) {
      const fd = Number(destination);
      if (typeof destination === "string" && Number.isFinite(fd)) {
        return fd;
      }
      if (destination === void 0) {
        return 1;
      }
      return destination;
    }
    module2.exports = {
      noop,
      buildSafeSonicBoom,
      asChindings,
      asJson,
      genLog,
      createArgsNormalizer,
      stringify,
      buildFormatters,
      normalizeDestFileDescriptor
    };
  }
});

// node_modules/pino/lib/constants.js
var require_constants = __commonJS({
  "node_modules/pino/lib/constants.js"(exports2, module2) {
    var DEFAULT_LEVELS = {
      trace: 10,
      debug: 20,
      info: 30,
      warn: 40,
      error: 50,
      fatal: 60
    };
    var SORTING_ORDER = {
      ASC: "ASC",
      DESC: "DESC"
    };
    module2.exports = {
      DEFAULT_LEVELS,
      SORTING_ORDER
    };
  }
});

// node_modules/pino/lib/levels.js
var require_levels = __commonJS({
  "node_modules/pino/lib/levels.js"(exports2, module2) {
    "use strict";
    var {
      lsCacheSym,
      levelValSym,
      useOnlyCustomLevelsSym,
      streamSym,
      formattersSym,
      hooksSym,
      levelCompSym
    } = require_symbols3();
    var { noop, genLog } = require_tools();
    var { DEFAULT_LEVELS, SORTING_ORDER } = require_constants();
    var levelMethods = {
      fatal: (hook) => {
        const logFatal = genLog(DEFAULT_LEVELS.fatal, hook);
        return function(...args) {
          const stream = this[streamSym];
          logFatal.call(this, ...args);
          if (typeof stream.flushSync === "function") {
            try {
              stream.flushSync();
            } catch (e) {
            }
          }
        };
      },
      error: (hook) => genLog(DEFAULT_LEVELS.error, hook),
      warn: (hook) => genLog(DEFAULT_LEVELS.warn, hook),
      info: (hook) => genLog(DEFAULT_LEVELS.info, hook),
      debug: (hook) => genLog(DEFAULT_LEVELS.debug, hook),
      trace: (hook) => genLog(DEFAULT_LEVELS.trace, hook)
    };
    var nums = Object.keys(DEFAULT_LEVELS).reduce((o, k) => {
      o[DEFAULT_LEVELS[k]] = k;
      return o;
    }, {});
    var initialLsCache = Object.keys(nums).reduce((o, k) => {
      o[k] = '{"level":' + Number(k);
      return o;
    }, {});
    function genLsCache(instance) {
      const formatter = instance[formattersSym].level;
      const { labels } = instance.levels;
      const cache = {};
      for (const label in labels) {
        const level = formatter(labels[label], Number(label));
        cache[label] = JSON.stringify(level).slice(0, -1);
      }
      instance[lsCacheSym] = cache;
      return instance;
    }
    function isStandardLevel(level, useOnlyCustomLevels) {
      if (useOnlyCustomLevels) {
        return false;
      }
      switch (level) {
        case "fatal":
        case "error":
        case "warn":
        case "info":
        case "debug":
        case "trace":
          return true;
        default:
          return false;
      }
    }
    function setLevel(level) {
      const { labels, values } = this.levels;
      if (typeof level === "number") {
        if (labels[level] === void 0) throw Error("unknown level value" + level);
        level = labels[level];
      }
      if (values[level] === void 0) throw Error("unknown level " + level);
      const preLevelVal = this[levelValSym];
      const levelVal = this[levelValSym] = values[level];
      const useOnlyCustomLevelsVal = this[useOnlyCustomLevelsSym];
      const levelComparison = this[levelCompSym];
      const hook = this[hooksSym].logMethod;
      for (const key in values) {
        if (levelComparison(values[key], levelVal) === false) {
          this[key] = noop;
          continue;
        }
        this[key] = isStandardLevel(key, useOnlyCustomLevelsVal) ? levelMethods[key](hook) : genLog(values[key], hook);
      }
      this.emit(
        "level-change",
        level,
        levelVal,
        labels[preLevelVal],
        preLevelVal,
        this
      );
    }
    function getLevel(level) {
      const { levels, levelVal } = this;
      return levels && levels.labels ? levels.labels[levelVal] : "";
    }
    function isLevelEnabled(logLevel) {
      const { values } = this.levels;
      const logLevelVal = values[logLevel];
      return logLevelVal !== void 0 && this[levelCompSym](logLevelVal, this[levelValSym]);
    }
    function compareLevel(direction, current, expected) {
      if (direction === SORTING_ORDER.DESC) {
        return current <= expected;
      }
      return current >= expected;
    }
    function genLevelComparison(levelComparison) {
      if (typeof levelComparison === "string") {
        return compareLevel.bind(null, levelComparison);
      }
      return levelComparison;
    }
    function mappings(customLevels = null, useOnlyCustomLevels = false) {
      const customNums = customLevels ? Object.keys(customLevels).reduce((o, k) => {
        o[customLevels[k]] = k;
        return o;
      }, {}) : null;
      const labels = Object.assign(
        Object.create(Object.prototype, { Infinity: { value: "silent" } }),
        useOnlyCustomLevels ? null : nums,
        customNums
      );
      const values = Object.assign(
        Object.create(Object.prototype, { silent: { value: Infinity } }),
        useOnlyCustomLevels ? null : DEFAULT_LEVELS,
        customLevels
      );
      return { labels, values };
    }
    function assertDefaultLevelFound(defaultLevel, customLevels, useOnlyCustomLevels) {
      if (typeof defaultLevel === "number") {
        const values = [].concat(
          Object.keys(customLevels || {}).map((key) => customLevels[key]),
          useOnlyCustomLevels ? [] : Object.keys(nums).map((level) => +level),
          Infinity
        );
        if (!values.includes(defaultLevel)) {
          throw Error(`default level:${defaultLevel} must be included in custom levels`);
        }
        return;
      }
      const labels = Object.assign(
        Object.create(Object.prototype, { silent: { value: Infinity } }),
        useOnlyCustomLevels ? null : DEFAULT_LEVELS,
        customLevels
      );
      if (!(defaultLevel in labels)) {
        throw Error(`default level:${defaultLevel} must be included in custom levels`);
      }
    }
    function assertNoLevelCollisions(levels, customLevels) {
      const { labels, values } = levels;
      for (const k in customLevels) {
        if (k in values) {
          throw Error("levels cannot be overridden");
        }
        if (customLevels[k] in labels) {
          throw Error("pre-existing level values cannot be used for new levels");
        }
      }
    }
    function assertLevelComparison(levelComparison) {
      if (typeof levelComparison === "function") {
        return;
      }
      if (typeof levelComparison === "string" && Object.values(SORTING_ORDER).includes(levelComparison)) {
        return;
      }
      throw new Error('Levels comparison should be one of "ASC", "DESC" or "function" type');
    }
    module2.exports = {
      initialLsCache,
      genLsCache,
      levelMethods,
      getLevel,
      setLevel,
      isLevelEnabled,
      mappings,
      assertNoLevelCollisions,
      assertDefaultLevelFound,
      genLevelComparison,
      assertLevelComparison
    };
  }
});

// node_modules/pino/lib/meta.js
var require_meta = __commonJS({
  "node_modules/pino/lib/meta.js"(exports2, module2) {
    "use strict";
    module2.exports = { version: "9.7.0" };
  }
});

// node_modules/pino/lib/proto.js
var require_proto = __commonJS({
  "node_modules/pino/lib/proto.js"(exports2, module2) {
    "use strict";
    var { EventEmitter } = require("node:events");
    var {
      lsCacheSym,
      levelValSym,
      setLevelSym,
      getLevelSym,
      chindingsSym,
      parsedChindingsSym,
      mixinSym,
      asJsonSym,
      writeSym,
      mixinMergeStrategySym,
      timeSym,
      timeSliceIndexSym,
      streamSym,
      serializersSym,
      formattersSym,
      errorKeySym,
      messageKeySym,
      useOnlyCustomLevelsSym,
      needsMetadataGsym,
      redactFmtSym,
      stringifySym,
      formatOptsSym,
      stringifiersSym,
      msgPrefixSym,
      hooksSym
    } = require_symbols3();
    var {
      getLevel,
      setLevel,
      isLevelEnabled,
      mappings,
      initialLsCache,
      genLsCache,
      assertNoLevelCollisions
    } = require_levels();
    var {
      asChindings,
      asJson,
      buildFormatters,
      stringify
    } = require_tools();
    var {
      version: version2
    } = require_meta();
    var redaction = require_redaction();
    var constructor = class Pino {
    };
    var prototype = {
      constructor,
      child,
      bindings,
      setBindings,
      flush,
      isLevelEnabled,
      version: version2,
      get level() {
        return this[getLevelSym]();
      },
      set level(lvl) {
        this[setLevelSym](lvl);
      },
      get levelVal() {
        return this[levelValSym];
      },
      set levelVal(n) {
        throw Error("levelVal is read-only");
      },
      [lsCacheSym]: initialLsCache,
      [writeSym]: write,
      [asJsonSym]: asJson,
      [getLevelSym]: getLevel,
      [setLevelSym]: setLevel
    };
    Object.setPrototypeOf(prototype, EventEmitter.prototype);
    module2.exports = function() {
      return Object.create(prototype);
    };
    var resetChildingsFormatter = (bindings2) => bindings2;
    function child(bindings2, options) {
      if (!bindings2) {
        throw Error("missing bindings for child Pino");
      }
      options = options || {};
      const serializers = this[serializersSym];
      const formatters = this[formattersSym];
      const instance = Object.create(this);
      if (options.hasOwnProperty("serializers") === true) {
        instance[serializersSym] = /* @__PURE__ */ Object.create(null);
        for (const k in serializers) {
          instance[serializersSym][k] = serializers[k];
        }
        const parentSymbols = Object.getOwnPropertySymbols(serializers);
        for (var i = 0; i < parentSymbols.length; i++) {
          const ks = parentSymbols[i];
          instance[serializersSym][ks] = serializers[ks];
        }
        for (const bk in options.serializers) {
          instance[serializersSym][bk] = options.serializers[bk];
        }
        const bindingsSymbols = Object.getOwnPropertySymbols(options.serializers);
        for (var bi2 = 0; bi2 < bindingsSymbols.length; bi2++) {
          const bks = bindingsSymbols[bi2];
          instance[serializersSym][bks] = options.serializers[bks];
        }
      } else instance[serializersSym] = serializers;
      if (options.hasOwnProperty("formatters")) {
        const { level, bindings: chindings, log: log2 } = options.formatters;
        instance[formattersSym] = buildFormatters(
          level || formatters.level,
          chindings || resetChildingsFormatter,
          log2 || formatters.log
        );
      } else {
        instance[formattersSym] = buildFormatters(
          formatters.level,
          resetChildingsFormatter,
          formatters.log
        );
      }
      if (options.hasOwnProperty("customLevels") === true) {
        assertNoLevelCollisions(this.levels, options.customLevels);
        instance.levels = mappings(options.customLevels, instance[useOnlyCustomLevelsSym]);
        genLsCache(instance);
      }
      if (typeof options.redact === "object" && options.redact !== null || Array.isArray(options.redact)) {
        instance.redact = options.redact;
        const stringifiers = redaction(instance.redact, stringify);
        const formatOpts = { stringify: stringifiers[redactFmtSym] };
        instance[stringifySym] = stringify;
        instance[stringifiersSym] = stringifiers;
        instance[formatOptsSym] = formatOpts;
      }
      if (typeof options.msgPrefix === "string") {
        instance[msgPrefixSym] = (this[msgPrefixSym] || "") + options.msgPrefix;
      }
      instance[chindingsSym] = asChindings(instance, bindings2);
      const childLevel = options.level || this.level;
      instance[setLevelSym](childLevel);
      this.onChild(instance);
      return instance;
    }
    function bindings() {
      const chindings = this[chindingsSym];
      const chindingsJson = `{${chindings.substr(1)}}`;
      const bindingsFromJson = JSON.parse(chindingsJson);
      delete bindingsFromJson.pid;
      delete bindingsFromJson.hostname;
      return bindingsFromJson;
    }
    function setBindings(newBindings) {
      const chindings = asChindings(this, newBindings);
      this[chindingsSym] = chindings;
      delete this[parsedChindingsSym];
    }
    function defaultMixinMergeStrategy(mergeObject, mixinObject) {
      return Object.assign(mixinObject, mergeObject);
    }
    function write(_obj, msg, num) {
      const t = this[timeSym]();
      const mixin = this[mixinSym];
      const errorKey = this[errorKeySym];
      const messageKey = this[messageKeySym];
      const mixinMergeStrategy = this[mixinMergeStrategySym] || defaultMixinMergeStrategy;
      let obj;
      const streamWriteHook = this[hooksSym].streamWrite;
      if (_obj === void 0 || _obj === null) {
        obj = {};
      } else if (_obj instanceof Error) {
        obj = { [errorKey]: _obj };
        if (msg === void 0) {
          msg = _obj.message;
        }
      } else {
        obj = _obj;
        if (msg === void 0 && _obj[messageKey] === void 0 && _obj[errorKey]) {
          msg = _obj[errorKey].message;
        }
      }
      if (mixin) {
        obj = mixinMergeStrategy(obj, mixin(obj, num, this));
      }
      const s = this[asJsonSym](obj, msg, num, t);
      const stream = this[streamSym];
      if (stream[needsMetadataGsym] === true) {
        stream.lastLevel = num;
        stream.lastObj = obj;
        stream.lastMsg = msg;
        stream.lastTime = t.slice(this[timeSliceIndexSym]);
        stream.lastLogger = this;
      }
      stream.write(streamWriteHook ? streamWriteHook(s) : s);
    }
    function noop() {
    }
    function flush(cb) {
      if (cb != null && typeof cb !== "function") {
        throw Error("callback must be a function");
      }
      const stream = this[streamSym];
      if (typeof stream.flush === "function") {
        stream.flush(cb || noop);
      } else if (cb) cb();
    }
  }
});

// node_modules/safe-stable-stringify/index.js
var require_safe_stable_stringify = __commonJS({
  "node_modules/safe-stable-stringify/index.js"(exports2, module2) {
    "use strict";
    var { hasOwnProperty } = Object.prototype;
    var stringify = configure();
    stringify.configure = configure;
    stringify.stringify = stringify;
    stringify.default = stringify;
    exports2.stringify = stringify;
    exports2.configure = configure;
    module2.exports = stringify;
    var strEscapeSequencesRegExp = /[\u0000-\u001f\u0022\u005c\ud800-\udfff]/;
    function strEscape(str) {
      if (str.length < 5e3 && !strEscapeSequencesRegExp.test(str)) {
        return `"${str}"`;
      }
      return JSON.stringify(str);
    }
    function sort(array, comparator) {
      if (array.length > 200 || comparator) {
        return array.sort(comparator);
      }
      for (let i = 1; i < array.length; i++) {
        const currentValue = array[i];
        let position = i;
        while (position !== 0 && array[position - 1] > currentValue) {
          array[position] = array[position - 1];
          position--;
        }
        array[position] = currentValue;
      }
      return array;
    }
    var typedArrayPrototypeGetSymbolToStringTag = Object.getOwnPropertyDescriptor(
      Object.getPrototypeOf(
        Object.getPrototypeOf(
          new Int8Array()
        )
      ),
      Symbol.toStringTag
    ).get;
    function isTypedArrayWithEntries(value) {
      return typedArrayPrototypeGetSymbolToStringTag.call(value) !== void 0 && value.length !== 0;
    }
    function stringifyTypedArray(array, separator, maximumBreadth) {
      if (array.length < maximumBreadth) {
        maximumBreadth = array.length;
      }
      const whitespace = separator === "," ? "" : " ";
      let res = `"0":${whitespace}${array[0]}`;
      for (let i = 1; i < maximumBreadth; i++) {
        res += `${separator}"${i}":${whitespace}${array[i]}`;
      }
      return res;
    }
    function getCircularValueOption(options) {
      if (hasOwnProperty.call(options, "circularValue")) {
        const circularValue = options.circularValue;
        if (typeof circularValue === "string") {
          return `"${circularValue}"`;
        }
        if (circularValue == null) {
          return circularValue;
        }
        if (circularValue === Error || circularValue === TypeError) {
          return {
            toString() {
              throw new TypeError("Converting circular structure to JSON");
            }
          };
        }
        throw new TypeError('The "circularValue" argument must be of type string or the value null or undefined');
      }
      return '"[Circular]"';
    }
    function getDeterministicOption(options) {
      let value;
      if (hasOwnProperty.call(options, "deterministic")) {
        value = options.deterministic;
        if (typeof value !== "boolean" && typeof value !== "function") {
          throw new TypeError('The "deterministic" argument must be of type boolean or comparator function');
        }
      }
      return value === void 0 ? true : value;
    }
    function getBooleanOption(options, key) {
      let value;
      if (hasOwnProperty.call(options, key)) {
        value = options[key];
        if (typeof value !== "boolean") {
          throw new TypeError(`The "${key}" argument must be of type boolean`);
        }
      }
      return value === void 0 ? true : value;
    }
    function getPositiveIntegerOption(options, key) {
      let value;
      if (hasOwnProperty.call(options, key)) {
        value = options[key];
        if (typeof value !== "number") {
          throw new TypeError(`The "${key}" argument must be of type number`);
        }
        if (!Number.isInteger(value)) {
          throw new TypeError(`The "${key}" argument must be an integer`);
        }
        if (value < 1) {
          throw new RangeError(`The "${key}" argument must be >= 1`);
        }
      }
      return value === void 0 ? Infinity : value;
    }
    function getItemCount(number) {
      if (number === 1) {
        return "1 item";
      }
      return `${number} items`;
    }
    function getUniqueReplacerSet(replacerArray) {
      const replacerSet = /* @__PURE__ */ new Set();
      for (const value of replacerArray) {
        if (typeof value === "string" || typeof value === "number") {
          replacerSet.add(String(value));
        }
      }
      return replacerSet;
    }
    function getStrictOption(options) {
      if (hasOwnProperty.call(options, "strict")) {
        const value = options.strict;
        if (typeof value !== "boolean") {
          throw new TypeError('The "strict" argument must be of type boolean');
        }
        if (value) {
          return (value2) => {
            let message = `Object can not safely be stringified. Received type ${typeof value2}`;
            if (typeof value2 !== "function") message += ` (${value2.toString()})`;
            throw new Error(message);
          };
        }
      }
    }
    function configure(options) {
      options = { ...options };
      const fail = getStrictOption(options);
      if (fail) {
        if (options.bigint === void 0) {
          options.bigint = false;
        }
        if (!("circularValue" in options)) {
          options.circularValue = Error;
        }
      }
      const circularValue = getCircularValueOption(options);
      const bigint = getBooleanOption(options, "bigint");
      const deterministic = getDeterministicOption(options);
      const comparator = typeof deterministic === "function" ? deterministic : void 0;
      const maximumDepth = getPositiveIntegerOption(options, "maximumDepth");
      const maximumBreadth = getPositiveIntegerOption(options, "maximumBreadth");
      function stringifyFnReplacer(key, parent, stack, replacer, spacer, indentation) {
        let value = parent[key];
        if (typeof value === "object" && value !== null && typeof value.toJSON === "function") {
          value = value.toJSON(key);
        }
        value = replacer.call(parent, key, value);
        switch (typeof value) {
          case "string":
            return strEscape(value);
          case "object": {
            if (value === null) {
              return "null";
            }
            if (stack.indexOf(value) !== -1) {
              return circularValue;
            }
            let res = "";
            let join5 = ",";
            const originalIndentation = indentation;
            if (Array.isArray(value)) {
              if (value.length === 0) {
                return "[]";
              }
              if (maximumDepth < stack.length + 1) {
                return '"[Array]"';
              }
              stack.push(value);
              if (spacer !== "") {
                indentation += spacer;
                res += `
${indentation}`;
                join5 = `,
${indentation}`;
              }
              const maximumValuesToStringify = Math.min(value.length, maximumBreadth);
              let i = 0;
              for (; i < maximumValuesToStringify - 1; i++) {
                const tmp2 = stringifyFnReplacer(String(i), value, stack, replacer, spacer, indentation);
                res += tmp2 !== void 0 ? tmp2 : "null";
                res += join5;
              }
              const tmp = stringifyFnReplacer(String(i), value, stack, replacer, spacer, indentation);
              res += tmp !== void 0 ? tmp : "null";
              if (value.length - 1 > maximumBreadth) {
                const removedKeys = value.length - maximumBreadth - 1;
                res += `${join5}"... ${getItemCount(removedKeys)} not stringified"`;
              }
              if (spacer !== "") {
                res += `
${originalIndentation}`;
              }
              stack.pop();
              return `[${res}]`;
            }
            let keys = Object.keys(value);
            const keyLength = keys.length;
            if (keyLength === 0) {
              return "{}";
            }
            if (maximumDepth < stack.length + 1) {
              return '"[Object]"';
            }
            let whitespace = "";
            let separator = "";
            if (spacer !== "") {
              indentation += spacer;
              join5 = `,
${indentation}`;
              whitespace = " ";
            }
            const maximumPropertiesToStringify = Math.min(keyLength, maximumBreadth);
            if (deterministic && !isTypedArrayWithEntries(value)) {
              keys = sort(keys, comparator);
            }
            stack.push(value);
            for (let i = 0; i < maximumPropertiesToStringify; i++) {
              const key2 = keys[i];
              const tmp = stringifyFnReplacer(key2, value, stack, replacer, spacer, indentation);
              if (tmp !== void 0) {
                res += `${separator}${strEscape(key2)}:${whitespace}${tmp}`;
                separator = join5;
              }
            }
            if (keyLength > maximumBreadth) {
              const removedKeys = keyLength - maximumBreadth;
              res += `${separator}"...":${whitespace}"${getItemCount(removedKeys)} not stringified"`;
              separator = join5;
            }
            if (spacer !== "" && separator.length > 1) {
              res = `
${indentation}${res}
${originalIndentation}`;
            }
            stack.pop();
            return `{${res}}`;
          }
          case "number":
            return isFinite(value) ? String(value) : fail ? fail(value) : "null";
          case "boolean":
            return value === true ? "true" : "false";
          case "undefined":
            return void 0;
          case "bigint":
            if (bigint) {
              return String(value);
            }
          // fallthrough
          default:
            return fail ? fail(value) : void 0;
        }
      }
      function stringifyArrayReplacer(key, value, stack, replacer, spacer, indentation) {
        if (typeof value === "object" && value !== null && typeof value.toJSON === "function") {
          value = value.toJSON(key);
        }
        switch (typeof value) {
          case "string":
            return strEscape(value);
          case "object": {
            if (value === null) {
              return "null";
            }
            if (stack.indexOf(value) !== -1) {
              return circularValue;
            }
            const originalIndentation = indentation;
            let res = "";
            let join5 = ",";
            if (Array.isArray(value)) {
              if (value.length === 0) {
                return "[]";
              }
              if (maximumDepth < stack.length + 1) {
                return '"[Array]"';
              }
              stack.push(value);
              if (spacer !== "") {
                indentation += spacer;
                res += `
${indentation}`;
                join5 = `,
${indentation}`;
              }
              const maximumValuesToStringify = Math.min(value.length, maximumBreadth);
              let i = 0;
              for (; i < maximumValuesToStringify - 1; i++) {
                const tmp2 = stringifyArrayReplacer(String(i), value[i], stack, replacer, spacer, indentation);
                res += tmp2 !== void 0 ? tmp2 : "null";
                res += join5;
              }
              const tmp = stringifyArrayReplacer(String(i), value[i], stack, replacer, spacer, indentation);
              res += tmp !== void 0 ? tmp : "null";
              if (value.length - 1 > maximumBreadth) {
                const removedKeys = value.length - maximumBreadth - 1;
                res += `${join5}"... ${getItemCount(removedKeys)} not stringified"`;
              }
              if (spacer !== "") {
                res += `
${originalIndentation}`;
              }
              stack.pop();
              return `[${res}]`;
            }
            stack.push(value);
            let whitespace = "";
            if (spacer !== "") {
              indentation += spacer;
              join5 = `,
${indentation}`;
              whitespace = " ";
            }
            let separator = "";
            for (const key2 of replacer) {
              const tmp = stringifyArrayReplacer(key2, value[key2], stack, replacer, spacer, indentation);
              if (tmp !== void 0) {
                res += `${separator}${strEscape(key2)}:${whitespace}${tmp}`;
                separator = join5;
              }
            }
            if (spacer !== "" && separator.length > 1) {
              res = `
${indentation}${res}
${originalIndentation}`;
            }
            stack.pop();
            return `{${res}}`;
          }
          case "number":
            return isFinite(value) ? String(value) : fail ? fail(value) : "null";
          case "boolean":
            return value === true ? "true" : "false";
          case "undefined":
            return void 0;
          case "bigint":
            if (bigint) {
              return String(value);
            }
          // fallthrough
          default:
            return fail ? fail(value) : void 0;
        }
      }
      function stringifyIndent(key, value, stack, spacer, indentation) {
        switch (typeof value) {
          case "string":
            return strEscape(value);
          case "object": {
            if (value === null) {
              return "null";
            }
            if (typeof value.toJSON === "function") {
              value = value.toJSON(key);
              if (typeof value !== "object") {
                return stringifyIndent(key, value, stack, spacer, indentation);
              }
              if (value === null) {
                return "null";
              }
            }
            if (stack.indexOf(value) !== -1) {
              return circularValue;
            }
            const originalIndentation = indentation;
            if (Array.isArray(value)) {
              if (value.length === 0) {
                return "[]";
              }
              if (maximumDepth < stack.length + 1) {
                return '"[Array]"';
              }
              stack.push(value);
              indentation += spacer;
              let res2 = `
${indentation}`;
              const join6 = `,
${indentation}`;
              const maximumValuesToStringify = Math.min(value.length, maximumBreadth);
              let i = 0;
              for (; i < maximumValuesToStringify - 1; i++) {
                const tmp2 = stringifyIndent(String(i), value[i], stack, spacer, indentation);
                res2 += tmp2 !== void 0 ? tmp2 : "null";
                res2 += join6;
              }
              const tmp = stringifyIndent(String(i), value[i], stack, spacer, indentation);
              res2 += tmp !== void 0 ? tmp : "null";
              if (value.length - 1 > maximumBreadth) {
                const removedKeys = value.length - maximumBreadth - 1;
                res2 += `${join6}"... ${getItemCount(removedKeys)} not stringified"`;
              }
              res2 += `
${originalIndentation}`;
              stack.pop();
              return `[${res2}]`;
            }
            let keys = Object.keys(value);
            const keyLength = keys.length;
            if (keyLength === 0) {
              return "{}";
            }
            if (maximumDepth < stack.length + 1) {
              return '"[Object]"';
            }
            indentation += spacer;
            const join5 = `,
${indentation}`;
            let res = "";
            let separator = "";
            let maximumPropertiesToStringify = Math.min(keyLength, maximumBreadth);
            if (isTypedArrayWithEntries(value)) {
              res += stringifyTypedArray(value, join5, maximumBreadth);
              keys = keys.slice(value.length);
              maximumPropertiesToStringify -= value.length;
              separator = join5;
            }
            if (deterministic) {
              keys = sort(keys, comparator);
            }
            stack.push(value);
            for (let i = 0; i < maximumPropertiesToStringify; i++) {
              const key2 = keys[i];
              const tmp = stringifyIndent(key2, value[key2], stack, spacer, indentation);
              if (tmp !== void 0) {
                res += `${separator}${strEscape(key2)}: ${tmp}`;
                separator = join5;
              }
            }
            if (keyLength > maximumBreadth) {
              const removedKeys = keyLength - maximumBreadth;
              res += `${separator}"...": "${getItemCount(removedKeys)} not stringified"`;
              separator = join5;
            }
            if (separator !== "") {
              res = `
${indentation}${res}
${originalIndentation}`;
            }
            stack.pop();
            return `{${res}}`;
          }
          case "number":
            return isFinite(value) ? String(value) : fail ? fail(value) : "null";
          case "boolean":
            return value === true ? "true" : "false";
          case "undefined":
            return void 0;
          case "bigint":
            if (bigint) {
              return String(value);
            }
          // fallthrough
          default:
            return fail ? fail(value) : void 0;
        }
      }
      function stringifySimple(key, value, stack) {
        switch (typeof value) {
          case "string":
            return strEscape(value);
          case "object": {
            if (value === null) {
              return "null";
            }
            if (typeof value.toJSON === "function") {
              value = value.toJSON(key);
              if (typeof value !== "object") {
                return stringifySimple(key, value, stack);
              }
              if (value === null) {
                return "null";
              }
            }
            if (stack.indexOf(value) !== -1) {
              return circularValue;
            }
            let res = "";
            const hasLength = value.length !== void 0;
            if (hasLength && Array.isArray(value)) {
              if (value.length === 0) {
                return "[]";
              }
              if (maximumDepth < stack.length + 1) {
                return '"[Array]"';
              }
              stack.push(value);
              const maximumValuesToStringify = Math.min(value.length, maximumBreadth);
              let i = 0;
              for (; i < maximumValuesToStringify - 1; i++) {
                const tmp2 = stringifySimple(String(i), value[i], stack);
                res += tmp2 !== void 0 ? tmp2 : "null";
                res += ",";
              }
              const tmp = stringifySimple(String(i), value[i], stack);
              res += tmp !== void 0 ? tmp : "null";
              if (value.length - 1 > maximumBreadth) {
                const removedKeys = value.length - maximumBreadth - 1;
                res += `,"... ${getItemCount(removedKeys)} not stringified"`;
              }
              stack.pop();
              return `[${res}]`;
            }
            let keys = Object.keys(value);
            const keyLength = keys.length;
            if (keyLength === 0) {
              return "{}";
            }
            if (maximumDepth < stack.length + 1) {
              return '"[Object]"';
            }
            let separator = "";
            let maximumPropertiesToStringify = Math.min(keyLength, maximumBreadth);
            if (hasLength && isTypedArrayWithEntries(value)) {
              res += stringifyTypedArray(value, ",", maximumBreadth);
              keys = keys.slice(value.length);
              maximumPropertiesToStringify -= value.length;
              separator = ",";
            }
            if (deterministic) {
              keys = sort(keys, comparator);
            }
            stack.push(value);
            for (let i = 0; i < maximumPropertiesToStringify; i++) {
              const key2 = keys[i];
              const tmp = stringifySimple(key2, value[key2], stack);
              if (tmp !== void 0) {
                res += `${separator}${strEscape(key2)}:${tmp}`;
                separator = ",";
              }
            }
            if (keyLength > maximumBreadth) {
              const removedKeys = keyLength - maximumBreadth;
              res += `${separator}"...":"${getItemCount(removedKeys)} not stringified"`;
            }
            stack.pop();
            return `{${res}}`;
          }
          case "number":
            return isFinite(value) ? String(value) : fail ? fail(value) : "null";
          case "boolean":
            return value === true ? "true" : "false";
          case "undefined":
            return void 0;
          case "bigint":
            if (bigint) {
              return String(value);
            }
          // fallthrough
          default:
            return fail ? fail(value) : void 0;
        }
      }
      function stringify2(value, replacer, space) {
        if (arguments.length > 1) {
          let spacer = "";
          if (typeof space === "number") {
            spacer = " ".repeat(Math.min(space, 10));
          } else if (typeof space === "string") {
            spacer = space.slice(0, 10);
          }
          if (replacer != null) {
            if (typeof replacer === "function") {
              return stringifyFnReplacer("", { "": value }, [], replacer, spacer, "");
            }
            if (Array.isArray(replacer)) {
              return stringifyArrayReplacer("", value, [], getUniqueReplacerSet(replacer), spacer, "");
            }
          }
          if (spacer.length !== 0) {
            return stringifyIndent("", value, [], spacer, "");
          }
        }
        return stringifySimple("", value, []);
      }
      return stringify2;
    }
  }
});

// node_modules/pino/lib/multistream.js
var require_multistream = __commonJS({
  "node_modules/pino/lib/multistream.js"(exports2, module2) {
    "use strict";
    var metadata = Symbol.for("pino.metadata");
    var { DEFAULT_LEVELS } = require_constants();
    var DEFAULT_INFO_LEVEL = DEFAULT_LEVELS.info;
    function multistream(streamsArray, opts) {
      let counter = 0;
      streamsArray = streamsArray || [];
      opts = opts || { dedupe: false };
      const streamLevels = Object.create(DEFAULT_LEVELS);
      streamLevels.silent = Infinity;
      if (opts.levels && typeof opts.levels === "object") {
        Object.keys(opts.levels).forEach((i) => {
          streamLevels[i] = opts.levels[i];
        });
      }
      const res = {
        write,
        add,
        emit,
        flushSync,
        end,
        minLevel: 0,
        streams: [],
        clone,
        [metadata]: true,
        streamLevels
      };
      if (Array.isArray(streamsArray)) {
        streamsArray.forEach(add, res);
      } else {
        add.call(res, streamsArray);
      }
      streamsArray = null;
      return res;
      function write(data) {
        let dest;
        const level = this.lastLevel;
        const { streams } = this;
        let recordedLevel = 0;
        let stream;
        for (let i = initLoopVar(streams.length, opts.dedupe); checkLoopVar(i, streams.length, opts.dedupe); i = adjustLoopVar(i, opts.dedupe)) {
          dest = streams[i];
          if (dest.level <= level) {
            if (recordedLevel !== 0 && recordedLevel !== dest.level) {
              break;
            }
            stream = dest.stream;
            if (stream[metadata]) {
              const { lastTime, lastMsg, lastObj, lastLogger } = this;
              stream.lastLevel = level;
              stream.lastTime = lastTime;
              stream.lastMsg = lastMsg;
              stream.lastObj = lastObj;
              stream.lastLogger = lastLogger;
            }
            stream.write(data);
            if (opts.dedupe) {
              recordedLevel = dest.level;
            }
          } else if (!opts.dedupe) {
            break;
          }
        }
      }
      function emit(...args) {
        for (const { stream } of this.streams) {
          if (typeof stream.emit === "function") {
            stream.emit(...args);
          }
        }
      }
      function flushSync() {
        for (const { stream } of this.streams) {
          if (typeof stream.flushSync === "function") {
            stream.flushSync();
          }
        }
      }
      function add(dest) {
        if (!dest) {
          return res;
        }
        const isStream = typeof dest.write === "function" || dest.stream;
        const stream_ = dest.write ? dest : dest.stream;
        if (!isStream) {
          throw Error("stream object needs to implement either StreamEntry or DestinationStream interface");
        }
        const { streams, streamLevels: streamLevels2 } = this;
        let level;
        if (typeof dest.levelVal === "number") {
          level = dest.levelVal;
        } else if (typeof dest.level === "string") {
          level = streamLevels2[dest.level];
        } else if (typeof dest.level === "number") {
          level = dest.level;
        } else {
          level = DEFAULT_INFO_LEVEL;
        }
        const dest_ = {
          stream: stream_,
          level,
          levelVal: void 0,
          id: counter++
        };
        streams.unshift(dest_);
        streams.sort(compareByLevel);
        this.minLevel = streams[0].level;
        return res;
      }
      function end() {
        for (const { stream } of this.streams) {
          if (typeof stream.flushSync === "function") {
            stream.flushSync();
          }
          stream.end();
        }
      }
      function clone(level) {
        const streams = new Array(this.streams.length);
        for (let i = 0; i < streams.length; i++) {
          streams[i] = {
            level,
            stream: this.streams[i].stream
          };
        }
        return {
          write,
          add,
          minLevel: level,
          streams,
          clone,
          emit,
          flushSync,
          [metadata]: true
        };
      }
    }
    function compareByLevel(a, b) {
      return a.level - b.level;
    }
    function initLoopVar(length, dedupe) {
      return dedupe ? length - 1 : 0;
    }
    function adjustLoopVar(i, dedupe) {
      return dedupe ? i - 1 : i + 1;
    }
    function checkLoopVar(i, length, dedupe) {
      return dedupe ? i >= 0 : i < length;
    }
    module2.exports = multistream;
  }
});

// node_modules/pino/pino.js
var require_pino = __commonJS({
  "node_modules/pino/pino.js"(exports2, module2) {
    "use strict";
    var os2 = require("node:os");
    var stdSerializers = require_pino_std_serializers();
    var caller = require_caller();
    var redaction = require_redaction();
    var time = require_time();
    var proto = require_proto();
    var symbols = require_symbols3();
    var { configure } = require_safe_stable_stringify();
    var { assertDefaultLevelFound, mappings, genLsCache, genLevelComparison, assertLevelComparison } = require_levels();
    var { DEFAULT_LEVELS, SORTING_ORDER } = require_constants();
    var {
      createArgsNormalizer,
      asChindings,
      buildSafeSonicBoom,
      buildFormatters,
      stringify,
      normalizeDestFileDescriptor,
      noop
    } = require_tools();
    var { version: version2 } = require_meta();
    var {
      chindingsSym,
      redactFmtSym,
      serializersSym,
      timeSym,
      timeSliceIndexSym,
      streamSym,
      stringifySym,
      stringifySafeSym,
      stringifiersSym,
      setLevelSym,
      endSym,
      formatOptsSym,
      messageKeySym,
      errorKeySym,
      nestedKeySym,
      mixinSym,
      levelCompSym,
      useOnlyCustomLevelsSym,
      formattersSym,
      hooksSym,
      nestedKeyStrSym,
      mixinMergeStrategySym,
      msgPrefixSym
    } = symbols;
    var { epochTime, nullTime } = time;
    var { pid } = process;
    var hostname = os2.hostname();
    var defaultErrorSerializer = stdSerializers.err;
    var defaultOptions = {
      level: "info",
      levelComparison: SORTING_ORDER.ASC,
      levels: DEFAULT_LEVELS,
      messageKey: "msg",
      errorKey: "err",
      nestedKey: null,
      enabled: true,
      base: { pid, hostname },
      serializers: Object.assign(/* @__PURE__ */ Object.create(null), {
        err: defaultErrorSerializer
      }),
      formatters: Object.assign(/* @__PURE__ */ Object.create(null), {
        bindings(bindings) {
          return bindings;
        },
        level(label, number) {
          return { level: number };
        }
      }),
      hooks: {
        logMethod: void 0,
        streamWrite: void 0
      },
      timestamp: epochTime,
      name: void 0,
      redact: null,
      customLevels: null,
      useOnlyCustomLevels: false,
      depthLimit: 5,
      edgeLimit: 100
    };
    var normalize = createArgsNormalizer(defaultOptions);
    var serializers = Object.assign(/* @__PURE__ */ Object.create(null), stdSerializers);
    function pino(...args) {
      const instance = {};
      const { opts, stream } = normalize(instance, caller(), ...args);
      if (opts.level && typeof opts.level === "string" && DEFAULT_LEVELS[opts.level.toLowerCase()] !== void 0) opts.level = opts.level.toLowerCase();
      const {
        redact,
        crlf,
        serializers: serializers2,
        timestamp,
        messageKey,
        errorKey,
        nestedKey,
        base,
        name,
        level,
        customLevels,
        levelComparison,
        mixin,
        mixinMergeStrategy,
        useOnlyCustomLevels,
        formatters,
        hooks,
        depthLimit,
        edgeLimit,
        onChild,
        msgPrefix
      } = opts;
      const stringifySafe = configure({
        maximumDepth: depthLimit,
        maximumBreadth: edgeLimit
      });
      const allFormatters = buildFormatters(
        formatters.level,
        formatters.bindings,
        formatters.log
      );
      const stringifyFn = stringify.bind({
        [stringifySafeSym]: stringifySafe
      });
      const stringifiers = redact ? redaction(redact, stringifyFn) : {};
      const formatOpts = redact ? { stringify: stringifiers[redactFmtSym] } : { stringify: stringifyFn };
      const end = "}" + (crlf ? "\r\n" : "\n");
      const coreChindings = asChindings.bind(null, {
        [chindingsSym]: "",
        [serializersSym]: serializers2,
        [stringifiersSym]: stringifiers,
        [stringifySym]: stringify,
        [stringifySafeSym]: stringifySafe,
        [formattersSym]: allFormatters
      });
      let chindings = "";
      if (base !== null) {
        if (name === void 0) {
          chindings = coreChindings(base);
        } else {
          chindings = coreChindings(Object.assign({}, base, { name }));
        }
      }
      const time2 = timestamp instanceof Function ? timestamp : timestamp ? epochTime : nullTime;
      const timeSliceIndex = time2().indexOf(":") + 1;
      if (useOnlyCustomLevels && !customLevels) throw Error("customLevels is required if useOnlyCustomLevels is set true");
      if (mixin && typeof mixin !== "function") throw Error(`Unknown mixin type "${typeof mixin}" - expected "function"`);
      if (msgPrefix && typeof msgPrefix !== "string") throw Error(`Unknown msgPrefix type "${typeof msgPrefix}" - expected "string"`);
      assertDefaultLevelFound(level, customLevels, useOnlyCustomLevels);
      const levels = mappings(customLevels, useOnlyCustomLevels);
      if (typeof stream.emit === "function") {
        stream.emit("message", { code: "PINO_CONFIG", config: { levels, messageKey, errorKey } });
      }
      assertLevelComparison(levelComparison);
      const levelCompFunc = genLevelComparison(levelComparison);
      Object.assign(instance, {
        levels,
        [levelCompSym]: levelCompFunc,
        [useOnlyCustomLevelsSym]: useOnlyCustomLevels,
        [streamSym]: stream,
        [timeSym]: time2,
        [timeSliceIndexSym]: timeSliceIndex,
        [stringifySym]: stringify,
        [stringifySafeSym]: stringifySafe,
        [stringifiersSym]: stringifiers,
        [endSym]: end,
        [formatOptsSym]: formatOpts,
        [messageKeySym]: messageKey,
        [errorKeySym]: errorKey,
        [nestedKeySym]: nestedKey,
        // protect against injection
        [nestedKeyStrSym]: nestedKey ? `,${JSON.stringify(nestedKey)}:{` : "",
        [serializersSym]: serializers2,
        [mixinSym]: mixin,
        [mixinMergeStrategySym]: mixinMergeStrategy,
        [chindingsSym]: chindings,
        [formattersSym]: allFormatters,
        [hooksSym]: hooks,
        silent: noop,
        onChild,
        [msgPrefixSym]: msgPrefix
      });
      Object.setPrototypeOf(instance, proto());
      genLsCache(instance);
      instance[setLevelSym](level);
      return instance;
    }
    module2.exports = pino;
    module2.exports.destination = (dest = process.stdout.fd) => {
      if (typeof dest === "object") {
        dest.dest = normalizeDestFileDescriptor(dest.dest || process.stdout.fd);
        return buildSafeSonicBoom(dest);
      } else {
        return buildSafeSonicBoom({ dest: normalizeDestFileDescriptor(dest), minLength: 0 });
      }
    };
    module2.exports.transport = require_transport();
    module2.exports.multistream = require_multistream();
    module2.exports.levels = mappings();
    module2.exports.stdSerializers = serializers;
    module2.exports.stdTimeFunctions = Object.assign({}, time);
    module2.exports.symbols = symbols;
    module2.exports.version = version2;
    module2.exports.default = pino;
    module2.exports.pino = pino;
  }
});

// node_modules/fastify/lib/logger-pino.js
var require_logger_pino = __commonJS({
  "node_modules/fastify/lib/logger-pino.js"(exports2, module2) {
    "use strict";
    var pino = require_pino();
    var { serializersSym } = pino.symbols;
    var {
      FST_ERR_LOG_INVALID_DESTINATION
    } = require_errors2();
    function createPinoLogger(opts) {
      if (opts.stream && opts.file) {
        throw new FST_ERR_LOG_INVALID_DESTINATION();
      } else if (opts.file) {
        opts.stream = pino.destination(opts.file);
        delete opts.file;
      }
      const prevLogger = opts.logger;
      const prevGenReqId = opts.genReqId;
      let logger = null;
      if (prevLogger) {
        opts.logger = void 0;
        opts.genReqId = void 0;
        if (prevLogger[serializersSym]) {
          opts.serializers = Object.assign({}, opts.serializers, prevLogger[serializersSym]);
        }
        logger = prevLogger.child({}, opts);
        opts.logger = prevLogger;
        opts.genReqId = prevGenReqId;
      } else {
        logger = pino(opts, opts.stream);
      }
      return logger;
    }
    var serializers = {
      req: function asReqValue(req) {
        return {
          method: req.method,
          url: req.url,
          version: req.headers && req.headers["accept-version"],
          host: req.host,
          remoteAddress: req.ip,
          remotePort: req.socket ? req.socket.remotePort : void 0
        };
      },
      err: pino.stdSerializers.err,
      res: function asResValue(reply) {
        return {
          statusCode: reply.statusCode
        };
      }
    };
    module2.exports = {
      serializers,
      createPinoLogger
    };
  }
});

// node_modules/fastify/lib/logger-factory.js
var require_logger_factory = __commonJS({
  "node_modules/fastify/lib/logger-factory.js"(exports2, module2) {
    "use strict";
    var {
      FST_ERR_LOG_LOGGER_AND_LOGGER_INSTANCE_PROVIDED,
      FST_ERR_LOG_INVALID_LOGGER_CONFIG,
      FST_ERR_LOG_INVALID_LOGGER_INSTANCE,
      FST_ERR_LOG_INVALID_LOGGER
    } = require_errors2();
    function createChildLogger(context, logger, req, reqId, loggerOpts) {
      const loggerBindings = {
        [context.requestIdLogLabel]: reqId
      };
      const child = context.childLoggerFactory.call(context.server, logger, loggerBindings, loggerOpts || {}, req);
      if (context.childLoggerFactory !== defaultChildLoggerFactory) {
        validateLogger(child, true);
      }
      return child;
    }
    function defaultChildLoggerFactory(logger, bindings, opts) {
      return logger.child(bindings, opts);
    }
    function validateLogger(logger, strict) {
      const methods = ["info", "error", "debug", "fatal", "warn", "trace", "child"];
      const missingMethods = logger ? methods.filter((method) => !logger[method] || typeof logger[method] !== "function") : methods;
      if (!missingMethods.length) {
        return true;
      } else if (missingMethods.length === methods.length && !strict) {
        return false;
      } else {
        throw FST_ERR_LOG_INVALID_LOGGER(missingMethods.join(","));
      }
    }
    function createLogger(options) {
      if (options.logger && options.loggerInstance) {
        throw new FST_ERR_LOG_LOGGER_AND_LOGGER_INSTANCE_PROVIDED();
      }
      if (!options.loggerInstance && !options.logger) {
        const nullLogger = require_abstract_logging();
        const logger2 = nullLogger;
        logger2.child = () => logger2;
        return { logger: logger2, hasLogger: false };
      }
      const { createPinoLogger, serializers } = require_logger_pino();
      if (validateLogger(options.loggerInstance)) {
        const logger2 = createPinoLogger({
          logger: options.loggerInstance,
          serializers: Object.assign({}, serializers, options.loggerInstance.serializers)
        });
        return { logger: logger2, hasLogger: true };
      }
      if (validateLogger(options.logger)) {
        throw FST_ERR_LOG_INVALID_LOGGER_CONFIG();
      }
      if (options.loggerInstance) {
        throw FST_ERR_LOG_INVALID_LOGGER_INSTANCE();
      }
      const localLoggerOptions = {};
      if (Object.prototype.toString.call(options.logger) === "[object Object]") {
        Reflect.ownKeys(options.logger).forEach((prop) => {
          Object.defineProperty(localLoggerOptions, prop, {
            value: options.logger[prop],
            writable: true,
            enumerable: true,
            configurable: true
          });
        });
      }
      localLoggerOptions.level = localLoggerOptions.level || "info";
      localLoggerOptions.serializers = Object.assign({}, serializers, localLoggerOptions.serializers);
      options.logger = localLoggerOptions;
      const logger = createPinoLogger(options.logger);
      return { logger, hasLogger: true };
    }
    function now() {
      const ts = process.hrtime();
      return ts[0] * 1e3 + ts[1] / 1e6;
    }
    module2.exports = {
      createChildLogger,
      defaultChildLoggerFactory,
      createLogger,
      validateLogger,
      now
    };
  }
});

// node_modules/rfdc/index.js
var require_rfdc = __commonJS({
  "node_modules/rfdc/index.js"(exports2, module2) {
    "use strict";
    module2.exports = rfdc;
    function copyBuffer(cur) {
      if (cur instanceof Buffer) {
        return Buffer.from(cur);
      }
      return new cur.constructor(cur.buffer.slice(), cur.byteOffset, cur.length);
    }
    function rfdc(opts) {
      opts = opts || {};
      if (opts.circles) return rfdcCircles(opts);
      const constructorHandlers = /* @__PURE__ */ new Map();
      constructorHandlers.set(Date, (o) => new Date(o));
      constructorHandlers.set(Map, (o, fn) => new Map(cloneArray(Array.from(o), fn)));
      constructorHandlers.set(Set, (o, fn) => new Set(cloneArray(Array.from(o), fn)));
      if (opts.constructorHandlers) {
        for (const handler2 of opts.constructorHandlers) {
          constructorHandlers.set(handler2[0], handler2[1]);
        }
      }
      let handler = null;
      return opts.proto ? cloneProto : clone;
      function cloneArray(a, fn) {
        const keys = Object.keys(a);
        const a2 = new Array(keys.length);
        for (let i = 0; i < keys.length; i++) {
          const k = keys[i];
          const cur = a[k];
          if (typeof cur !== "object" || cur === null) {
            a2[k] = cur;
          } else if (cur.constructor !== Object && (handler = constructorHandlers.get(cur.constructor))) {
            a2[k] = handler(cur, fn);
          } else if (ArrayBuffer.isView(cur)) {
            a2[k] = copyBuffer(cur);
          } else {
            a2[k] = fn(cur);
          }
        }
        return a2;
      }
      function clone(o) {
        if (typeof o !== "object" || o === null) return o;
        if (Array.isArray(o)) return cloneArray(o, clone);
        if (o.constructor !== Object && (handler = constructorHandlers.get(o.constructor))) {
          return handler(o, clone);
        }
        const o2 = {};
        for (const k in o) {
          if (Object.hasOwnProperty.call(o, k) === false) continue;
          const cur = o[k];
          if (typeof cur !== "object" || cur === null) {
            o2[k] = cur;
          } else if (cur.constructor !== Object && (handler = constructorHandlers.get(cur.constructor))) {
            o2[k] = handler(cur, clone);
          } else if (ArrayBuffer.isView(cur)) {
            o2[k] = copyBuffer(cur);
          } else {
            o2[k] = clone(cur);
          }
        }
        return o2;
      }
      function cloneProto(o) {
        if (typeof o !== "object" || o === null) return o;
        if (Array.isArray(o)) return cloneArray(o, cloneProto);
        if (o.constructor !== Object && (handler = constructorHandlers.get(o.constructor))) {
          return handler(o, cloneProto);
        }
        const o2 = {};
        for (const k in o) {
          const cur = o[k];
          if (typeof cur !== "object" || cur === null) {
            o2[k] = cur;
          } else if (cur.constructor !== Object && (handler = constructorHandlers.get(cur.constructor))) {
            o2[k] = handler(cur, cloneProto);
          } else if (ArrayBuffer.isView(cur)) {
            o2[k] = copyBuffer(cur);
          } else {
            o2[k] = cloneProto(cur);
          }
        }
        return o2;
      }
    }
    function rfdcCircles(opts) {
      const refs = [];
      const refsNew = [];
      const constructorHandlers = /* @__PURE__ */ new Map();
      constructorHandlers.set(Date, (o) => new Date(o));
      constructorHandlers.set(Map, (o, fn) => new Map(cloneArray(Array.from(o), fn)));
      constructorHandlers.set(Set, (o, fn) => new Set(cloneArray(Array.from(o), fn)));
      if (opts.constructorHandlers) {
        for (const handler2 of opts.constructorHandlers) {
          constructorHandlers.set(handler2[0], handler2[1]);
        }
      }
      let handler = null;
      return opts.proto ? cloneProto : clone;
      function cloneArray(a, fn) {
        const keys = Object.keys(a);
        const a2 = new Array(keys.length);
        for (let i = 0; i < keys.length; i++) {
          const k = keys[i];
          const cur = a[k];
          if (typeof cur !== "object" || cur === null) {
            a2[k] = cur;
          } else if (cur.constructor !== Object && (handler = constructorHandlers.get(cur.constructor))) {
            a2[k] = handler(cur, fn);
          } else if (ArrayBuffer.isView(cur)) {
            a2[k] = copyBuffer(cur);
          } else {
            const index = refs.indexOf(cur);
            if (index !== -1) {
              a2[k] = refsNew[index];
            } else {
              a2[k] = fn(cur);
            }
          }
        }
        return a2;
      }
      function clone(o) {
        if (typeof o !== "object" || o === null) return o;
        if (Array.isArray(o)) return cloneArray(o, clone);
        if (o.constructor !== Object && (handler = constructorHandlers.get(o.constructor))) {
          return handler(o, clone);
        }
        const o2 = {};
        refs.push(o);
        refsNew.push(o2);
        for (const k in o) {
          if (Object.hasOwnProperty.call(o, k) === false) continue;
          const cur = o[k];
          if (typeof cur !== "object" || cur === null) {
            o2[k] = cur;
          } else if (cur.constructor !== Object && (handler = constructorHandlers.get(cur.constructor))) {
            o2[k] = handler(cur, clone);
          } else if (ArrayBuffer.isView(cur)) {
            o2[k] = copyBuffer(cur);
          } else {
            const i = refs.indexOf(cur);
            if (i !== -1) {
              o2[k] = refsNew[i];
            } else {
              o2[k] = clone(cur);
            }
          }
        }
        refs.pop();
        refsNew.pop();
        return o2;
      }
      function cloneProto(o) {
        if (typeof o !== "object" || o === null) return o;
        if (Array.isArray(o)) return cloneArray(o, cloneProto);
        if (o.constructor !== Object && (handler = constructorHandlers.get(o.constructor))) {
          return handler(o, cloneProto);
        }
        const o2 = {};
        refs.push(o);
        refsNew.push(o2);
        for (const k in o) {
          const cur = o[k];
          if (typeof cur !== "object" || cur === null) {
            o2[k] = cur;
          } else if (cur.constructor !== Object && (handler = constructorHandlers.get(cur.constructor))) {
            o2[k] = handler(cur, cloneProto);
          } else if (ArrayBuffer.isView(cur)) {
            o2[k] = copyBuffer(cur);
          } else {
            const i = refs.indexOf(cur);
            if (i !== -1) {
              o2[k] = refsNew[i];
            } else {
              o2[k] = cloneProto(cur);
            }
          }
        }
        refs.pop();
        refsNew.pop();
        return o2;
      }
    }
  }
});

// node_modules/fastify/lib/schemas.js
var require_schemas = __commonJS({
  "node_modules/fastify/lib/schemas.js"(exports2, module2) {
    "use strict";
    var fastClone = require_rfdc()({ circles: false, proto: true });
    var { kSchemaVisited, kSchemaResponse } = require_symbols2();
    var kFluentSchema = Symbol.for("fluent-schema-object");
    var {
      FST_ERR_SCH_MISSING_ID,
      FST_ERR_SCH_ALREADY_PRESENT,
      FST_ERR_SCH_DUPLICATE,
      FST_ERR_SCH_CONTENT_MISSING_SCHEMA
    } = require_errors2();
    var SCHEMAS_SOURCE = ["params", "body", "querystring", "query", "headers"];
    function Schemas(initStore) {
      this.store = initStore || {};
    }
    Schemas.prototype.add = function(inputSchema) {
      const schema = fastClone(
        inputSchema.isFluentSchema || inputSchema.isFluentJSONSchema || inputSchema[kFluentSchema] ? inputSchema.valueOf() : inputSchema
      );
      const id2 = schema.$id;
      if (!id2) {
        throw new FST_ERR_SCH_MISSING_ID();
      }
      if (this.store[id2]) {
        throw new FST_ERR_SCH_ALREADY_PRESENT(id2);
      }
      this.store[id2] = schema;
    };
    Schemas.prototype.getSchemas = function() {
      return Object.assign({}, this.store);
    };
    Schemas.prototype.getSchema = function(schemaId) {
      return this.store[schemaId];
    };
    function isCustomSchemaPrototype(schema) {
      return typeof schema === "object" && Object.getPrototypeOf(schema) !== Object.prototype;
    }
    function normalizeSchema(routeSchemas, serverOptions) {
      if (routeSchemas[kSchemaVisited]) {
        return routeSchemas;
      }
      if (routeSchemas.query) {
        if (routeSchemas.querystring) {
          throw new FST_ERR_SCH_DUPLICATE("querystring");
        }
        routeSchemas.querystring = routeSchemas.query;
      }
      generateFluentSchema(routeSchemas);
      for (const key of SCHEMAS_SOURCE) {
        const schema = routeSchemas[key];
        if (schema && !isCustomSchemaPrototype(schema)) {
          if (key === "body" && schema.content) {
            const contentProperty = schema.content;
            const keys = Object.keys(contentProperty);
            for (let i = 0; i < keys.length; i++) {
              const contentType = keys[i];
              const contentSchema = contentProperty[contentType].schema;
              if (!contentSchema) {
                throw new FST_ERR_SCH_CONTENT_MISSING_SCHEMA(contentType);
              }
            }
            continue;
          }
        }
      }
      if (routeSchemas.response) {
        const httpCodes = Object.keys(routeSchemas.response);
        for (const code of httpCodes) {
          if (isCustomSchemaPrototype(routeSchemas.response[code])) {
            continue;
          }
          const contentProperty = routeSchemas.response[code].content;
          if (contentProperty) {
            const keys = Object.keys(contentProperty);
            for (let i = 0; i < keys.length; i++) {
              const mediaName = keys[i];
              if (!contentProperty[mediaName].schema) {
                throw new FST_ERR_SCH_CONTENT_MISSING_SCHEMA(mediaName);
              }
            }
          }
        }
      }
      routeSchemas[kSchemaVisited] = true;
      return routeSchemas;
    }
    function generateFluentSchema(schema) {
      for (const key of SCHEMAS_SOURCE) {
        if (schema[key] && (schema[key].isFluentSchema || schema[key][kFluentSchema])) {
          schema[key] = schema[key].valueOf();
        }
      }
      if (schema.response) {
        const httpCodes = Object.keys(schema.response);
        for (const code of httpCodes) {
          if (schema.response[code].isFluentSchema || schema.response[code][kFluentSchema]) {
            schema.response[code] = schema.response[code].valueOf();
          }
        }
      }
    }
    function getSchemaSerializer(context, statusCode, contentType) {
      const responseSchemaDef = context[kSchemaResponse];
      if (!responseSchemaDef) {
        return false;
      }
      if (responseSchemaDef[statusCode]) {
        if (responseSchemaDef[statusCode].constructor === Object && contentType) {
          const mediaName = contentType.split(";", 1)[0];
          if (responseSchemaDef[statusCode][mediaName]) {
            return responseSchemaDef[statusCode][mediaName];
          }
          if (responseSchemaDef[statusCode]["*/*"]) {
            return responseSchemaDef[statusCode]["*/*"];
          }
          return false;
        }
        return responseSchemaDef[statusCode];
      }
      const fallbackStatusCode = (statusCode + "")[0] + "xx";
      if (responseSchemaDef[fallbackStatusCode]) {
        if (responseSchemaDef[fallbackStatusCode].constructor === Object && contentType) {
          const mediaName = contentType.split(";", 1)[0];
          if (responseSchemaDef[fallbackStatusCode][mediaName]) {
            return responseSchemaDef[fallbackStatusCode][mediaName];
          }
          if (responseSchemaDef[fallbackStatusCode]["*/*"]) {
            return responseSchemaDef[fallbackStatusCode]["*/*"];
          }
          return false;
        }
        return responseSchemaDef[fallbackStatusCode];
      }
      if (responseSchemaDef.default) {
        if (responseSchemaDef.default.constructor === Object && contentType) {
          const mediaName = contentType.split(";", 1)[0];
          if (responseSchemaDef.default[mediaName]) {
            return responseSchemaDef.default[mediaName];
          }
          if (responseSchemaDef.default["*/*"]) {
            return responseSchemaDef.default["*/*"];
          }
          return false;
        }
        return responseSchemaDef.default;
      }
      return false;
    }
    module2.exports = {
      buildSchemas(initStore) {
        return new Schemas(initStore);
      },
      getSchemaSerializer,
      normalizeSchema
    };
  }
});

// node_modules/fast-json-stringify/lib/serializer.js
var require_serializer = __commonJS({
  "node_modules/fast-json-stringify/lib/serializer.js"(exports2, module2) {
    "use strict";
    var STR_ESCAPE = /[\u0000-\u001f\u0022\u005c\ud800-\udfff]/;
    module2.exports = class Serializer {
      constructor(options) {
        switch (options && options.rounding) {
          case "floor":
            this.parseInteger = Math.floor;
            break;
          case "ceil":
            this.parseInteger = Math.ceil;
            break;
          case "round":
            this.parseInteger = Math.round;
            break;
          case "trunc":
          default:
            this.parseInteger = Math.trunc;
            break;
        }
        this._options = options;
      }
      asInteger(i) {
        if (Number.isInteger(i)) {
          return "" + i;
        } else if (typeof i === "bigint") {
          return i.toString();
        }
        const integer = this.parseInteger(i);
        if (integer === Infinity || integer === -Infinity || integer !== integer) {
          throw new Error(`The value "${i}" cannot be converted to an integer.`);
        }
        return "" + integer;
      }
      asNumber(i) {
        const num = Number(i);
        if (num !== num) {
          throw new Error(`The value "${i}" cannot be converted to a number.`);
        } else if (num === Infinity || num === -Infinity) {
          return "null";
        } else {
          return "" + num;
        }
      }
      asBoolean(bool) {
        return bool && "true" || "false";
      }
      asDateTime(date) {
        if (date === null) return '""';
        if (date instanceof Date) {
          return '"' + date.toISOString() + '"';
        }
        if (typeof date === "string") {
          return '"' + date + '"';
        }
        throw new Error(`The value "${date}" cannot be converted to a date-time.`);
      }
      asDate(date) {
        if (date === null) return '""';
        if (date instanceof Date) {
          return '"' + new Date(date.getTime() - date.getTimezoneOffset() * 6e4).toISOString().slice(0, 10) + '"';
        }
        if (typeof date === "string") {
          return '"' + date + '"';
        }
        throw new Error(`The value "${date}" cannot be converted to a date.`);
      }
      asTime(date) {
        if (date === null) return '""';
        if (date instanceof Date) {
          return '"' + new Date(date.getTime() - date.getTimezoneOffset() * 6e4).toISOString().slice(11, 19) + '"';
        }
        if (typeof date === "string") {
          return '"' + date + '"';
        }
        throw new Error(`The value "${date}" cannot be converted to a time.`);
      }
      asString(str) {
        const len = str.length;
        if (len < 42) {
          let result = "";
          let last = -1;
          let point = 255;
          for (let i = 0; i < len; i++) {
            point = str.charCodeAt(i);
            if (point === 34 || // '"'
            point === 92) {
              last === -1 && (last = 0);
              result += str.slice(last, i) + "\\";
              last = i;
            } else if (point < 32 || point >= 55296 && point <= 57343) {
              return JSON.stringify(str);
            }
          }
          return last === -1 && '"' + str + '"' || '"' + result + str.slice(last) + '"';
        } else if (len < 5e3 && STR_ESCAPE.test(str) === false) {
          return '"' + str + '"';
        } else {
          return JSON.stringify(str);
        }
      }
      asUnsafeString(str) {
        return '"' + str + '"';
      }
      getState() {
        return this._options;
      }
      static restoreFromState(state) {
        return new Serializer(state);
      }
    };
  }
});

// node_modules/fastify/lib/error-serializer.js
var require_error_serializer = __commonJS({
  "node_modules/fastify/lib/error-serializer.js"(exports2, module2) {
    "use strict";
    var Serializer = require_serializer();
    var serializerState = { "mode": "standalone" };
    var serializer = Serializer.restoreFromState(serializerState);
    var validator = null;
    module2.exports = function anonymous(validator2, serializer2) {
      const JSON_STR_BEGIN_OBJECT = "{";
      const JSON_STR_END_OBJECT = "}";
      const JSON_STR_BEGIN_ARRAY = "[";
      const JSON_STR_END_ARRAY = "]";
      const JSON_STR_COMMA = ",";
      const JSON_STR_COLONS = ":";
      const JSON_STR_QUOTE = '"';
      const JSON_STR_EMPTY_OBJECT = JSON_STR_BEGIN_OBJECT + JSON_STR_END_OBJECT;
      const JSON_STR_EMPTY_ARRAY = JSON_STR_BEGIN_ARRAY + JSON_STR_END_ARRAY;
      const JSON_STR_EMPTY_STRING = JSON_STR_QUOTE + JSON_STR_QUOTE;
      const JSON_STR_NULL = "null";
      function anonymous0(input) {
        const obj = input && typeof input.toJSON === "function" ? input.toJSON() : input;
        if (obj === null) return JSON_STR_EMPTY_OBJECT;
        let value;
        let json = JSON_STR_BEGIN_OBJECT;
        let addComma = false;
        value = obj["statusCode"];
        if (value !== void 0) {
          !addComma && (addComma = true) || (json += JSON_STR_COMMA);
          json += '"statusCode":';
          json += serializer2.asNumber(value);
        }
        value = obj["code"];
        if (value !== void 0) {
          !addComma && (addComma = true) || (json += JSON_STR_COMMA);
          json += '"code":';
          if (typeof value !== "string") {
            if (value === null) {
              json += JSON_STR_EMPTY_STRING;
            } else if (value instanceof Date) {
              json += JSON_STR_QUOTE + value.toISOString() + JSON_STR_QUOTE;
            } else if (value instanceof RegExp) {
              json += serializer2.asString(value.source);
            } else {
              json += serializer2.asString(value.toString());
            }
          } else {
            json += serializer2.asString(value);
          }
        }
        value = obj["error"];
        if (value !== void 0) {
          !addComma && (addComma = true) || (json += JSON_STR_COMMA);
          json += '"error":';
          if (typeof value !== "string") {
            if (value === null) {
              json += JSON_STR_EMPTY_STRING;
            } else if (value instanceof Date) {
              json += JSON_STR_QUOTE + value.toISOString() + JSON_STR_QUOTE;
            } else if (value instanceof RegExp) {
              json += serializer2.asString(value.source);
            } else {
              json += serializer2.asString(value.toString());
            }
          } else {
            json += serializer2.asString(value);
          }
        }
        value = obj["message"];
        if (value !== void 0) {
          !addComma && (addComma = true) || (json += JSON_STR_COMMA);
          json += '"message":';
          if (typeof value !== "string") {
            if (value === null) {
              json += JSON_STR_EMPTY_STRING;
            } else if (value instanceof Date) {
              json += JSON_STR_QUOTE + value.toISOString() + JSON_STR_QUOTE;
            } else if (value instanceof RegExp) {
              json += serializer2.asString(value.source);
            } else {
              json += serializer2.asString(value.toString());
            }
          } else {
            json += serializer2.asString(value);
          }
        }
        return json + JSON_STR_END_OBJECT;
      }
      const main2 = anonymous0;
      return main2;
    }(validator, serializer);
  }
});

// node_modules/fastify/lib/error-handler.js
var require_error_handler = __commonJS({
  "node_modules/fastify/lib/error-handler.js"(exports2, module2) {
    "use strict";
    var statusCodes = require("node:http").STATUS_CODES;
    var wrapThenable = require_wrapThenable();
    var {
      kReplyHeaders,
      kReplyNextErrorHandler,
      kReplyIsRunningOnErrorHook,
      kReplyHasStatusCode,
      kRouteContext,
      kDisableRequestLogging
    } = require_symbols2();
    var {
      FST_ERR_REP_INVALID_PAYLOAD_TYPE,
      FST_ERR_FAILED_ERROR_SERIALIZATION
    } = require_errors2();
    var { getSchemaSerializer } = require_schemas();
    var serializeError = require_error_serializer();
    var rootErrorHandler = {
      func: defaultErrorHandler,
      toJSON() {
        return this.func.name.toString() + "()";
      }
    };
    function handleError(reply, error, cb) {
      reply[kReplyIsRunningOnErrorHook] = false;
      const context = reply[kRouteContext];
      if (reply[kReplyNextErrorHandler] === false) {
        fallbackErrorHandler(error, reply, function(reply2, payload) {
          try {
            reply2.raw.writeHead(reply2.raw.statusCode, reply2[kReplyHeaders]);
          } catch (error2) {
            if (!reply2.log[kDisableRequestLogging]) {
              reply2.log.warn(
                { req: reply2.request, res: reply2, err: error2 },
                error2 && error2.message
              );
            }
            reply2.raw.writeHead(reply2.raw.statusCode);
          }
          reply2.raw.end(payload);
        });
        return;
      }
      const errorHandler = reply[kReplyNextErrorHandler] || context.errorHandler;
      reply[kReplyNextErrorHandler] = Object.getPrototypeOf(errorHandler);
      delete reply[kReplyHeaders]["content-type"];
      delete reply[kReplyHeaders]["content-length"];
      const func = errorHandler.func;
      if (!func) {
        reply[kReplyNextErrorHandler] = false;
        fallbackErrorHandler(error, reply, cb);
        return;
      }
      try {
        const result = func(error, reply.request, reply);
        if (result !== void 0) {
          if (result !== null && typeof result.then === "function") {
            wrapThenable(result, reply);
          } else {
            reply.send(result);
          }
        }
      } catch (err) {
        reply.send(err);
      }
    }
    function defaultErrorHandler(error, request, reply) {
      setErrorHeaders(error, reply);
      if (!reply[kReplyHasStatusCode] || reply.statusCode === 200) {
        const statusCode = error.statusCode || error.status;
        reply.code(statusCode >= 400 ? statusCode : 500);
      }
      if (reply.statusCode < 500) {
        if (!reply.log[kDisableRequestLogging]) {
          reply.log.info(
            { res: reply, err: error },
            error && error.message
          );
        }
      } else {
        if (!reply.log[kDisableRequestLogging]) {
          reply.log.error(
            { req: request, res: reply, err: error },
            error && error.message
          );
        }
      }
      reply.send(error);
    }
    function fallbackErrorHandler(error, reply, cb) {
      const res = reply.raw;
      const statusCode = reply.statusCode;
      reply[kReplyHeaders]["content-type"] = reply[kReplyHeaders]["content-type"] ?? "application/json; charset=utf-8";
      let payload;
      try {
        const serializerFn = getSchemaSerializer(reply[kRouteContext], statusCode, reply[kReplyHeaders]["content-type"]);
        if (serializerFn === false) {
          payload = serializeError({
            error: statusCodes[statusCode + ""],
            code: error.code,
            message: error.message,
            statusCode
          });
        } else {
          payload = serializerFn(Object.create(error, {
            error: { value: statusCodes[statusCode + ""] },
            message: { value: error.message },
            statusCode: { value: statusCode }
          }));
        }
      } catch (err) {
        if (!reply.log[kDisableRequestLogging]) {
          reply.log.error({ err, statusCode: res.statusCode }, "The serializer for the given status code failed");
        }
        reply.code(500);
        payload = serializeError(new FST_ERR_FAILED_ERROR_SERIALIZATION(err.message, error.message));
      }
      if (typeof payload !== "string" && !Buffer.isBuffer(payload)) {
        payload = serializeError(new FST_ERR_REP_INVALID_PAYLOAD_TYPE(typeof payload));
      }
      reply[kReplyHeaders]["content-length"] = "" + Buffer.byteLength(payload);
      cb(reply, payload);
    }
    function buildErrorHandler(parent = rootErrorHandler, func) {
      if (!func) {
        return parent;
      }
      const errorHandler = Object.create(parent);
      errorHandler.func = func;
      return errorHandler;
    }
    function setErrorHeaders(error, reply) {
      const res = reply.raw;
      let statusCode = res.statusCode;
      statusCode = statusCode >= 400 ? statusCode : 500;
      if (error != null) {
        if (error.headers !== void 0) {
          reply.headers(error.headers);
        }
        if (error.status >= 400) {
          statusCode = error.status;
        } else if (error.statusCode >= 400) {
          statusCode = error.statusCode;
        }
      }
      res.statusCode = statusCode;
    }
    module2.exports = {
      buildErrorHandler,
      handleError
    };
  }
});

// node_modules/fastify/lib/decorate.js
var require_decorate = __commonJS({
  "node_modules/fastify/lib/decorate.js"(exports2, module2) {
    "use strict";
    var {
      kReply,
      kRequest,
      kState,
      kHasBeenDecorated
    } = require_symbols2();
    var {
      FST_ERR_DEC_ALREADY_PRESENT,
      FST_ERR_DEC_MISSING_DEPENDENCY,
      FST_ERR_DEC_AFTER_START,
      FST_ERR_DEC_REFERENCE_TYPE,
      FST_ERR_DEC_DEPENDENCY_INVALID_TYPE,
      FST_ERR_DEC_UNDECLARED
    } = require_errors2();
    function decorate(instance, name, fn, dependencies) {
      if (Object.hasOwn(instance, name)) {
        throw new FST_ERR_DEC_ALREADY_PRESENT(name);
      }
      checkDependencies(instance, name, dependencies);
      if (fn && (typeof fn.getter === "function" || typeof fn.setter === "function")) {
        Object.defineProperty(instance, name, {
          get: fn.getter,
          set: fn.setter
        });
      } else {
        instance[name] = fn;
      }
    }
    function getInstanceDecorator(name) {
      if (!checkExistence(this, name)) {
        throw new FST_ERR_DEC_UNDECLARED(name, "instance");
      }
      if (typeof this[name] === "function") {
        return this[name].bind(this);
      }
      return this[name];
    }
    function decorateConstructor(konstructor, name, fn, dependencies) {
      const instance = konstructor.prototype;
      if (Object.hasOwn(instance, name) || hasKey(konstructor, name)) {
        throw new FST_ERR_DEC_ALREADY_PRESENT(name);
      }
      konstructor[kHasBeenDecorated] = true;
      checkDependencies(konstructor, name, dependencies);
      if (fn && (typeof fn.getter === "function" || typeof fn.setter === "function")) {
        Object.defineProperty(instance, name, {
          get: fn.getter,
          set: fn.setter
        });
      } else if (typeof fn === "function") {
        instance[name] = fn;
      } else {
        konstructor.props.push({ key: name, value: fn });
      }
    }
    function checkReferenceType(name, fn) {
      if (typeof fn === "object" && fn && !(typeof fn.getter === "function" || typeof fn.setter === "function")) {
        throw new FST_ERR_DEC_REFERENCE_TYPE(name, typeof fn);
      }
    }
    function decorateFastify(name, fn, dependencies) {
      assertNotStarted(this, name);
      decorate(this, name, fn, dependencies);
      return this;
    }
    function checkExistence(instance, name) {
      if (name) {
        return name in instance || instance.prototype && name in instance.prototype || hasKey(instance, name);
      }
      return instance in this;
    }
    function hasKey(fn, name) {
      if (fn.props) {
        return fn.props.find(({ key }) => key === name);
      }
      return false;
    }
    function checkRequestExistence(name) {
      if (name && hasKey(this[kRequest], name)) return true;
      return checkExistence(this[kRequest].prototype, name);
    }
    function checkReplyExistence(name) {
      if (name && hasKey(this[kReply], name)) return true;
      return checkExistence(this[kReply].prototype, name);
    }
    function checkDependencies(instance, name, deps) {
      if (deps === void 0 || deps === null) {
        return;
      }
      if (!Array.isArray(deps)) {
        throw new FST_ERR_DEC_DEPENDENCY_INVALID_TYPE(name);
      }
      for (let i = 0; i !== deps.length; ++i) {
        if (!checkExistence(instance, deps[i])) {
          throw new FST_ERR_DEC_MISSING_DEPENDENCY(deps[i]);
        }
      }
    }
    function decorateReply(name, fn, dependencies) {
      assertNotStarted(this, name);
      checkReferenceType(name, fn);
      decorateConstructor(this[kReply], name, fn, dependencies);
      return this;
    }
    function decorateRequest(name, fn, dependencies) {
      assertNotStarted(this, name);
      checkReferenceType(name, fn);
      decorateConstructor(this[kRequest], name, fn, dependencies);
      return this;
    }
    function assertNotStarted(instance, name) {
      if (instance[kState].started) {
        throw new FST_ERR_DEC_AFTER_START(name);
      }
    }
    module2.exports = {
      add: decorateFastify,
      exist: checkExistence,
      existRequest: checkRequestExistence,
      existReply: checkReplyExistence,
      dependencies: checkDependencies,
      decorateReply,
      decorateRequest,
      getInstanceDecorator,
      hasKey
    };
  }
});

// node_modules/fastify/lib/reply.js
var require_reply = __commonJS({
  "node_modules/fastify/lib/reply.js"(exports2, module2) {
    "use strict";
    var eos = require("node:stream").finished;
    var Readable = require("node:stream").Readable;
    var {
      kFourOhFourContext,
      kReplyErrorHandlerCalled,
      kReplyHijacked,
      kReplyStartTime,
      kReplyEndTime,
      kReplySerializer,
      kReplySerializerDefault,
      kReplyIsError,
      kReplyHeaders,
      kReplyTrailers,
      kReplyHasStatusCode,
      kReplyIsRunningOnErrorHook,
      kReplyNextErrorHandler,
      kDisableRequestLogging,
      kSchemaResponse,
      kReplyCacheSerializeFns,
      kSchemaController,
      kOptions,
      kRouteContext
    } = require_symbols2();
    var {
      onSendHookRunner,
      onResponseHookRunner,
      preHandlerHookRunner,
      preSerializationHookRunner
    } = require_hooks();
    var internals = require_handleRequest()[Symbol.for("internals")];
    var loggerUtils = require_logger_factory();
    var now = loggerUtils.now;
    var { handleError } = require_error_handler();
    var { getSchemaSerializer } = require_schemas();
    var CONTENT_TYPE = {
      JSON: "application/json; charset=utf-8",
      PLAIN: "text/plain; charset=utf-8",
      OCTET: "application/octet-stream"
    };
    var {
      FST_ERR_REP_INVALID_PAYLOAD_TYPE,
      FST_ERR_REP_RESPONSE_BODY_CONSUMED,
      FST_ERR_REP_READABLE_STREAM_LOCKED,
      FST_ERR_REP_ALREADY_SENT,
      FST_ERR_SEND_INSIDE_ONERR,
      FST_ERR_BAD_STATUS_CODE,
      FST_ERR_BAD_TRAILER_NAME,
      FST_ERR_BAD_TRAILER_VALUE,
      FST_ERR_MISSING_SERIALIZATION_FN,
      FST_ERR_MISSING_CONTENTTYPE_SERIALIZATION_FN,
      FST_ERR_DEC_UNDECLARED
    } = require_errors2();
    var decorators = require_decorate();
    var toString = Object.prototype.toString;
    function Reply(res, request, log2) {
      this.raw = res;
      this[kReplySerializer] = null;
      this[kReplyErrorHandlerCalled] = false;
      this[kReplyIsError] = false;
      this[kReplyIsRunningOnErrorHook] = false;
      this.request = request;
      this[kReplyHeaders] = {};
      this[kReplyTrailers] = null;
      this[kReplyHasStatusCode] = false;
      this[kReplyStartTime] = void 0;
      this.log = log2;
    }
    Reply.props = [];
    Object.defineProperties(Reply.prototype, {
      [kRouteContext]: {
        get() {
          return this.request[kRouteContext];
        }
      },
      elapsedTime: {
        get() {
          if (this[kReplyStartTime] === void 0) {
            return 0;
          }
          return (this[kReplyEndTime] || now()) - this[kReplyStartTime];
        }
      },
      server: {
        get() {
          return this.request[kRouteContext].server;
        }
      },
      sent: {
        enumerable: true,
        get() {
          return (this[kReplyHijacked] || this.raw.writableEnded) === true;
        }
      },
      statusCode: {
        get() {
          return this.raw.statusCode;
        },
        set(value) {
          this.code(value);
        }
      },
      routeOptions: {
        get() {
          return this.request.routeOptions;
        }
      }
    });
    Reply.prototype.writeEarlyHints = function(hints, callback) {
      this.raw.writeEarlyHints(hints, callback);
      return this;
    };
    Reply.prototype.hijack = function() {
      this[kReplyHijacked] = true;
      return this;
    };
    Reply.prototype.send = function(payload) {
      if (this[kReplyIsRunningOnErrorHook] === true) {
        throw new FST_ERR_SEND_INSIDE_ONERR();
      }
      if (this.sent) {
        this.log.warn({ err: new FST_ERR_REP_ALREADY_SENT(this.request.url, this.request.method) });
        return this;
      }
      if (payload instanceof Error || this[kReplyIsError] === true) {
        this[kReplyIsError] = false;
        onErrorHook(this, payload, onSendHook);
        return this;
      }
      if (payload === void 0) {
        onSendHook(this, payload);
        return this;
      }
      const contentType = this.getHeader("content-type");
      const hasContentType = contentType !== void 0;
      if (payload !== null) {
        if (
          // node:stream
          typeof payload.pipe === "function" || // node:stream/web
          typeof payload.getReader === "function" || // Response
          toString.call(payload) === "[object Response]"
        ) {
          onSendHook(this, payload);
          return this;
        }
        if (payload?.buffer instanceof ArrayBuffer) {
          if (hasContentType === false) {
            this[kReplyHeaders]["content-type"] = CONTENT_TYPE.OCTET;
          }
          const payloadToSend = Buffer.isBuffer(payload) ? payload : Buffer.from(payload.buffer, payload.byteOffset, payload.byteLength);
          onSendHook(this, payloadToSend);
          return this;
        }
        if (hasContentType === false && typeof payload === "string") {
          this[kReplyHeaders]["content-type"] = CONTENT_TYPE.PLAIN;
          onSendHook(this, payload);
          return this;
        }
      }
      if (this[kReplySerializer] !== null) {
        if (typeof payload !== "string") {
          preSerializationHook(this, payload);
          return this;
        } else {
          payload = this[kReplySerializer](payload);
        }
      } else if (hasContentType === false || contentType.indexOf("json") > -1) {
        if (hasContentType === false) {
          this[kReplyHeaders]["content-type"] = CONTENT_TYPE.JSON;
        } else {
          if (contentType.indexOf("charset") === -1) {
            const customContentType = contentType.trim();
            if (customContentType.endsWith(";")) {
              this[kReplyHeaders]["content-type"] = `${customContentType} charset=utf-8`;
            } else {
              this[kReplyHeaders]["content-type"] = `${customContentType}; charset=utf-8`;
            }
          }
        }
        if (typeof payload !== "string") {
          preSerializationHook(this, payload);
          return this;
        }
      }
      onSendHook(this, payload);
      return this;
    };
    Reply.prototype.getHeader = function(key) {
      key = key.toLowerCase();
      const value = this[kReplyHeaders][key];
      return value !== void 0 ? value : this.raw.getHeader(key);
    };
    Reply.prototype.getHeaders = function() {
      return {
        ...this.raw.getHeaders(),
        ...this[kReplyHeaders]
      };
    };
    Reply.prototype.hasHeader = function(key) {
      key = key.toLowerCase();
      return this[kReplyHeaders][key] !== void 0 || this.raw.hasHeader(key);
    };
    Reply.prototype.removeHeader = function(key) {
      delete this[kReplyHeaders][key.toLowerCase()];
      return this;
    };
    Reply.prototype.header = function(key, value = "") {
      key = key.toLowerCase();
      if (this[kReplyHeaders][key] && key === "set-cookie") {
        if (typeof this[kReplyHeaders][key] === "string") {
          this[kReplyHeaders][key] = [this[kReplyHeaders][key]];
        }
        if (Array.isArray(value)) {
          Array.prototype.push.apply(this[kReplyHeaders][key], value);
        } else {
          this[kReplyHeaders][key].push(value);
        }
      } else {
        this[kReplyHeaders][key] = value;
      }
      return this;
    };
    Reply.prototype.headers = function(headers) {
      const keys = Object.keys(headers);
      for (let i = 0; i !== keys.length; ++i) {
        const key = keys[i];
        this.header(key, headers[key]);
      }
      return this;
    };
    var INVALID_TRAILERS = /* @__PURE__ */ new Set([
      "transfer-encoding",
      "content-length",
      "host",
      "cache-control",
      "max-forwards",
      "te",
      "authorization",
      "set-cookie",
      "content-encoding",
      "content-type",
      "content-range",
      "trailer"
    ]);
    Reply.prototype.trailer = function(key, fn) {
      key = key.toLowerCase();
      if (INVALID_TRAILERS.has(key)) {
        throw new FST_ERR_BAD_TRAILER_NAME(key);
      }
      if (typeof fn !== "function") {
        throw new FST_ERR_BAD_TRAILER_VALUE(key, typeof fn);
      }
      if (this[kReplyTrailers] === null) this[kReplyTrailers] = {};
      this[kReplyTrailers][key] = fn;
      return this;
    };
    Reply.prototype.hasTrailer = function(key) {
      return this[kReplyTrailers]?.[key.toLowerCase()] !== void 0;
    };
    Reply.prototype.removeTrailer = function(key) {
      if (this[kReplyTrailers] === null) return this;
      this[kReplyTrailers][key.toLowerCase()] = void 0;
      return this;
    };
    Reply.prototype.code = function(code) {
      const statusCode = +code;
      if (!(statusCode >= 100 && statusCode <= 599)) {
        throw new FST_ERR_BAD_STATUS_CODE(code || String(code));
      }
      this.raw.statusCode = statusCode;
      this[kReplyHasStatusCode] = true;
      return this;
    };
    Reply.prototype.status = Reply.prototype.code;
    Reply.prototype.getSerializationFunction = function(schemaOrStatus, contentType) {
      let serialize2;
      if (typeof schemaOrStatus === "string" || typeof schemaOrStatus === "number") {
        if (typeof contentType === "string") {
          serialize2 = this[kRouteContext][kSchemaResponse]?.[schemaOrStatus]?.[contentType];
        } else {
          serialize2 = this[kRouteContext][kSchemaResponse]?.[schemaOrStatus];
        }
      } else if (typeof schemaOrStatus === "object") {
        serialize2 = this[kRouteContext][kReplyCacheSerializeFns]?.get(schemaOrStatus);
      }
      return serialize2;
    };
    Reply.prototype.compileSerializationSchema = function(schema, httpStatus = null, contentType = null) {
      const { request } = this;
      const { method, url } = request;
      if (this[kRouteContext][kReplyCacheSerializeFns]?.has(schema)) {
        return this[kRouteContext][kReplyCacheSerializeFns].get(schema);
      }
      const serializerCompiler = this[kRouteContext].serializerCompiler || this.server[kSchemaController].serializerCompiler || // We compile the schemas if no custom serializerCompiler is provided
      // nor set
      (this.server[kSchemaController].setupSerializer(this.server[kOptions]) || this.server[kSchemaController].serializerCompiler);
      const serializeFn = serializerCompiler({
        schema,
        method,
        url,
        httpStatus,
        contentType
      });
      if (this[kRouteContext][kReplyCacheSerializeFns] == null) {
        this[kRouteContext][kReplyCacheSerializeFns] = /* @__PURE__ */ new WeakMap();
      }
      this[kRouteContext][kReplyCacheSerializeFns].set(schema, serializeFn);
      return serializeFn;
    };
    Reply.prototype.serializeInput = function(input, schema, httpStatus, contentType) {
      const possibleContentType = httpStatus;
      let serialize2;
      httpStatus = typeof schema === "string" || typeof schema === "number" ? schema : httpStatus;
      contentType = httpStatus && possibleContentType !== httpStatus ? possibleContentType : contentType;
      if (httpStatus != null) {
        if (contentType != null) {
          serialize2 = this[kRouteContext][kSchemaResponse]?.[httpStatus]?.[contentType];
        } else {
          serialize2 = this[kRouteContext][kSchemaResponse]?.[httpStatus];
        }
        if (serialize2 == null) {
          if (contentType) throw new FST_ERR_MISSING_CONTENTTYPE_SERIALIZATION_FN(httpStatus, contentType);
          throw new FST_ERR_MISSING_SERIALIZATION_FN(httpStatus);
        }
      } else {
        if (this[kRouteContext][kReplyCacheSerializeFns]?.has(schema)) {
          serialize2 = this[kRouteContext][kReplyCacheSerializeFns].get(schema);
        } else {
          serialize2 = this.compileSerializationSchema(schema, httpStatus, contentType);
        }
      }
      return serialize2(input);
    };
    Reply.prototype.serialize = function(payload) {
      if (this[kReplySerializer] !== null) {
        return this[kReplySerializer](payload);
      } else {
        if (this[kRouteContext] && this[kRouteContext][kReplySerializerDefault]) {
          return this[kRouteContext][kReplySerializerDefault](payload, this.raw.statusCode);
        } else {
          return serialize(this[kRouteContext], payload, this.raw.statusCode);
        }
      }
    };
    Reply.prototype.serializer = function(fn) {
      this[kReplySerializer] = fn;
      return this;
    };
    Reply.prototype.type = function(type) {
      this[kReplyHeaders]["content-type"] = type;
      return this;
    };
    Reply.prototype.redirect = function(url, code) {
      if (!code) {
        code = this[kReplyHasStatusCode] ? this.raw.statusCode : 302;
      }
      return this.header("location", url).code(code).send();
    };
    Reply.prototype.callNotFound = function() {
      notFound(this);
      return this;
    };
    Reply.prototype.then = function(fulfilled, rejected) {
      if (this.sent) {
        fulfilled();
        return;
      }
      eos(this.raw, (err) => {
        if (err && err.code !== "ERR_STREAM_PREMATURE_CLOSE") {
          if (rejected) {
            rejected(err);
          } else {
            this.log && this.log.warn("unhandled rejection on reply.then");
          }
        } else {
          fulfilled();
        }
      });
    };
    Reply.prototype.getDecorator = function(name) {
      if (!decorators.hasKey(this, name) && !decorators.exist(this, name)) {
        throw new FST_ERR_DEC_UNDECLARED(name, "reply");
      }
      const decorator = this[name];
      if (typeof decorator === "function") {
        return decorator.bind(this);
      }
      return decorator;
    };
    function preSerializationHook(reply, payload) {
      if (reply[kRouteContext].preSerialization !== null) {
        preSerializationHookRunner(
          reply[kRouteContext].preSerialization,
          reply.request,
          reply,
          payload,
          preSerializationHookEnd
        );
      } else {
        preSerializationHookEnd(null, void 0, reply, payload);
      }
    }
    function preSerializationHookEnd(err, _request, reply, payload) {
      if (err != null) {
        onErrorHook(reply, err);
        return;
      }
      try {
        if (reply[kReplySerializer] !== null) {
          payload = reply[kReplySerializer](payload);
        } else if (reply[kRouteContext] && reply[kRouteContext][kReplySerializerDefault]) {
          payload = reply[kRouteContext][kReplySerializerDefault](payload, reply.raw.statusCode);
        } else {
          payload = serialize(reply[kRouteContext], payload, reply.raw.statusCode, reply[kReplyHeaders]["content-type"]);
        }
      } catch (e) {
        wrapSerializationError(e, reply);
        onErrorHook(reply, e);
        return;
      }
      onSendHook(reply, payload);
    }
    function wrapSerializationError(error, reply) {
      error.serialization = reply[kRouteContext].config;
    }
    function onSendHook(reply, payload) {
      if (reply[kRouteContext].onSend !== null) {
        onSendHookRunner(
          reply[kRouteContext].onSend,
          reply.request,
          reply,
          payload,
          wrapOnSendEnd
        );
      } else {
        onSendEnd(reply, payload);
      }
    }
    function wrapOnSendEnd(err, request, reply, payload) {
      if (err != null) {
        onErrorHook(reply, err);
      } else {
        onSendEnd(reply, payload);
      }
    }
    function safeWriteHead(reply, statusCode) {
      const res = reply.raw;
      try {
        res.writeHead(statusCode, reply[kReplyHeaders]);
      } catch (err) {
        if (err.code === "ERR_HTTP_HEADERS_SENT") {
          reply.log.warn(`Reply was already sent, did you forget to "return reply" in the "${reply.request.raw.url}" (${reply.request.raw.method}) route?`);
        }
        throw err;
      }
    }
    function onSendEnd(reply, payload) {
      const res = reply.raw;
      const req = reply.request;
      if (reply[kReplyTrailers] !== null) {
        const trailerHeaders = Object.keys(reply[kReplyTrailers]);
        let header = "";
        for (const trailerName of trailerHeaders) {
          if (typeof reply[kReplyTrailers][trailerName] !== "function") continue;
          header += " ";
          header += trailerName;
        }
        reply.header("Transfer-Encoding", "chunked");
        reply.header("Trailer", header.trim());
      }
      if (toString.call(payload) === "[object Response]") {
        if (typeof payload.status === "number") {
          reply.code(payload.status);
        }
        if (typeof payload.headers === "object" && typeof payload.headers.forEach === "function") {
          for (const [headerName, headerValue] of payload.headers) {
            reply.header(headerName, headerValue);
          }
        }
        if (payload.body !== null) {
          if (payload.bodyUsed) {
            throw new FST_ERR_REP_RESPONSE_BODY_CONSUMED();
          }
        }
        payload = payload.body;
      }
      const statusCode = res.statusCode;
      if (payload === void 0 || payload === null) {
        if (statusCode >= 200 && statusCode !== 204 && statusCode !== 304 && req.method !== "HEAD" && reply[kReplyTrailers] === null) {
          reply[kReplyHeaders]["content-length"] = "0";
        }
        safeWriteHead(reply, statusCode);
        sendTrailer(payload, res, reply);
        return;
      }
      if (statusCode >= 100 && statusCode < 200 || statusCode === 204) {
        reply.removeHeader("content-type");
        reply.removeHeader("content-length");
        safeWriteHead(reply, statusCode);
        sendTrailer(void 0, res, reply);
        if (typeof payload.resume === "function") {
          payload.on("error", noop);
          payload.resume();
        }
        return;
      }
      if (typeof payload.pipe === "function") {
        sendStream(payload, res, reply);
        return;
      }
      if (typeof payload.getReader === "function") {
        sendWebStream(payload, res, reply);
        return;
      }
      if (typeof payload !== "string" && !Buffer.isBuffer(payload)) {
        throw new FST_ERR_REP_INVALID_PAYLOAD_TYPE(typeof payload);
      }
      if (reply[kReplyTrailers] === null) {
        const contentLength = reply[kReplyHeaders]["content-length"];
        if (!contentLength || req.raw.method !== "HEAD" && Number(contentLength) !== Buffer.byteLength(payload)) {
          reply[kReplyHeaders]["content-length"] = "" + Buffer.byteLength(payload);
        }
      }
      safeWriteHead(reply, statusCode);
      res.write(payload);
      sendTrailer(payload, res, reply);
    }
    function logStreamError(logger, err, res) {
      if (err.code === "ERR_STREAM_PREMATURE_CLOSE") {
        if (!logger[kDisableRequestLogging]) {
          logger.info({ res }, "stream closed prematurely");
        }
      } else {
        logger.warn({ err }, "response terminated with an error with headers already sent");
      }
    }
    function sendWebStream(payload, res, reply) {
      if (payload.locked) {
        throw FST_ERR_REP_READABLE_STREAM_LOCKED();
      }
      const nodeStream = Readable.fromWeb(payload);
      sendStream(nodeStream, res, reply);
    }
    function sendStream(payload, res, reply) {
      let sourceOpen = true;
      let errorLogged = false;
      sendStreamTrailer(payload, res, reply);
      eos(payload, { readable: true, writable: false }, function(err) {
        sourceOpen = false;
        if (err != null) {
          if (res.headersSent || reply.request.raw.aborted === true) {
            if (!errorLogged) {
              errorLogged = true;
              logStreamError(reply.log, err, reply);
            }
            res.destroy();
          } else {
            onErrorHook(reply, err);
          }
        }
      });
      eos(res, function(err) {
        if (sourceOpen) {
          if (err != null && res.headersSent && !errorLogged) {
            errorLogged = true;
            logStreamError(reply.log, err, res);
          }
          if (typeof payload.destroy === "function") {
            payload.destroy();
          } else if (typeof payload.close === "function") {
            payload.close(noop);
          } else if (typeof payload.abort === "function") {
            payload.abort();
          } else {
            reply.log.warn("stream payload does not end properly");
          }
        }
      });
      if (!res.headersSent) {
        for (const key in reply[kReplyHeaders]) {
          res.setHeader(key, reply[kReplyHeaders][key]);
        }
      } else {
        reply.log.warn("response will send, but you shouldn't use res.writeHead in stream mode");
      }
      payload.pipe(res);
    }
    function sendTrailer(payload, res, reply) {
      if (reply[kReplyTrailers] === null) {
        res.end(null, null, null);
        return;
      }
      const trailerHeaders = Object.keys(reply[kReplyTrailers]);
      const trailers = {};
      let handled = 0;
      let skipped = true;
      function send() {
        if (handled === 0) {
          res.addTrailers(trailers);
          res.end(null, null, null);
        }
      }
      for (const trailerName of trailerHeaders) {
        let cb = function(err, value) {
          handled++;
          if (err) reply.log.debug(err);
          else trailers[trailerName] = value;
          process.nextTick(send);
        };
        if (typeof reply[kReplyTrailers][trailerName] !== "function") continue;
        skipped = false;
        handled--;
        const result = reply[kReplyTrailers][trailerName](reply, payload, cb);
        if (typeof result === "object" && typeof result.then === "function") {
          result.then((v) => cb(null, v), cb);
        }
      }
      if (skipped) res.end(null, null, null);
    }
    function sendStreamTrailer(payload, res, reply) {
      if (reply[kReplyTrailers] === null) return;
      payload.on("end", () => sendTrailer(null, res, reply));
    }
    function onErrorHook(reply, error, cb) {
      if (reply[kRouteContext].onError !== null && !reply[kReplyNextErrorHandler]) {
        reply[kReplyIsRunningOnErrorHook] = true;
        onSendHookRunner(
          reply[kRouteContext].onError,
          reply.request,
          reply,
          error,
          () => handleError(reply, error, cb)
        );
      } else {
        handleError(reply, error, cb);
      }
    }
    function setupResponseListeners(reply) {
      reply[kReplyStartTime] = now();
      const onResFinished = (err) => {
        reply[kReplyEndTime] = now();
        reply.raw.removeListener("finish", onResFinished);
        reply.raw.removeListener("error", onResFinished);
        const ctx = reply[kRouteContext];
        if (ctx && ctx.onResponse !== null) {
          onResponseHookRunner(
            ctx.onResponse,
            reply.request,
            reply,
            onResponseCallback
          );
        } else {
          onResponseCallback(err, reply.request, reply);
        }
      };
      reply.raw.on("finish", onResFinished);
      reply.raw.on("error", onResFinished);
    }
    function onResponseCallback(err, request, reply) {
      if (reply.log[kDisableRequestLogging]) {
        return;
      }
      const responseTime = reply.elapsedTime;
      if (err != null) {
        reply.log.error({
          res: reply,
          err,
          responseTime
        }, "request errored");
        return;
      }
      reply.log.info({
        res: reply,
        responseTime
      }, "request completed");
    }
    function buildReply(R) {
      const props = R.props.slice();
      function _Reply(res, request, log2) {
        this.raw = res;
        this[kReplyIsError] = false;
        this[kReplyErrorHandlerCalled] = false;
        this[kReplyHijacked] = false;
        this[kReplySerializer] = null;
        this.request = request;
        this[kReplyHeaders] = {};
        this[kReplyTrailers] = null;
        this[kReplyStartTime] = void 0;
        this[kReplyEndTime] = void 0;
        this.log = log2;
        let prop;
        for (let i = 0; i < props.length; i++) {
          prop = props[i];
          this[prop.key] = prop.value;
        }
      }
      Object.setPrototypeOf(_Reply.prototype, R.prototype);
      Object.setPrototypeOf(_Reply, R);
      _Reply.parent = R;
      _Reply.props = props;
      return _Reply;
    }
    function notFound(reply) {
      if (reply[kRouteContext][kFourOhFourContext] === null) {
        reply.log.warn("Trying to send a NotFound error inside a 404 handler. Sending basic 404 response.");
        reply.code(404).send("404 Not Found");
        return;
      }
      reply.request[kRouteContext] = reply[kRouteContext][kFourOhFourContext];
      if (reply[kRouteContext].preHandler !== null) {
        preHandlerHookRunner(
          reply[kRouteContext].preHandler,
          reply.request,
          reply,
          internals.preHandlerCallback
        );
      } else {
        internals.preHandlerCallback(null, reply.request, reply);
      }
    }
    function serialize(context, data, statusCode, contentType) {
      const fnSerialize = getSchemaSerializer(context, statusCode, contentType);
      if (fnSerialize) {
        return fnSerialize(data);
      }
      return JSON.stringify(data);
    }
    function noop() {
    }
    module2.exports = Reply;
    module2.exports.buildReply = buildReply;
    module2.exports.setupResponseListeners = setupResponseListeners;
  }
});

// node_modules/@fastify/forwarded/index.js
var require_forwarded = __commonJS({
  "node_modules/@fastify/forwarded/index.js"(exports2, module2) {
    "use strict";
    function forwarded(req) {
      if (!req) {
        throw new TypeError("argument req is required");
      }
      const header = req.headers["x-forwarded-for"];
      const socketAddr = req.socket.remoteAddress;
      if (!header || typeof header !== "string") {
        return [socketAddr];
      } else if (header.indexOf(",") === -1) {
        const remote = header.trim();
        return remote.length ? [socketAddr, remote] : [socketAddr];
      } else {
        return parse(header, socketAddr);
      }
    }
    function parse(header, socketAddr) {
      const result = [socketAddr];
      let end = header.length;
      let start = end;
      let char;
      let i;
      for (i = end - 1; i >= 0; --i) {
        char = header[i];
        if (char === " ") {
          start === end && (start = end = i);
        } else if (char === ",") {
          start !== end && result.push(header.slice(start, end));
          start = end = i;
        } else {
          start = i;
        }
      }
      start !== end && result.push(header.substring(start, end));
      return result;
    }
    module2.exports = forwarded;
    module2.exports.default = forwarded;
    module2.exports.forwarded = forwarded;
  }
});

// node_modules/ipaddr.js/lib/ipaddr.js
var require_ipaddr = __commonJS({
  "node_modules/ipaddr.js/lib/ipaddr.js"(exports2, module2) {
    (function(root) {
      "use strict";
      const ipv4Part = "(0?\\d+|0x[a-f0-9]+)";
      const ipv4Regexes = {
        fourOctet: new RegExp(`^${ipv4Part}\\.${ipv4Part}\\.${ipv4Part}\\.${ipv4Part}$`, "i"),
        threeOctet: new RegExp(`^${ipv4Part}\\.${ipv4Part}\\.${ipv4Part}$`, "i"),
        twoOctet: new RegExp(`^${ipv4Part}\\.${ipv4Part}$`, "i"),
        longValue: new RegExp(`^${ipv4Part}$`, "i")
      };
      const octalRegex = new RegExp(`^0[0-7]+$`, "i");
      const hexRegex = new RegExp(`^0x[a-f0-9]+$`, "i");
      const zoneIndex = "%[0-9a-z]{1,}";
      const ipv6Part = "(?:[0-9a-f]+::?)+";
      const ipv6Regexes = {
        zoneIndex: new RegExp(zoneIndex, "i"),
        "native": new RegExp(`^(::)?(${ipv6Part})?([0-9a-f]+)?(::)?(${zoneIndex})?$`, "i"),
        deprecatedTransitional: new RegExp(`^(?:::)(${ipv4Part}\\.${ipv4Part}\\.${ipv4Part}\\.${ipv4Part}(${zoneIndex})?)$`, "i"),
        transitional: new RegExp(`^((?:${ipv6Part})|(?:::)(?:${ipv6Part})?)${ipv4Part}\\.${ipv4Part}\\.${ipv4Part}\\.${ipv4Part}(${zoneIndex})?$`, "i")
      };
      function expandIPv6(string, parts) {
        if (string.indexOf("::") !== string.lastIndexOf("::")) {
          return null;
        }
        let colonCount = 0;
        let lastColon = -1;
        let zoneId = (string.match(ipv6Regexes.zoneIndex) || [])[0];
        let replacement, replacementCount;
        if (zoneId) {
          zoneId = zoneId.substring(1);
          string = string.replace(/%.+$/, "");
        }
        while ((lastColon = string.indexOf(":", lastColon + 1)) >= 0) {
          colonCount++;
        }
        if (string.substr(0, 2) === "::") {
          colonCount--;
        }
        if (string.substr(-2, 2) === "::") {
          colonCount--;
        }
        if (colonCount > parts) {
          return null;
        }
        replacementCount = parts - colonCount;
        replacement = ":";
        while (replacementCount--) {
          replacement += "0:";
        }
        string = string.replace("::", replacement);
        if (string[0] === ":") {
          string = string.slice(1);
        }
        if (string[string.length - 1] === ":") {
          string = string.slice(0, -1);
        }
        parts = function() {
          const ref = string.split(":");
          const results = [];
          for (let i = 0; i < ref.length; i++) {
            results.push(parseInt(ref[i], 16));
          }
          return results;
        }();
        return {
          parts,
          zoneId
        };
      }
      function matchCIDR(first, second, partSize, cidrBits) {
        if (first.length !== second.length) {
          throw new Error("ipaddr: cannot match CIDR for objects with different lengths");
        }
        let part = 0;
        let shift;
        while (cidrBits > 0) {
          shift = partSize - cidrBits;
          if (shift < 0) {
            shift = 0;
          }
          if (first[part] >> shift !== second[part] >> shift) {
            return false;
          }
          cidrBits -= partSize;
          part += 1;
        }
        return true;
      }
      function parseIntAuto(string) {
        if (hexRegex.test(string)) {
          return parseInt(string, 16);
        }
        if (string[0] === "0" && !isNaN(parseInt(string[1], 10))) {
          if (octalRegex.test(string)) {
            return parseInt(string, 8);
          }
          throw new Error(`ipaddr: cannot parse ${string} as octal`);
        }
        return parseInt(string, 10);
      }
      function padPart(part, length) {
        while (part.length < length) {
          part = `0${part}`;
        }
        return part;
      }
      const ipaddr = {};
      ipaddr.IPv4 = function() {
        function IPv4(octets) {
          if (octets.length !== 4) {
            throw new Error("ipaddr: ipv4 octet count should be 4");
          }
          let i, octet;
          for (i = 0; i < octets.length; i++) {
            octet = octets[i];
            if (!(0 <= octet && octet <= 255)) {
              throw new Error("ipaddr: ipv4 octet should fit in 8 bits");
            }
          }
          this.octets = octets;
        }
        IPv4.prototype.SpecialRanges = {
          unspecified: [[new IPv4([0, 0, 0, 0]), 8]],
          broadcast: [[new IPv4([255, 255, 255, 255]), 32]],
          // RFC3171
          multicast: [[new IPv4([224, 0, 0, 0]), 4]],
          // RFC3927
          linkLocal: [[new IPv4([169, 254, 0, 0]), 16]],
          // RFC5735
          loopback: [[new IPv4([127, 0, 0, 0]), 8]],
          // RFC6598
          carrierGradeNat: [[new IPv4([100, 64, 0, 0]), 10]],
          // RFC1918
          "private": [
            [new IPv4([10, 0, 0, 0]), 8],
            [new IPv4([172, 16, 0, 0]), 12],
            [new IPv4([192, 168, 0, 0]), 16]
          ],
          // Reserved and testing-only ranges; RFCs 5735, 5737, 2544, 1700
          reserved: [
            [new IPv4([192, 0, 0, 0]), 24],
            [new IPv4([192, 0, 2, 0]), 24],
            [new IPv4([192, 88, 99, 0]), 24],
            [new IPv4([198, 18, 0, 0]), 15],
            [new IPv4([198, 51, 100, 0]), 24],
            [new IPv4([203, 0, 113, 0]), 24],
            [new IPv4([240, 0, 0, 0]), 4]
          ],
          // RFC7534, RFC7535
          as112: [
            [new IPv4([192, 175, 48, 0]), 24],
            [new IPv4([192, 31, 196, 0]), 24]
          ],
          // RFC7450
          amt: [
            [new IPv4([192, 52, 193, 0]), 24]
          ]
        };
        IPv4.prototype.kind = function() {
          return "ipv4";
        };
        IPv4.prototype.match = function(other, cidrRange) {
          let ref;
          if (cidrRange === void 0) {
            ref = other;
            other = ref[0];
            cidrRange = ref[1];
          }
          if (other.kind() !== "ipv4") {
            throw new Error("ipaddr: cannot match ipv4 address with non-ipv4 one");
          }
          return matchCIDR(this.octets, other.octets, 8, cidrRange);
        };
        IPv4.prototype.prefixLengthFromSubnetMask = function() {
          let cidr = 0;
          let stop = false;
          const zerotable = {
            0: 8,
            128: 7,
            192: 6,
            224: 5,
            240: 4,
            248: 3,
            252: 2,
            254: 1,
            255: 0
          };
          let i, octet, zeros;
          for (i = 3; i >= 0; i -= 1) {
            octet = this.octets[i];
            if (octet in zerotable) {
              zeros = zerotable[octet];
              if (stop && zeros !== 0) {
                return null;
              }
              if (zeros !== 8) {
                stop = true;
              }
              cidr += zeros;
            } else {
              return null;
            }
          }
          return 32 - cidr;
        };
        IPv4.prototype.range = function() {
          return ipaddr.subnetMatch(this, this.SpecialRanges);
        };
        IPv4.prototype.toByteArray = function() {
          return this.octets.slice(0);
        };
        IPv4.prototype.toIPv4MappedAddress = function() {
          return ipaddr.IPv6.parse(`::ffff:${this.toString()}`);
        };
        IPv4.prototype.toNormalizedString = function() {
          return this.toString();
        };
        IPv4.prototype.toString = function() {
          return this.octets.join(".");
        };
        return IPv4;
      }();
      ipaddr.IPv4.broadcastAddressFromCIDR = function(string) {
        try {
          const cidr = this.parseCIDR(string);
          const ipInterfaceOctets = cidr[0].toByteArray();
          const subnetMaskOctets = this.subnetMaskFromPrefixLength(cidr[1]).toByteArray();
          const octets = [];
          let i = 0;
          while (i < 4) {
            octets.push(parseInt(ipInterfaceOctets[i], 10) | parseInt(subnetMaskOctets[i], 10) ^ 255);
            i++;
          }
          return new this(octets);
        } catch (e) {
          throw new Error("ipaddr: the address does not have IPv4 CIDR format");
        }
      };
      ipaddr.IPv4.isIPv4 = function(string) {
        return this.parser(string) !== null;
      };
      ipaddr.IPv4.isValid = function(string) {
        try {
          new this(this.parser(string));
          return true;
        } catch (e) {
          return false;
        }
      };
      ipaddr.IPv4.isValidCIDR = function(string) {
        try {
          this.parseCIDR(string);
          return true;
        } catch (e) {
          return false;
        }
      };
      ipaddr.IPv4.isValidFourPartDecimal = function(string) {
        if (ipaddr.IPv4.isValid(string) && string.match(/^(0|[1-9]\d*)(\.(0|[1-9]\d*)){3}$/)) {
          return true;
        } else {
          return false;
        }
      };
      ipaddr.IPv4.networkAddressFromCIDR = function(string) {
        let cidr, i, ipInterfaceOctets, octets, subnetMaskOctets;
        try {
          cidr = this.parseCIDR(string);
          ipInterfaceOctets = cidr[0].toByteArray();
          subnetMaskOctets = this.subnetMaskFromPrefixLength(cidr[1]).toByteArray();
          octets = [];
          i = 0;
          while (i < 4) {
            octets.push(parseInt(ipInterfaceOctets[i], 10) & parseInt(subnetMaskOctets[i], 10));
            i++;
          }
          return new this(octets);
        } catch (e) {
          throw new Error("ipaddr: the address does not have IPv4 CIDR format");
        }
      };
      ipaddr.IPv4.parse = function(string) {
        const parts = this.parser(string);
        if (parts === null) {
          throw new Error("ipaddr: string is not formatted like an IPv4 Address");
        }
        return new this(parts);
      };
      ipaddr.IPv4.parseCIDR = function(string) {
        let match;
        if (match = string.match(/^(.+)\/(\d+)$/)) {
          const maskLength = parseInt(match[2]);
          if (maskLength >= 0 && maskLength <= 32) {
            const parsed = [this.parse(match[1]), maskLength];
            Object.defineProperty(parsed, "toString", {
              value: function() {
                return this.join("/");
              }
            });
            return parsed;
          }
        }
        throw new Error("ipaddr: string is not formatted like an IPv4 CIDR range");
      };
      ipaddr.IPv4.parser = function(string) {
        let match, part, value;
        if (match = string.match(ipv4Regexes.fourOctet)) {
          return function() {
            const ref = match.slice(1, 6);
            const results = [];
            for (let i = 0; i < ref.length; i++) {
              part = ref[i];
              results.push(parseIntAuto(part));
            }
            return results;
          }();
        } else if (match = string.match(ipv4Regexes.longValue)) {
          value = parseIntAuto(match[1]);
          if (value > 4294967295 || value < 0) {
            throw new Error("ipaddr: address outside defined range");
          }
          return function() {
            const results = [];
            let shift;
            for (shift = 0; shift <= 24; shift += 8) {
              results.push(value >> shift & 255);
            }
            return results;
          }().reverse();
        } else if (match = string.match(ipv4Regexes.twoOctet)) {
          return function() {
            const ref = match.slice(1, 4);
            const results = [];
            value = parseIntAuto(ref[1]);
            if (value > 16777215 || value < 0) {
              throw new Error("ipaddr: address outside defined range");
            }
            results.push(parseIntAuto(ref[0]));
            results.push(value >> 16 & 255);
            results.push(value >> 8 & 255);
            results.push(value & 255);
            return results;
          }();
        } else if (match = string.match(ipv4Regexes.threeOctet)) {
          return function() {
            const ref = match.slice(1, 5);
            const results = [];
            value = parseIntAuto(ref[2]);
            if (value > 65535 || value < 0) {
              throw new Error("ipaddr: address outside defined range");
            }
            results.push(parseIntAuto(ref[0]));
            results.push(parseIntAuto(ref[1]));
            results.push(value >> 8 & 255);
            results.push(value & 255);
            return results;
          }();
        } else {
          return null;
        }
      };
      ipaddr.IPv4.subnetMaskFromPrefixLength = function(prefix) {
        prefix = parseInt(prefix);
        if (prefix < 0 || prefix > 32) {
          throw new Error("ipaddr: invalid IPv4 prefix length");
        }
        const octets = [0, 0, 0, 0];
        let j = 0;
        const filledOctetCount = Math.floor(prefix / 8);
        while (j < filledOctetCount) {
          octets[j] = 255;
          j++;
        }
        if (filledOctetCount < 4) {
          octets[filledOctetCount] = Math.pow(2, prefix % 8) - 1 << 8 - prefix % 8;
        }
        return new this(octets);
      };
      ipaddr.IPv6 = function() {
        function IPv6(parts, zoneId) {
          let i, part;
          if (parts.length === 16) {
            this.parts = [];
            for (i = 0; i <= 14; i += 2) {
              this.parts.push(parts[i] << 8 | parts[i + 1]);
            }
          } else if (parts.length === 8) {
            this.parts = parts;
          } else {
            throw new Error("ipaddr: ipv6 part count should be 8 or 16");
          }
          for (i = 0; i < this.parts.length; i++) {
            part = this.parts[i];
            if (!(0 <= part && part <= 65535)) {
              throw new Error("ipaddr: ipv6 part should fit in 16 bits");
            }
          }
          if (zoneId) {
            this.zoneId = zoneId;
          }
        }
        IPv6.prototype.SpecialRanges = {
          // RFC4291, here and after
          unspecified: [new IPv6([0, 0, 0, 0, 0, 0, 0, 0]), 128],
          linkLocal: [new IPv6([65152, 0, 0, 0, 0, 0, 0, 0]), 10],
          multicast: [new IPv6([65280, 0, 0, 0, 0, 0, 0, 0]), 8],
          loopback: [new IPv6([0, 0, 0, 0, 0, 0, 0, 1]), 128],
          uniqueLocal: [new IPv6([64512, 0, 0, 0, 0, 0, 0, 0]), 7],
          ipv4Mapped: [new IPv6([0, 0, 0, 0, 0, 65535, 0, 0]), 96],
          // RFC6666
          discard: [new IPv6([256, 0, 0, 0, 0, 0, 0, 0]), 64],
          // RFC6145
          rfc6145: [new IPv6([0, 0, 0, 0, 65535, 0, 0, 0]), 96],
          // RFC6052
          rfc6052: [new IPv6([100, 65435, 0, 0, 0, 0, 0, 0]), 96],
          // RFC3056
          "6to4": [new IPv6([8194, 0, 0, 0, 0, 0, 0, 0]), 16],
          // RFC6052, RFC6146
          teredo: [new IPv6([8193, 0, 0, 0, 0, 0, 0, 0]), 32],
          // RFC5180
          benchmarking: [new IPv6([8193, 2, 0, 0, 0, 0, 0, 0]), 48],
          // RFC7450
          amt: [new IPv6([8193, 3, 0, 0, 0, 0, 0, 0]), 32],
          as112v6: [
            [new IPv6([8193, 4, 274, 0, 0, 0, 0, 0]), 48],
            [new IPv6([9760, 79, 32768, 0, 0, 0, 0, 0]), 48]
          ],
          deprecated: [new IPv6([8193, 16, 0, 0, 0, 0, 0, 0]), 28],
          orchid2: [new IPv6([8193, 32, 0, 0, 0, 0, 0, 0]), 28],
          droneRemoteIdProtocolEntityTags: [new IPv6([8193, 48, 0, 0, 0, 0, 0, 0]), 28],
          reserved: [
            // RFC3849
            [new IPv6([8193, 0, 0, 0, 0, 0, 0, 0]), 23],
            // RFC2928
            [new IPv6([8193, 3512, 0, 0, 0, 0, 0, 0]), 32]
          ]
        };
        IPv6.prototype.isIPv4MappedAddress = function() {
          return this.range() === "ipv4Mapped";
        };
        IPv6.prototype.kind = function() {
          return "ipv6";
        };
        IPv6.prototype.match = function(other, cidrRange) {
          let ref;
          if (cidrRange === void 0) {
            ref = other;
            other = ref[0];
            cidrRange = ref[1];
          }
          if (other.kind() !== "ipv6") {
            throw new Error("ipaddr: cannot match ipv6 address with non-ipv6 one");
          }
          return matchCIDR(this.parts, other.parts, 16, cidrRange);
        };
        IPv6.prototype.prefixLengthFromSubnetMask = function() {
          let cidr = 0;
          let stop = false;
          const zerotable = {
            0: 16,
            32768: 15,
            49152: 14,
            57344: 13,
            61440: 12,
            63488: 11,
            64512: 10,
            65024: 9,
            65280: 8,
            65408: 7,
            65472: 6,
            65504: 5,
            65520: 4,
            65528: 3,
            65532: 2,
            65534: 1,
            65535: 0
          };
          let part, zeros;
          for (let i = 7; i >= 0; i -= 1) {
            part = this.parts[i];
            if (part in zerotable) {
              zeros = zerotable[part];
              if (stop && zeros !== 0) {
                return null;
              }
              if (zeros !== 16) {
                stop = true;
              }
              cidr += zeros;
            } else {
              return null;
            }
          }
          return 128 - cidr;
        };
        IPv6.prototype.range = function() {
          return ipaddr.subnetMatch(this, this.SpecialRanges);
        };
        IPv6.prototype.toByteArray = function() {
          let part;
          const bytes = [];
          const ref = this.parts;
          for (let i = 0; i < ref.length; i++) {
            part = ref[i];
            bytes.push(part >> 8);
            bytes.push(part & 255);
          }
          return bytes;
        };
        IPv6.prototype.toFixedLengthString = function() {
          const addr = function() {
            const results = [];
            for (let i = 0; i < this.parts.length; i++) {
              results.push(padPart(this.parts[i].toString(16), 4));
            }
            return results;
          }.call(this).join(":");
          let suffix = "";
          if (this.zoneId) {
            suffix = `%${this.zoneId}`;
          }
          return addr + suffix;
        };
        IPv6.prototype.toIPv4Address = function() {
          if (!this.isIPv4MappedAddress()) {
            throw new Error("ipaddr: trying to convert a generic ipv6 address to ipv4");
          }
          const ref = this.parts.slice(-2);
          const high = ref[0];
          const low = ref[1];
          return new ipaddr.IPv4([high >> 8, high & 255, low >> 8, low & 255]);
        };
        IPv6.prototype.toNormalizedString = function() {
          const addr = function() {
            const results = [];
            for (let i = 0; i < this.parts.length; i++) {
              results.push(this.parts[i].toString(16));
            }
            return results;
          }.call(this).join(":");
          let suffix = "";
          if (this.zoneId) {
            suffix = `%${this.zoneId}`;
          }
          return addr + suffix;
        };
        IPv6.prototype.toRFC5952String = function() {
          const regex = /((^|:)(0(:|$)){2,})/g;
          const string = this.toNormalizedString();
          let bestMatchIndex = 0;
          let bestMatchLength = -1;
          let match;
          while (match = regex.exec(string)) {
            if (match[0].length > bestMatchLength) {
              bestMatchIndex = match.index;
              bestMatchLength = match[0].length;
            }
          }
          if (bestMatchLength < 0) {
            return string;
          }
          return `${string.substring(0, bestMatchIndex)}::${string.substring(bestMatchIndex + bestMatchLength)}`;
        };
        IPv6.prototype.toString = function() {
          return this.toRFC5952String();
        };
        return IPv6;
      }();
      ipaddr.IPv6.broadcastAddressFromCIDR = function(string) {
        try {
          const cidr = this.parseCIDR(string);
          const ipInterfaceOctets = cidr[0].toByteArray();
          const subnetMaskOctets = this.subnetMaskFromPrefixLength(cidr[1]).toByteArray();
          const octets = [];
          let i = 0;
          while (i < 16) {
            octets.push(parseInt(ipInterfaceOctets[i], 10) | parseInt(subnetMaskOctets[i], 10) ^ 255);
            i++;
          }
          return new this(octets);
        } catch (e) {
          throw new Error(`ipaddr: the address does not have IPv6 CIDR format (${e})`);
        }
      };
      ipaddr.IPv6.isIPv6 = function(string) {
        return this.parser(string) !== null;
      };
      ipaddr.IPv6.isValid = function(string) {
        if (typeof string === "string" && string.indexOf(":") === -1) {
          return false;
        }
        try {
          const addr = this.parser(string);
          new this(addr.parts, addr.zoneId);
          return true;
        } catch (e) {
          return false;
        }
      };
      ipaddr.IPv6.isValidCIDR = function(string) {
        if (typeof string === "string" && string.indexOf(":") === -1) {
          return false;
        }
        try {
          this.parseCIDR(string);
          return true;
        } catch (e) {
          return false;
        }
      };
      ipaddr.IPv6.networkAddressFromCIDR = function(string) {
        let cidr, i, ipInterfaceOctets, octets, subnetMaskOctets;
        try {
          cidr = this.parseCIDR(string);
          ipInterfaceOctets = cidr[0].toByteArray();
          subnetMaskOctets = this.subnetMaskFromPrefixLength(cidr[1]).toByteArray();
          octets = [];
          i = 0;
          while (i < 16) {
            octets.push(parseInt(ipInterfaceOctets[i], 10) & parseInt(subnetMaskOctets[i], 10));
            i++;
          }
          return new this(octets);
        } catch (e) {
          throw new Error(`ipaddr: the address does not have IPv6 CIDR format (${e})`);
        }
      };
      ipaddr.IPv6.parse = function(string) {
        const addr = this.parser(string);
        if (addr.parts === null) {
          throw new Error("ipaddr: string is not formatted like an IPv6 Address");
        }
        return new this(addr.parts, addr.zoneId);
      };
      ipaddr.IPv6.parseCIDR = function(string) {
        let maskLength, match, parsed;
        if (match = string.match(/^(.+)\/(\d+)$/)) {
          maskLength = parseInt(match[2]);
          if (maskLength >= 0 && maskLength <= 128) {
            parsed = [this.parse(match[1]), maskLength];
            Object.defineProperty(parsed, "toString", {
              value: function() {
                return this.join("/");
              }
            });
            return parsed;
          }
        }
        throw new Error("ipaddr: string is not formatted like an IPv6 CIDR range");
      };
      ipaddr.IPv6.parser = function(string) {
        let addr, i, match, octet, octets, zoneId;
        if (match = string.match(ipv6Regexes.deprecatedTransitional)) {
          return this.parser(`::ffff:${match[1]}`);
        }
        if (ipv6Regexes.native.test(string)) {
          return expandIPv6(string, 8);
        }
        if (match = string.match(ipv6Regexes.transitional)) {
          zoneId = match[6] || "";
          addr = match[1];
          if (!match[1].endsWith("::")) {
            addr = addr.slice(0, -1);
          }
          addr = expandIPv6(addr + zoneId, 6);
          if (addr.parts) {
            octets = [
              parseInt(match[2]),
              parseInt(match[3]),
              parseInt(match[4]),
              parseInt(match[5])
            ];
            for (i = 0; i < octets.length; i++) {
              octet = octets[i];
              if (!(0 <= octet && octet <= 255)) {
                return null;
              }
            }
            addr.parts.push(octets[0] << 8 | octets[1]);
            addr.parts.push(octets[2] << 8 | octets[3]);
            return {
              parts: addr.parts,
              zoneId: addr.zoneId
            };
          }
        }
        return null;
      };
      ipaddr.IPv6.subnetMaskFromPrefixLength = function(prefix) {
        prefix = parseInt(prefix);
        if (prefix < 0 || prefix > 128) {
          throw new Error("ipaddr: invalid IPv6 prefix length");
        }
        const octets = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];
        let j = 0;
        const filledOctetCount = Math.floor(prefix / 8);
        while (j < filledOctetCount) {
          octets[j] = 255;
          j++;
        }
        if (filledOctetCount < 16) {
          octets[filledOctetCount] = Math.pow(2, prefix % 8) - 1 << 8 - prefix % 8;
        }
        return new this(octets);
      };
      ipaddr.fromByteArray = function(bytes) {
        const length = bytes.length;
        if (length === 4) {
          return new ipaddr.IPv4(bytes);
        } else if (length === 16) {
          return new ipaddr.IPv6(bytes);
        } else {
          throw new Error("ipaddr: the binary input is neither an IPv6 nor IPv4 address");
        }
      };
      ipaddr.isValid = function(string) {
        return ipaddr.IPv6.isValid(string) || ipaddr.IPv4.isValid(string);
      };
      ipaddr.isValidCIDR = function(string) {
        return ipaddr.IPv6.isValidCIDR(string) || ipaddr.IPv4.isValidCIDR(string);
      };
      ipaddr.parse = function(string) {
        if (ipaddr.IPv6.isValid(string)) {
          return ipaddr.IPv6.parse(string);
        } else if (ipaddr.IPv4.isValid(string)) {
          return ipaddr.IPv4.parse(string);
        } else {
          throw new Error("ipaddr: the address has neither IPv6 nor IPv4 format");
        }
      };
      ipaddr.parseCIDR = function(string) {
        try {
          return ipaddr.IPv6.parseCIDR(string);
        } catch (e) {
          try {
            return ipaddr.IPv4.parseCIDR(string);
          } catch (e2) {
            throw new Error("ipaddr: the address has neither IPv6 nor IPv4 CIDR format");
          }
        }
      };
      ipaddr.process = function(string) {
        const addr = this.parse(string);
        if (addr.kind() === "ipv6" && addr.isIPv4MappedAddress()) {
          return addr.toIPv4Address();
        } else {
          return addr;
        }
      };
      ipaddr.subnetMatch = function(address, rangeList, defaultName) {
        let i, rangeName, rangeSubnets, subnet;
        if (defaultName === void 0 || defaultName === null) {
          defaultName = "unicast";
        }
        for (rangeName in rangeList) {
          if (Object.prototype.hasOwnProperty.call(rangeList, rangeName)) {
            rangeSubnets = rangeList[rangeName];
            if (rangeSubnets[0] && !(rangeSubnets[0] instanceof Array)) {
              rangeSubnets = [rangeSubnets];
            }
            for (i = 0; i < rangeSubnets.length; i++) {
              subnet = rangeSubnets[i];
              if (address.kind() === subnet[0].kind() && address.match.apply(address, subnet)) {
                return rangeName;
              }
            }
          }
        }
        return defaultName;
      };
      if (typeof module2 !== "undefined" && module2.exports) {
        module2.exports = ipaddr;
      } else {
        root.ipaddr = ipaddr;
      }
    })(exports2);
  }
});

// node_modules/@fastify/proxy-addr/index.js
var require_proxy_addr = __commonJS({
  "node_modules/@fastify/proxy-addr/index.js"(exports2, module2) {
    "use strict";
    module2.exports = proxyaddr;
    module2.exports.default = proxyaddr;
    module2.exports.proxyaddr = proxyaddr;
    module2.exports.all = alladdrs;
    module2.exports.compile = compile;
    var forwarded = require_forwarded();
    var ipaddr = require_ipaddr();
    var DIGIT_REGEXP = /^\d+$/u;
    var isip = ipaddr.isValid;
    var parseip = ipaddr.parse;
    var IP_RANGES = {
      linklocal: ["169.254.0.0/16", "fe80::/10"],
      loopback: ["127.0.0.1/8", "::1/128"],
      uniquelocal: ["10.0.0.0/8", "172.16.0.0/12", "192.168.0.0/16", "fc00::/7"]
    };
    function alladdrs(req, trust) {
      const addrs = forwarded(req);
      if (!trust) {
        return addrs;
      }
      if (typeof trust !== "function") {
        trust = compile(trust);
      }
      for (var i = 0; i < addrs.length - 1; i++) {
        if (trust(addrs[i], i)) continue;
        addrs.length = i + 1;
      }
      return addrs;
    }
    function compile(val) {
      if (!val) {
        throw new TypeError("argument is required");
      }
      let trust;
      if (typeof val === "string") {
        trust = [val];
      } else if (Array.isArray(val)) {
        trust = val.slice();
      } else {
        throw new TypeError("unsupported trust argument");
      }
      for (var i = 0; i < trust.length; i++) {
        val = trust[i];
        if (!Object.prototype.hasOwnProperty.call(IP_RANGES, val)) {
          continue;
        }
        val = IP_RANGES[val];
        trust.splice.apply(trust, [i, 1].concat(val));
        i += val.length - 1;
      }
      return compileTrust(compileRangeSubnets(trust));
    }
    function compileRangeSubnets(arr) {
      const rangeSubnets = new Array(arr.length);
      for (var i = 0; i < arr.length; i++) {
        rangeSubnets[i] = parseipNotation(arr[i]);
      }
      return rangeSubnets;
    }
    function compileTrust(rangeSubnets) {
      const len = rangeSubnets.length;
      return len === 0 ? trustNone : len === 1 ? trustSingle(rangeSubnets[0]) : trustMulti(rangeSubnets);
    }
    function parseipNotation(note) {
      const pos = note.lastIndexOf("/");
      const str = pos !== -1 ? note.substring(0, pos) : note;
      if (!isip(str)) {
        throw new TypeError("invalid IP address: " + str);
      }
      let ip = parseip(str);
      if (pos === -1 && ip.kind() === "ipv6" && ip.isIPv4MappedAddress()) {
        ip = ip.toIPv4Address();
      }
      const max = ip.kind() === "ipv6" ? 128 : 32;
      let range = pos !== -1 ? note.substring(pos + 1, note.length) : null;
      if (range === null) {
        range = max;
      } else if (DIGIT_REGEXP.test(range)) {
        range = parseInt(range, 10);
      } else if (ip.kind() === "ipv4" && isip(range)) {
        range = parseNetmask(range);
      } else {
        range = null;
      }
      if (range <= 0 || range > max) {
        throw new TypeError("invalid range on address: " + note);
      }
      return [ip, range];
    }
    function parseNetmask(netmask) {
      const ip = parseip(netmask);
      const kind = ip.kind();
      return kind === "ipv4" ? ip.prefixLengthFromSubnetMask() : null;
    }
    function proxyaddr(req, trust) {
      if (!req) {
        throw new TypeError("req argument is required");
      }
      if (!trust) {
        throw new TypeError("trust argument is required");
      }
      const addrs = alladdrs(req, trust);
      const addr = addrs[addrs.length - 1];
      return addr;
    }
    function trustNone() {
      return false;
    }
    function trustMulti(subnets) {
      return function trust(addr) {
        if (!isip(addr)) return false;
        const ip = parseip(addr);
        let ipconv;
        const kind = ip.kind();
        for (var i = 0; i < subnets.length; i++) {
          const subnet = subnets[i];
          const subnetip = subnet[0];
          const subnetkind = subnetip.kind();
          const subnetrange = subnet[1];
          let trusted = ip;
          if (kind !== subnetkind) {
            if (subnetkind === "ipv4" && !ip.isIPv4MappedAddress()) {
              continue;
            }
            if (!ipconv) {
              ipconv = subnetkind === "ipv4" ? ip.toIPv4Address() : ip.toIPv4MappedAddress();
            }
            trusted = ipconv;
          }
          if (trusted.match(subnetip, subnetrange)) {
            return true;
          }
        }
        return false;
      };
    }
    function trustSingle(subnet) {
      const subnetip = subnet[0];
      const subnetkind = subnetip.kind();
      const subnetisipv4 = subnetkind === "ipv4";
      const subnetrange = subnet[1];
      return function trust(addr) {
        if (!isip(addr)) return false;
        let ip = parseip(addr);
        const kind = ip.kind();
        if (kind !== subnetkind) {
          if (subnetisipv4 && !ip.isIPv4MappedAddress()) {
            return false;
          }
          ip = subnetisipv4 ? ip.toIPv4Address() : ip.toIPv4MappedAddress();
        }
        return ip.match(subnetip, subnetrange);
      };
    }
  }
});

// node_modules/fastify/lib/request.js
var require_request = __commonJS({
  "node_modules/fastify/lib/request.js"(exports2, module2) {
    "use strict";
    var proxyAddr = require_proxy_addr();
    var {
      kHasBeenDecorated,
      kSchemaBody,
      kSchemaHeaders,
      kSchemaParams,
      kSchemaQuerystring,
      kSchemaController,
      kOptions,
      kRequestCacheValidateFns,
      kRouteContext,
      kRequestOriginalUrl
    } = require_symbols2();
    var { FST_ERR_REQ_INVALID_VALIDATION_INVOCATION, FST_ERR_DEC_UNDECLARED } = require_errors2();
    var decorators = require_decorate();
    var HTTP_PART_SYMBOL_MAP = {
      body: kSchemaBody,
      headers: kSchemaHeaders,
      params: kSchemaParams,
      querystring: kSchemaQuerystring,
      query: kSchemaQuerystring
    };
    function Request(id2, params, req, query, log2, context) {
      this.id = id2;
      this[kRouteContext] = context;
      this.params = params;
      this.raw = req;
      this.query = query;
      this.log = log2;
      this.body = void 0;
    }
    Request.props = [];
    function getTrustProxyFn(tp) {
      if (typeof tp === "function") {
        return tp;
      }
      if (tp === true) {
        return null;
      }
      if (typeof tp === "number") {
        return function(a, i) {
          return i < tp;
        };
      }
      if (typeof tp === "string") {
        const values = tp.split(",").map((it2) => it2.trim());
        return proxyAddr.compile(values);
      }
      return proxyAddr.compile(tp);
    }
    function buildRequest(R, trustProxy) {
      if (trustProxy) {
        return buildRequestWithTrustProxy(R, trustProxy);
      }
      return buildRegularRequest(R);
    }
    function buildRegularRequest(R) {
      const props = R.props.slice();
      function _Request(id2, params, req, query, log2, context) {
        this.id = id2;
        this[kRouteContext] = context;
        this.params = params;
        this.raw = req;
        this.query = query;
        this.log = log2;
        this.body = void 0;
        let prop;
        for (let i = 0; i < props.length; i++) {
          prop = props[i];
          this[prop.key] = prop.value;
        }
      }
      Object.setPrototypeOf(_Request.prototype, R.prototype);
      Object.setPrototypeOf(_Request, R);
      _Request.props = props;
      _Request.parent = R;
      return _Request;
    }
    function getLastEntryInMultiHeaderValue(headerValue) {
      const lastIndex = headerValue.lastIndexOf(",");
      return lastIndex === -1 ? headerValue.trim() : headerValue.slice(lastIndex + 1).trim();
    }
    function buildRequestWithTrustProxy(R, trustProxy) {
      const _Request = buildRegularRequest(R);
      const proxyFn = getTrustProxyFn(trustProxy);
      _Request[kHasBeenDecorated] = true;
      Object.defineProperties(_Request.prototype, {
        ip: {
          get() {
            const addrs = proxyAddr.all(this.raw, proxyFn);
            return addrs[addrs.length - 1];
          }
        },
        ips: {
          get() {
            return proxyAddr.all(this.raw, proxyFn);
          }
        },
        host: {
          get() {
            if (this.ip !== void 0 && this.headers["x-forwarded-host"]) {
              return getLastEntryInMultiHeaderValue(this.headers["x-forwarded-host"]);
            }
            return this.headers.host ?? this.headers[":authority"] ?? "";
          }
        },
        protocol: {
          get() {
            if (this.headers["x-forwarded-proto"]) {
              return getLastEntryInMultiHeaderValue(this.headers["x-forwarded-proto"]);
            }
            if (this.socket) {
              return this.socket.encrypted ? "https" : "http";
            }
          }
        }
      });
      return _Request;
    }
    function assertsRequestDecoration(request, name) {
      if (!decorators.hasKey(request, name) && !decorators.exist(request, name)) {
        throw new FST_ERR_DEC_UNDECLARED(name, "request");
      }
    }
    Object.defineProperties(Request.prototype, {
      server: {
        get() {
          return this[kRouteContext].server;
        }
      },
      url: {
        get() {
          return this.raw.url;
        }
      },
      originalUrl: {
        get() {
          if (!this[kRequestOriginalUrl]) {
            this[kRequestOriginalUrl] = this.raw.originalUrl || this.raw.url;
          }
          return this[kRequestOriginalUrl];
        }
      },
      method: {
        get() {
          return this.raw.method;
        }
      },
      routeOptions: {
        get() {
          const context = this[kRouteContext];
          const routeLimit = context._parserOptions.limit;
          const serverLimit = context.server.initialConfig.bodyLimit;
          const version2 = context.server.hasConstraintStrategy("version") ? this.raw.headers["accept-version"] : void 0;
          const options = {
            method: context.config?.method,
            url: context.config?.url,
            bodyLimit: routeLimit || serverLimit,
            attachValidation: context.attachValidation,
            logLevel: context.logLevel,
            exposeHeadRoute: context.exposeHeadRoute,
            prefixTrailingSlash: context.prefixTrailingSlash,
            handler: context.handler,
            config: context.config,
            schema: context.schema,
            version: version2
          };
          return options;
        }
      },
      is404: {
        get() {
          return this[kRouteContext].config?.url === void 0;
        }
      },
      socket: {
        get() {
          return this.raw.socket;
        }
      },
      ip: {
        get() {
          if (this.socket) {
            return this.socket.remoteAddress;
          }
        }
      },
      host: {
        get() {
          return this.raw.headers.host ?? this.raw.headers[":authority"] ?? "";
        }
      },
      hostname: {
        get() {
          return this.host.split(":", 1)[0];
        }
      },
      port: {
        get() {
          const portFromHost = parseInt(this.host.split(":").slice(-1)[0]);
          if (!isNaN(portFromHost)) {
            return portFromHost;
          }
          const host = this.headers.host ?? this.headers[":authority"] ?? "";
          const portFromHeader = parseInt(host.split(":").slice(-1)[0]);
          if (!isNaN(portFromHeader)) {
            return portFromHeader;
          }
          return null;
        }
      },
      protocol: {
        get() {
          if (this.socket) {
            return this.socket.encrypted ? "https" : "http";
          }
        }
      },
      headers: {
        get() {
          if (this.additionalHeaders) {
            return Object.assign({}, this.raw.headers, this.additionalHeaders);
          }
          return this.raw.headers;
        },
        set(headers) {
          this.additionalHeaders = headers;
        }
      },
      getValidationFunction: {
        value: function(httpPartOrSchema) {
          if (typeof httpPartOrSchema === "string") {
            const symbol = HTTP_PART_SYMBOL_MAP[httpPartOrSchema];
            return this[kRouteContext][symbol];
          } else if (typeof httpPartOrSchema === "object") {
            return this[kRouteContext][kRequestCacheValidateFns]?.get(httpPartOrSchema);
          }
        }
      },
      compileValidationSchema: {
        value: function(schema, httpPart = null) {
          const { method, url } = this;
          if (this[kRouteContext][kRequestCacheValidateFns]?.has(schema)) {
            return this[kRouteContext][kRequestCacheValidateFns].get(schema);
          }
          const validatorCompiler = this[kRouteContext].validatorCompiler || this.server[kSchemaController].validatorCompiler || // We compile the schemas if no custom validatorCompiler is provided
          // nor set
          (this.server[kSchemaController].setupValidator(this.server[kOptions]) || this.server[kSchemaController].validatorCompiler);
          const validateFn = validatorCompiler({
            schema,
            method,
            url,
            httpPart
          });
          if (this[kRouteContext][kRequestCacheValidateFns] == null) {
            this[kRouteContext][kRequestCacheValidateFns] = /* @__PURE__ */ new WeakMap();
          }
          this[kRouteContext][kRequestCacheValidateFns].set(schema, validateFn);
          return validateFn;
        }
      },
      validateInput: {
        value: function(input, schema, httpPart) {
          httpPart = typeof schema === "string" ? schema : httpPart;
          const symbol = httpPart != null && typeof httpPart === "string" && HTTP_PART_SYMBOL_MAP[httpPart];
          let validate;
          if (symbol) {
            validate = this[kRouteContext][symbol];
          }
          if (validate == null && (schema == null || typeof schema !== "object" || Array.isArray(schema))) {
            throw new FST_ERR_REQ_INVALID_VALIDATION_INVOCATION(httpPart);
          }
          if (validate == null) {
            if (this[kRouteContext][kRequestCacheValidateFns]?.has(schema)) {
              validate = this[kRouteContext][kRequestCacheValidateFns].get(schema);
            } else {
              validate = this.compileValidationSchema(schema, httpPart);
            }
          }
          return validate(input);
        }
      },
      getDecorator: {
        value: function(name) {
          assertsRequestDecoration(this, name);
          const decorator = this[name];
          if (typeof decorator === "function") {
            return decorator.bind(this);
          }
          return decorator;
        }
      },
      setDecorator: {
        value: function(name, value) {
          assertsRequestDecoration(this, name);
          this[name] = value;
        }
      }
    });
    module2.exports = Request;
    module2.exports.buildRequest = buildRequest;
  }
});

// node_modules/fastify/lib/context.js
var require_context = __commonJS({
  "node_modules/fastify/lib/context.js"(exports2, module2) {
    "use strict";
    var {
      kFourOhFourContext,
      kReplySerializerDefault,
      kSchemaErrorFormatter,
      kErrorHandler,
      kChildLoggerFactory,
      kOptions,
      kReply,
      kRequest,
      kBodyLimit,
      kLogLevel,
      kContentTypeParser,
      kRouteByFastify,
      kRequestCacheValidateFns,
      kReplyCacheSerializeFns
    } = require_symbols2();
    function Context({
      schema,
      handler,
      config,
      requestIdLogLabel,
      childLoggerFactory,
      errorHandler,
      bodyLimit,
      logLevel,
      logSerializers,
      attachValidation,
      validatorCompiler,
      serializerCompiler,
      replySerializer,
      schemaErrorFormatter,
      exposeHeadRoute,
      prefixTrailingSlash,
      server,
      isFastify
    }) {
      this.schema = schema;
      this.handler = handler;
      this.Reply = server[kReply];
      this.Request = server[kRequest];
      this.contentTypeParser = server[kContentTypeParser];
      this.onRequest = null;
      this.onSend = null;
      this.onError = null;
      this.onTimeout = null;
      this.preHandler = null;
      this.onResponse = null;
      this.preSerialization = null;
      this.onRequestAbort = null;
      this.config = config;
      this.errorHandler = errorHandler || server[kErrorHandler];
      this.requestIdLogLabel = requestIdLogLabel || server[kOptions].requestIdLogLabel;
      this.childLoggerFactory = childLoggerFactory || server[kChildLoggerFactory];
      this._middie = null;
      this._parserOptions = {
        limit: bodyLimit || server[kBodyLimit]
      };
      this.exposeHeadRoute = exposeHeadRoute;
      this.prefixTrailingSlash = prefixTrailingSlash;
      this.logLevel = logLevel || server[kLogLevel];
      this.logSerializers = logSerializers;
      this[kFourOhFourContext] = null;
      this.attachValidation = attachValidation;
      this[kReplySerializerDefault] = replySerializer;
      this.schemaErrorFormatter = schemaErrorFormatter || server[kSchemaErrorFormatter] || defaultSchemaErrorFormatter;
      this[kRouteByFastify] = isFastify;
      this[kRequestCacheValidateFns] = null;
      this[kReplyCacheSerializeFns] = null;
      this.validatorCompiler = validatorCompiler || null;
      this.serializerCompiler = serializerCompiler || null;
      this.server = server;
    }
    function defaultSchemaErrorFormatter(errors, dataVar) {
      let text = "";
      const separator = ", ";
      for (let i = 0; i !== errors.length; ++i) {
        const e = errors[i];
        text += dataVar + (e.instancePath || "") + " " + e.message + separator;
      }
      return new Error(text.slice(0, -separator.length));
    }
    module2.exports = Context;
  }
});

// node_modules/toad-cache/dist/toad-cache.cjs
var require_toad_cache = __commonJS({
  "node_modules/toad-cache/dist/toad-cache.cjs"(exports2) {
    "use strict";
    var FifoMap = class {
      constructor(max = 1e3, ttlInMsecs = 0) {
        if (isNaN(max) || max < 0) {
          throw new Error("Invalid max value");
        }
        if (isNaN(ttlInMsecs) || ttlInMsecs < 0) {
          throw new Error("Invalid ttl value");
        }
        this.first = null;
        this.items = /* @__PURE__ */ new Map();
        this.last = null;
        this.max = max;
        this.ttl = ttlInMsecs;
      }
      get size() {
        return this.items.size;
      }
      clear() {
        this.items = /* @__PURE__ */ new Map();
        this.first = null;
        this.last = null;
      }
      delete(key) {
        if (this.items.has(key)) {
          const deletedItem = this.items.get(key);
          this.items.delete(key);
          if (deletedItem.prev !== null) {
            deletedItem.prev.next = deletedItem.next;
          }
          if (deletedItem.next !== null) {
            deletedItem.next.prev = deletedItem.prev;
          }
          if (this.first === deletedItem) {
            this.first = deletedItem.next;
          }
          if (this.last === deletedItem) {
            this.last = deletedItem.prev;
          }
        }
      }
      deleteMany(keys) {
        for (var i = 0; i < keys.length; i++) {
          this.delete(keys[i]);
        }
      }
      evict() {
        if (this.size > 0) {
          const item = this.first;
          this.items.delete(item.key);
          if (this.size === 0) {
            this.first = null;
            this.last = null;
          } else {
            this.first = item.next;
            this.first.prev = null;
          }
        }
      }
      expiresAt(key) {
        if (this.items.has(key)) {
          return this.items.get(key).expiry;
        }
      }
      get(key) {
        if (this.items.has(key)) {
          const item = this.items.get(key);
          if (this.ttl > 0 && item.expiry <= Date.now()) {
            this.delete(key);
            return;
          }
          return item.value;
        }
      }
      getMany(keys) {
        const result = [];
        for (var i = 0; i < keys.length; i++) {
          result.push(this.get(keys[i]));
        }
        return result;
      }
      keys() {
        return this.items.keys();
      }
      set(key, value) {
        if (this.items.has(key)) {
          const item2 = this.items.get(key);
          item2.value = value;
          item2.expiry = this.ttl > 0 ? Date.now() + this.ttl : this.ttl;
          return;
        }
        if (this.max > 0 && this.size === this.max) {
          this.evict();
        }
        const item = {
          expiry: this.ttl > 0 ? Date.now() + this.ttl : this.ttl,
          key,
          prev: this.last,
          next: null,
          value
        };
        this.items.set(key, item);
        if (this.size === 1) {
          this.first = item;
        } else {
          this.last.next = item;
        }
        this.last = item;
      }
    };
    var LruMap = class {
      constructor(max = 1e3, ttlInMsecs = 0) {
        if (isNaN(max) || max < 0) {
          throw new Error("Invalid max value");
        }
        if (isNaN(ttlInMsecs) || ttlInMsecs < 0) {
          throw new Error("Invalid ttl value");
        }
        this.first = null;
        this.items = /* @__PURE__ */ new Map();
        this.last = null;
        this.max = max;
        this.ttl = ttlInMsecs;
      }
      get size() {
        return this.items.size;
      }
      bumpLru(item) {
        if (this.last === item) {
          return;
        }
        const last = this.last;
        const next = item.next;
        const prev = item.prev;
        if (this.first === item) {
          this.first = next;
        }
        item.next = null;
        item.prev = last;
        last.next = item;
        if (prev !== null) {
          prev.next = next;
        }
        if (next !== null) {
          next.prev = prev;
        }
        this.last = item;
      }
      clear() {
        this.items = /* @__PURE__ */ new Map();
        this.first = null;
        this.last = null;
      }
      delete(key) {
        if (this.items.has(key)) {
          const item = this.items.get(key);
          this.items.delete(key);
          if (item.prev !== null) {
            item.prev.next = item.next;
          }
          if (item.next !== null) {
            item.next.prev = item.prev;
          }
          if (this.first === item) {
            this.first = item.next;
          }
          if (this.last === item) {
            this.last = item.prev;
          }
        }
      }
      deleteMany(keys) {
        for (var i = 0; i < keys.length; i++) {
          this.delete(keys[i]);
        }
      }
      evict() {
        if (this.size > 0) {
          const item = this.first;
          this.items.delete(item.key);
          if (this.size === 0) {
            this.first = null;
            this.last = null;
          } else {
            this.first = item.next;
            this.first.prev = null;
          }
        }
      }
      expiresAt(key) {
        if (this.items.has(key)) {
          return this.items.get(key).expiry;
        }
      }
      get(key) {
        if (this.items.has(key)) {
          const item = this.items.get(key);
          if (this.ttl > 0 && item.expiry <= Date.now()) {
            this.delete(key);
            return;
          }
          this.bumpLru(item);
          return item.value;
        }
      }
      getMany(keys) {
        const result = [];
        for (var i = 0; i < keys.length; i++) {
          result.push(this.get(keys[i]));
        }
        return result;
      }
      keys() {
        return this.items.keys();
      }
      set(key, value) {
        if (this.items.has(key)) {
          const item2 = this.items.get(key);
          item2.value = value;
          item2.expiry = this.ttl > 0 ? Date.now() + this.ttl : this.ttl;
          if (this.last !== item2) {
            this.bumpLru(item2);
          }
          return;
        }
        if (this.max > 0 && this.size === this.max) {
          this.evict();
        }
        const item = {
          expiry: this.ttl > 0 ? Date.now() + this.ttl : this.ttl,
          key,
          prev: this.last,
          next: null,
          value
        };
        this.items.set(key, item);
        if (this.size === 1) {
          this.first = item;
        } else {
          this.last.next = item;
        }
        this.last = item;
      }
    };
    var LruObject = class {
      constructor(max = 1e3, ttlInMsecs = 0) {
        if (isNaN(max) || max < 0) {
          throw new Error("Invalid max value");
        }
        if (isNaN(ttlInMsecs) || ttlInMsecs < 0) {
          throw new Error("Invalid ttl value");
        }
        this.first = null;
        this.items = /* @__PURE__ */ Object.create(null);
        this.last = null;
        this.size = 0;
        this.max = max;
        this.ttl = ttlInMsecs;
      }
      bumpLru(item) {
        if (this.last === item) {
          return;
        }
        const last = this.last;
        const next = item.next;
        const prev = item.prev;
        if (this.first === item) {
          this.first = next;
        }
        item.next = null;
        item.prev = last;
        last.next = item;
        if (prev !== null) {
          prev.next = next;
        }
        if (next !== null) {
          next.prev = prev;
        }
        this.last = item;
      }
      clear() {
        this.items = /* @__PURE__ */ Object.create(null);
        this.first = null;
        this.last = null;
        this.size = 0;
      }
      delete(key) {
        if (Object.prototype.hasOwnProperty.call(this.items, key)) {
          const item = this.items[key];
          delete this.items[key];
          this.size--;
          if (item.prev !== null) {
            item.prev.next = item.next;
          }
          if (item.next !== null) {
            item.next.prev = item.prev;
          }
          if (this.first === item) {
            this.first = item.next;
          }
          if (this.last === item) {
            this.last = item.prev;
          }
        }
      }
      deleteMany(keys) {
        for (var i = 0; i < keys.length; i++) {
          this.delete(keys[i]);
        }
      }
      evict() {
        if (this.size > 0) {
          const item = this.first;
          delete this.items[item.key];
          if (--this.size === 0) {
            this.first = null;
            this.last = null;
          } else {
            this.first = item.next;
            this.first.prev = null;
          }
        }
      }
      expiresAt(key) {
        if (Object.prototype.hasOwnProperty.call(this.items, key)) {
          return this.items[key].expiry;
        }
      }
      get(key) {
        if (Object.prototype.hasOwnProperty.call(this.items, key)) {
          const item = this.items[key];
          if (this.ttl > 0 && item.expiry <= Date.now()) {
            this.delete(key);
            return;
          }
          this.bumpLru(item);
          return item.value;
        }
      }
      getMany(keys) {
        const result = [];
        for (var i = 0; i < keys.length; i++) {
          result.push(this.get(keys[i]));
        }
        return result;
      }
      keys() {
        return Object.keys(this.items);
      }
      set(key, value) {
        if (Object.prototype.hasOwnProperty.call(this.items, key)) {
          const item2 = this.items[key];
          item2.value = value;
          item2.expiry = this.ttl > 0 ? Date.now() + this.ttl : this.ttl;
          if (this.last !== item2) {
            this.bumpLru(item2);
          }
          return;
        }
        if (this.max > 0 && this.size === this.max) {
          this.evict();
        }
        const item = {
          expiry: this.ttl > 0 ? Date.now() + this.ttl : this.ttl,
          key,
          prev: this.last,
          next: null,
          value
        };
        this.items[key] = item;
        if (++this.size === 1) {
          this.first = item;
        } else {
          this.last.next = item;
        }
        this.last = item;
      }
    };
    var HitStatisticsRecord = class {
      constructor() {
        this.records = {};
      }
      initForCache(cacheId, currentTimeStamp) {
        this.records[cacheId] = {
          [currentTimeStamp]: {
            cacheSize: 0,
            hits: 0,
            falsyHits: 0,
            emptyHits: 0,
            misses: 0,
            expirations: 0,
            evictions: 0,
            invalidateOne: 0,
            invalidateAll: 0,
            sets: 0
          }
        };
      }
      resetForCache(cacheId) {
        for (let key of Object.keys(this.records[cacheId])) {
          this.records[cacheId][key] = {
            cacheSize: 0,
            hits: 0,
            falsyHits: 0,
            emptyHits: 0,
            misses: 0,
            expirations: 0,
            evictions: 0,
            invalidateOne: 0,
            invalidateAll: 0,
            sets: 0
          };
        }
      }
      getStatistics() {
        return this.records;
      }
    };
    function getTimestamp(date) {
      return `${date.getFullYear()}-${(date.getMonth() + 1).toString().padStart(2, "0")}-${date.getDate().toString().padStart(2, "0")}`;
    }
    var HitStatistics = class {
      constructor(cacheId, statisticTtlInHours, globalStatisticsRecord) {
        this.cacheId = cacheId;
        this.statisticTtlInHours = statisticTtlInHours;
        this.collectionStart = /* @__PURE__ */ new Date();
        this.currentTimeStamp = getTimestamp(this.collectionStart);
        this.records = globalStatisticsRecord || new HitStatisticsRecord();
        this.records.initForCache(this.cacheId, this.currentTimeStamp);
      }
      get currentRecord() {
        if (!this.records.records[this.cacheId][this.currentTimeStamp]) {
          this.records.records[this.cacheId][this.currentTimeStamp] = {
            cacheSize: 0,
            hits: 0,
            falsyHits: 0,
            emptyHits: 0,
            misses: 0,
            expirations: 0,
            evictions: 0,
            sets: 0,
            invalidateOne: 0,
            invalidateAll: 0
          };
        }
        return this.records.records[this.cacheId][this.currentTimeStamp];
      }
      hoursPassed() {
        return (Date.now() - this.collectionStart) / 1e3 / 60 / 60;
      }
      addHit() {
        this.archiveIfNeeded();
        this.currentRecord.hits++;
      }
      addFalsyHit() {
        this.archiveIfNeeded();
        this.currentRecord.falsyHits++;
      }
      addEmptyHit() {
        this.archiveIfNeeded();
        this.currentRecord.emptyHits++;
      }
      addMiss() {
        this.archiveIfNeeded();
        this.currentRecord.misses++;
      }
      addEviction() {
        this.archiveIfNeeded();
        this.currentRecord.evictions++;
      }
      setCacheSize(currentSize) {
        this.archiveIfNeeded();
        this.currentRecord.cacheSize = currentSize;
      }
      addExpiration() {
        this.archiveIfNeeded();
        this.currentRecord.expirations++;
      }
      addSet() {
        this.archiveIfNeeded();
        this.currentRecord.sets++;
      }
      addInvalidateOne() {
        this.archiveIfNeeded();
        this.currentRecord.invalidateOne++;
      }
      addInvalidateAll() {
        this.archiveIfNeeded();
        this.currentRecord.invalidateAll++;
      }
      getStatistics() {
        return this.records.getStatistics();
      }
      archiveIfNeeded() {
        if (this.hoursPassed() >= this.statisticTtlInHours) {
          this.collectionStart = /* @__PURE__ */ new Date();
          this.currentTimeStamp = getTimestamp(this.collectionStart);
          this.records.initForCache(this.cacheId, this.currentTimeStamp);
        }
      }
    };
    var LruObjectHitStatistics = class extends LruObject {
      constructor(max, ttlInMsecs, cacheId, globalStatisticsRecord, statisticTtlInHours) {
        super(max || 1e3, ttlInMsecs || 0);
        if (!cacheId) {
          throw new Error("Cache id is mandatory");
        }
        this.hitStatistics = new HitStatistics(
          cacheId,
          statisticTtlInHours !== void 0 ? statisticTtlInHours : 24,
          globalStatisticsRecord
        );
      }
      getStatistics() {
        return this.hitStatistics.getStatistics();
      }
      set(key, value) {
        super.set(key, value);
        this.hitStatistics.addSet();
        this.hitStatistics.setCacheSize(this.size);
      }
      evict() {
        super.evict();
        this.hitStatistics.addEviction();
        this.hitStatistics.setCacheSize(this.size);
      }
      delete(key, isExpiration = false) {
        super.delete(key);
        if (!isExpiration) {
          this.hitStatistics.addInvalidateOne();
        }
        this.hitStatistics.setCacheSize(this.size);
      }
      clear() {
        super.clear();
        this.hitStatistics.addInvalidateAll();
        this.hitStatistics.setCacheSize(this.size);
      }
      get(key) {
        if (Object.prototype.hasOwnProperty.call(this.items, key)) {
          const item = this.items[key];
          if (this.ttl > 0 && item.expiry <= Date.now()) {
            this.delete(key, true);
            this.hitStatistics.addExpiration();
            return;
          }
          this.bumpLru(item);
          if (!item.value) {
            this.hitStatistics.addFalsyHit();
          }
          if (item.value === void 0 || item.value === null || item.value === "") {
            this.hitStatistics.addEmptyHit();
          }
          this.hitStatistics.addHit();
          return item.value;
        }
        this.hitStatistics.addMiss();
      }
    };
    var FifoObject = class {
      constructor(max = 1e3, ttlInMsecs = 0) {
        if (isNaN(max) || max < 0) {
          throw new Error("Invalid max value");
        }
        if (isNaN(ttlInMsecs) || ttlInMsecs < 0) {
          throw new Error("Invalid ttl value");
        }
        this.first = null;
        this.items = /* @__PURE__ */ Object.create(null);
        this.last = null;
        this.size = 0;
        this.max = max;
        this.ttl = ttlInMsecs;
      }
      clear() {
        this.items = /* @__PURE__ */ Object.create(null);
        this.first = null;
        this.last = null;
        this.size = 0;
      }
      delete(key) {
        if (Object.prototype.hasOwnProperty.call(this.items, key)) {
          const deletedItem = this.items[key];
          delete this.items[key];
          this.size--;
          if (deletedItem.prev !== null) {
            deletedItem.prev.next = deletedItem.next;
          }
          if (deletedItem.next !== null) {
            deletedItem.next.prev = deletedItem.prev;
          }
          if (this.first === deletedItem) {
            this.first = deletedItem.next;
          }
          if (this.last === deletedItem) {
            this.last = deletedItem.prev;
          }
        }
      }
      deleteMany(keys) {
        for (var i = 0; i < keys.length; i++) {
          this.delete(keys[i]);
        }
      }
      evict() {
        if (this.size > 0) {
          const item = this.first;
          delete this.items[item.key];
          if (--this.size === 0) {
            this.first = null;
            this.last = null;
          } else {
            this.first = item.next;
            this.first.prev = null;
          }
        }
      }
      expiresAt(key) {
        if (Object.prototype.hasOwnProperty.call(this.items, key)) {
          return this.items[key].expiry;
        }
      }
      get(key) {
        if (Object.prototype.hasOwnProperty.call(this.items, key)) {
          const item = this.items[key];
          if (this.ttl > 0 && item.expiry <= Date.now()) {
            this.delete(key);
            return;
          }
          return item.value;
        }
      }
      getMany(keys) {
        const result = [];
        for (var i = 0; i < keys.length; i++) {
          result.push(this.get(keys[i]));
        }
        return result;
      }
      keys() {
        return Object.keys(this.items);
      }
      set(key, value) {
        if (Object.prototype.hasOwnProperty.call(this.items, key)) {
          const item2 = this.items[key];
          item2.value = value;
          item2.expiry = this.ttl > 0 ? Date.now() + this.ttl : this.ttl;
          return;
        }
        if (this.max > 0 && this.size === this.max) {
          this.evict();
        }
        const item = {
          expiry: this.ttl > 0 ? Date.now() + this.ttl : this.ttl,
          key,
          prev: this.last,
          next: null,
          value
        };
        this.items[key] = item;
        if (++this.size === 1) {
          this.first = item;
        } else {
          this.last.next = item;
        }
        this.last = item;
      }
    };
    exports2.Fifo = FifoObject;
    exports2.FifoMap = FifoMap;
    exports2.FifoObject = FifoObject;
    exports2.HitStatisticsRecord = HitStatisticsRecord;
    exports2.Lru = LruObject;
    exports2.LruHitStatistics = LruObjectHitStatistics;
    exports2.LruMap = LruMap;
    exports2.LruObject = LruObject;
    exports2.LruObjectHitStatistics = LruObjectHitStatistics;
  }
});

// node_modules/secure-json-parse/index.js
var require_secure_json_parse = __commonJS({
  "node_modules/secure-json-parse/index.js"(exports2, module2) {
    "use strict";
    var hasBuffer = typeof Buffer !== "undefined";
    var suspectProtoRx = /"(?:_|\\u005[Ff])(?:_|\\u005[Ff])(?:p|\\u0070)(?:r|\\u0072)(?:o|\\u006[Ff])(?:t|\\u0074)(?:o|\\u006[Ff])(?:_|\\u005[Ff])(?:_|\\u005[Ff])"\s*:/;
    var suspectConstructorRx = /"(?:c|\\u0063)(?:o|\\u006[Ff])(?:n|\\u006[Ee])(?:s|\\u0073)(?:t|\\u0074)(?:r|\\u0072)(?:u|\\u0075)(?:c|\\u0063)(?:t|\\u0074)(?:o|\\u006[Ff])(?:r|\\u0072)"\s*:/;
    function _parse(text, reviver, options) {
      if (options == null) {
        if (reviver !== null && typeof reviver === "object") {
          options = reviver;
          reviver = void 0;
        }
      }
      if (hasBuffer && Buffer.isBuffer(text)) {
        text = text.toString();
      }
      if (text && text.charCodeAt(0) === 65279) {
        text = text.slice(1);
      }
      const obj = JSON.parse(text, reviver);
      if (obj === null || typeof obj !== "object") {
        return obj;
      }
      const protoAction = options && options.protoAction || "error";
      const constructorAction = options && options.constructorAction || "error";
      if (protoAction === "ignore" && constructorAction === "ignore") {
        return obj;
      }
      if (protoAction !== "ignore" && constructorAction !== "ignore") {
        if (suspectProtoRx.test(text) === false && suspectConstructorRx.test(text) === false) {
          return obj;
        }
      } else if (protoAction !== "ignore" && constructorAction === "ignore") {
        if (suspectProtoRx.test(text) === false) {
          return obj;
        }
      } else {
        if (suspectConstructorRx.test(text) === false) {
          return obj;
        }
      }
      return filter(obj, { protoAction, constructorAction, safe: options && options.safe });
    }
    function filter(obj, { protoAction = "error", constructorAction = "error", safe } = {}) {
      let next = [obj];
      while (next.length) {
        const nodes = next;
        next = [];
        for (const node of nodes) {
          if (protoAction !== "ignore" && Object.prototype.hasOwnProperty.call(node, "__proto__")) {
            if (safe === true) {
              return null;
            } else if (protoAction === "error") {
              throw new SyntaxError("Object contains forbidden prototype property");
            }
            delete node.__proto__;
          }
          if (constructorAction !== "ignore" && Object.prototype.hasOwnProperty.call(node, "constructor") && Object.prototype.hasOwnProperty.call(node.constructor, "prototype")) {
            if (safe === true) {
              return null;
            } else if (constructorAction === "error") {
              throw new SyntaxError("Object contains forbidden prototype property");
            }
            delete node.constructor;
          }
          for (const key in node) {
            const value = node[key];
            if (value && typeof value === "object") {
              next.push(value);
            }
          }
        }
      }
      return obj;
    }
    function parse(text, reviver, options) {
      const { stackTraceLimit } = Error;
      Error.stackTraceLimit = 0;
      try {
        return _parse(text, reviver, options);
      } finally {
        Error.stackTraceLimit = stackTraceLimit;
      }
    }
    function safeParse(text, reviver) {
      const { stackTraceLimit } = Error;
      Error.stackTraceLimit = 0;
      try {
        return _parse(text, reviver, { safe: true });
      } catch {
        return void 0;
      } finally {
        Error.stackTraceLimit = stackTraceLimit;
      }
    }
    module2.exports = parse;
    module2.exports.default = parse;
    module2.exports.parse = parse;
    module2.exports.safeParse = safeParse;
    module2.exports.scan = filter;
  }
});

// node_modules/fastify/lib/contentTypeParser.js
var require_contentTypeParser = __commonJS({
  "node_modules/fastify/lib/contentTypeParser.js"(exports2, module2) {
    "use strict";
    var { AsyncResource } = require("node:async_hooks");
    var { FifoMap: Fifo } = require_toad_cache();
    var { parse: secureJsonParse } = require_secure_json_parse();
    var {
      kDefaultJsonParse,
      kContentTypeParser,
      kBodyLimit,
      kRequestPayloadStream,
      kState,
      kTestInternals,
      kReplyIsError,
      kRouteContext
    } = require_symbols2();
    var {
      FST_ERR_CTP_INVALID_TYPE,
      FST_ERR_CTP_EMPTY_TYPE,
      FST_ERR_CTP_ALREADY_PRESENT,
      FST_ERR_CTP_INVALID_HANDLER,
      FST_ERR_CTP_INVALID_PARSE_TYPE,
      FST_ERR_CTP_BODY_TOO_LARGE,
      FST_ERR_CTP_INVALID_MEDIA_TYPE,
      FST_ERR_CTP_INVALID_CONTENT_LENGTH,
      FST_ERR_CTP_EMPTY_JSON_BODY,
      FST_ERR_CTP_INSTANCE_ALREADY_STARTED
    } = require_errors2();
    var { FSTSEC001 } = require_warnings();
    function ContentTypeParser(bodyLimit, onProtoPoisoning, onConstructorPoisoning) {
      this[kDefaultJsonParse] = getDefaultJsonParser(onProtoPoisoning, onConstructorPoisoning);
      this.customParsers = /* @__PURE__ */ new Map();
      this.customParsers.set("application/json", new Parser(true, false, bodyLimit, this[kDefaultJsonParse]));
      this.customParsers.set("text/plain", new Parser(true, false, bodyLimit, defaultPlainTextParser));
      this.parserList = ["application/json", "text/plain"];
      this.parserRegExpList = [];
      this.cache = new Fifo(100);
    }
    ContentTypeParser.prototype.add = function(contentType, opts, parserFn) {
      const contentTypeIsString = typeof contentType === "string";
      if (contentTypeIsString) {
        contentType = contentType.trim().toLowerCase();
        if (contentType.length === 0) throw new FST_ERR_CTP_EMPTY_TYPE();
      } else if (!(contentType instanceof RegExp)) {
        throw new FST_ERR_CTP_INVALID_TYPE();
      }
      if (typeof parserFn !== "function") {
        throw new FST_ERR_CTP_INVALID_HANDLER();
      }
      if (this.existingParser(contentType)) {
        throw new FST_ERR_CTP_ALREADY_PRESENT(contentType);
      }
      if (opts.parseAs !== void 0) {
        if (opts.parseAs !== "string" && opts.parseAs !== "buffer") {
          throw new FST_ERR_CTP_INVALID_PARSE_TYPE(opts.parseAs);
        }
      }
      const parser = new Parser(
        opts.parseAs === "string",
        opts.parseAs === "buffer",
        opts.bodyLimit,
        parserFn
      );
      if (contentType === "*") {
        this.customParsers.set("", parser);
      } else {
        if (contentTypeIsString) {
          this.parserList.unshift(contentType);
          this.customParsers.set(contentType, parser);
        } else {
          validateRegExp(contentType);
          this.parserRegExpList.unshift(contentType);
          this.customParsers.set(contentType.toString(), parser);
        }
      }
    };
    ContentTypeParser.prototype.hasParser = function(contentType) {
      if (typeof contentType === "string") {
        contentType = contentType.trim().toLowerCase();
      } else {
        if (!(contentType instanceof RegExp)) throw new FST_ERR_CTP_INVALID_TYPE();
        contentType = contentType.toString();
      }
      return this.customParsers.has(contentType);
    };
    ContentTypeParser.prototype.existingParser = function(contentType) {
      if (contentType === "application/json" && this.customParsers.has(contentType)) {
        return this.customParsers.get(contentType).fn !== this[kDefaultJsonParse];
      }
      if (contentType === "text/plain" && this.customParsers.has(contentType)) {
        return this.customParsers.get(contentType).fn !== defaultPlainTextParser;
      }
      return this.hasParser(contentType);
    };
    ContentTypeParser.prototype.getParser = function(contentType) {
      let parser = this.customParsers.get(contentType);
      if (parser !== void 0) return parser;
      parser = this.cache.get(contentType);
      if (parser !== void 0) return parser;
      const caseInsensitiveContentType = contentType.toLowerCase();
      for (let i = 0; i !== this.parserList.length; ++i) {
        const parserListItem = this.parserList[i];
        if (caseInsensitiveContentType.slice(0, parserListItem.length) === parserListItem && (caseInsensitiveContentType.length === parserListItem.length || caseInsensitiveContentType.charCodeAt(parserListItem.length) === 59 || caseInsensitiveContentType.charCodeAt(parserListItem.length) === 32)) {
          parser = this.customParsers.get(parserListItem);
          this.cache.set(contentType, parser);
          return parser;
        }
      }
      for (let j = 0; j !== this.parserRegExpList.length; ++j) {
        const parserRegExp = this.parserRegExpList[j];
        if (parserRegExp.test(contentType)) {
          parser = this.customParsers.get(parserRegExp.toString());
          this.cache.set(contentType, parser);
          return parser;
        }
      }
      return this.customParsers.get("");
    };
    ContentTypeParser.prototype.removeAll = function() {
      this.customParsers = /* @__PURE__ */ new Map();
      this.parserRegExpList = [];
      this.parserList = [];
      this.cache = new Fifo(100);
    };
    ContentTypeParser.prototype.remove = function(contentType) {
      let parsers;
      if (typeof contentType === "string") {
        contentType = contentType.trim().toLowerCase();
        parsers = this.parserList;
      } else {
        if (!(contentType instanceof RegExp)) throw new FST_ERR_CTP_INVALID_TYPE();
        contentType = contentType.toString();
        parsers = this.parserRegExpList;
      }
      const removed = this.customParsers.delete(contentType);
      const idx = parsers.findIndex((ct) => ct.toString() === contentType);
      if (idx > -1) {
        parsers.splice(idx, 1);
      }
      return removed || idx > -1;
    };
    ContentTypeParser.prototype.run = function(contentType, handler, request, reply) {
      const parser = this.getParser(contentType);
      if (parser === void 0) {
        if (request.is404) {
          handler(request, reply);
        } else {
          reply.send(new FST_ERR_CTP_INVALID_MEDIA_TYPE(contentType || void 0));
        }
        return;
      }
      const resource = new AsyncResource("content-type-parser:run", request);
      if (parser.asString === true || parser.asBuffer === true) {
        rawBody(
          request,
          reply,
          reply[kRouteContext]._parserOptions,
          parser,
          done
        );
      } else {
        const result = parser.fn(request, request[kRequestPayloadStream], done);
        if (result && typeof result.then === "function") {
          result.then((body) => done(null, body), done);
        }
      }
      function done(error, body) {
        resource.runInAsyncScope(() => {
          resource.emitDestroy();
          if (error) {
            reply[kReplyIsError] = true;
            reply.send(error);
          } else {
            request.body = body;
            handler(request, reply);
          }
        });
      }
    };
    function rawBody(request, reply, options, parser, done) {
      const asString = parser.asString;
      const limit = options.limit === null ? parser.bodyLimit : options.limit;
      const contentLength = Number(request.headers["content-length"]);
      if (contentLength > limit) {
        reply.header("connection", "close");
        reply.send(new FST_ERR_CTP_BODY_TOO_LARGE());
        return;
      }
      let receivedLength = 0;
      let body = asString === true ? "" : [];
      const payload = request[kRequestPayloadStream] || request.raw;
      if (asString === true) {
        payload.setEncoding("utf8");
      }
      payload.on("data", onData);
      payload.on("end", onEnd);
      payload.on("error", onEnd);
      payload.resume();
      function onData(chunk) {
        receivedLength += chunk.length;
        const { receivedEncodedLength = 0 } = payload;
        if (receivedLength > limit || receivedEncodedLength > limit) {
          payload.removeListener("data", onData);
          payload.removeListener("end", onEnd);
          payload.removeListener("error", onEnd);
          reply.send(new FST_ERR_CTP_BODY_TOO_LARGE());
          return;
        }
        if (asString === true) {
          body += chunk;
        } else {
          body.push(chunk);
        }
      }
      function onEnd(err) {
        payload.removeListener("data", onData);
        payload.removeListener("end", onEnd);
        payload.removeListener("error", onEnd);
        if (err !== void 0) {
          if (!(typeof err.statusCode === "number" && err.statusCode >= 400)) {
            err.statusCode = 400;
          }
          reply[kReplyIsError] = true;
          reply.code(err.statusCode).send(err);
          return;
        }
        if (asString === true) {
          receivedLength = Buffer.byteLength(body);
        }
        if (!Number.isNaN(contentLength) && (payload.receivedEncodedLength || receivedLength) !== contentLength) {
          reply.header("connection", "close");
          reply.send(new FST_ERR_CTP_INVALID_CONTENT_LENGTH());
          return;
        }
        if (asString === false) {
          body = Buffer.concat(body);
        }
        const result = parser.fn(request, body, done);
        if (result && typeof result.then === "function") {
          result.then((body2) => done(null, body2), done);
        }
      }
    }
    function getDefaultJsonParser(onProtoPoisoning, onConstructorPoisoning) {
      return defaultJsonParser;
      function defaultJsonParser(req, body, done) {
        if (body.length === 0) {
          done(new FST_ERR_CTP_EMPTY_JSON_BODY(), void 0);
          return;
        }
        try {
          done(null, secureJsonParse(body, { protoAction: onProtoPoisoning, constructorAction: onConstructorPoisoning }));
        } catch (err) {
          err.statusCode = 400;
          done(err, void 0);
        }
      }
    }
    function defaultPlainTextParser(req, body, done) {
      done(null, body);
    }
    function Parser(asString, asBuffer, bodyLimit, fn) {
      this.asString = asString;
      this.asBuffer = asBuffer;
      this.bodyLimit = bodyLimit;
      this.fn = fn;
    }
    function buildContentTypeParser(c) {
      const contentTypeParser = new ContentTypeParser();
      contentTypeParser[kDefaultJsonParse] = c[kDefaultJsonParse];
      contentTypeParser.customParsers = new Map(c.customParsers.entries());
      contentTypeParser.parserList = c.parserList.slice();
      contentTypeParser.parserRegExpList = c.parserRegExpList.slice();
      return contentTypeParser;
    }
    function addContentTypeParser(contentType, opts, parser) {
      if (this[kState].started) {
        throw new FST_ERR_CTP_INSTANCE_ALREADY_STARTED("addContentTypeParser");
      }
      if (typeof opts === "function") {
        parser = opts;
        opts = {};
      }
      if (!opts) opts = {};
      if (!opts.bodyLimit) opts.bodyLimit = this[kBodyLimit];
      if (Array.isArray(contentType)) {
        contentType.forEach((type) => this[kContentTypeParser].add(type, opts, parser));
      } else {
        this[kContentTypeParser].add(contentType, opts, parser);
      }
      return this;
    }
    function hasContentTypeParser(contentType) {
      return this[kContentTypeParser].hasParser(contentType);
    }
    function removeContentTypeParser(contentType) {
      if (this[kState].started) {
        throw new FST_ERR_CTP_INSTANCE_ALREADY_STARTED("removeContentTypeParser");
      }
      if (Array.isArray(contentType)) {
        for (const type of contentType) {
          this[kContentTypeParser].remove(type);
        }
      } else {
        this[kContentTypeParser].remove(contentType);
      }
    }
    function removeAllContentTypeParsers() {
      if (this[kState].started) {
        throw new FST_ERR_CTP_INSTANCE_ALREADY_STARTED("removeAllContentTypeParsers");
      }
      this[kContentTypeParser].removeAll();
    }
    function validateRegExp(regexp) {
      if (regexp.source[0] !== "^" && regexp.source.includes(";?") === false) {
        FSTSEC001(regexp.source);
      }
    }
    module2.exports = ContentTypeParser;
    module2.exports.helpers = {
      buildContentTypeParser,
      addContentTypeParser,
      hasContentTypeParser,
      removeContentTypeParser,
      removeAllContentTypeParsers
    };
    module2.exports.defaultParsers = {
      getDefaultJsonParser,
      defaultTextParser: defaultPlainTextParser
    };
    module2.exports[kTestInternals] = { rawBody };
  }
});

// node_modules/dequal/dist/index.js
var require_dist = __commonJS({
  "node_modules/dequal/dist/index.js"(exports2) {
    var has = Object.prototype.hasOwnProperty;
    function find(iter, tar, key) {
      for (key of iter.keys()) {
        if (dequal(key, tar)) return key;
      }
    }
    function dequal(foo, bar) {
      var ctor, len, tmp;
      if (foo === bar) return true;
      if (foo && bar && (ctor = foo.constructor) === bar.constructor) {
        if (ctor === Date) return foo.getTime() === bar.getTime();
        if (ctor === RegExp) return foo.toString() === bar.toString();
        if (ctor === Array) {
          if ((len = foo.length) === bar.length) {
            while (len-- && dequal(foo[len], bar[len])) ;
          }
          return len === -1;
        }
        if (ctor === Set) {
          if (foo.size !== bar.size) {
            return false;
          }
          for (len of foo) {
            tmp = len;
            if (tmp && typeof tmp === "object") {
              tmp = find(bar, tmp);
              if (!tmp) return false;
            }
            if (!bar.has(tmp)) return false;
          }
          return true;
        }
        if (ctor === Map) {
          if (foo.size !== bar.size) {
            return false;
          }
          for (len of foo) {
            tmp = len[0];
            if (tmp && typeof tmp === "object") {
              tmp = find(bar, tmp);
              if (!tmp) return false;
            }
            if (!dequal(len[1], bar.get(tmp))) {
              return false;
            }
          }
          return true;
        }
        if (ctor === ArrayBuffer) {
          foo = new Uint8Array(foo);
          bar = new Uint8Array(bar);
        } else if (ctor === DataView) {
          if ((len = foo.byteLength) === bar.byteLength) {
            while (len-- && foo.getInt8(len) === bar.getInt8(len)) ;
          }
          return len === -1;
        }
        if (ArrayBuffer.isView(foo)) {
          if ((len = foo.byteLength) === bar.byteLength) {
            while (len-- && foo[len] === bar[len]) ;
          }
          return len === -1;
        }
        if (!ctor || typeof foo === "object") {
          len = 0;
          for (ctor in foo) {
            if (has.call(foo, ctor) && ++len && !has.call(bar, ctor)) return false;
            if (!(ctor in bar) || !dequal(foo[ctor], bar[ctor])) return false;
          }
          return Object.keys(bar).length === len;
        }
      }
      return foo !== foo && bar !== bar;
    }
    exports2.dequal = dequal;
  }
});

// node_modules/json-schema-ref-resolver/index.js
var require_json_schema_ref_resolver = __commonJS({
  "node_modules/json-schema-ref-resolver/index.js"(exports2, module2) {
    "use strict";
    var { dequal: deepEqual } = require_dist();
    var jsonSchemaRefSymbol = Symbol.for("json-schema-ref");
    var RefResolver = class {
      #schemas;
      #derefSchemas;
      #insertRefSymbol;
      #allowEqualDuplicates;
      #cloneSchemaWithoutRefs;
      constructor(opts = {}) {
        this.#schemas = {};
        this.#derefSchemas = {};
        this.#insertRefSymbol = opts.insertRefSymbol ?? false;
        this.#allowEqualDuplicates = opts.allowEqualDuplicates ?? true;
        this.#cloneSchemaWithoutRefs = opts.cloneSchemaWithoutRefs ?? false;
      }
      addSchema(schema, rootSchemaId, isRootSchema = true) {
        if (isRootSchema) {
          if (schema.$id !== void 0 && schema.$id.charAt(0) !== "#") {
            rootSchemaId = schema.$id;
          } else {
            this.#insertSchemaBySchemaId(schema, rootSchemaId);
          }
        }
        const schemaId = schema.$id;
        if (schemaId !== void 0 && typeof schemaId === "string") {
          if (schemaId.charAt(0) === "#") {
            this.#insertSchemaByAnchor(schema, rootSchemaId, schemaId);
          } else {
            this.#insertSchemaBySchemaId(schema, schemaId);
            rootSchemaId = schemaId;
          }
        }
        const ref = schema.$ref;
        if (ref !== void 0 && typeof ref === "string") {
          const { refSchemaId, refJsonPointer } = this.#parseSchemaRef(ref, rootSchemaId);
          this.#schemas[rootSchemaId].refs.push({
            schemaId: refSchemaId,
            jsonPointer: refJsonPointer
          });
        }
        for (const key in schema) {
          if (typeof schema[key] === "object" && schema[key] !== null) {
            this.addSchema(schema[key], rootSchemaId, false);
          }
        }
      }
      getSchema(schemaId, jsonPointer = "#") {
        const schema = this.#schemas[schemaId];
        if (schema === void 0) {
          throw new Error(
            `Cannot resolve ref "${schemaId}${jsonPointer}". Schema with id "${schemaId}" is not found.`
          );
        }
        if (schema.anchors[jsonPointer] !== void 0) {
          return schema.anchors[jsonPointer];
        }
        return getDataByJSONPointer(schema.schema, jsonPointer);
      }
      hasSchema(schemaId) {
        return this.#schemas[schemaId] !== void 0;
      }
      getSchemaRefs(schemaId) {
        const schema = this.#schemas[schemaId];
        if (schema === void 0) {
          throw new Error(`Schema with id "${schemaId}" is not found.`);
        }
        return schema.refs;
      }
      getSchemaDependencies(schemaId, dependencies = {}) {
        const schema = this.#schemas[schemaId];
        for (const ref of schema.refs) {
          const dependencySchemaId = ref.schemaId;
          if (dependencySchemaId === schemaId || dependencies[dependencySchemaId] !== void 0) continue;
          dependencies[dependencySchemaId] = this.getSchema(dependencySchemaId);
          this.getSchemaDependencies(dependencySchemaId, dependencies);
        }
        return dependencies;
      }
      derefSchema(schemaId) {
        if (this.#derefSchemas[schemaId] !== void 0) return;
        const schema = this.#schemas[schemaId];
        if (schema === void 0) {
          throw new Error(`Schema with id "${schemaId}" is not found.`);
        }
        if (!this.#cloneSchemaWithoutRefs && schema.refs.length === 0) {
          this.#derefSchemas[schemaId] = {
            schema: schema.schema,
            anchors: schema.anchors
          };
        }
        const refs = [];
        this.#addDerefSchema(schema.schema, schemaId, true, refs);
        const dependencies = this.getSchemaDependencies(schemaId);
        for (const schemaId2 in dependencies) {
          const schema2 = dependencies[schemaId2];
          this.#addDerefSchema(schema2, schemaId2, true, refs);
        }
        for (const ref of refs) {
          const {
            refSchemaId,
            refJsonPointer
          } = this.#parseSchemaRef(ref.ref, ref.sourceSchemaId);
          const targetSchema = this.getDerefSchema(refSchemaId, refJsonPointer);
          if (targetSchema === null) {
            throw new Error(
              `Cannot resolve ref "${ref.ref}". Ref "${refJsonPointer}" is not found in schema "${refSchemaId}".`
            );
          }
          ref.targetSchema = targetSchema;
          ref.targetSchemaId = refSchemaId;
        }
        for (const ref of refs) {
          this.#resolveRef(ref, refs);
        }
      }
      getDerefSchema(schemaId, jsonPointer = "#") {
        let derefSchema = this.#derefSchemas[schemaId];
        if (derefSchema === void 0) {
          this.derefSchema(schemaId);
          derefSchema = this.#derefSchemas[schemaId];
        }
        if (derefSchema.anchors[jsonPointer] !== void 0) {
          return derefSchema.anchors[jsonPointer];
        }
        return getDataByJSONPointer(derefSchema.schema, jsonPointer);
      }
      #parseSchemaRef(ref, schemaId) {
        const sharpIndex = ref.indexOf("#");
        if (sharpIndex === -1) {
          return { refSchemaId: ref, refJsonPointer: "#" };
        }
        if (sharpIndex === 0) {
          return { refSchemaId: schemaId, refJsonPointer: ref };
        }
        return {
          refSchemaId: ref.slice(0, sharpIndex),
          refJsonPointer: ref.slice(sharpIndex)
        };
      }
      #addDerefSchema(schema, rootSchemaId, isRootSchema, refs = []) {
        const derefSchema = Array.isArray(schema) ? [...schema] : { ...schema };
        if (isRootSchema) {
          if (schema.$id !== void 0 && schema.$id.charAt(0) !== "#") {
            rootSchemaId = schema.$id;
          } else {
            this.#insertDerefSchemaBySchemaId(derefSchema, rootSchemaId);
          }
        }
        const schemaId = derefSchema.$id;
        if (schemaId !== void 0 && typeof schemaId === "string") {
          if (schemaId.charAt(0) === "#") {
            this.#insertDerefSchemaByAnchor(derefSchema, rootSchemaId, schemaId);
          } else {
            this.#insertDerefSchemaBySchemaId(derefSchema, schemaId);
            rootSchemaId = schemaId;
          }
        }
        if (derefSchema.$ref !== void 0) {
          refs.push({
            ref: derefSchema.$ref,
            sourceSchemaId: rootSchemaId,
            sourceSchema: derefSchema
          });
        }
        for (const key in derefSchema) {
          const value = derefSchema[key];
          if (typeof value === "object" && value !== null) {
            derefSchema[key] = this.#addDerefSchema(value, rootSchemaId, false, refs);
          }
        }
        return derefSchema;
      }
      #resolveRef(ref, refs) {
        const { sourceSchema, targetSchema } = ref;
        if (!sourceSchema.$ref) return;
        if (this.#insertRefSymbol) {
          sourceSchema[jsonSchemaRefSymbol] = sourceSchema.$ref;
        }
        delete sourceSchema.$ref;
        if (targetSchema.$ref) {
          const targetSchemaRef = refs.find((ref2) => ref2.sourceSchema === targetSchema);
          this.#resolveRef(targetSchemaRef, refs);
        }
        for (const key in targetSchema) {
          if (key === "$id") continue;
          if (sourceSchema[key] !== void 0) {
            if (deepEqual(sourceSchema[key], targetSchema[key])) continue;
            throw new Error(
              `Cannot resolve ref "${ref.ref}". Property "${key}" already exists in schema "${ref.sourceSchemaId}".`
            );
          }
          sourceSchema[key] = targetSchema[key];
        }
        ref.isResolved = true;
      }
      #insertSchemaBySchemaId(schema, schemaId) {
        const foundSchema = this.#schemas[schemaId];
        if (foundSchema !== void 0) {
          if (this.#allowEqualDuplicates && deepEqual(schema, foundSchema.schema)) return;
          throw new Error(`There is already another schema with id "${schemaId}".`);
        }
        this.#schemas[schemaId] = { schema, anchors: {}, refs: [] };
      }
      #insertSchemaByAnchor(schema, schemaId, anchor) {
        const { anchors } = this.#schemas[schemaId];
        if (anchors[anchor] !== void 0) {
          throw new Error(`There is already another anchor "${anchor}" in schema "${schemaId}".`);
        }
        anchors[anchor] = schema;
      }
      #insertDerefSchemaBySchemaId(schema, schemaId) {
        const foundSchema = this.#derefSchemas[schemaId];
        if (foundSchema !== void 0) return;
        this.#derefSchemas[schemaId] = { schema, anchors: {} };
      }
      #insertDerefSchemaByAnchor(schema, schemaId, anchor) {
        const { anchors } = this.#derefSchemas[schemaId];
        anchors[anchor] = schema;
      }
    };
    function getDataByJSONPointer(data, jsonPointer) {
      const parts = jsonPointer.split("/");
      let current = data;
      for (const part of parts) {
        if (part === "" || part === "#") continue;
        if (typeof current !== "object" || current === null) {
          return null;
        }
        current = current[part];
      }
      return current ?? null;
    }
    module2.exports = { RefResolver };
  }
});

// node_modules/ajv/dist/compile/codegen/code.js
var require_code = __commonJS({
  "node_modules/ajv/dist/compile/codegen/code.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.regexpCode = exports2.getEsmExportName = exports2.getProperty = exports2.safeStringify = exports2.stringify = exports2.strConcat = exports2.addCodeArg = exports2.str = exports2._ = exports2.nil = exports2._Code = exports2.Name = exports2.IDENTIFIER = exports2._CodeOrName = void 0;
    var _CodeOrName = class {
    };
    exports2._CodeOrName = _CodeOrName;
    exports2.IDENTIFIER = /^[a-z$_][a-z$_0-9]*$/i;
    var Name = class extends _CodeOrName {
      constructor(s) {
        super();
        if (!exports2.IDENTIFIER.test(s))
          throw new Error("CodeGen: name must be a valid identifier");
        this.str = s;
      }
      toString() {
        return this.str;
      }
      emptyStr() {
        return false;
      }
      get names() {
        return { [this.str]: 1 };
      }
    };
    exports2.Name = Name;
    var _Code = class extends _CodeOrName {
      constructor(code) {
        super();
        this._items = typeof code === "string" ? [code] : code;
      }
      toString() {
        return this.str;
      }
      emptyStr() {
        if (this._items.length > 1)
          return false;
        const item = this._items[0];
        return item === "" || item === '""';
      }
      get str() {
        var _a;
        return (_a = this._str) !== null && _a !== void 0 ? _a : this._str = this._items.reduce((s, c) => `${s}${c}`, "");
      }
      get names() {
        var _a;
        return (_a = this._names) !== null && _a !== void 0 ? _a : this._names = this._items.reduce((names, c) => {
          if (c instanceof Name)
            names[c.str] = (names[c.str] || 0) + 1;
          return names;
        }, {});
      }
    };
    exports2._Code = _Code;
    exports2.nil = new _Code("");
    function _(strs, ...args) {
      const code = [strs[0]];
      let i = 0;
      while (i < args.length) {
        addCodeArg(code, args[i]);
        code.push(strs[++i]);
      }
      return new _Code(code);
    }
    exports2._ = _;
    var plus = new _Code("+");
    function str(strs, ...args) {
      const expr = [safeStringify(strs[0])];
      let i = 0;
      while (i < args.length) {
        expr.push(plus);
        addCodeArg(expr, args[i]);
        expr.push(plus, safeStringify(strs[++i]));
      }
      optimize(expr);
      return new _Code(expr);
    }
    exports2.str = str;
    function addCodeArg(code, arg) {
      if (arg instanceof _Code)
        code.push(...arg._items);
      else if (arg instanceof Name)
        code.push(arg);
      else
        code.push(interpolate(arg));
    }
    exports2.addCodeArg = addCodeArg;
    function optimize(expr) {
      let i = 1;
      while (i < expr.length - 1) {
        if (expr[i] === plus) {
          const res = mergeExprItems(expr[i - 1], expr[i + 1]);
          if (res !== void 0) {
            expr.splice(i - 1, 3, res);
            continue;
          }
          expr[i++] = "+";
        }
        i++;
      }
    }
    function mergeExprItems(a, b) {
      if (b === '""')
        return a;
      if (a === '""')
        return b;
      if (typeof a == "string") {
        if (b instanceof Name || a[a.length - 1] !== '"')
          return;
        if (typeof b != "string")
          return `${a.slice(0, -1)}${b}"`;
        if (b[0] === '"')
          return a.slice(0, -1) + b.slice(1);
        return;
      }
      if (typeof b == "string" && b[0] === '"' && !(a instanceof Name))
        return `"${a}${b.slice(1)}`;
      return;
    }
    function strConcat(c1, c2) {
      return c2.emptyStr() ? c1 : c1.emptyStr() ? c2 : str`${c1}${c2}`;
    }
    exports2.strConcat = strConcat;
    function interpolate(x) {
      return typeof x == "number" || typeof x == "boolean" || x === null ? x : safeStringify(Array.isArray(x) ? x.join(",") : x);
    }
    function stringify(x) {
      return new _Code(safeStringify(x));
    }
    exports2.stringify = stringify;
    function safeStringify(x) {
      return JSON.stringify(x).replace(/\u2028/g, "\\u2028").replace(/\u2029/g, "\\u2029");
    }
    exports2.safeStringify = safeStringify;
    function getProperty(key) {
      return typeof key == "string" && exports2.IDENTIFIER.test(key) ? new _Code(`.${key}`) : _`[${key}]`;
    }
    exports2.getProperty = getProperty;
    function getEsmExportName(key) {
      if (typeof key == "string" && exports2.IDENTIFIER.test(key)) {
        return new _Code(`${key}`);
      }
      throw new Error(`CodeGen: invalid export name: ${key}, use explicit $id name mapping`);
    }
    exports2.getEsmExportName = getEsmExportName;
    function regexpCode(rx) {
      return new _Code(rx.toString());
    }
    exports2.regexpCode = regexpCode;
  }
});

// node_modules/ajv/dist/compile/codegen/scope.js
var require_scope = __commonJS({
  "node_modules/ajv/dist/compile/codegen/scope.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ValueScope = exports2.ValueScopeName = exports2.Scope = exports2.varKinds = exports2.UsedValueState = void 0;
    var code_1 = require_code();
    var ValueError = class extends Error {
      constructor(name) {
        super(`CodeGen: "code" for ${name} not defined`);
        this.value = name.value;
      }
    };
    var UsedValueState;
    (function(UsedValueState2) {
      UsedValueState2[UsedValueState2["Started"] = 0] = "Started";
      UsedValueState2[UsedValueState2["Completed"] = 1] = "Completed";
    })(UsedValueState || (exports2.UsedValueState = UsedValueState = {}));
    exports2.varKinds = {
      const: new code_1.Name("const"),
      let: new code_1.Name("let"),
      var: new code_1.Name("var")
    };
    var Scope = class {
      constructor({ prefixes, parent } = {}) {
        this._names = {};
        this._prefixes = prefixes;
        this._parent = parent;
      }
      toName(nameOrPrefix) {
        return nameOrPrefix instanceof code_1.Name ? nameOrPrefix : this.name(nameOrPrefix);
      }
      name(prefix) {
        return new code_1.Name(this._newName(prefix));
      }
      _newName(prefix) {
        const ng = this._names[prefix] || this._nameGroup(prefix);
        return `${prefix}${ng.index++}`;
      }
      _nameGroup(prefix) {
        var _a, _b;
        if (((_b = (_a = this._parent) === null || _a === void 0 ? void 0 : _a._prefixes) === null || _b === void 0 ? void 0 : _b.has(prefix)) || this._prefixes && !this._prefixes.has(prefix)) {
          throw new Error(`CodeGen: prefix "${prefix}" is not allowed in this scope`);
        }
        return this._names[prefix] = { prefix, index: 0 };
      }
    };
    exports2.Scope = Scope;
    var ValueScopeName = class extends code_1.Name {
      constructor(prefix, nameStr) {
        super(nameStr);
        this.prefix = prefix;
      }
      setValue(value, { property, itemIndex }) {
        this.value = value;
        this.scopePath = (0, code_1._)`.${new code_1.Name(property)}[${itemIndex}]`;
      }
    };
    exports2.ValueScopeName = ValueScopeName;
    var line = (0, code_1._)`\n`;
    var ValueScope = class extends Scope {
      constructor(opts) {
        super(opts);
        this._values = {};
        this._scope = opts.scope;
        this.opts = { ...opts, _n: opts.lines ? line : code_1.nil };
      }
      get() {
        return this._scope;
      }
      name(prefix) {
        return new ValueScopeName(prefix, this._newName(prefix));
      }
      value(nameOrPrefix, value) {
        var _a;
        if (value.ref === void 0)
          throw new Error("CodeGen: ref must be passed in value");
        const name = this.toName(nameOrPrefix);
        const { prefix } = name;
        const valueKey = (_a = value.key) !== null && _a !== void 0 ? _a : value.ref;
        let vs = this._values[prefix];
        if (vs) {
          const _name = vs.get(valueKey);
          if (_name)
            return _name;
        } else {
          vs = this._values[prefix] = /* @__PURE__ */ new Map();
        }
        vs.set(valueKey, name);
        const s = this._scope[prefix] || (this._scope[prefix] = []);
        const itemIndex = s.length;
        s[itemIndex] = value.ref;
        name.setValue(value, { property: prefix, itemIndex });
        return name;
      }
      getValue(prefix, keyOrRef) {
        const vs = this._values[prefix];
        if (!vs)
          return;
        return vs.get(keyOrRef);
      }
      scopeRefs(scopeName, values = this._values) {
        return this._reduceValues(values, (name) => {
          if (name.scopePath === void 0)
            throw new Error(`CodeGen: name "${name}" has no value`);
          return (0, code_1._)`${scopeName}${name.scopePath}`;
        });
      }
      scopeCode(values = this._values, usedValues, getCode) {
        return this._reduceValues(values, (name) => {
          if (name.value === void 0)
            throw new Error(`CodeGen: name "${name}" has no value`);
          return name.value.code;
        }, usedValues, getCode);
      }
      _reduceValues(values, valueCode, usedValues = {}, getCode) {
        let code = code_1.nil;
        for (const prefix in values) {
          const vs = values[prefix];
          if (!vs)
            continue;
          const nameSet = usedValues[prefix] = usedValues[prefix] || /* @__PURE__ */ new Map();
          vs.forEach((name) => {
            if (nameSet.has(name))
              return;
            nameSet.set(name, UsedValueState.Started);
            let c = valueCode(name);
            if (c) {
              const def = this.opts.es5 ? exports2.varKinds.var : exports2.varKinds.const;
              code = (0, code_1._)`${code}${def} ${name} = ${c};${this.opts._n}`;
            } else if (c = getCode === null || getCode === void 0 ? void 0 : getCode(name)) {
              code = (0, code_1._)`${code}${c}${this.opts._n}`;
            } else {
              throw new ValueError(name);
            }
            nameSet.set(name, UsedValueState.Completed);
          });
        }
        return code;
      }
    };
    exports2.ValueScope = ValueScope;
  }
});

// node_modules/ajv/dist/compile/codegen/index.js
var require_codegen = __commonJS({
  "node_modules/ajv/dist/compile/codegen/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.or = exports2.and = exports2.not = exports2.CodeGen = exports2.operators = exports2.varKinds = exports2.ValueScopeName = exports2.ValueScope = exports2.Scope = exports2.Name = exports2.regexpCode = exports2.stringify = exports2.getProperty = exports2.nil = exports2.strConcat = exports2.str = exports2._ = void 0;
    var code_1 = require_code();
    var scope_1 = require_scope();
    var code_2 = require_code();
    Object.defineProperty(exports2, "_", { enumerable: true, get: function() {
      return code_2._;
    } });
    Object.defineProperty(exports2, "str", { enumerable: true, get: function() {
      return code_2.str;
    } });
    Object.defineProperty(exports2, "strConcat", { enumerable: true, get: function() {
      return code_2.strConcat;
    } });
    Object.defineProperty(exports2, "nil", { enumerable: true, get: function() {
      return code_2.nil;
    } });
    Object.defineProperty(exports2, "getProperty", { enumerable: true, get: function() {
      return code_2.getProperty;
    } });
    Object.defineProperty(exports2, "stringify", { enumerable: true, get: function() {
      return code_2.stringify;
    } });
    Object.defineProperty(exports2, "regexpCode", { enumerable: true, get: function() {
      return code_2.regexpCode;
    } });
    Object.defineProperty(exports2, "Name", { enumerable: true, get: function() {
      return code_2.Name;
    } });
    var scope_2 = require_scope();
    Object.defineProperty(exports2, "Scope", { enumerable: true, get: function() {
      return scope_2.Scope;
    } });
    Object.defineProperty(exports2, "ValueScope", { enumerable: true, get: function() {
      return scope_2.ValueScope;
    } });
    Object.defineProperty(exports2, "ValueScopeName", { enumerable: true, get: function() {
      return scope_2.ValueScopeName;
    } });
    Object.defineProperty(exports2, "varKinds", { enumerable: true, get: function() {
      return scope_2.varKinds;
    } });
    exports2.operators = {
      GT: new code_1._Code(">"),
      GTE: new code_1._Code(">="),
      LT: new code_1._Code("<"),
      LTE: new code_1._Code("<="),
      EQ: new code_1._Code("==="),
      NEQ: new code_1._Code("!=="),
      NOT: new code_1._Code("!"),
      OR: new code_1._Code("||"),
      AND: new code_1._Code("&&"),
      ADD: new code_1._Code("+")
    };
    var Node = class {
      optimizeNodes() {
        return this;
      }
      optimizeNames(_names, _constants) {
        return this;
      }
    };
    var Def = class extends Node {
      constructor(varKind, name, rhs) {
        super();
        this.varKind = varKind;
        this.name = name;
        this.rhs = rhs;
      }
      render({ es5, _n }) {
        const varKind = es5 ? scope_1.varKinds.var : this.varKind;
        const rhs = this.rhs === void 0 ? "" : ` = ${this.rhs}`;
        return `${varKind} ${this.name}${rhs};` + _n;
      }
      optimizeNames(names, constants) {
        if (!names[this.name.str])
          return;
        if (this.rhs)
          this.rhs = optimizeExpr(this.rhs, names, constants);
        return this;
      }
      get names() {
        return this.rhs instanceof code_1._CodeOrName ? this.rhs.names : {};
      }
    };
    var Assign = class extends Node {
      constructor(lhs, rhs, sideEffects) {
        super();
        this.lhs = lhs;
        this.rhs = rhs;
        this.sideEffects = sideEffects;
      }
      render({ _n }) {
        return `${this.lhs} = ${this.rhs};` + _n;
      }
      optimizeNames(names, constants) {
        if (this.lhs instanceof code_1.Name && !names[this.lhs.str] && !this.sideEffects)
          return;
        this.rhs = optimizeExpr(this.rhs, names, constants);
        return this;
      }
      get names() {
        const names = this.lhs instanceof code_1.Name ? {} : { ...this.lhs.names };
        return addExprNames(names, this.rhs);
      }
    };
    var AssignOp = class extends Assign {
      constructor(lhs, op2, rhs, sideEffects) {
        super(lhs, rhs, sideEffects);
        this.op = op2;
      }
      render({ _n }) {
        return `${this.lhs} ${this.op}= ${this.rhs};` + _n;
      }
    };
    var Label = class extends Node {
      constructor(label) {
        super();
        this.label = label;
        this.names = {};
      }
      render({ _n }) {
        return `${this.label}:` + _n;
      }
    };
    var Break = class extends Node {
      constructor(label) {
        super();
        this.label = label;
        this.names = {};
      }
      render({ _n }) {
        const label = this.label ? ` ${this.label}` : "";
        return `break${label};` + _n;
      }
    };
    var Throw = class extends Node {
      constructor(error) {
        super();
        this.error = error;
      }
      render({ _n }) {
        return `throw ${this.error};` + _n;
      }
      get names() {
        return this.error.names;
      }
    };
    var AnyCode = class extends Node {
      constructor(code) {
        super();
        this.code = code;
      }
      render({ _n }) {
        return `${this.code};` + _n;
      }
      optimizeNodes() {
        return `${this.code}` ? this : void 0;
      }
      optimizeNames(names, constants) {
        this.code = optimizeExpr(this.code, names, constants);
        return this;
      }
      get names() {
        return this.code instanceof code_1._CodeOrName ? this.code.names : {};
      }
    };
    var ParentNode = class extends Node {
      constructor(nodes = []) {
        super();
        this.nodes = nodes;
      }
      render(opts) {
        return this.nodes.reduce((code, n) => code + n.render(opts), "");
      }
      optimizeNodes() {
        const { nodes } = this;
        let i = nodes.length;
        while (i--) {
          const n = nodes[i].optimizeNodes();
          if (Array.isArray(n))
            nodes.splice(i, 1, ...n);
          else if (n)
            nodes[i] = n;
          else
            nodes.splice(i, 1);
        }
        return nodes.length > 0 ? this : void 0;
      }
      optimizeNames(names, constants) {
        const { nodes } = this;
        let i = nodes.length;
        while (i--) {
          const n = nodes[i];
          if (n.optimizeNames(names, constants))
            continue;
          subtractNames(names, n.names);
          nodes.splice(i, 1);
        }
        return nodes.length > 0 ? this : void 0;
      }
      get names() {
        return this.nodes.reduce((names, n) => addNames(names, n.names), {});
      }
    };
    var BlockNode = class extends ParentNode {
      render(opts) {
        return "{" + opts._n + super.render(opts) + "}" + opts._n;
      }
    };
    var Root = class extends ParentNode {
    };
    var Else = class extends BlockNode {
    };
    Else.kind = "else";
    var If2 = class _If extends BlockNode {
      constructor(condition, nodes) {
        super(nodes);
        this.condition = condition;
      }
      render(opts) {
        let code = `if(${this.condition})` + super.render(opts);
        if (this.else)
          code += "else " + this.else.render(opts);
        return code;
      }
      optimizeNodes() {
        super.optimizeNodes();
        const cond = this.condition;
        if (cond === true)
          return this.nodes;
        let e = this.else;
        if (e) {
          const ns = e.optimizeNodes();
          e = this.else = Array.isArray(ns) ? new Else(ns) : ns;
        }
        if (e) {
          if (cond === false)
            return e instanceof _If ? e : e.nodes;
          if (this.nodes.length)
            return this;
          return new _If(not(cond), e instanceof _If ? [e] : e.nodes);
        }
        if (cond === false || !this.nodes.length)
          return void 0;
        return this;
      }
      optimizeNames(names, constants) {
        var _a;
        this.else = (_a = this.else) === null || _a === void 0 ? void 0 : _a.optimizeNames(names, constants);
        if (!(super.optimizeNames(names, constants) || this.else))
          return;
        this.condition = optimizeExpr(this.condition, names, constants);
        return this;
      }
      get names() {
        const names = super.names;
        addExprNames(names, this.condition);
        if (this.else)
          addNames(names, this.else.names);
        return names;
      }
    };
    If2.kind = "if";
    var For = class extends BlockNode {
    };
    For.kind = "for";
    var ForLoop = class extends For {
      constructor(iteration) {
        super();
        this.iteration = iteration;
      }
      render(opts) {
        return `for(${this.iteration})` + super.render(opts);
      }
      optimizeNames(names, constants) {
        if (!super.optimizeNames(names, constants))
          return;
        this.iteration = optimizeExpr(this.iteration, names, constants);
        return this;
      }
      get names() {
        return addNames(super.names, this.iteration.names);
      }
    };
    var ForRange = class extends For {
      constructor(varKind, name, from, to) {
        super();
        this.varKind = varKind;
        this.name = name;
        this.from = from;
        this.to = to;
      }
      render(opts) {
        const varKind = opts.es5 ? scope_1.varKinds.var : this.varKind;
        const { name, from, to } = this;
        return `for(${varKind} ${name}=${from}; ${name}<${to}; ${name}++)` + super.render(opts);
      }
      get names() {
        const names = addExprNames(super.names, this.from);
        return addExprNames(names, this.to);
      }
    };
    var ForIter = class extends For {
      constructor(loop, varKind, name, iterable) {
        super();
        this.loop = loop;
        this.varKind = varKind;
        this.name = name;
        this.iterable = iterable;
      }
      render(opts) {
        return `for(${this.varKind} ${this.name} ${this.loop} ${this.iterable})` + super.render(opts);
      }
      optimizeNames(names, constants) {
        if (!super.optimizeNames(names, constants))
          return;
        this.iterable = optimizeExpr(this.iterable, names, constants);
        return this;
      }
      get names() {
        return addNames(super.names, this.iterable.names);
      }
    };
    var Func = class extends BlockNode {
      constructor(name, args, async) {
        super();
        this.name = name;
        this.args = args;
        this.async = async;
      }
      render(opts) {
        const _async = this.async ? "async " : "";
        return `${_async}function ${this.name}(${this.args})` + super.render(opts);
      }
    };
    Func.kind = "func";
    var Return = class extends ParentNode {
      render(opts) {
        return "return " + super.render(opts);
      }
    };
    Return.kind = "return";
    var Try = class extends BlockNode {
      render(opts) {
        let code = "try" + super.render(opts);
        if (this.catch)
          code += this.catch.render(opts);
        if (this.finally)
          code += this.finally.render(opts);
        return code;
      }
      optimizeNodes() {
        var _a, _b;
        super.optimizeNodes();
        (_a = this.catch) === null || _a === void 0 ? void 0 : _a.optimizeNodes();
        (_b = this.finally) === null || _b === void 0 ? void 0 : _b.optimizeNodes();
        return this;
      }
      optimizeNames(names, constants) {
        var _a, _b;
        super.optimizeNames(names, constants);
        (_a = this.catch) === null || _a === void 0 ? void 0 : _a.optimizeNames(names, constants);
        (_b = this.finally) === null || _b === void 0 ? void 0 : _b.optimizeNames(names, constants);
        return this;
      }
      get names() {
        const names = super.names;
        if (this.catch)
          addNames(names, this.catch.names);
        if (this.finally)
          addNames(names, this.finally.names);
        return names;
      }
    };
    var Catch = class extends BlockNode {
      constructor(error) {
        super();
        this.error = error;
      }
      render(opts) {
        return `catch(${this.error})` + super.render(opts);
      }
    };
    Catch.kind = "catch";
    var Finally = class extends BlockNode {
      render(opts) {
        return "finally" + super.render(opts);
      }
    };
    Finally.kind = "finally";
    var CodeGen = class {
      constructor(extScope, opts = {}) {
        this._values = {};
        this._blockStarts = [];
        this._constants = {};
        this.opts = { ...opts, _n: opts.lines ? "\n" : "" };
        this._extScope = extScope;
        this._scope = new scope_1.Scope({ parent: extScope });
        this._nodes = [new Root()];
      }
      toString() {
        return this._root.render(this.opts);
      }
      // returns unique name in the internal scope
      name(prefix) {
        return this._scope.name(prefix);
      }
      // reserves unique name in the external scope
      scopeName(prefix) {
        return this._extScope.name(prefix);
      }
      // reserves unique name in the external scope and assigns value to it
      scopeValue(prefixOrName, value) {
        const name = this._extScope.value(prefixOrName, value);
        const vs = this._values[name.prefix] || (this._values[name.prefix] = /* @__PURE__ */ new Set());
        vs.add(name);
        return name;
      }
      getScopeValue(prefix, keyOrRef) {
        return this._extScope.getValue(prefix, keyOrRef);
      }
      // return code that assigns values in the external scope to the names that are used internally
      // (same names that were returned by gen.scopeName or gen.scopeValue)
      scopeRefs(scopeName) {
        return this._extScope.scopeRefs(scopeName, this._values);
      }
      scopeCode() {
        return this._extScope.scopeCode(this._values);
      }
      _def(varKind, nameOrPrefix, rhs, constant) {
        const name = this._scope.toName(nameOrPrefix);
        if (rhs !== void 0 && constant)
          this._constants[name.str] = rhs;
        this._leafNode(new Def(varKind, name, rhs));
        return name;
      }
      // `const` declaration (`var` in es5 mode)
      const(nameOrPrefix, rhs, _constant) {
        return this._def(scope_1.varKinds.const, nameOrPrefix, rhs, _constant);
      }
      // `let` declaration with optional assignment (`var` in es5 mode)
      let(nameOrPrefix, rhs, _constant) {
        return this._def(scope_1.varKinds.let, nameOrPrefix, rhs, _constant);
      }
      // `var` declaration with optional assignment
      var(nameOrPrefix, rhs, _constant) {
        return this._def(scope_1.varKinds.var, nameOrPrefix, rhs, _constant);
      }
      // assignment code
      assign(lhs, rhs, sideEffects) {
        return this._leafNode(new Assign(lhs, rhs, sideEffects));
      }
      // `+=` code
      add(lhs, rhs) {
        return this._leafNode(new AssignOp(lhs, exports2.operators.ADD, rhs));
      }
      // appends passed SafeExpr to code or executes Block
      code(c) {
        if (typeof c == "function")
          c();
        else if (c !== code_1.nil)
          this._leafNode(new AnyCode(c));
        return this;
      }
      // returns code for object literal for the passed argument list of key-value pairs
      object(...keyValues) {
        const code = ["{"];
        for (const [key, value] of keyValues) {
          if (code.length > 1)
            code.push(",");
          code.push(key);
          if (key !== value || this.opts.es5) {
            code.push(":");
            (0, code_1.addCodeArg)(code, value);
          }
        }
        code.push("}");
        return new code_1._Code(code);
      }
      // `if` clause (or statement if `thenBody` and, optionally, `elseBody` are passed)
      if(condition, thenBody, elseBody) {
        this._blockNode(new If2(condition));
        if (thenBody && elseBody) {
          this.code(thenBody).else().code(elseBody).endIf();
        } else if (thenBody) {
          this.code(thenBody).endIf();
        } else if (elseBody) {
          throw new Error('CodeGen: "else" body without "then" body');
        }
        return this;
      }
      // `else if` clause - invalid without `if` or after `else` clauses
      elseIf(condition) {
        return this._elseNode(new If2(condition));
      }
      // `else` clause - only valid after `if` or `else if` clauses
      else() {
        return this._elseNode(new Else());
      }
      // end `if` statement (needed if gen.if was used only with condition)
      endIf() {
        return this._endBlockNode(If2, Else);
      }
      _for(node, forBody) {
        this._blockNode(node);
        if (forBody)
          this.code(forBody).endFor();
        return this;
      }
      // a generic `for` clause (or statement if `forBody` is passed)
      for(iteration, forBody) {
        return this._for(new ForLoop(iteration), forBody);
      }
      // `for` statement for a range of values
      forRange(nameOrPrefix, from, to, forBody, varKind = this.opts.es5 ? scope_1.varKinds.var : scope_1.varKinds.let) {
        const name = this._scope.toName(nameOrPrefix);
        return this._for(new ForRange(varKind, name, from, to), () => forBody(name));
      }
      // `for-of` statement (in es5 mode replace with a normal for loop)
      forOf(nameOrPrefix, iterable, forBody, varKind = scope_1.varKinds.const) {
        const name = this._scope.toName(nameOrPrefix);
        if (this.opts.es5) {
          const arr = iterable instanceof code_1.Name ? iterable : this.var("_arr", iterable);
          return this.forRange("_i", 0, (0, code_1._)`${arr}.length`, (i) => {
            this.var(name, (0, code_1._)`${arr}[${i}]`);
            forBody(name);
          });
        }
        return this._for(new ForIter("of", varKind, name, iterable), () => forBody(name));
      }
      // `for-in` statement.
      // With option `ownProperties` replaced with a `for-of` loop for object keys
      forIn(nameOrPrefix, obj, forBody, varKind = this.opts.es5 ? scope_1.varKinds.var : scope_1.varKinds.const) {
        if (this.opts.ownProperties) {
          return this.forOf(nameOrPrefix, (0, code_1._)`Object.keys(${obj})`, forBody);
        }
        const name = this._scope.toName(nameOrPrefix);
        return this._for(new ForIter("in", varKind, name, obj), () => forBody(name));
      }
      // end `for` loop
      endFor() {
        return this._endBlockNode(For);
      }
      // `label` statement
      label(label) {
        return this._leafNode(new Label(label));
      }
      // `break` statement
      break(label) {
        return this._leafNode(new Break(label));
      }
      // `return` statement
      return(value) {
        const node = new Return();
        this._blockNode(node);
        this.code(value);
        if (node.nodes.length !== 1)
          throw new Error('CodeGen: "return" should have one node');
        return this._endBlockNode(Return);
      }
      // `try` statement
      try(tryBody, catchCode, finallyCode) {
        if (!catchCode && !finallyCode)
          throw new Error('CodeGen: "try" without "catch" and "finally"');
        const node = new Try();
        this._blockNode(node);
        this.code(tryBody);
        if (catchCode) {
          const error = this.name("e");
          this._currNode = node.catch = new Catch(error);
          catchCode(error);
        }
        if (finallyCode) {
          this._currNode = node.finally = new Finally();
          this.code(finallyCode);
        }
        return this._endBlockNode(Catch, Finally);
      }
      // `throw` statement
      throw(error) {
        return this._leafNode(new Throw(error));
      }
      // start self-balancing block
      block(body, nodeCount) {
        this._blockStarts.push(this._nodes.length);
        if (body)
          this.code(body).endBlock(nodeCount);
        return this;
      }
      // end the current self-balancing block
      endBlock(nodeCount) {
        const len = this._blockStarts.pop();
        if (len === void 0)
          throw new Error("CodeGen: not in self-balancing block");
        const toClose = this._nodes.length - len;
        if (toClose < 0 || nodeCount !== void 0 && toClose !== nodeCount) {
          throw new Error(`CodeGen: wrong number of nodes: ${toClose} vs ${nodeCount} expected`);
        }
        this._nodes.length = len;
        return this;
      }
      // `function` heading (or definition if funcBody is passed)
      func(name, args = code_1.nil, async, funcBody) {
        this._blockNode(new Func(name, args, async));
        if (funcBody)
          this.code(funcBody).endFunc();
        return this;
      }
      // end function definition
      endFunc() {
        return this._endBlockNode(Func);
      }
      optimize(n = 1) {
        while (n-- > 0) {
          this._root.optimizeNodes();
          this._root.optimizeNames(this._root.names, this._constants);
        }
      }
      _leafNode(node) {
        this._currNode.nodes.push(node);
        return this;
      }
      _blockNode(node) {
        this._currNode.nodes.push(node);
        this._nodes.push(node);
      }
      _endBlockNode(N1, N2) {
        const n = this._currNode;
        if (n instanceof N1 || N2 && n instanceof N2) {
          this._nodes.pop();
          return this;
        }
        throw new Error(`CodeGen: not in block "${N2 ? `${N1.kind}/${N2.kind}` : N1.kind}"`);
      }
      _elseNode(node) {
        const n = this._currNode;
        if (!(n instanceof If2)) {
          throw new Error('CodeGen: "else" without "if"');
        }
        this._currNode = n.else = node;
        return this;
      }
      get _root() {
        return this._nodes[0];
      }
      get _currNode() {
        const ns = this._nodes;
        return ns[ns.length - 1];
      }
      set _currNode(node) {
        const ns = this._nodes;
        ns[ns.length - 1] = node;
      }
    };
    exports2.CodeGen = CodeGen;
    function addNames(names, from) {
      for (const n in from)
        names[n] = (names[n] || 0) + (from[n] || 0);
      return names;
    }
    function addExprNames(names, from) {
      return from instanceof code_1._CodeOrName ? addNames(names, from.names) : names;
    }
    function optimizeExpr(expr, names, constants) {
      if (expr instanceof code_1.Name)
        return replaceName(expr);
      if (!canOptimize(expr))
        return expr;
      return new code_1._Code(expr._items.reduce((items, c) => {
        if (c instanceof code_1.Name)
          c = replaceName(c);
        if (c instanceof code_1._Code)
          items.push(...c._items);
        else
          items.push(c);
        return items;
      }, []));
      function replaceName(n) {
        const c = constants[n.str];
        if (c === void 0 || names[n.str] !== 1)
          return n;
        delete names[n.str];
        return c;
      }
      function canOptimize(e) {
        return e instanceof code_1._Code && e._items.some((c) => c instanceof code_1.Name && names[c.str] === 1 && constants[c.str] !== void 0);
      }
    }
    function subtractNames(names, from) {
      for (const n in from)
        names[n] = (names[n] || 0) - (from[n] || 0);
    }
    function not(x) {
      return typeof x == "boolean" || typeof x == "number" || x === null ? !x : (0, code_1._)`!${par(x)}`;
    }
    exports2.not = not;
    var andCode = mappend(exports2.operators.AND);
    function and(...args) {
      return args.reduce(andCode);
    }
    exports2.and = and;
    var orCode = mappend(exports2.operators.OR);
    function or(...args) {
      return args.reduce(orCode);
    }
    exports2.or = or;
    function mappend(op2) {
      return (x, y) => x === code_1.nil ? y : y === code_1.nil ? x : (0, code_1._)`${par(x)} ${op2} ${par(y)}`;
    }
    function par(x) {
      return x instanceof code_1.Name ? x : (0, code_1._)`(${x})`;
    }
  }
});

// node_modules/ajv/dist/compile/util.js
var require_util2 = __commonJS({
  "node_modules/ajv/dist/compile/util.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.checkStrictMode = exports2.getErrorPath = exports2.Type = exports2.useFunc = exports2.setEvaluated = exports2.evaluatedPropsToName = exports2.mergeEvaluated = exports2.eachItem = exports2.unescapeJsonPointer = exports2.escapeJsonPointer = exports2.escapeFragment = exports2.unescapeFragment = exports2.schemaRefOrVal = exports2.schemaHasRulesButRef = exports2.schemaHasRules = exports2.checkUnknownRules = exports2.alwaysValidSchema = exports2.toHash = void 0;
    var codegen_1 = require_codegen();
    var code_1 = require_code();
    function toHash(arr) {
      const hash = {};
      for (const item of arr)
        hash[item] = true;
      return hash;
    }
    exports2.toHash = toHash;
    function alwaysValidSchema(it2, schema) {
      if (typeof schema == "boolean")
        return schema;
      if (Object.keys(schema).length === 0)
        return true;
      checkUnknownRules(it2, schema);
      return !schemaHasRules(schema, it2.self.RULES.all);
    }
    exports2.alwaysValidSchema = alwaysValidSchema;
    function checkUnknownRules(it2, schema = it2.schema) {
      const { opts, self: self2 } = it2;
      if (!opts.strictSchema)
        return;
      if (typeof schema === "boolean")
        return;
      const rules = self2.RULES.keywords;
      for (const key in schema) {
        if (!rules[key])
          checkStrictMode(it2, `unknown keyword: "${key}"`);
      }
    }
    exports2.checkUnknownRules = checkUnknownRules;
    function schemaHasRules(schema, rules) {
      if (typeof schema == "boolean")
        return !schema;
      for (const key in schema)
        if (rules[key])
          return true;
      return false;
    }
    exports2.schemaHasRules = schemaHasRules;
    function schemaHasRulesButRef(schema, RULES) {
      if (typeof schema == "boolean")
        return !schema;
      for (const key in schema)
        if (key !== "$ref" && RULES.all[key])
          return true;
      return false;
    }
    exports2.schemaHasRulesButRef = schemaHasRulesButRef;
    function schemaRefOrVal({ topSchemaRef, schemaPath }, schema, keyword, $data) {
      if (!$data) {
        if (typeof schema == "number" || typeof schema == "boolean")
          return schema;
        if (typeof schema == "string")
          return (0, codegen_1._)`${schema}`;
      }
      return (0, codegen_1._)`${topSchemaRef}${schemaPath}${(0, codegen_1.getProperty)(keyword)}`;
    }
    exports2.schemaRefOrVal = schemaRefOrVal;
    function unescapeFragment(str) {
      return unescapeJsonPointer(decodeURIComponent(str));
    }
    exports2.unescapeFragment = unescapeFragment;
    function escapeFragment(str) {
      return encodeURIComponent(escapeJsonPointer(str));
    }
    exports2.escapeFragment = escapeFragment;
    function escapeJsonPointer(str) {
      if (typeof str == "number")
        return `${str}`;
      return str.replace(/~/g, "~0").replace(/\//g, "~1");
    }
    exports2.escapeJsonPointer = escapeJsonPointer;
    function unescapeJsonPointer(str) {
      return str.replace(/~1/g, "/").replace(/~0/g, "~");
    }
    exports2.unescapeJsonPointer = unescapeJsonPointer;
    function eachItem(xs, f) {
      if (Array.isArray(xs)) {
        for (const x of xs)
          f(x);
      } else {
        f(xs);
      }
    }
    exports2.eachItem = eachItem;
    function makeMergeEvaluated({ mergeNames, mergeToName, mergeValues, resultToName }) {
      return (gen, from, to, toName) => {
        const res = to === void 0 ? from : to instanceof codegen_1.Name ? (from instanceof codegen_1.Name ? mergeNames(gen, from, to) : mergeToName(gen, from, to), to) : from instanceof codegen_1.Name ? (mergeToName(gen, to, from), from) : mergeValues(from, to);
        return toName === codegen_1.Name && !(res instanceof codegen_1.Name) ? resultToName(gen, res) : res;
      };
    }
    exports2.mergeEvaluated = {
      props: makeMergeEvaluated({
        mergeNames: (gen, from, to) => gen.if((0, codegen_1._)`${to} !== true && ${from} !== undefined`, () => {
          gen.if((0, codegen_1._)`${from} === true`, () => gen.assign(to, true), () => gen.assign(to, (0, codegen_1._)`${to} || {}`).code((0, codegen_1._)`Object.assign(${to}, ${from})`));
        }),
        mergeToName: (gen, from, to) => gen.if((0, codegen_1._)`${to} !== true`, () => {
          if (from === true) {
            gen.assign(to, true);
          } else {
            gen.assign(to, (0, codegen_1._)`${to} || {}`);
            setEvaluated(gen, to, from);
          }
        }),
        mergeValues: (from, to) => from === true ? true : { ...from, ...to },
        resultToName: evaluatedPropsToName
      }),
      items: makeMergeEvaluated({
        mergeNames: (gen, from, to) => gen.if((0, codegen_1._)`${to} !== true && ${from} !== undefined`, () => gen.assign(to, (0, codegen_1._)`${from} === true ? true : ${to} > ${from} ? ${to} : ${from}`)),
        mergeToName: (gen, from, to) => gen.if((0, codegen_1._)`${to} !== true`, () => gen.assign(to, from === true ? true : (0, codegen_1._)`${to} > ${from} ? ${to} : ${from}`)),
        mergeValues: (from, to) => from === true ? true : Math.max(from, to),
        resultToName: (gen, items) => gen.var("items", items)
      })
    };
    function evaluatedPropsToName(gen, ps) {
      if (ps === true)
        return gen.var("props", true);
      const props = gen.var("props", (0, codegen_1._)`{}`);
      if (ps !== void 0)
        setEvaluated(gen, props, ps);
      return props;
    }
    exports2.evaluatedPropsToName = evaluatedPropsToName;
    function setEvaluated(gen, props, ps) {
      Object.keys(ps).forEach((p) => gen.assign((0, codegen_1._)`${props}${(0, codegen_1.getProperty)(p)}`, true));
    }
    exports2.setEvaluated = setEvaluated;
    var snippets = {};
    function useFunc(gen, f) {
      return gen.scopeValue("func", {
        ref: f,
        code: snippets[f.code] || (snippets[f.code] = new code_1._Code(f.code))
      });
    }
    exports2.useFunc = useFunc;
    var Type;
    (function(Type2) {
      Type2[Type2["Num"] = 0] = "Num";
      Type2[Type2["Str"] = 1] = "Str";
    })(Type || (exports2.Type = Type = {}));
    function getErrorPath(dataProp, dataPropType, jsPropertySyntax) {
      if (dataProp instanceof codegen_1.Name) {
        const isNumber = dataPropType === Type.Num;
        return jsPropertySyntax ? isNumber ? (0, codegen_1._)`"[" + ${dataProp} + "]"` : (0, codegen_1._)`"['" + ${dataProp} + "']"` : isNumber ? (0, codegen_1._)`"/" + ${dataProp}` : (0, codegen_1._)`"/" + ${dataProp}.replace(/~/g, "~0").replace(/\\//g, "~1")`;
      }
      return jsPropertySyntax ? (0, codegen_1.getProperty)(dataProp).toString() : "/" + escapeJsonPointer(dataProp);
    }
    exports2.getErrorPath = getErrorPath;
    function checkStrictMode(it2, msg, mode = it2.opts.strictSchema) {
      if (!mode)
        return;
      msg = `strict mode: ${msg}`;
      if (mode === true)
        throw new Error(msg);
      it2.self.logger.warn(msg);
    }
    exports2.checkStrictMode = checkStrictMode;
  }
});

// node_modules/ajv/dist/compile/names.js
var require_names = __commonJS({
  "node_modules/ajv/dist/compile/names.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var codegen_1 = require_codegen();
    var names = {
      // validation function arguments
      data: new codegen_1.Name("data"),
      // data passed to validation function
      // args passed from referencing schema
      valCxt: new codegen_1.Name("valCxt"),
      // validation/data context - should not be used directly, it is destructured to the names below
      instancePath: new codegen_1.Name("instancePath"),
      parentData: new codegen_1.Name("parentData"),
      parentDataProperty: new codegen_1.Name("parentDataProperty"),
      rootData: new codegen_1.Name("rootData"),
      // root data - same as the data passed to the first/top validation function
      dynamicAnchors: new codegen_1.Name("dynamicAnchors"),
      // used to support recursiveRef and dynamicRef
      // function scoped variables
      vErrors: new codegen_1.Name("vErrors"),
      // null or array of validation errors
      errors: new codegen_1.Name("errors"),
      // counter of validation errors
      this: new codegen_1.Name("this"),
      // "globals"
      self: new codegen_1.Name("self"),
      scope: new codegen_1.Name("scope"),
      // JTD serialize/parse name for JSON string and position
      json: new codegen_1.Name("json"),
      jsonPos: new codegen_1.Name("jsonPos"),
      jsonLen: new codegen_1.Name("jsonLen"),
      jsonPart: new codegen_1.Name("jsonPart")
    };
    exports2.default = names;
  }
});

// node_modules/ajv/dist/compile/errors.js
var require_errors3 = __commonJS({
  "node_modules/ajv/dist/compile/errors.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.extendErrors = exports2.resetErrorsCount = exports2.reportExtraError = exports2.reportError = exports2.keyword$DataError = exports2.keywordError = void 0;
    var codegen_1 = require_codegen();
    var util_1 = require_util2();
    var names_1 = require_names();
    exports2.keywordError = {
      message: ({ keyword }) => (0, codegen_1.str)`must pass "${keyword}" keyword validation`
    };
    exports2.keyword$DataError = {
      message: ({ keyword, schemaType }) => schemaType ? (0, codegen_1.str)`"${keyword}" keyword must be ${schemaType} ($data)` : (0, codegen_1.str)`"${keyword}" keyword is invalid ($data)`
    };
    function reportError(cxt, error = exports2.keywordError, errorPaths, overrideAllErrors) {
      const { it: it2 } = cxt;
      const { gen, compositeRule, allErrors } = it2;
      const errObj = errorObjectCode(cxt, error, errorPaths);
      if (overrideAllErrors !== null && overrideAllErrors !== void 0 ? overrideAllErrors : compositeRule || allErrors) {
        addError(gen, errObj);
      } else {
        returnErrors(it2, (0, codegen_1._)`[${errObj}]`);
      }
    }
    exports2.reportError = reportError;
    function reportExtraError(cxt, error = exports2.keywordError, errorPaths) {
      const { it: it2 } = cxt;
      const { gen, compositeRule, allErrors } = it2;
      const errObj = errorObjectCode(cxt, error, errorPaths);
      addError(gen, errObj);
      if (!(compositeRule || allErrors)) {
        returnErrors(it2, names_1.default.vErrors);
      }
    }
    exports2.reportExtraError = reportExtraError;
    function resetErrorsCount(gen, errsCount) {
      gen.assign(names_1.default.errors, errsCount);
      gen.if((0, codegen_1._)`${names_1.default.vErrors} !== null`, () => gen.if(errsCount, () => gen.assign((0, codegen_1._)`${names_1.default.vErrors}.length`, errsCount), () => gen.assign(names_1.default.vErrors, null)));
    }
    exports2.resetErrorsCount = resetErrorsCount;
    function extendErrors({ gen, keyword, schemaValue, data, errsCount, it: it2 }) {
      if (errsCount === void 0)
        throw new Error("ajv implementation error");
      const err = gen.name("err");
      gen.forRange("i", errsCount, names_1.default.errors, (i) => {
        gen.const(err, (0, codegen_1._)`${names_1.default.vErrors}[${i}]`);
        gen.if((0, codegen_1._)`${err}.instancePath === undefined`, () => gen.assign((0, codegen_1._)`${err}.instancePath`, (0, codegen_1.strConcat)(names_1.default.instancePath, it2.errorPath)));
        gen.assign((0, codegen_1._)`${err}.schemaPath`, (0, codegen_1.str)`${it2.errSchemaPath}/${keyword}`);
        if (it2.opts.verbose) {
          gen.assign((0, codegen_1._)`${err}.schema`, schemaValue);
          gen.assign((0, codegen_1._)`${err}.data`, data);
        }
      });
    }
    exports2.extendErrors = extendErrors;
    function addError(gen, errObj) {
      const err = gen.const("err", errObj);
      gen.if((0, codegen_1._)`${names_1.default.vErrors} === null`, () => gen.assign(names_1.default.vErrors, (0, codegen_1._)`[${err}]`), (0, codegen_1._)`${names_1.default.vErrors}.push(${err})`);
      gen.code((0, codegen_1._)`${names_1.default.errors}++`);
    }
    function returnErrors(it2, errs) {
      const { gen, validateName, schemaEnv } = it2;
      if (schemaEnv.$async) {
        gen.throw((0, codegen_1._)`new ${it2.ValidationError}(${errs})`);
      } else {
        gen.assign((0, codegen_1._)`${validateName}.errors`, errs);
        gen.return(false);
      }
    }
    var E = {
      keyword: new codegen_1.Name("keyword"),
      schemaPath: new codegen_1.Name("schemaPath"),
      // also used in JTD errors
      params: new codegen_1.Name("params"),
      propertyName: new codegen_1.Name("propertyName"),
      message: new codegen_1.Name("message"),
      schema: new codegen_1.Name("schema"),
      parentSchema: new codegen_1.Name("parentSchema")
    };
    function errorObjectCode(cxt, error, errorPaths) {
      const { createErrors } = cxt.it;
      if (createErrors === false)
        return (0, codegen_1._)`{}`;
      return errorObject(cxt, error, errorPaths);
    }
    function errorObject(cxt, error, errorPaths = {}) {
      const { gen, it: it2 } = cxt;
      const keyValues = [
        errorInstancePath(it2, errorPaths),
        errorSchemaPath(cxt, errorPaths)
      ];
      extraErrorProps(cxt, error, keyValues);
      return gen.object(...keyValues);
    }
    function errorInstancePath({ errorPath }, { instancePath }) {
      const instPath = instancePath ? (0, codegen_1.str)`${errorPath}${(0, util_1.getErrorPath)(instancePath, util_1.Type.Str)}` : errorPath;
      return [names_1.default.instancePath, (0, codegen_1.strConcat)(names_1.default.instancePath, instPath)];
    }
    function errorSchemaPath({ keyword, it: { errSchemaPath } }, { schemaPath, parentSchema }) {
      let schPath = parentSchema ? errSchemaPath : (0, codegen_1.str)`${errSchemaPath}/${keyword}`;
      if (schemaPath) {
        schPath = (0, codegen_1.str)`${schPath}${(0, util_1.getErrorPath)(schemaPath, util_1.Type.Str)}`;
      }
      return [E.schemaPath, schPath];
    }
    function extraErrorProps(cxt, { params, message }, keyValues) {
      const { keyword, data, schemaValue, it: it2 } = cxt;
      const { opts, propertyName, topSchemaRef, schemaPath } = it2;
      keyValues.push([E.keyword, keyword], [E.params, typeof params == "function" ? params(cxt) : params || (0, codegen_1._)`{}`]);
      if (opts.messages) {
        keyValues.push([E.message, typeof message == "function" ? message(cxt) : message]);
      }
      if (opts.verbose) {
        keyValues.push([E.schema, schemaValue], [E.parentSchema, (0, codegen_1._)`${topSchemaRef}${schemaPath}`], [names_1.default.data, data]);
      }
      if (propertyName)
        keyValues.push([E.propertyName, propertyName]);
    }
  }
});

// node_modules/ajv/dist/compile/validate/boolSchema.js
var require_boolSchema = __commonJS({
  "node_modules/ajv/dist/compile/validate/boolSchema.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.boolOrEmptySchema = exports2.topBoolOrEmptySchema = void 0;
    var errors_1 = require_errors3();
    var codegen_1 = require_codegen();
    var names_1 = require_names();
    var boolError = {
      message: "boolean schema is false"
    };
    function topBoolOrEmptySchema(it2) {
      const { gen, schema, validateName } = it2;
      if (schema === false) {
        falseSchemaError(it2, false);
      } else if (typeof schema == "object" && schema.$async === true) {
        gen.return(names_1.default.data);
      } else {
        gen.assign((0, codegen_1._)`${validateName}.errors`, null);
        gen.return(true);
      }
    }
    exports2.topBoolOrEmptySchema = topBoolOrEmptySchema;
    function boolOrEmptySchema(it2, valid) {
      const { gen, schema } = it2;
      if (schema === false) {
        gen.var(valid, false);
        falseSchemaError(it2);
      } else {
        gen.var(valid, true);
      }
    }
    exports2.boolOrEmptySchema = boolOrEmptySchema;
    function falseSchemaError(it2, overrideAllErrors) {
      const { gen, data } = it2;
      const cxt = {
        gen,
        keyword: "false schema",
        data,
        schema: false,
        schemaCode: false,
        schemaValue: false,
        params: {},
        it: it2
      };
      (0, errors_1.reportError)(cxt, boolError, void 0, overrideAllErrors);
    }
  }
});

// node_modules/ajv/dist/compile/rules.js
var require_rules = __commonJS({
  "node_modules/ajv/dist/compile/rules.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.getRules = exports2.isJSONType = void 0;
    var _jsonTypes = ["string", "number", "integer", "boolean", "null", "object", "array"];
    var jsonTypes = new Set(_jsonTypes);
    function isJSONType(x) {
      return typeof x == "string" && jsonTypes.has(x);
    }
    exports2.isJSONType = isJSONType;
    function getRules() {
      const groups = {
        number: { type: "number", rules: [] },
        string: { type: "string", rules: [] },
        array: { type: "array", rules: [] },
        object: { type: "object", rules: [] }
      };
      return {
        types: { ...groups, integer: true, boolean: true, null: true },
        rules: [{ rules: [] }, groups.number, groups.string, groups.array, groups.object],
        post: { rules: [] },
        all: {},
        keywords: {}
      };
    }
    exports2.getRules = getRules;
  }
});

// node_modules/ajv/dist/compile/validate/applicability.js
var require_applicability = __commonJS({
  "node_modules/ajv/dist/compile/validate/applicability.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.shouldUseRule = exports2.shouldUseGroup = exports2.schemaHasRulesForType = void 0;
    function schemaHasRulesForType({ schema, self: self2 }, type) {
      const group = self2.RULES.types[type];
      return group && group !== true && shouldUseGroup(schema, group);
    }
    exports2.schemaHasRulesForType = schemaHasRulesForType;
    function shouldUseGroup(schema, group) {
      return group.rules.some((rule) => shouldUseRule(schema, rule));
    }
    exports2.shouldUseGroup = shouldUseGroup;
    function shouldUseRule(schema, rule) {
      var _a;
      return schema[rule.keyword] !== void 0 || ((_a = rule.definition.implements) === null || _a === void 0 ? void 0 : _a.some((kwd) => schema[kwd] !== void 0));
    }
    exports2.shouldUseRule = shouldUseRule;
  }
});

// node_modules/ajv/dist/compile/validate/dataType.js
var require_dataType = __commonJS({
  "node_modules/ajv/dist/compile/validate/dataType.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.reportTypeError = exports2.checkDataTypes = exports2.checkDataType = exports2.coerceAndCheckDataType = exports2.getJSONTypes = exports2.getSchemaTypes = exports2.DataType = void 0;
    var rules_1 = require_rules();
    var applicability_1 = require_applicability();
    var errors_1 = require_errors3();
    var codegen_1 = require_codegen();
    var util_1 = require_util2();
    var DataType;
    (function(DataType2) {
      DataType2[DataType2["Correct"] = 0] = "Correct";
      DataType2[DataType2["Wrong"] = 1] = "Wrong";
    })(DataType || (exports2.DataType = DataType = {}));
    function getSchemaTypes(schema) {
      const types = getJSONTypes(schema.type);
      const hasNull = types.includes("null");
      if (hasNull) {
        if (schema.nullable === false)
          throw new Error("type: null contradicts nullable: false");
      } else {
        if (!types.length && schema.nullable !== void 0) {
          throw new Error('"nullable" cannot be used without "type"');
        }
        if (schema.nullable === true)
          types.push("null");
      }
      return types;
    }
    exports2.getSchemaTypes = getSchemaTypes;
    function getJSONTypes(ts) {
      const types = Array.isArray(ts) ? ts : ts ? [ts] : [];
      if (types.every(rules_1.isJSONType))
        return types;
      throw new Error("type must be JSONType or JSONType[]: " + types.join(","));
    }
    exports2.getJSONTypes = getJSONTypes;
    function coerceAndCheckDataType(it2, types) {
      const { gen, data, opts } = it2;
      const coerceTo = coerceToTypes(types, opts.coerceTypes);
      const checkTypes = types.length > 0 && !(coerceTo.length === 0 && types.length === 1 && (0, applicability_1.schemaHasRulesForType)(it2, types[0]));
      if (checkTypes) {
        const wrongType = checkDataTypes(types, data, opts.strictNumbers, DataType.Wrong);
        gen.if(wrongType, () => {
          if (coerceTo.length)
            coerceData(it2, types, coerceTo);
          else
            reportTypeError(it2);
        });
      }
      return checkTypes;
    }
    exports2.coerceAndCheckDataType = coerceAndCheckDataType;
    var COERCIBLE = /* @__PURE__ */ new Set(["string", "number", "integer", "boolean", "null"]);
    function coerceToTypes(types, coerceTypes) {
      return coerceTypes ? types.filter((t) => COERCIBLE.has(t) || coerceTypes === "array" && t === "array") : [];
    }
    function coerceData(it2, types, coerceTo) {
      const { gen, data, opts } = it2;
      const dataType = gen.let("dataType", (0, codegen_1._)`typeof ${data}`);
      const coerced = gen.let("coerced", (0, codegen_1._)`undefined`);
      if (opts.coerceTypes === "array") {
        gen.if((0, codegen_1._)`${dataType} == 'object' && Array.isArray(${data}) && ${data}.length == 1`, () => gen.assign(data, (0, codegen_1._)`${data}[0]`).assign(dataType, (0, codegen_1._)`typeof ${data}`).if(checkDataTypes(types, data, opts.strictNumbers), () => gen.assign(coerced, data)));
      }
      gen.if((0, codegen_1._)`${coerced} !== undefined`);
      for (const t of coerceTo) {
        if (COERCIBLE.has(t) || t === "array" && opts.coerceTypes === "array") {
          coerceSpecificType(t);
        }
      }
      gen.else();
      reportTypeError(it2);
      gen.endIf();
      gen.if((0, codegen_1._)`${coerced} !== undefined`, () => {
        gen.assign(data, coerced);
        assignParentData(it2, coerced);
      });
      function coerceSpecificType(t) {
        switch (t) {
          case "string":
            gen.elseIf((0, codegen_1._)`${dataType} == "number" || ${dataType} == "boolean"`).assign(coerced, (0, codegen_1._)`"" + ${data}`).elseIf((0, codegen_1._)`${data} === null`).assign(coerced, (0, codegen_1._)`""`);
            return;
          case "number":
            gen.elseIf((0, codegen_1._)`${dataType} == "boolean" || ${data} === null
              || (${dataType} == "string" && ${data} && ${data} == +${data})`).assign(coerced, (0, codegen_1._)`+${data}`);
            return;
          case "integer":
            gen.elseIf((0, codegen_1._)`${dataType} === "boolean" || ${data} === null
              || (${dataType} === "string" && ${data} && ${data} == +${data} && !(${data} % 1))`).assign(coerced, (0, codegen_1._)`+${data}`);
            return;
          case "boolean":
            gen.elseIf((0, codegen_1._)`${data} === "false" || ${data} === 0 || ${data} === null`).assign(coerced, false).elseIf((0, codegen_1._)`${data} === "true" || ${data} === 1`).assign(coerced, true);
            return;
          case "null":
            gen.elseIf((0, codegen_1._)`${data} === "" || ${data} === 0 || ${data} === false`);
            gen.assign(coerced, null);
            return;
          case "array":
            gen.elseIf((0, codegen_1._)`${dataType} === "string" || ${dataType} === "number"
              || ${dataType} === "boolean" || ${data} === null`).assign(coerced, (0, codegen_1._)`[${data}]`);
        }
      }
    }
    function assignParentData({ gen, parentData, parentDataProperty }, expr) {
      gen.if((0, codegen_1._)`${parentData} !== undefined`, () => gen.assign((0, codegen_1._)`${parentData}[${parentDataProperty}]`, expr));
    }
    function checkDataType(dataType, data, strictNums, correct = DataType.Correct) {
      const EQ = correct === DataType.Correct ? codegen_1.operators.EQ : codegen_1.operators.NEQ;
      let cond;
      switch (dataType) {
        case "null":
          return (0, codegen_1._)`${data} ${EQ} null`;
        case "array":
          cond = (0, codegen_1._)`Array.isArray(${data})`;
          break;
        case "object":
          cond = (0, codegen_1._)`${data} && typeof ${data} == "object" && !Array.isArray(${data})`;
          break;
        case "integer":
          cond = numCond((0, codegen_1._)`!(${data} % 1) && !isNaN(${data})`);
          break;
        case "number":
          cond = numCond();
          break;
        default:
          return (0, codegen_1._)`typeof ${data} ${EQ} ${dataType}`;
      }
      return correct === DataType.Correct ? cond : (0, codegen_1.not)(cond);
      function numCond(_cond = codegen_1.nil) {
        return (0, codegen_1.and)((0, codegen_1._)`typeof ${data} == "number"`, _cond, strictNums ? (0, codegen_1._)`isFinite(${data})` : codegen_1.nil);
      }
    }
    exports2.checkDataType = checkDataType;
    function checkDataTypes(dataTypes, data, strictNums, correct) {
      if (dataTypes.length === 1) {
        return checkDataType(dataTypes[0], data, strictNums, correct);
      }
      let cond;
      const types = (0, util_1.toHash)(dataTypes);
      if (types.array && types.object) {
        const notObj = (0, codegen_1._)`typeof ${data} != "object"`;
        cond = types.null ? notObj : (0, codegen_1._)`!${data} || ${notObj}`;
        delete types.null;
        delete types.array;
        delete types.object;
      } else {
        cond = codegen_1.nil;
      }
      if (types.number)
        delete types.integer;
      for (const t in types)
        cond = (0, codegen_1.and)(cond, checkDataType(t, data, strictNums, correct));
      return cond;
    }
    exports2.checkDataTypes = checkDataTypes;
    var typeError = {
      message: ({ schema }) => `must be ${schema}`,
      params: ({ schema, schemaValue }) => typeof schema == "string" ? (0, codegen_1._)`{type: ${schema}}` : (0, codegen_1._)`{type: ${schemaValue}}`
    };
    function reportTypeError(it2) {
      const cxt = getTypeErrorContext(it2);
      (0, errors_1.reportError)(cxt, typeError);
    }
    exports2.reportTypeError = reportTypeError;
    function getTypeErrorContext(it2) {
      const { gen, data, schema } = it2;
      const schemaCode = (0, util_1.schemaRefOrVal)(it2, schema, "type");
      return {
        gen,
        keyword: "type",
        data,
        schema: schema.type,
        schemaCode,
        schemaValue: schemaCode,
        parentSchema: schema,
        params: {},
        it: it2
      };
    }
  }
});

// node_modules/ajv/dist/compile/validate/defaults.js
var require_defaults = __commonJS({
  "node_modules/ajv/dist/compile/validate/defaults.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.assignDefaults = void 0;
    var codegen_1 = require_codegen();
    var util_1 = require_util2();
    function assignDefaults(it2, ty) {
      const { properties, items } = it2.schema;
      if (ty === "object" && properties) {
        for (const key in properties) {
          assignDefault(it2, key, properties[key].default);
        }
      } else if (ty === "array" && Array.isArray(items)) {
        items.forEach((sch, i) => assignDefault(it2, i, sch.default));
      }
    }
    exports2.assignDefaults = assignDefaults;
    function assignDefault(it2, prop, defaultValue) {
      const { gen, compositeRule, data, opts } = it2;
      if (defaultValue === void 0)
        return;
      const childData = (0, codegen_1._)`${data}${(0, codegen_1.getProperty)(prop)}`;
      if (compositeRule) {
        (0, util_1.checkStrictMode)(it2, `default is ignored for: ${childData}`);
        return;
      }
      let condition = (0, codegen_1._)`${childData} === undefined`;
      if (opts.useDefaults === "empty") {
        condition = (0, codegen_1._)`${condition} || ${childData} === null || ${childData} === ""`;
      }
      gen.if(condition, (0, codegen_1._)`${childData} = ${(0, codegen_1.stringify)(defaultValue)}`);
    }
  }
});

// node_modules/ajv/dist/vocabularies/code.js
var require_code2 = __commonJS({
  "node_modules/ajv/dist/vocabularies/code.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.validateUnion = exports2.validateArray = exports2.usePattern = exports2.callValidateCode = exports2.schemaProperties = exports2.allSchemaProperties = exports2.noPropertyInData = exports2.propertyInData = exports2.isOwnProperty = exports2.hasPropFunc = exports2.reportMissingProp = exports2.checkMissingProp = exports2.checkReportMissingProp = void 0;
    var codegen_1 = require_codegen();
    var util_1 = require_util2();
    var names_1 = require_names();
    var util_2 = require_util2();
    function checkReportMissingProp(cxt, prop) {
      const { gen, data, it: it2 } = cxt;
      gen.if(noPropertyInData(gen, data, prop, it2.opts.ownProperties), () => {
        cxt.setParams({ missingProperty: (0, codegen_1._)`${prop}` }, true);
        cxt.error();
      });
    }
    exports2.checkReportMissingProp = checkReportMissingProp;
    function checkMissingProp({ gen, data, it: { opts } }, properties, missing) {
      return (0, codegen_1.or)(...properties.map((prop) => (0, codegen_1.and)(noPropertyInData(gen, data, prop, opts.ownProperties), (0, codegen_1._)`${missing} = ${prop}`)));
    }
    exports2.checkMissingProp = checkMissingProp;
    function reportMissingProp(cxt, missing) {
      cxt.setParams({ missingProperty: missing }, true);
      cxt.error();
    }
    exports2.reportMissingProp = reportMissingProp;
    function hasPropFunc(gen) {
      return gen.scopeValue("func", {
        // eslint-disable-next-line @typescript-eslint/unbound-method
        ref: Object.prototype.hasOwnProperty,
        code: (0, codegen_1._)`Object.prototype.hasOwnProperty`
      });
    }
    exports2.hasPropFunc = hasPropFunc;
    function isOwnProperty(gen, data, property) {
      return (0, codegen_1._)`${hasPropFunc(gen)}.call(${data}, ${property})`;
    }
    exports2.isOwnProperty = isOwnProperty;
    function propertyInData(gen, data, property, ownProperties) {
      const cond = (0, codegen_1._)`${data}${(0, codegen_1.getProperty)(property)} !== undefined`;
      return ownProperties ? (0, codegen_1._)`${cond} && ${isOwnProperty(gen, data, property)}` : cond;
    }
    exports2.propertyInData = propertyInData;
    function noPropertyInData(gen, data, property, ownProperties) {
      const cond = (0, codegen_1._)`${data}${(0, codegen_1.getProperty)(property)} === undefined`;
      return ownProperties ? (0, codegen_1.or)(cond, (0, codegen_1.not)(isOwnProperty(gen, data, property))) : cond;
    }
    exports2.noPropertyInData = noPropertyInData;
    function allSchemaProperties(schemaMap) {
      return schemaMap ? Object.keys(schemaMap).filter((p) => p !== "__proto__") : [];
    }
    exports2.allSchemaProperties = allSchemaProperties;
    function schemaProperties(it2, schemaMap) {
      return allSchemaProperties(schemaMap).filter((p) => !(0, util_1.alwaysValidSchema)(it2, schemaMap[p]));
    }
    exports2.schemaProperties = schemaProperties;
    function callValidateCode({ schemaCode, data, it: { gen, topSchemaRef, schemaPath, errorPath }, it: it2 }, func, context, passSchema) {
      const dataAndSchema = passSchema ? (0, codegen_1._)`${schemaCode}, ${data}, ${topSchemaRef}${schemaPath}` : data;
      const valCxt = [
        [names_1.default.instancePath, (0, codegen_1.strConcat)(names_1.default.instancePath, errorPath)],
        [names_1.default.parentData, it2.parentData],
        [names_1.default.parentDataProperty, it2.parentDataProperty],
        [names_1.default.rootData, names_1.default.rootData]
      ];
      if (it2.opts.dynamicRef)
        valCxt.push([names_1.default.dynamicAnchors, names_1.default.dynamicAnchors]);
      const args = (0, codegen_1._)`${dataAndSchema}, ${gen.object(...valCxt)}`;
      return context !== codegen_1.nil ? (0, codegen_1._)`${func}.call(${context}, ${args})` : (0, codegen_1._)`${func}(${args})`;
    }
    exports2.callValidateCode = callValidateCode;
    var newRegExp = (0, codegen_1._)`new RegExp`;
    function usePattern({ gen, it: { opts } }, pattern) {
      const u = opts.unicodeRegExp ? "u" : "";
      const { regExp } = opts.code;
      const rx = regExp(pattern, u);
      return gen.scopeValue("pattern", {
        key: rx.toString(),
        ref: rx,
        code: (0, codegen_1._)`${regExp.code === "new RegExp" ? newRegExp : (0, util_2.useFunc)(gen, regExp)}(${pattern}, ${u})`
      });
    }
    exports2.usePattern = usePattern;
    function validateArray(cxt) {
      const { gen, data, keyword, it: it2 } = cxt;
      const valid = gen.name("valid");
      if (it2.allErrors) {
        const validArr = gen.let("valid", true);
        validateItems(() => gen.assign(validArr, false));
        return validArr;
      }
      gen.var(valid, true);
      validateItems(() => gen.break());
      return valid;
      function validateItems(notValid) {
        const len = gen.const("len", (0, codegen_1._)`${data}.length`);
        gen.forRange("i", 0, len, (i) => {
          cxt.subschema({
            keyword,
            dataProp: i,
            dataPropType: util_1.Type.Num
          }, valid);
          gen.if((0, codegen_1.not)(valid), notValid);
        });
      }
    }
    exports2.validateArray = validateArray;
    function validateUnion(cxt) {
      const { gen, schema, keyword, it: it2 } = cxt;
      if (!Array.isArray(schema))
        throw new Error("ajv implementation error");
      const alwaysValid = schema.some((sch) => (0, util_1.alwaysValidSchema)(it2, sch));
      if (alwaysValid && !it2.opts.unevaluated)
        return;
      const valid = gen.let("valid", false);
      const schValid = gen.name("_valid");
      gen.block(() => schema.forEach((_sch, i) => {
        const schCxt = cxt.subschema({
          keyword,
          schemaProp: i,
          compositeRule: true
        }, schValid);
        gen.assign(valid, (0, codegen_1._)`${valid} || ${schValid}`);
        const merged = cxt.mergeValidEvaluated(schCxt, schValid);
        if (!merged)
          gen.if((0, codegen_1.not)(valid));
      }));
      cxt.result(valid, () => cxt.reset(), () => cxt.error(true));
    }
    exports2.validateUnion = validateUnion;
  }
});

// node_modules/ajv/dist/compile/validate/keyword.js
var require_keyword = __commonJS({
  "node_modules/ajv/dist/compile/validate/keyword.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.validateKeywordUsage = exports2.validSchemaType = exports2.funcKeywordCode = exports2.macroKeywordCode = void 0;
    var codegen_1 = require_codegen();
    var names_1 = require_names();
    var code_1 = require_code2();
    var errors_1 = require_errors3();
    function macroKeywordCode(cxt, def) {
      const { gen, keyword, schema, parentSchema, it: it2 } = cxt;
      const macroSchema = def.macro.call(it2.self, schema, parentSchema, it2);
      const schemaRef = useKeyword(gen, keyword, macroSchema);
      if (it2.opts.validateSchema !== false)
        it2.self.validateSchema(macroSchema, true);
      const valid = gen.name("valid");
      cxt.subschema({
        schema: macroSchema,
        schemaPath: codegen_1.nil,
        errSchemaPath: `${it2.errSchemaPath}/${keyword}`,
        topSchemaRef: schemaRef,
        compositeRule: true
      }, valid);
      cxt.pass(valid, () => cxt.error(true));
    }
    exports2.macroKeywordCode = macroKeywordCode;
    function funcKeywordCode(cxt, def) {
      var _a;
      const { gen, keyword, schema, parentSchema, $data, it: it2 } = cxt;
      checkAsyncKeyword(it2, def);
      const validate = !$data && def.compile ? def.compile.call(it2.self, schema, parentSchema, it2) : def.validate;
      const validateRef = useKeyword(gen, keyword, validate);
      const valid = gen.let("valid");
      cxt.block$data(valid, validateKeyword);
      cxt.ok((_a = def.valid) !== null && _a !== void 0 ? _a : valid);
      function validateKeyword() {
        if (def.errors === false) {
          assignValid();
          if (def.modifying)
            modifyData(cxt);
          reportErrs(() => cxt.error());
        } else {
          const ruleErrs = def.async ? validateAsync() : validateSync();
          if (def.modifying)
            modifyData(cxt);
          reportErrs(() => addErrs(cxt, ruleErrs));
        }
      }
      function validateAsync() {
        const ruleErrs = gen.let("ruleErrs", null);
        gen.try(() => assignValid((0, codegen_1._)`await `), (e) => gen.assign(valid, false).if((0, codegen_1._)`${e} instanceof ${it2.ValidationError}`, () => gen.assign(ruleErrs, (0, codegen_1._)`${e}.errors`), () => gen.throw(e)));
        return ruleErrs;
      }
      function validateSync() {
        const validateErrs = (0, codegen_1._)`${validateRef}.errors`;
        gen.assign(validateErrs, null);
        assignValid(codegen_1.nil);
        return validateErrs;
      }
      function assignValid(_await = def.async ? (0, codegen_1._)`await ` : codegen_1.nil) {
        const passCxt = it2.opts.passContext ? names_1.default.this : names_1.default.self;
        const passSchema = !("compile" in def && !$data || def.schema === false);
        gen.assign(valid, (0, codegen_1._)`${_await}${(0, code_1.callValidateCode)(cxt, validateRef, passCxt, passSchema)}`, def.modifying);
      }
      function reportErrs(errors) {
        var _a2;
        gen.if((0, codegen_1.not)((_a2 = def.valid) !== null && _a2 !== void 0 ? _a2 : valid), errors);
      }
    }
    exports2.funcKeywordCode = funcKeywordCode;
    function modifyData(cxt) {
      const { gen, data, it: it2 } = cxt;
      gen.if(it2.parentData, () => gen.assign(data, (0, codegen_1._)`${it2.parentData}[${it2.parentDataProperty}]`));
    }
    function addErrs(cxt, errs) {
      const { gen } = cxt;
      gen.if((0, codegen_1._)`Array.isArray(${errs})`, () => {
        gen.assign(names_1.default.vErrors, (0, codegen_1._)`${names_1.default.vErrors} === null ? ${errs} : ${names_1.default.vErrors}.concat(${errs})`).assign(names_1.default.errors, (0, codegen_1._)`${names_1.default.vErrors}.length`);
        (0, errors_1.extendErrors)(cxt);
      }, () => cxt.error());
    }
    function checkAsyncKeyword({ schemaEnv }, def) {
      if (def.async && !schemaEnv.$async)
        throw new Error("async keyword in sync schema");
    }
    function useKeyword(gen, keyword, result) {
      if (result === void 0)
        throw new Error(`keyword "${keyword}" failed to compile`);
      return gen.scopeValue("keyword", typeof result == "function" ? { ref: result } : { ref: result, code: (0, codegen_1.stringify)(result) });
    }
    function validSchemaType(schema, schemaType, allowUndefined = false) {
      return !schemaType.length || schemaType.some((st) => st === "array" ? Array.isArray(schema) : st === "object" ? schema && typeof schema == "object" && !Array.isArray(schema) : typeof schema == st || allowUndefined && typeof schema == "undefined");
    }
    exports2.validSchemaType = validSchemaType;
    function validateKeywordUsage({ schema, opts, self: self2, errSchemaPath }, def, keyword) {
      if (Array.isArray(def.keyword) ? !def.keyword.includes(keyword) : def.keyword !== keyword) {
        throw new Error("ajv implementation error");
      }
      const deps = def.dependencies;
      if (deps === null || deps === void 0 ? void 0 : deps.some((kwd) => !Object.prototype.hasOwnProperty.call(schema, kwd))) {
        throw new Error(`parent schema must have dependencies of ${keyword}: ${deps.join(",")}`);
      }
      if (def.validateSchema) {
        const valid = def.validateSchema(schema[keyword]);
        if (!valid) {
          const msg = `keyword "${keyword}" value is invalid at path "${errSchemaPath}": ` + self2.errorsText(def.validateSchema.errors);
          if (opts.validateSchema === "log")
            self2.logger.error(msg);
          else
            throw new Error(msg);
        }
      }
    }
    exports2.validateKeywordUsage = validateKeywordUsage;
  }
});

// node_modules/ajv/dist/compile/validate/subschema.js
var require_subschema = __commonJS({
  "node_modules/ajv/dist/compile/validate/subschema.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.extendSubschemaMode = exports2.extendSubschemaData = exports2.getSubschema = void 0;
    var codegen_1 = require_codegen();
    var util_1 = require_util2();
    function getSubschema(it2, { keyword, schemaProp, schema, schemaPath, errSchemaPath, topSchemaRef }) {
      if (keyword !== void 0 && schema !== void 0) {
        throw new Error('both "keyword" and "schema" passed, only one allowed');
      }
      if (keyword !== void 0) {
        const sch = it2.schema[keyword];
        return schemaProp === void 0 ? {
          schema: sch,
          schemaPath: (0, codegen_1._)`${it2.schemaPath}${(0, codegen_1.getProperty)(keyword)}`,
          errSchemaPath: `${it2.errSchemaPath}/${keyword}`
        } : {
          schema: sch[schemaProp],
          schemaPath: (0, codegen_1._)`${it2.schemaPath}${(0, codegen_1.getProperty)(keyword)}${(0, codegen_1.getProperty)(schemaProp)}`,
          errSchemaPath: `${it2.errSchemaPath}/${keyword}/${(0, util_1.escapeFragment)(schemaProp)}`
        };
      }
      if (schema !== void 0) {
        if (schemaPath === void 0 || errSchemaPath === void 0 || topSchemaRef === void 0) {
          throw new Error('"schemaPath", "errSchemaPath" and "topSchemaRef" are required with "schema"');
        }
        return {
          schema,
          schemaPath,
          topSchemaRef,
          errSchemaPath
        };
      }
      throw new Error('either "keyword" or "schema" must be passed');
    }
    exports2.getSubschema = getSubschema;
    function extendSubschemaData(subschema, it2, { dataProp, dataPropType: dpType, data, dataTypes, propertyName }) {
      if (data !== void 0 && dataProp !== void 0) {
        throw new Error('both "data" and "dataProp" passed, only one allowed');
      }
      const { gen } = it2;
      if (dataProp !== void 0) {
        const { errorPath, dataPathArr, opts } = it2;
        const nextData = gen.let("data", (0, codegen_1._)`${it2.data}${(0, codegen_1.getProperty)(dataProp)}`, true);
        dataContextProps(nextData);
        subschema.errorPath = (0, codegen_1.str)`${errorPath}${(0, util_1.getErrorPath)(dataProp, dpType, opts.jsPropertySyntax)}`;
        subschema.parentDataProperty = (0, codegen_1._)`${dataProp}`;
        subschema.dataPathArr = [...dataPathArr, subschema.parentDataProperty];
      }
      if (data !== void 0) {
        const nextData = data instanceof codegen_1.Name ? data : gen.let("data", data, true);
        dataContextProps(nextData);
        if (propertyName !== void 0)
          subschema.propertyName = propertyName;
      }
      if (dataTypes)
        subschema.dataTypes = dataTypes;
      function dataContextProps(_nextData) {
        subschema.data = _nextData;
        subschema.dataLevel = it2.dataLevel + 1;
        subschema.dataTypes = [];
        it2.definedProperties = /* @__PURE__ */ new Set();
        subschema.parentData = it2.data;
        subschema.dataNames = [...it2.dataNames, _nextData];
      }
    }
    exports2.extendSubschemaData = extendSubschemaData;
    function extendSubschemaMode(subschema, { jtdDiscriminator, jtdMetadata, compositeRule, createErrors, allErrors }) {
      if (compositeRule !== void 0)
        subschema.compositeRule = compositeRule;
      if (createErrors !== void 0)
        subschema.createErrors = createErrors;
      if (allErrors !== void 0)
        subschema.allErrors = allErrors;
      subschema.jtdDiscriminator = jtdDiscriminator;
      subschema.jtdMetadata = jtdMetadata;
    }
    exports2.extendSubschemaMode = extendSubschemaMode;
  }
});

// node_modules/fast-deep-equal/index.js
var require_fast_deep_equal = __commonJS({
  "node_modules/fast-deep-equal/index.js"(exports2, module2) {
    "use strict";
    module2.exports = function equal(a, b) {
      if (a === b) return true;
      if (a && b && typeof a == "object" && typeof b == "object") {
        if (a.constructor !== b.constructor) return false;
        var length, i, keys;
        if (Array.isArray(a)) {
          length = a.length;
          if (length != b.length) return false;
          for (i = length; i-- !== 0; )
            if (!equal(a[i], b[i])) return false;
          return true;
        }
        if (a.constructor === RegExp) return a.source === b.source && a.flags === b.flags;
        if (a.valueOf !== Object.prototype.valueOf) return a.valueOf() === b.valueOf();
        if (a.toString !== Object.prototype.toString) return a.toString() === b.toString();
        keys = Object.keys(a);
        length = keys.length;
        if (length !== Object.keys(b).length) return false;
        for (i = length; i-- !== 0; )
          if (!Object.prototype.hasOwnProperty.call(b, keys[i])) return false;
        for (i = length; i-- !== 0; ) {
          var key = keys[i];
          if (!equal(a[key], b[key])) return false;
        }
        return true;
      }
      return a !== a && b !== b;
    };
  }
});

// node_modules/json-schema-traverse/index.js
var require_json_schema_traverse = __commonJS({
  "node_modules/json-schema-traverse/index.js"(exports2, module2) {
    "use strict";
    var traverse = module2.exports = function(schema, opts, cb) {
      if (typeof opts == "function") {
        cb = opts;
        opts = {};
      }
      cb = opts.cb || cb;
      var pre = typeof cb == "function" ? cb : cb.pre || function() {
      };
      var post = cb.post || function() {
      };
      _traverse(opts, pre, post, schema, "", schema);
    };
    traverse.keywords = {
      additionalItems: true,
      items: true,
      contains: true,
      additionalProperties: true,
      propertyNames: true,
      not: true,
      if: true,
      then: true,
      else: true
    };
    traverse.arrayKeywords = {
      items: true,
      allOf: true,
      anyOf: true,
      oneOf: true
    };
    traverse.propsKeywords = {
      $defs: true,
      definitions: true,
      properties: true,
      patternProperties: true,
      dependencies: true
    };
    traverse.skipKeywords = {
      default: true,
      enum: true,
      const: true,
      required: true,
      maximum: true,
      minimum: true,
      exclusiveMaximum: true,
      exclusiveMinimum: true,
      multipleOf: true,
      maxLength: true,
      minLength: true,
      pattern: true,
      format: true,
      maxItems: true,
      minItems: true,
      uniqueItems: true,
      maxProperties: true,
      minProperties: true
    };
    function _traverse(opts, pre, post, schema, jsonPtr, rootSchema, parentJsonPtr, parentKeyword, parentSchema, keyIndex) {
      if (schema && typeof schema == "object" && !Array.isArray(schema)) {
        pre(schema, jsonPtr, rootSchema, parentJsonPtr, parentKeyword, parentSchema, keyIndex);
        for (var key in schema) {
          var sch = schema[key];
          if (Array.isArray(sch)) {
            if (key in traverse.arrayKeywords) {
              for (var i = 0; i < sch.length; i++)
                _traverse(opts, pre, post, sch[i], jsonPtr + "/" + key + "/" + i, rootSchema, jsonPtr, key, schema, i);
            }
          } else if (key in traverse.propsKeywords) {
            if (sch && typeof sch == "object") {
              for (var prop in sch)
                _traverse(opts, pre, post, sch[prop], jsonPtr + "/" + key + "/" + escapeJsonPtr(prop), rootSchema, jsonPtr, key, schema, prop);
            }
          } else if (key in traverse.keywords || opts.allKeys && !(key in traverse.skipKeywords)) {
            _traverse(opts, pre, post, sch, jsonPtr + "/" + key, rootSchema, jsonPtr, key, schema);
          }
        }
        post(schema, jsonPtr, rootSchema, parentJsonPtr, parentKeyword, parentSchema, keyIndex);
      }
    }
    function escapeJsonPtr(str) {
      return str.replace(/~/g, "~0").replace(/\//g, "~1");
    }
  }
});

// node_modules/ajv/dist/compile/resolve.js
var require_resolve = __commonJS({
  "node_modules/ajv/dist/compile/resolve.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.getSchemaRefs = exports2.resolveUrl = exports2.normalizeId = exports2._getFullPath = exports2.getFullPath = exports2.inlineRef = void 0;
    var util_1 = require_util2();
    var equal = require_fast_deep_equal();
    var traverse = require_json_schema_traverse();
    var SIMPLE_INLINED = /* @__PURE__ */ new Set([
      "type",
      "format",
      "pattern",
      "maxLength",
      "minLength",
      "maxProperties",
      "minProperties",
      "maxItems",
      "minItems",
      "maximum",
      "minimum",
      "uniqueItems",
      "multipleOf",
      "required",
      "enum",
      "const"
    ]);
    function inlineRef(schema, limit = true) {
      if (typeof schema == "boolean")
        return true;
      if (limit === true)
        return !hasRef(schema);
      if (!limit)
        return false;
      return countKeys(schema) <= limit;
    }
    exports2.inlineRef = inlineRef;
    var REF_KEYWORDS = /* @__PURE__ */ new Set([
      "$ref",
      "$recursiveRef",
      "$recursiveAnchor",
      "$dynamicRef",
      "$dynamicAnchor"
    ]);
    function hasRef(schema) {
      for (const key in schema) {
        if (REF_KEYWORDS.has(key))
          return true;
        const sch = schema[key];
        if (Array.isArray(sch) && sch.some(hasRef))
          return true;
        if (typeof sch == "object" && hasRef(sch))
          return true;
      }
      return false;
    }
    function countKeys(schema) {
      let count = 0;
      for (const key in schema) {
        if (key === "$ref")
          return Infinity;
        count++;
        if (SIMPLE_INLINED.has(key))
          continue;
        if (typeof schema[key] == "object") {
          (0, util_1.eachItem)(schema[key], (sch) => count += countKeys(sch));
        }
        if (count === Infinity)
          return Infinity;
      }
      return count;
    }
    function getFullPath(resolver, id2 = "", normalize) {
      if (normalize !== false)
        id2 = normalizeId(id2);
      const p = resolver.parse(id2);
      return _getFullPath(resolver, p);
    }
    exports2.getFullPath = getFullPath;
    function _getFullPath(resolver, p) {
      const serialized = resolver.serialize(p);
      return serialized.split("#")[0] + "#";
    }
    exports2._getFullPath = _getFullPath;
    var TRAILING_SLASH_HASH = /#\/?$/;
    function normalizeId(id2) {
      return id2 ? id2.replace(TRAILING_SLASH_HASH, "") : "";
    }
    exports2.normalizeId = normalizeId;
    function resolveUrl(resolver, baseId, id2) {
      id2 = normalizeId(id2);
      return resolver.resolve(baseId, id2);
    }
    exports2.resolveUrl = resolveUrl;
    var ANCHOR = /^[a-z_][-a-z0-9._]*$/i;
    function getSchemaRefs(schema, baseId) {
      if (typeof schema == "boolean")
        return {};
      const { schemaId, uriResolver } = this.opts;
      const schId = normalizeId(schema[schemaId] || baseId);
      const baseIds = { "": schId };
      const pathPrefix = getFullPath(uriResolver, schId, false);
      const localRefs = {};
      const schemaRefs = /* @__PURE__ */ new Set();
      traverse(schema, { allKeys: true }, (sch, jsonPtr, _, parentJsonPtr) => {
        if (parentJsonPtr === void 0)
          return;
        const fullPath = pathPrefix + jsonPtr;
        let innerBaseId = baseIds[parentJsonPtr];
        if (typeof sch[schemaId] == "string")
          innerBaseId = addRef.call(this, sch[schemaId]);
        addAnchor.call(this, sch.$anchor);
        addAnchor.call(this, sch.$dynamicAnchor);
        baseIds[jsonPtr] = innerBaseId;
        function addRef(ref) {
          const _resolve = this.opts.uriResolver.resolve;
          ref = normalizeId(innerBaseId ? _resolve(innerBaseId, ref) : ref);
          if (schemaRefs.has(ref))
            throw ambiguos(ref);
          schemaRefs.add(ref);
          let schOrRef = this.refs[ref];
          if (typeof schOrRef == "string")
            schOrRef = this.refs[schOrRef];
          if (typeof schOrRef == "object") {
            checkAmbiguosRef(sch, schOrRef.schema, ref);
          } else if (ref !== normalizeId(fullPath)) {
            if (ref[0] === "#") {
              checkAmbiguosRef(sch, localRefs[ref], ref);
              localRefs[ref] = sch;
            } else {
              this.refs[ref] = fullPath;
            }
          }
          return ref;
        }
        function addAnchor(anchor) {
          if (typeof anchor == "string") {
            if (!ANCHOR.test(anchor))
              throw new Error(`invalid anchor "${anchor}"`);
            addRef.call(this, `#${anchor}`);
          }
        }
      });
      return localRefs;
      function checkAmbiguosRef(sch1, sch2, ref) {
        if (sch2 !== void 0 && !equal(sch1, sch2))
          throw ambiguos(ref);
      }
      function ambiguos(ref) {
        return new Error(`reference "${ref}" resolves to more than one schema`);
      }
    }
    exports2.getSchemaRefs = getSchemaRefs;
  }
});

// node_modules/ajv/dist/compile/validate/index.js
var require_validate = __commonJS({
  "node_modules/ajv/dist/compile/validate/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.getData = exports2.KeywordCxt = exports2.validateFunctionCode = void 0;
    var boolSchema_1 = require_boolSchema();
    var dataType_1 = require_dataType();
    var applicability_1 = require_applicability();
    var dataType_2 = require_dataType();
    var defaults_1 = require_defaults();
    var keyword_1 = require_keyword();
    var subschema_1 = require_subschema();
    var codegen_1 = require_codegen();
    var names_1 = require_names();
    var resolve_1 = require_resolve();
    var util_1 = require_util2();
    var errors_1 = require_errors3();
    function validateFunctionCode(it2) {
      if (isSchemaObj(it2)) {
        checkKeywords(it2);
        if (schemaCxtHasRules(it2)) {
          topSchemaObjCode(it2);
          return;
        }
      }
      validateFunction(it2, () => (0, boolSchema_1.topBoolOrEmptySchema)(it2));
    }
    exports2.validateFunctionCode = validateFunctionCode;
    function validateFunction({ gen, validateName, schema, schemaEnv, opts }, body) {
      if (opts.code.es5) {
        gen.func(validateName, (0, codegen_1._)`${names_1.default.data}, ${names_1.default.valCxt}`, schemaEnv.$async, () => {
          gen.code((0, codegen_1._)`"use strict"; ${funcSourceUrl(schema, opts)}`);
          destructureValCxtES5(gen, opts);
          gen.code(body);
        });
      } else {
        gen.func(validateName, (0, codegen_1._)`${names_1.default.data}, ${destructureValCxt(opts)}`, schemaEnv.$async, () => gen.code(funcSourceUrl(schema, opts)).code(body));
      }
    }
    function destructureValCxt(opts) {
      return (0, codegen_1._)`{${names_1.default.instancePath}="", ${names_1.default.parentData}, ${names_1.default.parentDataProperty}, ${names_1.default.rootData}=${names_1.default.data}${opts.dynamicRef ? (0, codegen_1._)`, ${names_1.default.dynamicAnchors}={}` : codegen_1.nil}}={}`;
    }
    function destructureValCxtES5(gen, opts) {
      gen.if(names_1.default.valCxt, () => {
        gen.var(names_1.default.instancePath, (0, codegen_1._)`${names_1.default.valCxt}.${names_1.default.instancePath}`);
        gen.var(names_1.default.parentData, (0, codegen_1._)`${names_1.default.valCxt}.${names_1.default.parentData}`);
        gen.var(names_1.default.parentDataProperty, (0, codegen_1._)`${names_1.default.valCxt}.${names_1.default.parentDataProperty}`);
        gen.var(names_1.default.rootData, (0, codegen_1._)`${names_1.default.valCxt}.${names_1.default.rootData}`);
        if (opts.dynamicRef)
          gen.var(names_1.default.dynamicAnchors, (0, codegen_1._)`${names_1.default.valCxt}.${names_1.default.dynamicAnchors}`);
      }, () => {
        gen.var(names_1.default.instancePath, (0, codegen_1._)`""`);
        gen.var(names_1.default.parentData, (0, codegen_1._)`undefined`);
        gen.var(names_1.default.parentDataProperty, (0, codegen_1._)`undefined`);
        gen.var(names_1.default.rootData, names_1.default.data);
        if (opts.dynamicRef)
          gen.var(names_1.default.dynamicAnchors, (0, codegen_1._)`{}`);
      });
    }
    function topSchemaObjCode(it2) {
      const { schema, opts, gen } = it2;
      validateFunction(it2, () => {
        if (opts.$comment && schema.$comment)
          commentKeyword(it2);
        checkNoDefault(it2);
        gen.let(names_1.default.vErrors, null);
        gen.let(names_1.default.errors, 0);
        if (opts.unevaluated)
          resetEvaluated(it2);
        typeAndKeywords(it2);
        returnResults(it2);
      });
      return;
    }
    function resetEvaluated(it2) {
      const { gen, validateName } = it2;
      it2.evaluated = gen.const("evaluated", (0, codegen_1._)`${validateName}.evaluated`);
      gen.if((0, codegen_1._)`${it2.evaluated}.dynamicProps`, () => gen.assign((0, codegen_1._)`${it2.evaluated}.props`, (0, codegen_1._)`undefined`));
      gen.if((0, codegen_1._)`${it2.evaluated}.dynamicItems`, () => gen.assign((0, codegen_1._)`${it2.evaluated}.items`, (0, codegen_1._)`undefined`));
    }
    function funcSourceUrl(schema, opts) {
      const schId = typeof schema == "object" && schema[opts.schemaId];
      return schId && (opts.code.source || opts.code.process) ? (0, codegen_1._)`/*# sourceURL=${schId} */` : codegen_1.nil;
    }
    function subschemaCode(it2, valid) {
      if (isSchemaObj(it2)) {
        checkKeywords(it2);
        if (schemaCxtHasRules(it2)) {
          subSchemaObjCode(it2, valid);
          return;
        }
      }
      (0, boolSchema_1.boolOrEmptySchema)(it2, valid);
    }
    function schemaCxtHasRules({ schema, self: self2 }) {
      if (typeof schema == "boolean")
        return !schema;
      for (const key in schema)
        if (self2.RULES.all[key])
          return true;
      return false;
    }
    function isSchemaObj(it2) {
      return typeof it2.schema != "boolean";
    }
    function subSchemaObjCode(it2, valid) {
      const { schema, gen, opts } = it2;
      if (opts.$comment && schema.$comment)
        commentKeyword(it2);
      updateContext(it2);
      checkAsyncSchema(it2);
      const errsCount = gen.const("_errs", names_1.default.errors);
      typeAndKeywords(it2, errsCount);
      gen.var(valid, (0, codegen_1._)`${errsCount} === ${names_1.default.errors}`);
    }
    function checkKeywords(it2) {
      (0, util_1.checkUnknownRules)(it2);
      checkRefsAndKeywords(it2);
    }
    function typeAndKeywords(it2, errsCount) {
      if (it2.opts.jtd)
        return schemaKeywords(it2, [], false, errsCount);
      const types = (0, dataType_1.getSchemaTypes)(it2.schema);
      const checkedTypes = (0, dataType_1.coerceAndCheckDataType)(it2, types);
      schemaKeywords(it2, types, !checkedTypes, errsCount);
    }
    function checkRefsAndKeywords(it2) {
      const { schema, errSchemaPath, opts, self: self2 } = it2;
      if (schema.$ref && opts.ignoreKeywordsWithRef && (0, util_1.schemaHasRulesButRef)(schema, self2.RULES)) {
        self2.logger.warn(`$ref: keywords ignored in schema at path "${errSchemaPath}"`);
      }
    }
    function checkNoDefault(it2) {
      const { schema, opts } = it2;
      if (schema.default !== void 0 && opts.useDefaults && opts.strictSchema) {
        (0, util_1.checkStrictMode)(it2, "default is ignored in the schema root");
      }
    }
    function updateContext(it2) {
      const schId = it2.schema[it2.opts.schemaId];
      if (schId)
        it2.baseId = (0, resolve_1.resolveUrl)(it2.opts.uriResolver, it2.baseId, schId);
    }
    function checkAsyncSchema(it2) {
      if (it2.schema.$async && !it2.schemaEnv.$async)
        throw new Error("async schema in sync schema");
    }
    function commentKeyword({ gen, schemaEnv, schema, errSchemaPath, opts }) {
      const msg = schema.$comment;
      if (opts.$comment === true) {
        gen.code((0, codegen_1._)`${names_1.default.self}.logger.log(${msg})`);
      } else if (typeof opts.$comment == "function") {
        const schemaPath = (0, codegen_1.str)`${errSchemaPath}/$comment`;
        const rootName = gen.scopeValue("root", { ref: schemaEnv.root });
        gen.code((0, codegen_1._)`${names_1.default.self}.opts.$comment(${msg}, ${schemaPath}, ${rootName}.schema)`);
      }
    }
    function returnResults(it2) {
      const { gen, schemaEnv, validateName, ValidationError, opts } = it2;
      if (schemaEnv.$async) {
        gen.if((0, codegen_1._)`${names_1.default.errors} === 0`, () => gen.return(names_1.default.data), () => gen.throw((0, codegen_1._)`new ${ValidationError}(${names_1.default.vErrors})`));
      } else {
        gen.assign((0, codegen_1._)`${validateName}.errors`, names_1.default.vErrors);
        if (opts.unevaluated)
          assignEvaluated(it2);
        gen.return((0, codegen_1._)`${names_1.default.errors} === 0`);
      }
    }
    function assignEvaluated({ gen, evaluated, props, items }) {
      if (props instanceof codegen_1.Name)
        gen.assign((0, codegen_1._)`${evaluated}.props`, props);
      if (items instanceof codegen_1.Name)
        gen.assign((0, codegen_1._)`${evaluated}.items`, items);
    }
    function schemaKeywords(it2, types, typeErrors, errsCount) {
      const { gen, schema, data, allErrors, opts, self: self2 } = it2;
      const { RULES } = self2;
      if (schema.$ref && (opts.ignoreKeywordsWithRef || !(0, util_1.schemaHasRulesButRef)(schema, RULES))) {
        gen.block(() => keywordCode(it2, "$ref", RULES.all.$ref.definition));
        return;
      }
      if (!opts.jtd)
        checkStrictTypes(it2, types);
      gen.block(() => {
        for (const group of RULES.rules)
          groupKeywords(group);
        groupKeywords(RULES.post);
      });
      function groupKeywords(group) {
        if (!(0, applicability_1.shouldUseGroup)(schema, group))
          return;
        if (group.type) {
          gen.if((0, dataType_2.checkDataType)(group.type, data, opts.strictNumbers));
          iterateKeywords(it2, group);
          if (types.length === 1 && types[0] === group.type && typeErrors) {
            gen.else();
            (0, dataType_2.reportTypeError)(it2);
          }
          gen.endIf();
        } else {
          iterateKeywords(it2, group);
        }
        if (!allErrors)
          gen.if((0, codegen_1._)`${names_1.default.errors} === ${errsCount || 0}`);
      }
    }
    function iterateKeywords(it2, group) {
      const { gen, schema, opts: { useDefaults } } = it2;
      if (useDefaults)
        (0, defaults_1.assignDefaults)(it2, group.type);
      gen.block(() => {
        for (const rule of group.rules) {
          if ((0, applicability_1.shouldUseRule)(schema, rule)) {
            keywordCode(it2, rule.keyword, rule.definition, group.type);
          }
        }
      });
    }
    function checkStrictTypes(it2, types) {
      if (it2.schemaEnv.meta || !it2.opts.strictTypes)
        return;
      checkContextTypes(it2, types);
      if (!it2.opts.allowUnionTypes)
        checkMultipleTypes(it2, types);
      checkKeywordTypes(it2, it2.dataTypes);
    }
    function checkContextTypes(it2, types) {
      if (!types.length)
        return;
      if (!it2.dataTypes.length) {
        it2.dataTypes = types;
        return;
      }
      types.forEach((t) => {
        if (!includesType(it2.dataTypes, t)) {
          strictTypesError(it2, `type "${t}" not allowed by context "${it2.dataTypes.join(",")}"`);
        }
      });
      narrowSchemaTypes(it2, types);
    }
    function checkMultipleTypes(it2, ts) {
      if (ts.length > 1 && !(ts.length === 2 && ts.includes("null"))) {
        strictTypesError(it2, "use allowUnionTypes to allow union type keyword");
      }
    }
    function checkKeywordTypes(it2, ts) {
      const rules = it2.self.RULES.all;
      for (const keyword in rules) {
        const rule = rules[keyword];
        if (typeof rule == "object" && (0, applicability_1.shouldUseRule)(it2.schema, rule)) {
          const { type } = rule.definition;
          if (type.length && !type.some((t) => hasApplicableType(ts, t))) {
            strictTypesError(it2, `missing type "${type.join(",")}" for keyword "${keyword}"`);
          }
        }
      }
    }
    function hasApplicableType(schTs, kwdT) {
      return schTs.includes(kwdT) || kwdT === "number" && schTs.includes("integer");
    }
    function includesType(ts, t) {
      return ts.includes(t) || t === "integer" && ts.includes("number");
    }
    function narrowSchemaTypes(it2, withTypes) {
      const ts = [];
      for (const t of it2.dataTypes) {
        if (includesType(withTypes, t))
          ts.push(t);
        else if (withTypes.includes("integer") && t === "number")
          ts.push("integer");
      }
      it2.dataTypes = ts;
    }
    function strictTypesError(it2, msg) {
      const schemaPath = it2.schemaEnv.baseId + it2.errSchemaPath;
      msg += ` at "${schemaPath}" (strictTypes)`;
      (0, util_1.checkStrictMode)(it2, msg, it2.opts.strictTypes);
    }
    var KeywordCxt = class {
      constructor(it2, def, keyword) {
        (0, keyword_1.validateKeywordUsage)(it2, def, keyword);
        this.gen = it2.gen;
        this.allErrors = it2.allErrors;
        this.keyword = keyword;
        this.data = it2.data;
        this.schema = it2.schema[keyword];
        this.$data = def.$data && it2.opts.$data && this.schema && this.schema.$data;
        this.schemaValue = (0, util_1.schemaRefOrVal)(it2, this.schema, keyword, this.$data);
        this.schemaType = def.schemaType;
        this.parentSchema = it2.schema;
        this.params = {};
        this.it = it2;
        this.def = def;
        if (this.$data) {
          this.schemaCode = it2.gen.const("vSchema", getData(this.$data, it2));
        } else {
          this.schemaCode = this.schemaValue;
          if (!(0, keyword_1.validSchemaType)(this.schema, def.schemaType, def.allowUndefined)) {
            throw new Error(`${keyword} value must be ${JSON.stringify(def.schemaType)}`);
          }
        }
        if ("code" in def ? def.trackErrors : def.errors !== false) {
          this.errsCount = it2.gen.const("_errs", names_1.default.errors);
        }
      }
      result(condition, successAction, failAction) {
        this.failResult((0, codegen_1.not)(condition), successAction, failAction);
      }
      failResult(condition, successAction, failAction) {
        this.gen.if(condition);
        if (failAction)
          failAction();
        else
          this.error();
        if (successAction) {
          this.gen.else();
          successAction();
          if (this.allErrors)
            this.gen.endIf();
        } else {
          if (this.allErrors)
            this.gen.endIf();
          else
            this.gen.else();
        }
      }
      pass(condition, failAction) {
        this.failResult((0, codegen_1.not)(condition), void 0, failAction);
      }
      fail(condition) {
        if (condition === void 0) {
          this.error();
          if (!this.allErrors)
            this.gen.if(false);
          return;
        }
        this.gen.if(condition);
        this.error();
        if (this.allErrors)
          this.gen.endIf();
        else
          this.gen.else();
      }
      fail$data(condition) {
        if (!this.$data)
          return this.fail(condition);
        const { schemaCode } = this;
        this.fail((0, codegen_1._)`${schemaCode} !== undefined && (${(0, codegen_1.or)(this.invalid$data(), condition)})`);
      }
      error(append, errorParams, errorPaths) {
        if (errorParams) {
          this.setParams(errorParams);
          this._error(append, errorPaths);
          this.setParams({});
          return;
        }
        this._error(append, errorPaths);
      }
      _error(append, errorPaths) {
        ;
        (append ? errors_1.reportExtraError : errors_1.reportError)(this, this.def.error, errorPaths);
      }
      $dataError() {
        (0, errors_1.reportError)(this, this.def.$dataError || errors_1.keyword$DataError);
      }
      reset() {
        if (this.errsCount === void 0)
          throw new Error('add "trackErrors" to keyword definition');
        (0, errors_1.resetErrorsCount)(this.gen, this.errsCount);
      }
      ok(cond) {
        if (!this.allErrors)
          this.gen.if(cond);
      }
      setParams(obj, assign) {
        if (assign)
          Object.assign(this.params, obj);
        else
          this.params = obj;
      }
      block$data(valid, codeBlock, $dataValid = codegen_1.nil) {
        this.gen.block(() => {
          this.check$data(valid, $dataValid);
          codeBlock();
        });
      }
      check$data(valid = codegen_1.nil, $dataValid = codegen_1.nil) {
        if (!this.$data)
          return;
        const { gen, schemaCode, schemaType, def } = this;
        gen.if((0, codegen_1.or)((0, codegen_1._)`${schemaCode} === undefined`, $dataValid));
        if (valid !== codegen_1.nil)
          gen.assign(valid, true);
        if (schemaType.length || def.validateSchema) {
          gen.elseIf(this.invalid$data());
          this.$dataError();
          if (valid !== codegen_1.nil)
            gen.assign(valid, false);
        }
        gen.else();
      }
      invalid$data() {
        const { gen, schemaCode, schemaType, def, it: it2 } = this;
        return (0, codegen_1.or)(wrong$DataType(), invalid$DataSchema());
        function wrong$DataType() {
          if (schemaType.length) {
            if (!(schemaCode instanceof codegen_1.Name))
              throw new Error("ajv implementation error");
            const st = Array.isArray(schemaType) ? schemaType : [schemaType];
            return (0, codegen_1._)`${(0, dataType_2.checkDataTypes)(st, schemaCode, it2.opts.strictNumbers, dataType_2.DataType.Wrong)}`;
          }
          return codegen_1.nil;
        }
        function invalid$DataSchema() {
          if (def.validateSchema) {
            const validateSchemaRef = gen.scopeValue("validate$data", { ref: def.validateSchema });
            return (0, codegen_1._)`!${validateSchemaRef}(${schemaCode})`;
          }
          return codegen_1.nil;
        }
      }
      subschema(appl, valid) {
        const subschema = (0, subschema_1.getSubschema)(this.it, appl);
        (0, subschema_1.extendSubschemaData)(subschema, this.it, appl);
        (0, subschema_1.extendSubschemaMode)(subschema, appl);
        const nextContext = { ...this.it, ...subschema, items: void 0, props: void 0 };
        subschemaCode(nextContext, valid);
        return nextContext;
      }
      mergeEvaluated(schemaCxt, toName) {
        const { it: it2, gen } = this;
        if (!it2.opts.unevaluated)
          return;
        if (it2.props !== true && schemaCxt.props !== void 0) {
          it2.props = util_1.mergeEvaluated.props(gen, schemaCxt.props, it2.props, toName);
        }
        if (it2.items !== true && schemaCxt.items !== void 0) {
          it2.items = util_1.mergeEvaluated.items(gen, schemaCxt.items, it2.items, toName);
        }
      }
      mergeValidEvaluated(schemaCxt, valid) {
        const { it: it2, gen } = this;
        if (it2.opts.unevaluated && (it2.props !== true || it2.items !== true)) {
          gen.if(valid, () => this.mergeEvaluated(schemaCxt, codegen_1.Name));
          return true;
        }
      }
    };
    exports2.KeywordCxt = KeywordCxt;
    function keywordCode(it2, keyword, def, ruleType) {
      const cxt = new KeywordCxt(it2, def, keyword);
      if ("code" in def) {
        def.code(cxt, ruleType);
      } else if (cxt.$data && def.validate) {
        (0, keyword_1.funcKeywordCode)(cxt, def);
      } else if ("macro" in def) {
        (0, keyword_1.macroKeywordCode)(cxt, def);
      } else if (def.compile || def.validate) {
        (0, keyword_1.funcKeywordCode)(cxt, def);
      }
    }
    var JSON_POINTER = /^\/(?:[^~]|~0|~1)*$/;
    var RELATIVE_JSON_POINTER = /^([0-9]+)(#|\/(?:[^~]|~0|~1)*)?$/;
    function getData($data, { dataLevel, dataNames, dataPathArr }) {
      let jsonPointer;
      let data;
      if ($data === "")
        return names_1.default.rootData;
      if ($data[0] === "/") {
        if (!JSON_POINTER.test($data))
          throw new Error(`Invalid JSON-pointer: ${$data}`);
        jsonPointer = $data;
        data = names_1.default.rootData;
      } else {
        const matches = RELATIVE_JSON_POINTER.exec($data);
        if (!matches)
          throw new Error(`Invalid JSON-pointer: ${$data}`);
        const up = +matches[1];
        jsonPointer = matches[2];
        if (jsonPointer === "#") {
          if (up >= dataLevel)
            throw new Error(errorMsg("property/index", up));
          return dataPathArr[dataLevel - up];
        }
        if (up > dataLevel)
          throw new Error(errorMsg("data", up));
        data = dataNames[dataLevel - up];
        if (!jsonPointer)
          return data;
      }
      let expr = data;
      const segments = jsonPointer.split("/");
      for (const segment of segments) {
        if (segment) {
          data = (0, codegen_1._)`${data}${(0, codegen_1.getProperty)((0, util_1.unescapeJsonPointer)(segment))}`;
          expr = (0, codegen_1._)`${expr} && ${data}`;
        }
      }
      return expr;
      function errorMsg(pointerType, up) {
        return `Cannot access ${pointerType} ${up} levels up, current level is ${dataLevel}`;
      }
    }
    exports2.getData = getData;
  }
});

// node_modules/ajv/dist/runtime/validation_error.js
var require_validation_error = __commonJS({
  "node_modules/ajv/dist/runtime/validation_error.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var ValidationError = class extends Error {
      constructor(errors) {
        super("validation failed");
        this.errors = errors;
        this.ajv = this.validation = true;
      }
    };
    exports2.default = ValidationError;
  }
});

// node_modules/ajv/dist/compile/ref_error.js
var require_ref_error = __commonJS({
  "node_modules/ajv/dist/compile/ref_error.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var resolve_1 = require_resolve();
    var MissingRefError = class extends Error {
      constructor(resolver, baseId, ref, msg) {
        super(msg || `can't resolve reference ${ref} from id ${baseId}`);
        this.missingRef = (0, resolve_1.resolveUrl)(resolver, baseId, ref);
        this.missingSchema = (0, resolve_1.normalizeId)((0, resolve_1.getFullPath)(resolver, this.missingRef));
      }
    };
    exports2.default = MissingRefError;
  }
});

// node_modules/ajv/dist/compile/index.js
var require_compile = __commonJS({
  "node_modules/ajv/dist/compile/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.resolveSchema = exports2.getCompilingSchema = exports2.resolveRef = exports2.compileSchema = exports2.SchemaEnv = void 0;
    var codegen_1 = require_codegen();
    var validation_error_1 = require_validation_error();
    var names_1 = require_names();
    var resolve_1 = require_resolve();
    var util_1 = require_util2();
    var validate_1 = require_validate();
    var SchemaEnv = class {
      constructor(env) {
        var _a;
        this.refs = {};
        this.dynamicAnchors = {};
        let schema;
        if (typeof env.schema == "object")
          schema = env.schema;
        this.schema = env.schema;
        this.schemaId = env.schemaId;
        this.root = env.root || this;
        this.baseId = (_a = env.baseId) !== null && _a !== void 0 ? _a : (0, resolve_1.normalizeId)(schema === null || schema === void 0 ? void 0 : schema[env.schemaId || "$id"]);
        this.schemaPath = env.schemaPath;
        this.localRefs = env.localRefs;
        this.meta = env.meta;
        this.$async = schema === null || schema === void 0 ? void 0 : schema.$async;
        this.refs = {};
      }
    };
    exports2.SchemaEnv = SchemaEnv;
    function compileSchema(sch) {
      const _sch = getCompilingSchema.call(this, sch);
      if (_sch)
        return _sch;
      const rootId = (0, resolve_1.getFullPath)(this.opts.uriResolver, sch.root.baseId);
      const { es5, lines } = this.opts.code;
      const { ownProperties } = this.opts;
      const gen = new codegen_1.CodeGen(this.scope, { es5, lines, ownProperties });
      let _ValidationError;
      if (sch.$async) {
        _ValidationError = gen.scopeValue("Error", {
          ref: validation_error_1.default,
          code: (0, codegen_1._)`require("ajv/dist/runtime/validation_error").default`
        });
      }
      const validateName = gen.scopeName("validate");
      sch.validateName = validateName;
      const schemaCxt = {
        gen,
        allErrors: this.opts.allErrors,
        data: names_1.default.data,
        parentData: names_1.default.parentData,
        parentDataProperty: names_1.default.parentDataProperty,
        dataNames: [names_1.default.data],
        dataPathArr: [codegen_1.nil],
        // TODO can its length be used as dataLevel if nil is removed?
        dataLevel: 0,
        dataTypes: [],
        definedProperties: /* @__PURE__ */ new Set(),
        topSchemaRef: gen.scopeValue("schema", this.opts.code.source === true ? { ref: sch.schema, code: (0, codegen_1.stringify)(sch.schema) } : { ref: sch.schema }),
        validateName,
        ValidationError: _ValidationError,
        schema: sch.schema,
        schemaEnv: sch,
        rootId,
        baseId: sch.baseId || rootId,
        schemaPath: codegen_1.nil,
        errSchemaPath: sch.schemaPath || (this.opts.jtd ? "" : "#"),
        errorPath: (0, codegen_1._)`""`,
        opts: this.opts,
        self: this
      };
      let sourceCode;
      try {
        this._compilations.add(sch);
        (0, validate_1.validateFunctionCode)(schemaCxt);
        gen.optimize(this.opts.code.optimize);
        const validateCode = gen.toString();
        sourceCode = `${gen.scopeRefs(names_1.default.scope)}return ${validateCode}`;
        if (this.opts.code.process)
          sourceCode = this.opts.code.process(sourceCode, sch);
        const makeValidate = new Function(`${names_1.default.self}`, `${names_1.default.scope}`, sourceCode);
        const validate = makeValidate(this, this.scope.get());
        this.scope.value(validateName, { ref: validate });
        validate.errors = null;
        validate.schema = sch.schema;
        validate.schemaEnv = sch;
        if (sch.$async)
          validate.$async = true;
        if (this.opts.code.source === true) {
          validate.source = { validateName, validateCode, scopeValues: gen._values };
        }
        if (this.opts.unevaluated) {
          const { props, items } = schemaCxt;
          validate.evaluated = {
            props: props instanceof codegen_1.Name ? void 0 : props,
            items: items instanceof codegen_1.Name ? void 0 : items,
            dynamicProps: props instanceof codegen_1.Name,
            dynamicItems: items instanceof codegen_1.Name
          };
          if (validate.source)
            validate.source.evaluated = (0, codegen_1.stringify)(validate.evaluated);
        }
        sch.validate = validate;
        return sch;
      } catch (e) {
        delete sch.validate;
        delete sch.validateName;
        if (sourceCode)
          this.logger.error("Error compiling schema, function code:", sourceCode);
        throw e;
      } finally {
        this._compilations.delete(sch);
      }
    }
    exports2.compileSchema = compileSchema;
    function resolveRef(root, baseId, ref) {
      var _a;
      ref = (0, resolve_1.resolveUrl)(this.opts.uriResolver, baseId, ref);
      const schOrFunc = root.refs[ref];
      if (schOrFunc)
        return schOrFunc;
      let _sch = resolve.call(this, root, ref);
      if (_sch === void 0) {
        const schema = (_a = root.localRefs) === null || _a === void 0 ? void 0 : _a[ref];
        const { schemaId } = this.opts;
        if (schema)
          _sch = new SchemaEnv({ schema, schemaId, root, baseId });
      }
      if (_sch === void 0)
        return;
      return root.refs[ref] = inlineOrCompile.call(this, _sch);
    }
    exports2.resolveRef = resolveRef;
    function inlineOrCompile(sch) {
      if ((0, resolve_1.inlineRef)(sch.schema, this.opts.inlineRefs))
        return sch.schema;
      return sch.validate ? sch : compileSchema.call(this, sch);
    }
    function getCompilingSchema(schEnv) {
      for (const sch of this._compilations) {
        if (sameSchemaEnv(sch, schEnv))
          return sch;
      }
    }
    exports2.getCompilingSchema = getCompilingSchema;
    function sameSchemaEnv(s1, s2) {
      return s1.schema === s2.schema && s1.root === s2.root && s1.baseId === s2.baseId;
    }
    function resolve(root, ref) {
      let sch;
      while (typeof (sch = this.refs[ref]) == "string")
        ref = sch;
      return sch || this.schemas[ref] || resolveSchema.call(this, root, ref);
    }
    function resolveSchema(root, ref) {
      const p = this.opts.uriResolver.parse(ref);
      const refPath = (0, resolve_1._getFullPath)(this.opts.uriResolver, p);
      let baseId = (0, resolve_1.getFullPath)(this.opts.uriResolver, root.baseId, void 0);
      if (Object.keys(root.schema).length > 0 && refPath === baseId) {
        return getJsonPointer.call(this, p, root);
      }
      const id2 = (0, resolve_1.normalizeId)(refPath);
      const schOrRef = this.refs[id2] || this.schemas[id2];
      if (typeof schOrRef == "string") {
        const sch = resolveSchema.call(this, root, schOrRef);
        if (typeof (sch === null || sch === void 0 ? void 0 : sch.schema) !== "object")
          return;
        return getJsonPointer.call(this, p, sch);
      }
      if (typeof (schOrRef === null || schOrRef === void 0 ? void 0 : schOrRef.schema) !== "object")
        return;
      if (!schOrRef.validate)
        compileSchema.call(this, schOrRef);
      if (id2 === (0, resolve_1.normalizeId)(ref)) {
        const { schema } = schOrRef;
        const { schemaId } = this.opts;
        const schId = schema[schemaId];
        if (schId)
          baseId = (0, resolve_1.resolveUrl)(this.opts.uriResolver, baseId, schId);
        return new SchemaEnv({ schema, schemaId, root, baseId });
      }
      return getJsonPointer.call(this, p, schOrRef);
    }
    exports2.resolveSchema = resolveSchema;
    var PREVENT_SCOPE_CHANGE = /* @__PURE__ */ new Set([
      "properties",
      "patternProperties",
      "enum",
      "dependencies",
      "definitions"
    ]);
    function getJsonPointer(parsedRef, { baseId, schema, root }) {
      var _a;
      if (((_a = parsedRef.fragment) === null || _a === void 0 ? void 0 : _a[0]) !== "/")
        return;
      for (const part of parsedRef.fragment.slice(1).split("/")) {
        if (typeof schema === "boolean")
          return;
        const partSchema = schema[(0, util_1.unescapeFragment)(part)];
        if (partSchema === void 0)
          return;
        schema = partSchema;
        const schId = typeof schema === "object" && schema[this.opts.schemaId];
        if (!PREVENT_SCOPE_CHANGE.has(part) && schId) {
          baseId = (0, resolve_1.resolveUrl)(this.opts.uriResolver, baseId, schId);
        }
      }
      let env;
      if (typeof schema != "boolean" && schema.$ref && !(0, util_1.schemaHasRulesButRef)(schema, this.RULES)) {
        const $ref = (0, resolve_1.resolveUrl)(this.opts.uriResolver, baseId, schema.$ref);
        env = resolveSchema.call(this, root, $ref);
      }
      const { schemaId } = this.opts;
      env = env || new SchemaEnv({ schema, schemaId, root, baseId });
      if (env.schema !== env.root.schema)
        return env;
      return void 0;
    }
  }
});

// node_modules/ajv/dist/refs/data.json
var require_data = __commonJS({
  "node_modules/ajv/dist/refs/data.json"(exports2, module2) {
    module2.exports = {
      $id: "https://raw.githubusercontent.com/ajv-validator/ajv/master/lib/refs/data.json#",
      description: "Meta-schema for $data reference (JSON AnySchema extension proposal)",
      type: "object",
      required: ["$data"],
      properties: {
        $data: {
          type: "string",
          anyOf: [{ format: "relative-json-pointer" }, { format: "json-pointer" }]
        }
      },
      additionalProperties: false
    };
  }
});

// node_modules/fast-uri/lib/scopedChars.js
var require_scopedChars = __commonJS({
  "node_modules/fast-uri/lib/scopedChars.js"(exports2, module2) {
    "use strict";
    var HEX = {
      0: 0,
      1: 1,
      2: 2,
      3: 3,
      4: 4,
      5: 5,
      6: 6,
      7: 7,
      8: 8,
      9: 9,
      a: 10,
      A: 10,
      b: 11,
      B: 11,
      c: 12,
      C: 12,
      d: 13,
      D: 13,
      e: 14,
      E: 14,
      f: 15,
      F: 15
    };
    module2.exports = {
      HEX
    };
  }
});

// node_modules/fast-uri/lib/utils.js
var require_utils = __commonJS({
  "node_modules/fast-uri/lib/utils.js"(exports2, module2) {
    "use strict";
    var { HEX } = require_scopedChars();
    var IPV4_REG = /^(?:(?:25[0-5]|2[0-4]\d|1\d{2}|[1-9]\d|\d)\.){3}(?:25[0-5]|2[0-4]\d|1\d{2}|[1-9]\d|\d)$/u;
    function normalizeIPv4(host) {
      if (findToken(host, ".") < 3) {
        return { host, isIPV4: false };
      }
      const matches = host.match(IPV4_REG) || [];
      const [address] = matches;
      if (address) {
        return { host: stripLeadingZeros(address, "."), isIPV4: true };
      } else {
        return { host, isIPV4: false };
      }
    }
    function stringArrayToHexStripped(input, keepZero = false) {
      let acc = "";
      let strip = true;
      for (const c of input) {
        if (HEX[c] === void 0) return void 0;
        if (c !== "0" && strip === true) strip = false;
        if (!strip) acc += c;
      }
      if (keepZero && acc.length === 0) acc = "0";
      return acc;
    }
    function getIPV6(input) {
      let tokenCount = 0;
      const output = { error: false, address: "", zone: "" };
      const address = [];
      const buffer = [];
      let isZone = false;
      let endipv6Encountered = false;
      let endIpv6 = false;
      function consume() {
        if (buffer.length) {
          if (isZone === false) {
            const hex = stringArrayToHexStripped(buffer);
            if (hex !== void 0) {
              address.push(hex);
            } else {
              output.error = true;
              return false;
            }
          }
          buffer.length = 0;
        }
        return true;
      }
      for (let i = 0; i < input.length; i++) {
        const cursor = input[i];
        if (cursor === "[" || cursor === "]") {
          continue;
        }
        if (cursor === ":") {
          if (endipv6Encountered === true) {
            endIpv6 = true;
          }
          if (!consume()) {
            break;
          }
          tokenCount++;
          address.push(":");
          if (tokenCount > 7) {
            output.error = true;
            break;
          }
          if (i - 1 >= 0 && input[i - 1] === ":") {
            endipv6Encountered = true;
          }
          continue;
        } else if (cursor === "%") {
          if (!consume()) {
            break;
          }
          isZone = true;
        } else {
          buffer.push(cursor);
          continue;
        }
      }
      if (buffer.length) {
        if (isZone) {
          output.zone = buffer.join("");
        } else if (endIpv6) {
          address.push(buffer.join(""));
        } else {
          address.push(stringArrayToHexStripped(buffer));
        }
      }
      output.address = address.join("");
      return output;
    }
    function normalizeIPv6(host) {
      if (findToken(host, ":") < 2) {
        return { host, isIPV6: false };
      }
      const ipv6 = getIPV6(host);
      if (!ipv6.error) {
        let newHost = ipv6.address;
        let escapedHost = ipv6.address;
        if (ipv6.zone) {
          newHost += "%" + ipv6.zone;
          escapedHost += "%25" + ipv6.zone;
        }
        return { host: newHost, escapedHost, isIPV6: true };
      } else {
        return { host, isIPV6: false };
      }
    }
    function stripLeadingZeros(str, token) {
      let out = "";
      let skip = true;
      const l = str.length;
      for (let i = 0; i < l; i++) {
        const c = str[i];
        if (c === "0" && skip) {
          if (i + 1 <= l && str[i + 1] === token || i + 1 === l) {
            out += c;
            skip = false;
          }
        } else {
          if (c === token) {
            skip = true;
          } else {
            skip = false;
          }
          out += c;
        }
      }
      return out;
    }
    function findToken(str, token) {
      let ind = 0;
      for (let i = 0; i < str.length; i++) {
        if (str[i] === token) ind++;
      }
      return ind;
    }
    var RDS1 = /^\.\.?\//u;
    var RDS2 = /^\/\.(?:\/|$)/u;
    var RDS3 = /^\/\.\.(?:\/|$)/u;
    var RDS5 = /^\/?(?:.|\n)*?(?=\/|$)/u;
    function removeDotSegments(input) {
      const output = [];
      while (input.length) {
        if (input.match(RDS1)) {
          input = input.replace(RDS1, "");
        } else if (input.match(RDS2)) {
          input = input.replace(RDS2, "/");
        } else if (input.match(RDS3)) {
          input = input.replace(RDS3, "/");
          output.pop();
        } else if (input === "." || input === "..") {
          input = "";
        } else {
          const im = input.match(RDS5);
          if (im) {
            const s = im[0];
            input = input.slice(s.length);
            output.push(s);
          } else {
            throw new Error("Unexpected dot segment condition");
          }
        }
      }
      return output.join("");
    }
    function normalizeComponentEncoding(components, esc) {
      const func = esc !== true ? escape : unescape;
      if (components.scheme !== void 0) {
        components.scheme = func(components.scheme);
      }
      if (components.userinfo !== void 0) {
        components.userinfo = func(components.userinfo);
      }
      if (components.host !== void 0) {
        components.host = func(components.host);
      }
      if (components.path !== void 0) {
        components.path = func(components.path);
      }
      if (components.query !== void 0) {
        components.query = func(components.query);
      }
      if (components.fragment !== void 0) {
        components.fragment = func(components.fragment);
      }
      return components;
    }
    function recomposeAuthority(components) {
      const uriTokens = [];
      if (components.userinfo !== void 0) {
        uriTokens.push(components.userinfo);
        uriTokens.push("@");
      }
      if (components.host !== void 0) {
        let host = unescape(components.host);
        const ipV4res = normalizeIPv4(host);
        if (ipV4res.isIPV4) {
          host = ipV4res.host;
        } else {
          const ipV6res = normalizeIPv6(ipV4res.host);
          if (ipV6res.isIPV6 === true) {
            host = `[${ipV6res.escapedHost}]`;
          } else {
            host = components.host;
          }
        }
        uriTokens.push(host);
      }
      if (typeof components.port === "number" || typeof components.port === "string") {
        uriTokens.push(":");
        uriTokens.push(String(components.port));
      }
      return uriTokens.length ? uriTokens.join("") : void 0;
    }
    module2.exports = {
      recomposeAuthority,
      normalizeComponentEncoding,
      removeDotSegments,
      normalizeIPv4,
      normalizeIPv6,
      stringArrayToHexStripped
    };
  }
});

// node_modules/fast-uri/lib/schemes.js
var require_schemes = __commonJS({
  "node_modules/fast-uri/lib/schemes.js"(exports2, module2) {
    "use strict";
    var UUID_REG = /^[\da-f]{8}-[\da-f]{4}-[\da-f]{4}-[\da-f]{4}-[\da-f]{12}$/iu;
    var URN_REG = /([\da-z][\d\-a-z]{0,31}):((?:[\w!$'()*+,\-.:;=@]|%[\da-f]{2})+)/iu;
    function isSecure(wsComponents) {
      return typeof wsComponents.secure === "boolean" ? wsComponents.secure : String(wsComponents.scheme).toLowerCase() === "wss";
    }
    function httpParse(components) {
      if (!components.host) {
        components.error = components.error || "HTTP URIs must have a host.";
      }
      return components;
    }
    function httpSerialize(components) {
      const secure = String(components.scheme).toLowerCase() === "https";
      if (components.port === (secure ? 443 : 80) || components.port === "") {
        components.port = void 0;
      }
      if (!components.path) {
        components.path = "/";
      }
      return components;
    }
    function wsParse(wsComponents) {
      wsComponents.secure = isSecure(wsComponents);
      wsComponents.resourceName = (wsComponents.path || "/") + (wsComponents.query ? "?" + wsComponents.query : "");
      wsComponents.path = void 0;
      wsComponents.query = void 0;
      return wsComponents;
    }
    function wsSerialize(wsComponents) {
      if (wsComponents.port === (isSecure(wsComponents) ? 443 : 80) || wsComponents.port === "") {
        wsComponents.port = void 0;
      }
      if (typeof wsComponents.secure === "boolean") {
        wsComponents.scheme = wsComponents.secure ? "wss" : "ws";
        wsComponents.secure = void 0;
      }
      if (wsComponents.resourceName) {
        const [path4, query] = wsComponents.resourceName.split("?");
        wsComponents.path = path4 && path4 !== "/" ? path4 : void 0;
        wsComponents.query = query;
        wsComponents.resourceName = void 0;
      }
      wsComponents.fragment = void 0;
      return wsComponents;
    }
    function urnParse(urnComponents, options) {
      if (!urnComponents.path) {
        urnComponents.error = "URN can not be parsed";
        return urnComponents;
      }
      const matches = urnComponents.path.match(URN_REG);
      if (matches) {
        const scheme = options.scheme || urnComponents.scheme || "urn";
        urnComponents.nid = matches[1].toLowerCase();
        urnComponents.nss = matches[2];
        const urnScheme = `${scheme}:${options.nid || urnComponents.nid}`;
        const schemeHandler = SCHEMES[urnScheme];
        urnComponents.path = void 0;
        if (schemeHandler) {
          urnComponents = schemeHandler.parse(urnComponents, options);
        }
      } else {
        urnComponents.error = urnComponents.error || "URN can not be parsed.";
      }
      return urnComponents;
    }
    function urnSerialize(urnComponents, options) {
      const scheme = options.scheme || urnComponents.scheme || "urn";
      const nid = urnComponents.nid.toLowerCase();
      const urnScheme = `${scheme}:${options.nid || nid}`;
      const schemeHandler = SCHEMES[urnScheme];
      if (schemeHandler) {
        urnComponents = schemeHandler.serialize(urnComponents, options);
      }
      const uriComponents = urnComponents;
      const nss = urnComponents.nss;
      uriComponents.path = `${nid || options.nid}:${nss}`;
      options.skipEscape = true;
      return uriComponents;
    }
    function urnuuidParse(urnComponents, options) {
      const uuidComponents = urnComponents;
      uuidComponents.uuid = uuidComponents.nss;
      uuidComponents.nss = void 0;
      if (!options.tolerant && (!uuidComponents.uuid || !UUID_REG.test(uuidComponents.uuid))) {
        uuidComponents.error = uuidComponents.error || "UUID is not valid.";
      }
      return uuidComponents;
    }
    function urnuuidSerialize(uuidComponents) {
      const urnComponents = uuidComponents;
      urnComponents.nss = (uuidComponents.uuid || "").toLowerCase();
      return urnComponents;
    }
    var http = {
      scheme: "http",
      domainHost: true,
      parse: httpParse,
      serialize: httpSerialize
    };
    var https = {
      scheme: "https",
      domainHost: http.domainHost,
      parse: httpParse,
      serialize: httpSerialize
    };
    var ws = {
      scheme: "ws",
      domainHost: true,
      parse: wsParse,
      serialize: wsSerialize
    };
    var wss = {
      scheme: "wss",
      domainHost: ws.domainHost,
      parse: ws.parse,
      serialize: ws.serialize
    };
    var urn = {
      scheme: "urn",
      parse: urnParse,
      serialize: urnSerialize,
      skipNormalize: true
    };
    var urnuuid = {
      scheme: "urn:uuid",
      parse: urnuuidParse,
      serialize: urnuuidSerialize,
      skipNormalize: true
    };
    var SCHEMES = {
      http,
      https,
      ws,
      wss,
      urn,
      "urn:uuid": urnuuid
    };
    module2.exports = SCHEMES;
  }
});

// node_modules/fast-uri/index.js
var require_fast_uri = __commonJS({
  "node_modules/fast-uri/index.js"(exports2, module2) {
    "use strict";
    var { normalizeIPv6, normalizeIPv4, removeDotSegments, recomposeAuthority, normalizeComponentEncoding } = require_utils();
    var SCHEMES = require_schemes();
    function normalize(uri, options) {
      if (typeof uri === "string") {
        uri = serialize(parse(uri, options), options);
      } else if (typeof uri === "object") {
        uri = parse(serialize(uri, options), options);
      }
      return uri;
    }
    function resolve(baseURI, relativeURI, options) {
      const schemelessOptions = Object.assign({ scheme: "null" }, options);
      const resolved = resolveComponents(parse(baseURI, schemelessOptions), parse(relativeURI, schemelessOptions), schemelessOptions, true);
      return serialize(resolved, { ...schemelessOptions, skipEscape: true });
    }
    function resolveComponents(base, relative, options, skipNormalization) {
      const target = {};
      if (!skipNormalization) {
        base = parse(serialize(base, options), options);
        relative = parse(serialize(relative, options), options);
      }
      options = options || {};
      if (!options.tolerant && relative.scheme) {
        target.scheme = relative.scheme;
        target.userinfo = relative.userinfo;
        target.host = relative.host;
        target.port = relative.port;
        target.path = removeDotSegments(relative.path || "");
        target.query = relative.query;
      } else {
        if (relative.userinfo !== void 0 || relative.host !== void 0 || relative.port !== void 0) {
          target.userinfo = relative.userinfo;
          target.host = relative.host;
          target.port = relative.port;
          target.path = removeDotSegments(relative.path || "");
          target.query = relative.query;
        } else {
          if (!relative.path) {
            target.path = base.path;
            if (relative.query !== void 0) {
              target.query = relative.query;
            } else {
              target.query = base.query;
            }
          } else {
            if (relative.path.charAt(0) === "/") {
              target.path = removeDotSegments(relative.path);
            } else {
              if ((base.userinfo !== void 0 || base.host !== void 0 || base.port !== void 0) && !base.path) {
                target.path = "/" + relative.path;
              } else if (!base.path) {
                target.path = relative.path;
              } else {
                target.path = base.path.slice(0, base.path.lastIndexOf("/") + 1) + relative.path;
              }
              target.path = removeDotSegments(target.path);
            }
            target.query = relative.query;
          }
          target.userinfo = base.userinfo;
          target.host = base.host;
          target.port = base.port;
        }
        target.scheme = base.scheme;
      }
      target.fragment = relative.fragment;
      return target;
    }
    function equal(uriA, uriB, options) {
      if (typeof uriA === "string") {
        uriA = unescape(uriA);
        uriA = serialize(normalizeComponentEncoding(parse(uriA, options), true), { ...options, skipEscape: true });
      } else if (typeof uriA === "object") {
        uriA = serialize(normalizeComponentEncoding(uriA, true), { ...options, skipEscape: true });
      }
      if (typeof uriB === "string") {
        uriB = unescape(uriB);
        uriB = serialize(normalizeComponentEncoding(parse(uriB, options), true), { ...options, skipEscape: true });
      } else if (typeof uriB === "object") {
        uriB = serialize(normalizeComponentEncoding(uriB, true), { ...options, skipEscape: true });
      }
      return uriA.toLowerCase() === uriB.toLowerCase();
    }
    function serialize(cmpts, opts) {
      const components = {
        host: cmpts.host,
        scheme: cmpts.scheme,
        userinfo: cmpts.userinfo,
        port: cmpts.port,
        path: cmpts.path,
        query: cmpts.query,
        nid: cmpts.nid,
        nss: cmpts.nss,
        uuid: cmpts.uuid,
        fragment: cmpts.fragment,
        reference: cmpts.reference,
        resourceName: cmpts.resourceName,
        secure: cmpts.secure,
        error: ""
      };
      const options = Object.assign({}, opts);
      const uriTokens = [];
      const schemeHandler = SCHEMES[(options.scheme || components.scheme || "").toLowerCase()];
      if (schemeHandler && schemeHandler.serialize) schemeHandler.serialize(components, options);
      if (components.path !== void 0) {
        if (!options.skipEscape) {
          components.path = escape(components.path);
          if (components.scheme !== void 0) {
            components.path = components.path.split("%3A").join(":");
          }
        } else {
          components.path = unescape(components.path);
        }
      }
      if (options.reference !== "suffix" && components.scheme) {
        uriTokens.push(components.scheme, ":");
      }
      const authority = recomposeAuthority(components);
      if (authority !== void 0) {
        if (options.reference !== "suffix") {
          uriTokens.push("//");
        }
        uriTokens.push(authority);
        if (components.path && components.path.charAt(0) !== "/") {
          uriTokens.push("/");
        }
      }
      if (components.path !== void 0) {
        let s = components.path;
        if (!options.absolutePath && (!schemeHandler || !schemeHandler.absolutePath)) {
          s = removeDotSegments(s);
        }
        if (authority === void 0) {
          s = s.replace(/^\/\//u, "/%2F");
        }
        uriTokens.push(s);
      }
      if (components.query !== void 0) {
        uriTokens.push("?", components.query);
      }
      if (components.fragment !== void 0) {
        uriTokens.push("#", components.fragment);
      }
      return uriTokens.join("");
    }
    var hexLookUp = Array.from({ length: 127 }, (_v, k) => /[^!"$&'()*+,\-.;=_`a-z{}~]/u.test(String.fromCharCode(k)));
    function nonSimpleDomain(value) {
      let code = 0;
      for (let i = 0, len = value.length; i < len; ++i) {
        code = value.charCodeAt(i);
        if (code > 126 || hexLookUp[code]) {
          return true;
        }
      }
      return false;
    }
    var URI_PARSE = /^(?:([^#/:?]+):)?(?:\/\/((?:([^#/?@]*)@)?(\[[^#/?\]]+\]|[^#/:?]*)(?::(\d*))?))?([^#?]*)(?:\?([^#]*))?(?:#((?:.|[\n\r])*))?/u;
    function parse(uri, opts) {
      const options = Object.assign({}, opts);
      const parsed = {
        scheme: void 0,
        userinfo: void 0,
        host: "",
        port: void 0,
        path: "",
        query: void 0,
        fragment: void 0
      };
      const gotEncoding = uri.indexOf("%") !== -1;
      let isIP = false;
      if (options.reference === "suffix") uri = (options.scheme ? options.scheme + ":" : "") + "//" + uri;
      const matches = uri.match(URI_PARSE);
      if (matches) {
        parsed.scheme = matches[1];
        parsed.userinfo = matches[3];
        parsed.host = matches[4];
        parsed.port = parseInt(matches[5], 10);
        parsed.path = matches[6] || "";
        parsed.query = matches[7];
        parsed.fragment = matches[8];
        if (isNaN(parsed.port)) {
          parsed.port = matches[5];
        }
        if (parsed.host) {
          const ipv4result = normalizeIPv4(parsed.host);
          if (ipv4result.isIPV4 === false) {
            const ipv6result = normalizeIPv6(ipv4result.host);
            parsed.host = ipv6result.host.toLowerCase();
            isIP = ipv6result.isIPV6;
          } else {
            parsed.host = ipv4result.host;
            isIP = true;
          }
        }
        if (parsed.scheme === void 0 && parsed.userinfo === void 0 && parsed.host === void 0 && parsed.port === void 0 && parsed.query === void 0 && !parsed.path) {
          parsed.reference = "same-document";
        } else if (parsed.scheme === void 0) {
          parsed.reference = "relative";
        } else if (parsed.fragment === void 0) {
          parsed.reference = "absolute";
        } else {
          parsed.reference = "uri";
        }
        if (options.reference && options.reference !== "suffix" && options.reference !== parsed.reference) {
          parsed.error = parsed.error || "URI is not a " + options.reference + " reference.";
        }
        const schemeHandler = SCHEMES[(options.scheme || parsed.scheme || "").toLowerCase()];
        if (!options.unicodeSupport && (!schemeHandler || !schemeHandler.unicodeSupport)) {
          if (parsed.host && (options.domainHost || schemeHandler && schemeHandler.domainHost) && isIP === false && nonSimpleDomain(parsed.host)) {
            try {
              parsed.host = URL.domainToASCII(parsed.host.toLowerCase());
            } catch (e) {
              parsed.error = parsed.error || "Host's domain name can not be converted to ASCII: " + e;
            }
          }
        }
        if (!schemeHandler || schemeHandler && !schemeHandler.skipNormalize) {
          if (gotEncoding && parsed.scheme !== void 0) {
            parsed.scheme = unescape(parsed.scheme);
          }
          if (gotEncoding && parsed.host !== void 0) {
            parsed.host = unescape(parsed.host);
          }
          if (parsed.path) {
            parsed.path = escape(unescape(parsed.path));
          }
          if (parsed.fragment) {
            parsed.fragment = encodeURI(decodeURIComponent(parsed.fragment));
          }
        }
        if (schemeHandler && schemeHandler.parse) {
          schemeHandler.parse(parsed, options);
        }
      } else {
        parsed.error = parsed.error || "URI can not be parsed.";
      }
      return parsed;
    }
    var fastUri = {
      SCHEMES,
      normalize,
      resolve,
      resolveComponents,
      equal,
      serialize,
      parse
    };
    module2.exports = fastUri;
    module2.exports.default = fastUri;
    module2.exports.fastUri = fastUri;
  }
});

// node_modules/ajv/dist/runtime/uri.js
var require_uri = __commonJS({
  "node_modules/ajv/dist/runtime/uri.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var uri = require_fast_uri();
    uri.code = 'require("ajv/dist/runtime/uri").default';
    exports2.default = uri;
  }
});

// node_modules/ajv/dist/core.js
var require_core = __commonJS({
  "node_modules/ajv/dist/core.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.CodeGen = exports2.Name = exports2.nil = exports2.stringify = exports2.str = exports2._ = exports2.KeywordCxt = void 0;
    var validate_1 = require_validate();
    Object.defineProperty(exports2, "KeywordCxt", { enumerable: true, get: function() {
      return validate_1.KeywordCxt;
    } });
    var codegen_1 = require_codegen();
    Object.defineProperty(exports2, "_", { enumerable: true, get: function() {
      return codegen_1._;
    } });
    Object.defineProperty(exports2, "str", { enumerable: true, get: function() {
      return codegen_1.str;
    } });
    Object.defineProperty(exports2, "stringify", { enumerable: true, get: function() {
      return codegen_1.stringify;
    } });
    Object.defineProperty(exports2, "nil", { enumerable: true, get: function() {
      return codegen_1.nil;
    } });
    Object.defineProperty(exports2, "Name", { enumerable: true, get: function() {
      return codegen_1.Name;
    } });
    Object.defineProperty(exports2, "CodeGen", { enumerable: true, get: function() {
      return codegen_1.CodeGen;
    } });
    var validation_error_1 = require_validation_error();
    var ref_error_1 = require_ref_error();
    var rules_1 = require_rules();
    var compile_1 = require_compile();
    var codegen_2 = require_codegen();
    var resolve_1 = require_resolve();
    var dataType_1 = require_dataType();
    var util_1 = require_util2();
    var $dataRefSchema = require_data();
    var uri_1 = require_uri();
    var defaultRegExp = (str, flags) => new RegExp(str, flags);
    defaultRegExp.code = "new RegExp";
    var META_IGNORE_OPTIONS = ["removeAdditional", "useDefaults", "coerceTypes"];
    var EXT_SCOPE_NAMES = /* @__PURE__ */ new Set([
      "validate",
      "serialize",
      "parse",
      "wrapper",
      "root",
      "schema",
      "keyword",
      "pattern",
      "formats",
      "validate$data",
      "func",
      "obj",
      "Error"
    ]);
    var removedOptions = {
      errorDataPath: "",
      format: "`validateFormats: false` can be used instead.",
      nullable: '"nullable" keyword is supported by default.',
      jsonPointers: "Deprecated jsPropertySyntax can be used instead.",
      extendRefs: "Deprecated ignoreKeywordsWithRef can be used instead.",
      missingRefs: "Pass empty schema with $id that should be ignored to ajv.addSchema.",
      processCode: "Use option `code: {process: (code, schemaEnv: object) => string}`",
      sourceCode: "Use option `code: {source: true}`",
      strictDefaults: "It is default now, see option `strict`.",
      strictKeywords: "It is default now, see option `strict`.",
      uniqueItems: '"uniqueItems" keyword is always validated.',
      unknownFormats: "Disable strict mode or pass `true` to `ajv.addFormat` (or `formats` option).",
      cache: "Map is used as cache, schema object as key.",
      serialize: "Map is used as cache, schema object as key.",
      ajvErrors: "It is default now."
    };
    var deprecatedOptions = {
      ignoreKeywordsWithRef: "",
      jsPropertySyntax: "",
      unicode: '"minLength"/"maxLength" account for unicode characters by default.'
    };
    var MAX_EXPRESSION = 200;
    function requiredOptions(o) {
      var _a, _b, _c, _d, _e, _f, _g, _h2, _j, _k, _l2, _m2, _o2, _p, _q, _r2, _s2, _t, _u, _v, _w, _x, _y, _z, _0;
      const s = o.strict;
      const _optz = (_a = o.code) === null || _a === void 0 ? void 0 : _a.optimize;
      const optimize = _optz === true || _optz === void 0 ? 1 : _optz || 0;
      const regExp = (_c = (_b = o.code) === null || _b === void 0 ? void 0 : _b.regExp) !== null && _c !== void 0 ? _c : defaultRegExp;
      const uriResolver = (_d = o.uriResolver) !== null && _d !== void 0 ? _d : uri_1.default;
      return {
        strictSchema: (_f = (_e = o.strictSchema) !== null && _e !== void 0 ? _e : s) !== null && _f !== void 0 ? _f : true,
        strictNumbers: (_h2 = (_g = o.strictNumbers) !== null && _g !== void 0 ? _g : s) !== null && _h2 !== void 0 ? _h2 : true,
        strictTypes: (_k = (_j = o.strictTypes) !== null && _j !== void 0 ? _j : s) !== null && _k !== void 0 ? _k : "log",
        strictTuples: (_m2 = (_l2 = o.strictTuples) !== null && _l2 !== void 0 ? _l2 : s) !== null && _m2 !== void 0 ? _m2 : "log",
        strictRequired: (_p = (_o2 = o.strictRequired) !== null && _o2 !== void 0 ? _o2 : s) !== null && _p !== void 0 ? _p : false,
        code: o.code ? { ...o.code, optimize, regExp } : { optimize, regExp },
        loopRequired: (_q = o.loopRequired) !== null && _q !== void 0 ? _q : MAX_EXPRESSION,
        loopEnum: (_r2 = o.loopEnum) !== null && _r2 !== void 0 ? _r2 : MAX_EXPRESSION,
        meta: (_s2 = o.meta) !== null && _s2 !== void 0 ? _s2 : true,
        messages: (_t = o.messages) !== null && _t !== void 0 ? _t : true,
        inlineRefs: (_u = o.inlineRefs) !== null && _u !== void 0 ? _u : true,
        schemaId: (_v = o.schemaId) !== null && _v !== void 0 ? _v : "$id",
        addUsedSchema: (_w = o.addUsedSchema) !== null && _w !== void 0 ? _w : true,
        validateSchema: (_x = o.validateSchema) !== null && _x !== void 0 ? _x : true,
        validateFormats: (_y = o.validateFormats) !== null && _y !== void 0 ? _y : true,
        unicodeRegExp: (_z = o.unicodeRegExp) !== null && _z !== void 0 ? _z : true,
        int32range: (_0 = o.int32range) !== null && _0 !== void 0 ? _0 : true,
        uriResolver
      };
    }
    var Ajv = class {
      constructor(opts = {}) {
        this.schemas = {};
        this.refs = {};
        this.formats = {};
        this._compilations = /* @__PURE__ */ new Set();
        this._loading = {};
        this._cache = /* @__PURE__ */ new Map();
        opts = this.opts = { ...opts, ...requiredOptions(opts) };
        const { es5, lines } = this.opts.code;
        this.scope = new codegen_2.ValueScope({ scope: {}, prefixes: EXT_SCOPE_NAMES, es5, lines });
        this.logger = getLogger(opts.logger);
        const formatOpt = opts.validateFormats;
        opts.validateFormats = false;
        this.RULES = (0, rules_1.getRules)();
        checkOptions.call(this, removedOptions, opts, "NOT SUPPORTED");
        checkOptions.call(this, deprecatedOptions, opts, "DEPRECATED", "warn");
        this._metaOpts = getMetaSchemaOptions.call(this);
        if (opts.formats)
          addInitialFormats.call(this);
        this._addVocabularies();
        this._addDefaultMetaSchema();
        if (opts.keywords)
          addInitialKeywords.call(this, opts.keywords);
        if (typeof opts.meta == "object")
          this.addMetaSchema(opts.meta);
        addInitialSchemas.call(this);
        opts.validateFormats = formatOpt;
      }
      _addVocabularies() {
        this.addKeyword("$async");
      }
      _addDefaultMetaSchema() {
        const { $data, meta, schemaId } = this.opts;
        let _dataRefSchema = $dataRefSchema;
        if (schemaId === "id") {
          _dataRefSchema = { ...$dataRefSchema };
          _dataRefSchema.id = _dataRefSchema.$id;
          delete _dataRefSchema.$id;
        }
        if (meta && $data)
          this.addMetaSchema(_dataRefSchema, _dataRefSchema[schemaId], false);
      }
      defaultMeta() {
        const { meta, schemaId } = this.opts;
        return this.opts.defaultMeta = typeof meta == "object" ? meta[schemaId] || meta : void 0;
      }
      validate(schemaKeyRef, data) {
        let v;
        if (typeof schemaKeyRef == "string") {
          v = this.getSchema(schemaKeyRef);
          if (!v)
            throw new Error(`no schema with key or ref "${schemaKeyRef}"`);
        } else {
          v = this.compile(schemaKeyRef);
        }
        const valid = v(data);
        if (!("$async" in v))
          this.errors = v.errors;
        return valid;
      }
      compile(schema, _meta) {
        const sch = this._addSchema(schema, _meta);
        return sch.validate || this._compileSchemaEnv(sch);
      }
      compileAsync(schema, meta) {
        if (typeof this.opts.loadSchema != "function") {
          throw new Error("options.loadSchema should be a function");
        }
        const { loadSchema } = this.opts;
        return runCompileAsync.call(this, schema, meta);
        async function runCompileAsync(_schema, _meta) {
          await loadMetaSchema.call(this, _schema.$schema);
          const sch = this._addSchema(_schema, _meta);
          return sch.validate || _compileAsync.call(this, sch);
        }
        async function loadMetaSchema($ref) {
          if ($ref && !this.getSchema($ref)) {
            await runCompileAsync.call(this, { $ref }, true);
          }
        }
        async function _compileAsync(sch) {
          try {
            return this._compileSchemaEnv(sch);
          } catch (e) {
            if (!(e instanceof ref_error_1.default))
              throw e;
            checkLoaded.call(this, e);
            await loadMissingSchema.call(this, e.missingSchema);
            return _compileAsync.call(this, sch);
          }
        }
        function checkLoaded({ missingSchema: ref, missingRef }) {
          if (this.refs[ref]) {
            throw new Error(`AnySchema ${ref} is loaded but ${missingRef} cannot be resolved`);
          }
        }
        async function loadMissingSchema(ref) {
          const _schema = await _loadSchema.call(this, ref);
          if (!this.refs[ref])
            await loadMetaSchema.call(this, _schema.$schema);
          if (!this.refs[ref])
            this.addSchema(_schema, ref, meta);
        }
        async function _loadSchema(ref) {
          const p = this._loading[ref];
          if (p)
            return p;
          try {
            return await (this._loading[ref] = loadSchema(ref));
          } finally {
            delete this._loading[ref];
          }
        }
      }
      // Adds schema to the instance
      addSchema(schema, key, _meta, _validateSchema = this.opts.validateSchema) {
        if (Array.isArray(schema)) {
          for (const sch of schema)
            this.addSchema(sch, void 0, _meta, _validateSchema);
          return this;
        }
        let id2;
        if (typeof schema === "object") {
          const { schemaId } = this.opts;
          id2 = schema[schemaId];
          if (id2 !== void 0 && typeof id2 != "string") {
            throw new Error(`schema ${schemaId} must be string`);
          }
        }
        key = (0, resolve_1.normalizeId)(key || id2);
        this._checkUnique(key);
        this.schemas[key] = this._addSchema(schema, _meta, key, _validateSchema, true);
        return this;
      }
      // Add schema that will be used to validate other schemas
      // options in META_IGNORE_OPTIONS are alway set to false
      addMetaSchema(schema, key, _validateSchema = this.opts.validateSchema) {
        this.addSchema(schema, key, true, _validateSchema);
        return this;
      }
      //  Validate schema against its meta-schema
      validateSchema(schema, throwOrLogError) {
        if (typeof schema == "boolean")
          return true;
        let $schema;
        $schema = schema.$schema;
        if ($schema !== void 0 && typeof $schema != "string") {
          throw new Error("$schema must be a string");
        }
        $schema = $schema || this.opts.defaultMeta || this.defaultMeta();
        if (!$schema) {
          this.logger.warn("meta-schema not available");
          this.errors = null;
          return true;
        }
        const valid = this.validate($schema, schema);
        if (!valid && throwOrLogError) {
          const message = "schema is invalid: " + this.errorsText();
          if (this.opts.validateSchema === "log")
            this.logger.error(message);
          else
            throw new Error(message);
        }
        return valid;
      }
      // Get compiled schema by `key` or `ref`.
      // (`key` that was passed to `addSchema` or full schema reference - `schema.$id` or resolved id)
      getSchema(keyRef) {
        let sch;
        while (typeof (sch = getSchEnv.call(this, keyRef)) == "string")
          keyRef = sch;
        if (sch === void 0) {
          const { schemaId } = this.opts;
          const root = new compile_1.SchemaEnv({ schema: {}, schemaId });
          sch = compile_1.resolveSchema.call(this, root, keyRef);
          if (!sch)
            return;
          this.refs[keyRef] = sch;
        }
        return sch.validate || this._compileSchemaEnv(sch);
      }
      // Remove cached schema(s).
      // If no parameter is passed all schemas but meta-schemas are removed.
      // If RegExp is passed all schemas with key/id matching pattern but meta-schemas are removed.
      // Even if schema is referenced by other schemas it still can be removed as other schemas have local references.
      removeSchema(schemaKeyRef) {
        if (schemaKeyRef instanceof RegExp) {
          this._removeAllSchemas(this.schemas, schemaKeyRef);
          this._removeAllSchemas(this.refs, schemaKeyRef);
          return this;
        }
        switch (typeof schemaKeyRef) {
          case "undefined":
            this._removeAllSchemas(this.schemas);
            this._removeAllSchemas(this.refs);
            this._cache.clear();
            return this;
          case "string": {
            const sch = getSchEnv.call(this, schemaKeyRef);
            if (typeof sch == "object")
              this._cache.delete(sch.schema);
            delete this.schemas[schemaKeyRef];
            delete this.refs[schemaKeyRef];
            return this;
          }
          case "object": {
            const cacheKey = schemaKeyRef;
            this._cache.delete(cacheKey);
            let id2 = schemaKeyRef[this.opts.schemaId];
            if (id2) {
              id2 = (0, resolve_1.normalizeId)(id2);
              delete this.schemas[id2];
              delete this.refs[id2];
            }
            return this;
          }
          default:
            throw new Error("ajv.removeSchema: invalid parameter");
        }
      }
      // add "vocabulary" - a collection of keywords
      addVocabulary(definitions) {
        for (const def of definitions)
          this.addKeyword(def);
        return this;
      }
      addKeyword(kwdOrDef, def) {
        let keyword;
        if (typeof kwdOrDef == "string") {
          keyword = kwdOrDef;
          if (typeof def == "object") {
            this.logger.warn("these parameters are deprecated, see docs for addKeyword");
            def.keyword = keyword;
          }
        } else if (typeof kwdOrDef == "object" && def === void 0) {
          def = kwdOrDef;
          keyword = def.keyword;
          if (Array.isArray(keyword) && !keyword.length) {
            throw new Error("addKeywords: keyword must be string or non-empty array");
          }
        } else {
          throw new Error("invalid addKeywords parameters");
        }
        checkKeyword.call(this, keyword, def);
        if (!def) {
          (0, util_1.eachItem)(keyword, (kwd) => addRule.call(this, kwd));
          return this;
        }
        keywordMetaschema.call(this, def);
        const definition = {
          ...def,
          type: (0, dataType_1.getJSONTypes)(def.type),
          schemaType: (0, dataType_1.getJSONTypes)(def.schemaType)
        };
        (0, util_1.eachItem)(keyword, definition.type.length === 0 ? (k) => addRule.call(this, k, definition) : (k) => definition.type.forEach((t) => addRule.call(this, k, definition, t)));
        return this;
      }
      getKeyword(keyword) {
        const rule = this.RULES.all[keyword];
        return typeof rule == "object" ? rule.definition : !!rule;
      }
      // Remove keyword
      removeKeyword(keyword) {
        const { RULES } = this;
        delete RULES.keywords[keyword];
        delete RULES.all[keyword];
        for (const group of RULES.rules) {
          const i = group.rules.findIndex((rule) => rule.keyword === keyword);
          if (i >= 0)
            group.rules.splice(i, 1);
        }
        return this;
      }
      // Add format
      addFormat(name, format) {
        if (typeof format == "string")
          format = new RegExp(format);
        this.formats[name] = format;
        return this;
      }
      errorsText(errors = this.errors, { separator = ", ", dataVar = "data" } = {}) {
        if (!errors || errors.length === 0)
          return "No errors";
        return errors.map((e) => `${dataVar}${e.instancePath} ${e.message}`).reduce((text, msg) => text + separator + msg);
      }
      $dataMetaSchema(metaSchema, keywordsJsonPointers) {
        const rules = this.RULES.all;
        metaSchema = JSON.parse(JSON.stringify(metaSchema));
        for (const jsonPointer of keywordsJsonPointers) {
          const segments = jsonPointer.split("/").slice(1);
          let keywords = metaSchema;
          for (const seg of segments)
            keywords = keywords[seg];
          for (const key in rules) {
            const rule = rules[key];
            if (typeof rule != "object")
              continue;
            const { $data } = rule.definition;
            const schema = keywords[key];
            if ($data && schema)
              keywords[key] = schemaOrData(schema);
          }
        }
        return metaSchema;
      }
      _removeAllSchemas(schemas, regex) {
        for (const keyRef in schemas) {
          const sch = schemas[keyRef];
          if (!regex || regex.test(keyRef)) {
            if (typeof sch == "string") {
              delete schemas[keyRef];
            } else if (sch && !sch.meta) {
              this._cache.delete(sch.schema);
              delete schemas[keyRef];
            }
          }
        }
      }
      _addSchema(schema, meta, baseId, validateSchema = this.opts.validateSchema, addSchema = this.opts.addUsedSchema) {
        let id2;
        const { schemaId } = this.opts;
        if (typeof schema == "object") {
          id2 = schema[schemaId];
        } else {
          if (this.opts.jtd)
            throw new Error("schema must be object");
          else if (typeof schema != "boolean")
            throw new Error("schema must be object or boolean");
        }
        let sch = this._cache.get(schema);
        if (sch !== void 0)
          return sch;
        baseId = (0, resolve_1.normalizeId)(id2 || baseId);
        const localRefs = resolve_1.getSchemaRefs.call(this, schema, baseId);
        sch = new compile_1.SchemaEnv({ schema, schemaId, meta, baseId, localRefs });
        this._cache.set(sch.schema, sch);
        if (addSchema && !baseId.startsWith("#")) {
          if (baseId)
            this._checkUnique(baseId);
          this.refs[baseId] = sch;
        }
        if (validateSchema)
          this.validateSchema(schema, true);
        return sch;
      }
      _checkUnique(id2) {
        if (this.schemas[id2] || this.refs[id2]) {
          throw new Error(`schema with key or id "${id2}" already exists`);
        }
      }
      _compileSchemaEnv(sch) {
        if (sch.meta)
          this._compileMetaSchema(sch);
        else
          compile_1.compileSchema.call(this, sch);
        if (!sch.validate)
          throw new Error("ajv implementation error");
        return sch.validate;
      }
      _compileMetaSchema(sch) {
        const currentOpts = this.opts;
        this.opts = this._metaOpts;
        try {
          compile_1.compileSchema.call(this, sch);
        } finally {
          this.opts = currentOpts;
        }
      }
    };
    Ajv.ValidationError = validation_error_1.default;
    Ajv.MissingRefError = ref_error_1.default;
    exports2.default = Ajv;
    function checkOptions(checkOpts, options, msg, log2 = "error") {
      for (const key in checkOpts) {
        const opt = key;
        if (opt in options)
          this.logger[log2](`${msg}: option ${key}. ${checkOpts[opt]}`);
      }
    }
    function getSchEnv(keyRef) {
      keyRef = (0, resolve_1.normalizeId)(keyRef);
      return this.schemas[keyRef] || this.refs[keyRef];
    }
    function addInitialSchemas() {
      const optsSchemas = this.opts.schemas;
      if (!optsSchemas)
        return;
      if (Array.isArray(optsSchemas))
        this.addSchema(optsSchemas);
      else
        for (const key in optsSchemas)
          this.addSchema(optsSchemas[key], key);
    }
    function addInitialFormats() {
      for (const name in this.opts.formats) {
        const format = this.opts.formats[name];
        if (format)
          this.addFormat(name, format);
      }
    }
    function addInitialKeywords(defs) {
      if (Array.isArray(defs)) {
        this.addVocabulary(defs);
        return;
      }
      this.logger.warn("keywords option as map is deprecated, pass array");
      for (const keyword in defs) {
        const def = defs[keyword];
        if (!def.keyword)
          def.keyword = keyword;
        this.addKeyword(def);
      }
    }
    function getMetaSchemaOptions() {
      const metaOpts = { ...this.opts };
      for (const opt of META_IGNORE_OPTIONS)
        delete metaOpts[opt];
      return metaOpts;
    }
    var noLogs = { log() {
    }, warn() {
    }, error() {
    } };
    function getLogger(logger) {
      if (logger === false)
        return noLogs;
      if (logger === void 0)
        return console;
      if (logger.log && logger.warn && logger.error)
        return logger;
      throw new Error("logger must implement log, warn and error methods");
    }
    var KEYWORD_NAME = /^[a-z_$][a-z0-9_$:-]*$/i;
    function checkKeyword(keyword, def) {
      const { RULES } = this;
      (0, util_1.eachItem)(keyword, (kwd) => {
        if (RULES.keywords[kwd])
          throw new Error(`Keyword ${kwd} is already defined`);
        if (!KEYWORD_NAME.test(kwd))
          throw new Error(`Keyword ${kwd} has invalid name`);
      });
      if (!def)
        return;
      if (def.$data && !("code" in def || "validate" in def)) {
        throw new Error('$data keyword must have "code" or "validate" function');
      }
    }
    function addRule(keyword, definition, dataType) {
      var _a;
      const post = definition === null || definition === void 0 ? void 0 : definition.post;
      if (dataType && post)
        throw new Error('keyword with "post" flag cannot have "type"');
      const { RULES } = this;
      let ruleGroup = post ? RULES.post : RULES.rules.find(({ type: t }) => t === dataType);
      if (!ruleGroup) {
        ruleGroup = { type: dataType, rules: [] };
        RULES.rules.push(ruleGroup);
      }
      RULES.keywords[keyword] = true;
      if (!definition)
        return;
      const rule = {
        keyword,
        definition: {
          ...definition,
          type: (0, dataType_1.getJSONTypes)(definition.type),
          schemaType: (0, dataType_1.getJSONTypes)(definition.schemaType)
        }
      };
      if (definition.before)
        addBeforeRule.call(this, ruleGroup, rule, definition.before);
      else
        ruleGroup.rules.push(rule);
      RULES.all[keyword] = rule;
      (_a = definition.implements) === null || _a === void 0 ? void 0 : _a.forEach((kwd) => this.addKeyword(kwd));
    }
    function addBeforeRule(ruleGroup, rule, before) {
      const i = ruleGroup.rules.findIndex((_rule) => _rule.keyword === before);
      if (i >= 0) {
        ruleGroup.rules.splice(i, 0, rule);
      } else {
        ruleGroup.rules.push(rule);
        this.logger.warn(`rule ${before} is not defined`);
      }
    }
    function keywordMetaschema(def) {
      let { metaSchema } = def;
      if (metaSchema === void 0)
        return;
      if (def.$data && this.opts.$data)
        metaSchema = schemaOrData(metaSchema);
      def.validateSchema = this.compile(metaSchema, true);
    }
    var $dataRef = {
      $ref: "https://raw.githubusercontent.com/ajv-validator/ajv/master/lib/refs/data.json#"
    };
    function schemaOrData(schema) {
      return { anyOf: [schema, $dataRef] };
    }
  }
});

// node_modules/ajv/dist/vocabularies/core/id.js
var require_id = __commonJS({
  "node_modules/ajv/dist/vocabularies/core/id.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var def = {
      keyword: "id",
      code() {
        throw new Error('NOT SUPPORTED: keyword "id", use "$id" for schema ID');
      }
    };
    exports2.default = def;
  }
});

// node_modules/ajv/dist/vocabularies/core/ref.js
var require_ref = __commonJS({
  "node_modules/ajv/dist/vocabularies/core/ref.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.callRef = exports2.getValidate = void 0;
    var ref_error_1 = require_ref_error();
    var code_1 = require_code2();
    var codegen_1 = require_codegen();
    var names_1 = require_names();
    var compile_1 = require_compile();
    var util_1 = require_util2();
    var def = {
      keyword: "$ref",
      schemaType: "string",
      code(cxt) {
        const { gen, schema: $ref, it: it2 } = cxt;
        const { baseId, schemaEnv: env, validateName, opts, self: self2 } = it2;
        const { root } = env;
        if (($ref === "#" || $ref === "#/") && baseId === root.baseId)
          return callRootRef();
        const schOrEnv = compile_1.resolveRef.call(self2, root, baseId, $ref);
        if (schOrEnv === void 0)
          throw new ref_error_1.default(it2.opts.uriResolver, baseId, $ref);
        if (schOrEnv instanceof compile_1.SchemaEnv)
          return callValidate(schOrEnv);
        return inlineRefSchema(schOrEnv);
        function callRootRef() {
          if (env === root)
            return callRef(cxt, validateName, env, env.$async);
          const rootName = gen.scopeValue("root", { ref: root });
          return callRef(cxt, (0, codegen_1._)`${rootName}.validate`, root, root.$async);
        }
        function callValidate(sch) {
          const v = getValidate(cxt, sch);
          callRef(cxt, v, sch, sch.$async);
        }
        function inlineRefSchema(sch) {
          const schName = gen.scopeValue("schema", opts.code.source === true ? { ref: sch, code: (0, codegen_1.stringify)(sch) } : { ref: sch });
          const valid = gen.name("valid");
          const schCxt = cxt.subschema({
            schema: sch,
            dataTypes: [],
            schemaPath: codegen_1.nil,
            topSchemaRef: schName,
            errSchemaPath: $ref
          }, valid);
          cxt.mergeEvaluated(schCxt);
          cxt.ok(valid);
        }
      }
    };
    function getValidate(cxt, sch) {
      const { gen } = cxt;
      return sch.validate ? gen.scopeValue("validate", { ref: sch.validate }) : (0, codegen_1._)`${gen.scopeValue("wrapper", { ref: sch })}.validate`;
    }
    exports2.getValidate = getValidate;
    function callRef(cxt, v, sch, $async) {
      const { gen, it: it2 } = cxt;
      const { allErrors, schemaEnv: env, opts } = it2;
      const passCxt = opts.passContext ? names_1.default.this : codegen_1.nil;
      if ($async)
        callAsyncRef();
      else
        callSyncRef();
      function callAsyncRef() {
        if (!env.$async)
          throw new Error("async schema referenced by sync schema");
        const valid = gen.let("valid");
        gen.try(() => {
          gen.code((0, codegen_1._)`await ${(0, code_1.callValidateCode)(cxt, v, passCxt)}`);
          addEvaluatedFrom(v);
          if (!allErrors)
            gen.assign(valid, true);
        }, (e) => {
          gen.if((0, codegen_1._)`!(${e} instanceof ${it2.ValidationError})`, () => gen.throw(e));
          addErrorsFrom(e);
          if (!allErrors)
            gen.assign(valid, false);
        });
        cxt.ok(valid);
      }
      function callSyncRef() {
        cxt.result((0, code_1.callValidateCode)(cxt, v, passCxt), () => addEvaluatedFrom(v), () => addErrorsFrom(v));
      }
      function addErrorsFrom(source) {
        const errs = (0, codegen_1._)`${source}.errors`;
        gen.assign(names_1.default.vErrors, (0, codegen_1._)`${names_1.default.vErrors} === null ? ${errs} : ${names_1.default.vErrors}.concat(${errs})`);
        gen.assign(names_1.default.errors, (0, codegen_1._)`${names_1.default.vErrors}.length`);
      }
      function addEvaluatedFrom(source) {
        var _a;
        if (!it2.opts.unevaluated)
          return;
        const schEvaluated = (_a = sch === null || sch === void 0 ? void 0 : sch.validate) === null || _a === void 0 ? void 0 : _a.evaluated;
        if (it2.props !== true) {
          if (schEvaluated && !schEvaluated.dynamicProps) {
            if (schEvaluated.props !== void 0) {
              it2.props = util_1.mergeEvaluated.props(gen, schEvaluated.props, it2.props);
            }
          } else {
            const props = gen.var("props", (0, codegen_1._)`${source}.evaluated.props`);
            it2.props = util_1.mergeEvaluated.props(gen, props, it2.props, codegen_1.Name);
          }
        }
        if (it2.items !== true) {
          if (schEvaluated && !schEvaluated.dynamicItems) {
            if (schEvaluated.items !== void 0) {
              it2.items = util_1.mergeEvaluated.items(gen, schEvaluated.items, it2.items);
            }
          } else {
            const items = gen.var("items", (0, codegen_1._)`${source}.evaluated.items`);
            it2.items = util_1.mergeEvaluated.items(gen, items, it2.items, codegen_1.Name);
          }
        }
      }
    }
    exports2.callRef = callRef;
    exports2.default = def;
  }
});

// node_modules/ajv/dist/vocabularies/core/index.js
var require_core2 = __commonJS({
  "node_modules/ajv/dist/vocabularies/core/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var id_1 = require_id();
    var ref_1 = require_ref();
    var core = [
      "$schema",
      "$id",
      "$defs",
      "$vocabulary",
      { keyword: "$comment" },
      "definitions",
      id_1.default,
      ref_1.default
    ];
    exports2.default = core;
  }
});

// node_modules/ajv/dist/vocabularies/validation/limitNumber.js
var require_limitNumber = __commonJS({
  "node_modules/ajv/dist/vocabularies/validation/limitNumber.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var codegen_1 = require_codegen();
    var ops = codegen_1.operators;
    var KWDs = {
      maximum: { okStr: "<=", ok: ops.LTE, fail: ops.GT },
      minimum: { okStr: ">=", ok: ops.GTE, fail: ops.LT },
      exclusiveMaximum: { okStr: "<", ok: ops.LT, fail: ops.GTE },
      exclusiveMinimum: { okStr: ">", ok: ops.GT, fail: ops.LTE }
    };
    var error = {
      message: ({ keyword, schemaCode }) => (0, codegen_1.str)`must be ${KWDs[keyword].okStr} ${schemaCode}`,
      params: ({ keyword, schemaCode }) => (0, codegen_1._)`{comparison: ${KWDs[keyword].okStr}, limit: ${schemaCode}}`
    };
    var def = {
      keyword: Object.keys(KWDs),
      type: "number",
      schemaType: "number",
      $data: true,
      error,
      code(cxt) {
        const { keyword, data, schemaCode } = cxt;
        cxt.fail$data((0, codegen_1._)`${data} ${KWDs[keyword].fail} ${schemaCode} || isNaN(${data})`);
      }
    };
    exports2.default = def;
  }
});

// node_modules/ajv/dist/vocabularies/validation/multipleOf.js
var require_multipleOf = __commonJS({
  "node_modules/ajv/dist/vocabularies/validation/multipleOf.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var codegen_1 = require_codegen();
    var error = {
      message: ({ schemaCode }) => (0, codegen_1.str)`must be multiple of ${schemaCode}`,
      params: ({ schemaCode }) => (0, codegen_1._)`{multipleOf: ${schemaCode}}`
    };
    var def = {
      keyword: "multipleOf",
      type: "number",
      schemaType: "number",
      $data: true,
      error,
      code(cxt) {
        const { gen, data, schemaCode, it: it2 } = cxt;
        const prec = it2.opts.multipleOfPrecision;
        const res = gen.let("res");
        const invalid = prec ? (0, codegen_1._)`Math.abs(Math.round(${res}) - ${res}) > 1e-${prec}` : (0, codegen_1._)`${res} !== parseInt(${res})`;
        cxt.fail$data((0, codegen_1._)`(${schemaCode} === 0 || (${res} = ${data}/${schemaCode}, ${invalid}))`);
      }
    };
    exports2.default = def;
  }
});

// node_modules/ajv/dist/runtime/ucs2length.js
var require_ucs2length = __commonJS({
  "node_modules/ajv/dist/runtime/ucs2length.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    function ucs2length(str) {
      const len = str.length;
      let length = 0;
      let pos = 0;
      let value;
      while (pos < len) {
        length++;
        value = str.charCodeAt(pos++);
        if (value >= 55296 && value <= 56319 && pos < len) {
          value = str.charCodeAt(pos);
          if ((value & 64512) === 56320)
            pos++;
        }
      }
      return length;
    }
    exports2.default = ucs2length;
    ucs2length.code = 'require("ajv/dist/runtime/ucs2length").default';
  }
});

// node_modules/ajv/dist/vocabularies/validation/limitLength.js
var require_limitLength = __commonJS({
  "node_modules/ajv/dist/vocabularies/validation/limitLength.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var codegen_1 = require_codegen();
    var util_1 = require_util2();
    var ucs2length_1 = require_ucs2length();
    var error = {
      message({ keyword, schemaCode }) {
        const comp = keyword === "maxLength" ? "more" : "fewer";
        return (0, codegen_1.str)`must NOT have ${comp} than ${schemaCode} characters`;
      },
      params: ({ schemaCode }) => (0, codegen_1._)`{limit: ${schemaCode}}`
    };
    var def = {
      keyword: ["maxLength", "minLength"],
      type: "string",
      schemaType: "number",
      $data: true,
      error,
      code(cxt) {
        const { keyword, data, schemaCode, it: it2 } = cxt;
        const op2 = keyword === "maxLength" ? codegen_1.operators.GT : codegen_1.operators.LT;
        const len = it2.opts.unicode === false ? (0, codegen_1._)`${data}.length` : (0, codegen_1._)`${(0, util_1.useFunc)(cxt.gen, ucs2length_1.default)}(${data})`;
        cxt.fail$data((0, codegen_1._)`${len} ${op2} ${schemaCode}`);
      }
    };
    exports2.default = def;
  }
});

// node_modules/ajv/dist/vocabularies/validation/pattern.js
var require_pattern = __commonJS({
  "node_modules/ajv/dist/vocabularies/validation/pattern.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var code_1 = require_code2();
    var codegen_1 = require_codegen();
    var error = {
      message: ({ schemaCode }) => (0, codegen_1.str)`must match pattern "${schemaCode}"`,
      params: ({ schemaCode }) => (0, codegen_1._)`{pattern: ${schemaCode}}`
    };
    var def = {
      keyword: "pattern",
      type: "string",
      schemaType: "string",
      $data: true,
      error,
      code(cxt) {
        const { data, $data, schema, schemaCode, it: it2 } = cxt;
        const u = it2.opts.unicodeRegExp ? "u" : "";
        const regExp = $data ? (0, codegen_1._)`(new RegExp(${schemaCode}, ${u}))` : (0, code_1.usePattern)(cxt, schema);
        cxt.fail$data((0, codegen_1._)`!${regExp}.test(${data})`);
      }
    };
    exports2.default = def;
  }
});

// node_modules/ajv/dist/vocabularies/validation/limitProperties.js
var require_limitProperties = __commonJS({
  "node_modules/ajv/dist/vocabularies/validation/limitProperties.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var codegen_1 = require_codegen();
    var error = {
      message({ keyword, schemaCode }) {
        const comp = keyword === "maxProperties" ? "more" : "fewer";
        return (0, codegen_1.str)`must NOT have ${comp} than ${schemaCode} properties`;
      },
      params: ({ schemaCode }) => (0, codegen_1._)`{limit: ${schemaCode}}`
    };
    var def = {
      keyword: ["maxProperties", "minProperties"],
      type: "object",
      schemaType: "number",
      $data: true,
      error,
      code(cxt) {
        const { keyword, data, schemaCode } = cxt;
        const op2 = keyword === "maxProperties" ? codegen_1.operators.GT : codegen_1.operators.LT;
        cxt.fail$data((0, codegen_1._)`Object.keys(${data}).length ${op2} ${schemaCode}`);
      }
    };
    exports2.default = def;
  }
});

// node_modules/ajv/dist/vocabularies/validation/required.js
var require_required = __commonJS({
  "node_modules/ajv/dist/vocabularies/validation/required.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var code_1 = require_code2();
    var codegen_1 = require_codegen();
    var util_1 = require_util2();
    var error = {
      message: ({ params: { missingProperty } }) => (0, codegen_1.str)`must have required property '${missingProperty}'`,
      params: ({ params: { missingProperty } }) => (0, codegen_1._)`{missingProperty: ${missingProperty}}`
    };
    var def = {
      keyword: "required",
      type: "object",
      schemaType: "array",
      $data: true,
      error,
      code(cxt) {
        const { gen, schema, schemaCode, data, $data, it: it2 } = cxt;
        const { opts } = it2;
        if (!$data && schema.length === 0)
          return;
        const useLoop = schema.length >= opts.loopRequired;
        if (it2.allErrors)
          allErrorsMode();
        else
          exitOnErrorMode();
        if (opts.strictRequired) {
          const props = cxt.parentSchema.properties;
          const { definedProperties } = cxt.it;
          for (const requiredKey of schema) {
            if ((props === null || props === void 0 ? void 0 : props[requiredKey]) === void 0 && !definedProperties.has(requiredKey)) {
              const schemaPath = it2.schemaEnv.baseId + it2.errSchemaPath;
              const msg = `required property "${requiredKey}" is not defined at "${schemaPath}" (strictRequired)`;
              (0, util_1.checkStrictMode)(it2, msg, it2.opts.strictRequired);
            }
          }
        }
        function allErrorsMode() {
          if (useLoop || $data) {
            cxt.block$data(codegen_1.nil, loopAllRequired);
          } else {
            for (const prop of schema) {
              (0, code_1.checkReportMissingProp)(cxt, prop);
            }
          }
        }
        function exitOnErrorMode() {
          const missing = gen.let("missing");
          if (useLoop || $data) {
            const valid = gen.let("valid", true);
            cxt.block$data(valid, () => loopUntilMissing(missing, valid));
            cxt.ok(valid);
          } else {
            gen.if((0, code_1.checkMissingProp)(cxt, schema, missing));
            (0, code_1.reportMissingProp)(cxt, missing);
            gen.else();
          }
        }
        function loopAllRequired() {
          gen.forOf("prop", schemaCode, (prop) => {
            cxt.setParams({ missingProperty: prop });
            gen.if((0, code_1.noPropertyInData)(gen, data, prop, opts.ownProperties), () => cxt.error());
          });
        }
        function loopUntilMissing(missing, valid) {
          cxt.setParams({ missingProperty: missing });
          gen.forOf(missing, schemaCode, () => {
            gen.assign(valid, (0, code_1.propertyInData)(gen, data, missing, opts.ownProperties));
            gen.if((0, codegen_1.not)(valid), () => {
              cxt.error();
              gen.break();
            });
          }, codegen_1.nil);
        }
      }
    };
    exports2.default = def;
  }
});

// node_modules/ajv/dist/vocabularies/validation/limitItems.js
var require_limitItems = __commonJS({
  "node_modules/ajv/dist/vocabularies/validation/limitItems.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var codegen_1 = require_codegen();
    var error = {
      message({ keyword, schemaCode }) {
        const comp = keyword === "maxItems" ? "more" : "fewer";
        return (0, codegen_1.str)`must NOT have ${comp} than ${schemaCode} items`;
      },
      params: ({ schemaCode }) => (0, codegen_1._)`{limit: ${schemaCode}}`
    };
    var def = {
      keyword: ["maxItems", "minItems"],
      type: "array",
      schemaType: "number",
      $data: true,
      error,
      code(cxt) {
        const { keyword, data, schemaCode } = cxt;
        const op2 = keyword === "maxItems" ? codegen_1.operators.GT : codegen_1.operators.LT;
        cxt.fail$data((0, codegen_1._)`${data}.length ${op2} ${schemaCode}`);
      }
    };
    exports2.default = def;
  }
});

// node_modules/ajv/dist/runtime/equal.js
var require_equal = __commonJS({
  "node_modules/ajv/dist/runtime/equal.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var equal = require_fast_deep_equal();
    equal.code = 'require("ajv/dist/runtime/equal").default';
    exports2.default = equal;
  }
});

// node_modules/ajv/dist/vocabularies/validation/uniqueItems.js
var require_uniqueItems = __commonJS({
  "node_modules/ajv/dist/vocabularies/validation/uniqueItems.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var dataType_1 = require_dataType();
    var codegen_1 = require_codegen();
    var util_1 = require_util2();
    var equal_1 = require_equal();
    var error = {
      message: ({ params: { i, j } }) => (0, codegen_1.str)`must NOT have duplicate items (items ## ${j} and ${i} are identical)`,
      params: ({ params: { i, j } }) => (0, codegen_1._)`{i: ${i}, j: ${j}}`
    };
    var def = {
      keyword: "uniqueItems",
      type: "array",
      schemaType: "boolean",
      $data: true,
      error,
      code(cxt) {
        const { gen, data, $data, schema, parentSchema, schemaCode, it: it2 } = cxt;
        if (!$data && !schema)
          return;
        const valid = gen.let("valid");
        const itemTypes = parentSchema.items ? (0, dataType_1.getSchemaTypes)(parentSchema.items) : [];
        cxt.block$data(valid, validateUniqueItems, (0, codegen_1._)`${schemaCode} === false`);
        cxt.ok(valid);
        function validateUniqueItems() {
          const i = gen.let("i", (0, codegen_1._)`${data}.length`);
          const j = gen.let("j");
          cxt.setParams({ i, j });
          gen.assign(valid, true);
          gen.if((0, codegen_1._)`${i} > 1`, () => (canOptimize() ? loopN : loopN2)(i, j));
        }
        function canOptimize() {
          return itemTypes.length > 0 && !itemTypes.some((t) => t === "object" || t === "array");
        }
        function loopN(i, j) {
          const item = gen.name("item");
          const wrongType = (0, dataType_1.checkDataTypes)(itemTypes, item, it2.opts.strictNumbers, dataType_1.DataType.Wrong);
          const indices = gen.const("indices", (0, codegen_1._)`{}`);
          gen.for((0, codegen_1._)`;${i}--;`, () => {
            gen.let(item, (0, codegen_1._)`${data}[${i}]`);
            gen.if(wrongType, (0, codegen_1._)`continue`);
            if (itemTypes.length > 1)
              gen.if((0, codegen_1._)`typeof ${item} == "string"`, (0, codegen_1._)`${item} += "_"`);
            gen.if((0, codegen_1._)`typeof ${indices}[${item}] == "number"`, () => {
              gen.assign(j, (0, codegen_1._)`${indices}[${item}]`);
              cxt.error();
              gen.assign(valid, false).break();
            }).code((0, codegen_1._)`${indices}[${item}] = ${i}`);
          });
        }
        function loopN2(i, j) {
          const eql = (0, util_1.useFunc)(gen, equal_1.default);
          const outer = gen.name("outer");
          gen.label(outer).for((0, codegen_1._)`;${i}--;`, () => gen.for((0, codegen_1._)`${j} = ${i}; ${j}--;`, () => gen.if((0, codegen_1._)`${eql}(${data}[${i}], ${data}[${j}])`, () => {
            cxt.error();
            gen.assign(valid, false).break(outer);
          })));
        }
      }
    };
    exports2.default = def;
  }
});

// node_modules/ajv/dist/vocabularies/validation/const.js
var require_const = __commonJS({
  "node_modules/ajv/dist/vocabularies/validation/const.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var codegen_1 = require_codegen();
    var util_1 = require_util2();
    var equal_1 = require_equal();
    var error = {
      message: "must be equal to constant",
      params: ({ schemaCode }) => (0, codegen_1._)`{allowedValue: ${schemaCode}}`
    };
    var def = {
      keyword: "const",
      $data: true,
      error,
      code(cxt) {
        const { gen, data, $data, schemaCode, schema } = cxt;
        if ($data || schema && typeof schema == "object") {
          cxt.fail$data((0, codegen_1._)`!${(0, util_1.useFunc)(gen, equal_1.default)}(${data}, ${schemaCode})`);
        } else {
          cxt.fail((0, codegen_1._)`${schema} !== ${data}`);
        }
      }
    };
    exports2.default = def;
  }
});

// node_modules/ajv/dist/vocabularies/validation/enum.js
var require_enum = __commonJS({
  "node_modules/ajv/dist/vocabularies/validation/enum.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var codegen_1 = require_codegen();
    var util_1 = require_util2();
    var equal_1 = require_equal();
    var error = {
      message: "must be equal to one of the allowed values",
      params: ({ schemaCode }) => (0, codegen_1._)`{allowedValues: ${schemaCode}}`
    };
    var def = {
      keyword: "enum",
      schemaType: "array",
      $data: true,
      error,
      code(cxt) {
        const { gen, data, $data, schema, schemaCode, it: it2 } = cxt;
        if (!$data && schema.length === 0)
          throw new Error("enum must have non-empty array");
        const useLoop = schema.length >= it2.opts.loopEnum;
        let eql;
        const getEql = () => eql !== null && eql !== void 0 ? eql : eql = (0, util_1.useFunc)(gen, equal_1.default);
        let valid;
        if (useLoop || $data) {
          valid = gen.let("valid");
          cxt.block$data(valid, loopEnum);
        } else {
          if (!Array.isArray(schema))
            throw new Error("ajv implementation error");
          const vSchema = gen.const("vSchema", schemaCode);
          valid = (0, codegen_1.or)(...schema.map((_x, i) => equalCode(vSchema, i)));
        }
        cxt.pass(valid);
        function loopEnum() {
          gen.assign(valid, false);
          gen.forOf("v", schemaCode, (v) => gen.if((0, codegen_1._)`${getEql()}(${data}, ${v})`, () => gen.assign(valid, true).break()));
        }
        function equalCode(vSchema, i) {
          const sch = schema[i];
          return typeof sch === "object" && sch !== null ? (0, codegen_1._)`${getEql()}(${data}, ${vSchema}[${i}])` : (0, codegen_1._)`${data} === ${sch}`;
        }
      }
    };
    exports2.default = def;
  }
});

// node_modules/ajv/dist/vocabularies/validation/index.js
var require_validation2 = __commonJS({
  "node_modules/ajv/dist/vocabularies/validation/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var limitNumber_1 = require_limitNumber();
    var multipleOf_1 = require_multipleOf();
    var limitLength_1 = require_limitLength();
    var pattern_1 = require_pattern();
    var limitProperties_1 = require_limitProperties();
    var required_1 = require_required();
    var limitItems_1 = require_limitItems();
    var uniqueItems_1 = require_uniqueItems();
    var const_1 = require_const();
    var enum_1 = require_enum();
    var validation = [
      // number
      limitNumber_1.default,
      multipleOf_1.default,
      // string
      limitLength_1.default,
      pattern_1.default,
      // object
      limitProperties_1.default,
      required_1.default,
      // array
      limitItems_1.default,
      uniqueItems_1.default,
      // any
      { keyword: "type", schemaType: ["string", "array"] },
      { keyword: "nullable", schemaType: "boolean" },
      const_1.default,
      enum_1.default
    ];
    exports2.default = validation;
  }
});

// node_modules/ajv/dist/vocabularies/applicator/additionalItems.js
var require_additionalItems = __commonJS({
  "node_modules/ajv/dist/vocabularies/applicator/additionalItems.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.validateAdditionalItems = void 0;
    var codegen_1 = require_codegen();
    var util_1 = require_util2();
    var error = {
      message: ({ params: { len } }) => (0, codegen_1.str)`must NOT have more than ${len} items`,
      params: ({ params: { len } }) => (0, codegen_1._)`{limit: ${len}}`
    };
    var def = {
      keyword: "additionalItems",
      type: "array",
      schemaType: ["boolean", "object"],
      before: "uniqueItems",
      error,
      code(cxt) {
        const { parentSchema, it: it2 } = cxt;
        const { items } = parentSchema;
        if (!Array.isArray(items)) {
          (0, util_1.checkStrictMode)(it2, '"additionalItems" is ignored when "items" is not an array of schemas');
          return;
        }
        validateAdditionalItems(cxt, items);
      }
    };
    function validateAdditionalItems(cxt, items) {
      const { gen, schema, data, keyword, it: it2 } = cxt;
      it2.items = true;
      const len = gen.const("len", (0, codegen_1._)`${data}.length`);
      if (schema === false) {
        cxt.setParams({ len: items.length });
        cxt.pass((0, codegen_1._)`${len} <= ${items.length}`);
      } else if (typeof schema == "object" && !(0, util_1.alwaysValidSchema)(it2, schema)) {
        const valid = gen.var("valid", (0, codegen_1._)`${len} <= ${items.length}`);
        gen.if((0, codegen_1.not)(valid), () => validateItems(valid));
        cxt.ok(valid);
      }
      function validateItems(valid) {
        gen.forRange("i", items.length, len, (i) => {
          cxt.subschema({ keyword, dataProp: i, dataPropType: util_1.Type.Num }, valid);
          if (!it2.allErrors)
            gen.if((0, codegen_1.not)(valid), () => gen.break());
        });
      }
    }
    exports2.validateAdditionalItems = validateAdditionalItems;
    exports2.default = def;
  }
});

// node_modules/ajv/dist/vocabularies/applicator/items.js
var require_items = __commonJS({
  "node_modules/ajv/dist/vocabularies/applicator/items.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.validateTuple = void 0;
    var codegen_1 = require_codegen();
    var util_1 = require_util2();
    var code_1 = require_code2();
    var def = {
      keyword: "items",
      type: "array",
      schemaType: ["object", "array", "boolean"],
      before: "uniqueItems",
      code(cxt) {
        const { schema, it: it2 } = cxt;
        if (Array.isArray(schema))
          return validateTuple(cxt, "additionalItems", schema);
        it2.items = true;
        if ((0, util_1.alwaysValidSchema)(it2, schema))
          return;
        cxt.ok((0, code_1.validateArray)(cxt));
      }
    };
    function validateTuple(cxt, extraItems, schArr = cxt.schema) {
      const { gen, parentSchema, data, keyword, it: it2 } = cxt;
      checkStrictTuple(parentSchema);
      if (it2.opts.unevaluated && schArr.length && it2.items !== true) {
        it2.items = util_1.mergeEvaluated.items(gen, schArr.length, it2.items);
      }
      const valid = gen.name("valid");
      const len = gen.const("len", (0, codegen_1._)`${data}.length`);
      schArr.forEach((sch, i) => {
        if ((0, util_1.alwaysValidSchema)(it2, sch))
          return;
        gen.if((0, codegen_1._)`${len} > ${i}`, () => cxt.subschema({
          keyword,
          schemaProp: i,
          dataProp: i
        }, valid));
        cxt.ok(valid);
      });
      function checkStrictTuple(sch) {
        const { opts, errSchemaPath } = it2;
        const l = schArr.length;
        const fullTuple = l === sch.minItems && (l === sch.maxItems || sch[extraItems] === false);
        if (opts.strictTuples && !fullTuple) {
          const msg = `"${keyword}" is ${l}-tuple, but minItems or maxItems/${extraItems} are not specified or different at path "${errSchemaPath}"`;
          (0, util_1.checkStrictMode)(it2, msg, opts.strictTuples);
        }
      }
    }
    exports2.validateTuple = validateTuple;
    exports2.default = def;
  }
});

// node_modules/ajv/dist/vocabularies/applicator/prefixItems.js
var require_prefixItems = __commonJS({
  "node_modules/ajv/dist/vocabularies/applicator/prefixItems.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var items_1 = require_items();
    var def = {
      keyword: "prefixItems",
      type: "array",
      schemaType: ["array"],
      before: "uniqueItems",
      code: (cxt) => (0, items_1.validateTuple)(cxt, "items")
    };
    exports2.default = def;
  }
});

// node_modules/ajv/dist/vocabularies/applicator/items2020.js
var require_items2020 = __commonJS({
  "node_modules/ajv/dist/vocabularies/applicator/items2020.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var codegen_1 = require_codegen();
    var util_1 = require_util2();
    var code_1 = require_code2();
    var additionalItems_1 = require_additionalItems();
    var error = {
      message: ({ params: { len } }) => (0, codegen_1.str)`must NOT have more than ${len} items`,
      params: ({ params: { len } }) => (0, codegen_1._)`{limit: ${len}}`
    };
    var def = {
      keyword: "items",
      type: "array",
      schemaType: ["object", "boolean"],
      before: "uniqueItems",
      error,
      code(cxt) {
        const { schema, parentSchema, it: it2 } = cxt;
        const { prefixItems } = parentSchema;
        it2.items = true;
        if ((0, util_1.alwaysValidSchema)(it2, schema))
          return;
        if (prefixItems)
          (0, additionalItems_1.validateAdditionalItems)(cxt, prefixItems);
        else
          cxt.ok((0, code_1.validateArray)(cxt));
      }
    };
    exports2.default = def;
  }
});

// node_modules/ajv/dist/vocabularies/applicator/contains.js
var require_contains = __commonJS({
  "node_modules/ajv/dist/vocabularies/applicator/contains.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var codegen_1 = require_codegen();
    var util_1 = require_util2();
    var error = {
      message: ({ params: { min, max } }) => max === void 0 ? (0, codegen_1.str)`must contain at least ${min} valid item(s)` : (0, codegen_1.str)`must contain at least ${min} and no more than ${max} valid item(s)`,
      params: ({ params: { min, max } }) => max === void 0 ? (0, codegen_1._)`{minContains: ${min}}` : (0, codegen_1._)`{minContains: ${min}, maxContains: ${max}}`
    };
    var def = {
      keyword: "contains",
      type: "array",
      schemaType: ["object", "boolean"],
      before: "uniqueItems",
      trackErrors: true,
      error,
      code(cxt) {
        const { gen, schema, parentSchema, data, it: it2 } = cxt;
        let min;
        let max;
        const { minContains, maxContains } = parentSchema;
        if (it2.opts.next) {
          min = minContains === void 0 ? 1 : minContains;
          max = maxContains;
        } else {
          min = 1;
        }
        const len = gen.const("len", (0, codegen_1._)`${data}.length`);
        cxt.setParams({ min, max });
        if (max === void 0 && min === 0) {
          (0, util_1.checkStrictMode)(it2, `"minContains" == 0 without "maxContains": "contains" keyword ignored`);
          return;
        }
        if (max !== void 0 && min > max) {
          (0, util_1.checkStrictMode)(it2, `"minContains" > "maxContains" is always invalid`);
          cxt.fail();
          return;
        }
        if ((0, util_1.alwaysValidSchema)(it2, schema)) {
          let cond = (0, codegen_1._)`${len} >= ${min}`;
          if (max !== void 0)
            cond = (0, codegen_1._)`${cond} && ${len} <= ${max}`;
          cxt.pass(cond);
          return;
        }
        it2.items = true;
        const valid = gen.name("valid");
        if (max === void 0 && min === 1) {
          validateItems(valid, () => gen.if(valid, () => gen.break()));
        } else if (min === 0) {
          gen.let(valid, true);
          if (max !== void 0)
            gen.if((0, codegen_1._)`${data}.length > 0`, validateItemsWithCount);
        } else {
          gen.let(valid, false);
          validateItemsWithCount();
        }
        cxt.result(valid, () => cxt.reset());
        function validateItemsWithCount() {
          const schValid = gen.name("_valid");
          const count = gen.let("count", 0);
          validateItems(schValid, () => gen.if(schValid, () => checkLimits(count)));
        }
        function validateItems(_valid, block) {
          gen.forRange("i", 0, len, (i) => {
            cxt.subschema({
              keyword: "contains",
              dataProp: i,
              dataPropType: util_1.Type.Num,
              compositeRule: true
            }, _valid);
            block();
          });
        }
        function checkLimits(count) {
          gen.code((0, codegen_1._)`${count}++`);
          if (max === void 0) {
            gen.if((0, codegen_1._)`${count} >= ${min}`, () => gen.assign(valid, true).break());
          } else {
            gen.if((0, codegen_1._)`${count} > ${max}`, () => gen.assign(valid, false).break());
            if (min === 1)
              gen.assign(valid, true);
            else
              gen.if((0, codegen_1._)`${count} >= ${min}`, () => gen.assign(valid, true));
          }
        }
      }
    };
    exports2.default = def;
  }
});

// node_modules/ajv/dist/vocabularies/applicator/dependencies.js
var require_dependencies = __commonJS({
  "node_modules/ajv/dist/vocabularies/applicator/dependencies.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.validateSchemaDeps = exports2.validatePropertyDeps = exports2.error = void 0;
    var codegen_1 = require_codegen();
    var util_1 = require_util2();
    var code_1 = require_code2();
    exports2.error = {
      message: ({ params: { property, depsCount, deps } }) => {
        const property_ies = depsCount === 1 ? "property" : "properties";
        return (0, codegen_1.str)`must have ${property_ies} ${deps} when property ${property} is present`;
      },
      params: ({ params: { property, depsCount, deps, missingProperty } }) => (0, codegen_1._)`{property: ${property},
    missingProperty: ${missingProperty},
    depsCount: ${depsCount},
    deps: ${deps}}`
      // TODO change to reference
    };
    var def = {
      keyword: "dependencies",
      type: "object",
      schemaType: "object",
      error: exports2.error,
      code(cxt) {
        const [propDeps, schDeps] = splitDependencies(cxt);
        validatePropertyDeps(cxt, propDeps);
        validateSchemaDeps(cxt, schDeps);
      }
    };
    function splitDependencies({ schema }) {
      const propertyDeps = {};
      const schemaDeps = {};
      for (const key in schema) {
        if (key === "__proto__")
          continue;
        const deps = Array.isArray(schema[key]) ? propertyDeps : schemaDeps;
        deps[key] = schema[key];
      }
      return [propertyDeps, schemaDeps];
    }
    function validatePropertyDeps(cxt, propertyDeps = cxt.schema) {
      const { gen, data, it: it2 } = cxt;
      if (Object.keys(propertyDeps).length === 0)
        return;
      const missing = gen.let("missing");
      for (const prop in propertyDeps) {
        const deps = propertyDeps[prop];
        if (deps.length === 0)
          continue;
        const hasProperty = (0, code_1.propertyInData)(gen, data, prop, it2.opts.ownProperties);
        cxt.setParams({
          property: prop,
          depsCount: deps.length,
          deps: deps.join(", ")
        });
        if (it2.allErrors) {
          gen.if(hasProperty, () => {
            for (const depProp of deps) {
              (0, code_1.checkReportMissingProp)(cxt, depProp);
            }
          });
        } else {
          gen.if((0, codegen_1._)`${hasProperty} && (${(0, code_1.checkMissingProp)(cxt, deps, missing)})`);
          (0, code_1.reportMissingProp)(cxt, missing);
          gen.else();
        }
      }
    }
    exports2.validatePropertyDeps = validatePropertyDeps;
    function validateSchemaDeps(cxt, schemaDeps = cxt.schema) {
      const { gen, data, keyword, it: it2 } = cxt;
      const valid = gen.name("valid");
      for (const prop in schemaDeps) {
        if ((0, util_1.alwaysValidSchema)(it2, schemaDeps[prop]))
          continue;
        gen.if(
          (0, code_1.propertyInData)(gen, data, prop, it2.opts.ownProperties),
          () => {
            const schCxt = cxt.subschema({ keyword, schemaProp: prop }, valid);
            cxt.mergeValidEvaluated(schCxt, valid);
          },
          () => gen.var(valid, true)
          // TODO var
        );
        cxt.ok(valid);
      }
    }
    exports2.validateSchemaDeps = validateSchemaDeps;
    exports2.default = def;
  }
});

// node_modules/ajv/dist/vocabularies/applicator/propertyNames.js
var require_propertyNames = __commonJS({
  "node_modules/ajv/dist/vocabularies/applicator/propertyNames.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var codegen_1 = require_codegen();
    var util_1 = require_util2();
    var error = {
      message: "property name must be valid",
      params: ({ params }) => (0, codegen_1._)`{propertyName: ${params.propertyName}}`
    };
    var def = {
      keyword: "propertyNames",
      type: "object",
      schemaType: ["object", "boolean"],
      error,
      code(cxt) {
        const { gen, schema, data, it: it2 } = cxt;
        if ((0, util_1.alwaysValidSchema)(it2, schema))
          return;
        const valid = gen.name("valid");
        gen.forIn("key", data, (key) => {
          cxt.setParams({ propertyName: key });
          cxt.subschema({
            keyword: "propertyNames",
            data: key,
            dataTypes: ["string"],
            propertyName: key,
            compositeRule: true
          }, valid);
          gen.if((0, codegen_1.not)(valid), () => {
            cxt.error(true);
            if (!it2.allErrors)
              gen.break();
          });
        });
        cxt.ok(valid);
      }
    };
    exports2.default = def;
  }
});

// node_modules/ajv/dist/vocabularies/applicator/additionalProperties.js
var require_additionalProperties = __commonJS({
  "node_modules/ajv/dist/vocabularies/applicator/additionalProperties.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var code_1 = require_code2();
    var codegen_1 = require_codegen();
    var names_1 = require_names();
    var util_1 = require_util2();
    var error = {
      message: "must NOT have additional properties",
      params: ({ params }) => (0, codegen_1._)`{additionalProperty: ${params.additionalProperty}}`
    };
    var def = {
      keyword: "additionalProperties",
      type: ["object"],
      schemaType: ["boolean", "object"],
      allowUndefined: true,
      trackErrors: true,
      error,
      code(cxt) {
        const { gen, schema, parentSchema, data, errsCount, it: it2 } = cxt;
        if (!errsCount)
          throw new Error("ajv implementation error");
        const { allErrors, opts } = it2;
        it2.props = true;
        if (opts.removeAdditional !== "all" && (0, util_1.alwaysValidSchema)(it2, schema))
          return;
        const props = (0, code_1.allSchemaProperties)(parentSchema.properties);
        const patProps = (0, code_1.allSchemaProperties)(parentSchema.patternProperties);
        checkAdditionalProperties();
        cxt.ok((0, codegen_1._)`${errsCount} === ${names_1.default.errors}`);
        function checkAdditionalProperties() {
          gen.forIn("key", data, (key) => {
            if (!props.length && !patProps.length)
              additionalPropertyCode(key);
            else
              gen.if(isAdditional(key), () => additionalPropertyCode(key));
          });
        }
        function isAdditional(key) {
          let definedProp;
          if (props.length > 8) {
            const propsSchema = (0, util_1.schemaRefOrVal)(it2, parentSchema.properties, "properties");
            definedProp = (0, code_1.isOwnProperty)(gen, propsSchema, key);
          } else if (props.length) {
            definedProp = (0, codegen_1.or)(...props.map((p) => (0, codegen_1._)`${key} === ${p}`));
          } else {
            definedProp = codegen_1.nil;
          }
          if (patProps.length) {
            definedProp = (0, codegen_1.or)(definedProp, ...patProps.map((p) => (0, codegen_1._)`${(0, code_1.usePattern)(cxt, p)}.test(${key})`));
          }
          return (0, codegen_1.not)(definedProp);
        }
        function deleteAdditional(key) {
          gen.code((0, codegen_1._)`delete ${data}[${key}]`);
        }
        function additionalPropertyCode(key) {
          if (opts.removeAdditional === "all" || opts.removeAdditional && schema === false) {
            deleteAdditional(key);
            return;
          }
          if (schema === false) {
            cxt.setParams({ additionalProperty: key });
            cxt.error();
            if (!allErrors)
              gen.break();
            return;
          }
          if (typeof schema == "object" && !(0, util_1.alwaysValidSchema)(it2, schema)) {
            const valid = gen.name("valid");
            if (opts.removeAdditional === "failing") {
              applyAdditionalSchema(key, valid, false);
              gen.if((0, codegen_1.not)(valid), () => {
                cxt.reset();
                deleteAdditional(key);
              });
            } else {
              applyAdditionalSchema(key, valid);
              if (!allErrors)
                gen.if((0, codegen_1.not)(valid), () => gen.break());
            }
          }
        }
        function applyAdditionalSchema(key, valid, errors) {
          const subschema = {
            keyword: "additionalProperties",
            dataProp: key,
            dataPropType: util_1.Type.Str
          };
          if (errors === false) {
            Object.assign(subschema, {
              compositeRule: true,
              createErrors: false,
              allErrors: false
            });
          }
          cxt.subschema(subschema, valid);
        }
      }
    };
    exports2.default = def;
  }
});

// node_modules/ajv/dist/vocabularies/applicator/properties.js
var require_properties = __commonJS({
  "node_modules/ajv/dist/vocabularies/applicator/properties.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var validate_1 = require_validate();
    var code_1 = require_code2();
    var util_1 = require_util2();
    var additionalProperties_1 = require_additionalProperties();
    var def = {
      keyword: "properties",
      type: "object",
      schemaType: "object",
      code(cxt) {
        const { gen, schema, parentSchema, data, it: it2 } = cxt;
        if (it2.opts.removeAdditional === "all" && parentSchema.additionalProperties === void 0) {
          additionalProperties_1.default.code(new validate_1.KeywordCxt(it2, additionalProperties_1.default, "additionalProperties"));
        }
        const allProps = (0, code_1.allSchemaProperties)(schema);
        for (const prop of allProps) {
          it2.definedProperties.add(prop);
        }
        if (it2.opts.unevaluated && allProps.length && it2.props !== true) {
          it2.props = util_1.mergeEvaluated.props(gen, (0, util_1.toHash)(allProps), it2.props);
        }
        const properties = allProps.filter((p) => !(0, util_1.alwaysValidSchema)(it2, schema[p]));
        if (properties.length === 0)
          return;
        const valid = gen.name("valid");
        for (const prop of properties) {
          if (hasDefault(prop)) {
            applyPropertySchema(prop);
          } else {
            gen.if((0, code_1.propertyInData)(gen, data, prop, it2.opts.ownProperties));
            applyPropertySchema(prop);
            if (!it2.allErrors)
              gen.else().var(valid, true);
            gen.endIf();
          }
          cxt.it.definedProperties.add(prop);
          cxt.ok(valid);
        }
        function hasDefault(prop) {
          return it2.opts.useDefaults && !it2.compositeRule && schema[prop].default !== void 0;
        }
        function applyPropertySchema(prop) {
          cxt.subschema({
            keyword: "properties",
            schemaProp: prop,
            dataProp: prop
          }, valid);
        }
      }
    };
    exports2.default = def;
  }
});

// node_modules/ajv/dist/vocabularies/applicator/patternProperties.js
var require_patternProperties = __commonJS({
  "node_modules/ajv/dist/vocabularies/applicator/patternProperties.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var code_1 = require_code2();
    var codegen_1 = require_codegen();
    var util_1 = require_util2();
    var util_2 = require_util2();
    var def = {
      keyword: "patternProperties",
      type: "object",
      schemaType: "object",
      code(cxt) {
        const { gen, schema, data, parentSchema, it: it2 } = cxt;
        const { opts } = it2;
        const patterns = (0, code_1.allSchemaProperties)(schema);
        const alwaysValidPatterns = patterns.filter((p) => (0, util_1.alwaysValidSchema)(it2, schema[p]));
        if (patterns.length === 0 || alwaysValidPatterns.length === patterns.length && (!it2.opts.unevaluated || it2.props === true)) {
          return;
        }
        const checkProperties = opts.strictSchema && !opts.allowMatchingProperties && parentSchema.properties;
        const valid = gen.name("valid");
        if (it2.props !== true && !(it2.props instanceof codegen_1.Name)) {
          it2.props = (0, util_2.evaluatedPropsToName)(gen, it2.props);
        }
        const { props } = it2;
        validatePatternProperties();
        function validatePatternProperties() {
          for (const pat of patterns) {
            if (checkProperties)
              checkMatchingProperties(pat);
            if (it2.allErrors) {
              validateProperties(pat);
            } else {
              gen.var(valid, true);
              validateProperties(pat);
              gen.if(valid);
            }
          }
        }
        function checkMatchingProperties(pat) {
          for (const prop in checkProperties) {
            if (new RegExp(pat).test(prop)) {
              (0, util_1.checkStrictMode)(it2, `property ${prop} matches pattern ${pat} (use allowMatchingProperties)`);
            }
          }
        }
        function validateProperties(pat) {
          gen.forIn("key", data, (key) => {
            gen.if((0, codegen_1._)`${(0, code_1.usePattern)(cxt, pat)}.test(${key})`, () => {
              const alwaysValid = alwaysValidPatterns.includes(pat);
              if (!alwaysValid) {
                cxt.subschema({
                  keyword: "patternProperties",
                  schemaProp: pat,
                  dataProp: key,
                  dataPropType: util_2.Type.Str
                }, valid);
              }
              if (it2.opts.unevaluated && props !== true) {
                gen.assign((0, codegen_1._)`${props}[${key}]`, true);
              } else if (!alwaysValid && !it2.allErrors) {
                gen.if((0, codegen_1.not)(valid), () => gen.break());
              }
            });
          });
        }
      }
    };
    exports2.default = def;
  }
});

// node_modules/ajv/dist/vocabularies/applicator/not.js
var require_not = __commonJS({
  "node_modules/ajv/dist/vocabularies/applicator/not.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var util_1 = require_util2();
    var def = {
      keyword: "not",
      schemaType: ["object", "boolean"],
      trackErrors: true,
      code(cxt) {
        const { gen, schema, it: it2 } = cxt;
        if ((0, util_1.alwaysValidSchema)(it2, schema)) {
          cxt.fail();
          return;
        }
        const valid = gen.name("valid");
        cxt.subschema({
          keyword: "not",
          compositeRule: true,
          createErrors: false,
          allErrors: false
        }, valid);
        cxt.failResult(valid, () => cxt.reset(), () => cxt.error());
      },
      error: { message: "must NOT be valid" }
    };
    exports2.default = def;
  }
});

// node_modules/ajv/dist/vocabularies/applicator/anyOf.js
var require_anyOf = __commonJS({
  "node_modules/ajv/dist/vocabularies/applicator/anyOf.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var code_1 = require_code2();
    var def = {
      keyword: "anyOf",
      schemaType: "array",
      trackErrors: true,
      code: code_1.validateUnion,
      error: { message: "must match a schema in anyOf" }
    };
    exports2.default = def;
  }
});

// node_modules/ajv/dist/vocabularies/applicator/oneOf.js
var require_oneOf = __commonJS({
  "node_modules/ajv/dist/vocabularies/applicator/oneOf.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var codegen_1 = require_codegen();
    var util_1 = require_util2();
    var error = {
      message: "must match exactly one schema in oneOf",
      params: ({ params }) => (0, codegen_1._)`{passingSchemas: ${params.passing}}`
    };
    var def = {
      keyword: "oneOf",
      schemaType: "array",
      trackErrors: true,
      error,
      code(cxt) {
        const { gen, schema, parentSchema, it: it2 } = cxt;
        if (!Array.isArray(schema))
          throw new Error("ajv implementation error");
        if (it2.opts.discriminator && parentSchema.discriminator)
          return;
        const schArr = schema;
        const valid = gen.let("valid", false);
        const passing = gen.let("passing", null);
        const schValid = gen.name("_valid");
        cxt.setParams({ passing });
        gen.block(validateOneOf);
        cxt.result(valid, () => cxt.reset(), () => cxt.error(true));
        function validateOneOf() {
          schArr.forEach((sch, i) => {
            let schCxt;
            if ((0, util_1.alwaysValidSchema)(it2, sch)) {
              gen.var(schValid, true);
            } else {
              schCxt = cxt.subschema({
                keyword: "oneOf",
                schemaProp: i,
                compositeRule: true
              }, schValid);
            }
            if (i > 0) {
              gen.if((0, codegen_1._)`${schValid} && ${valid}`).assign(valid, false).assign(passing, (0, codegen_1._)`[${passing}, ${i}]`).else();
            }
            gen.if(schValid, () => {
              gen.assign(valid, true);
              gen.assign(passing, i);
              if (schCxt)
                cxt.mergeEvaluated(schCxt, codegen_1.Name);
            });
          });
        }
      }
    };
    exports2.default = def;
  }
});

// node_modules/ajv/dist/vocabularies/applicator/allOf.js
var require_allOf = __commonJS({
  "node_modules/ajv/dist/vocabularies/applicator/allOf.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var util_1 = require_util2();
    var def = {
      keyword: "allOf",
      schemaType: "array",
      code(cxt) {
        const { gen, schema, it: it2 } = cxt;
        if (!Array.isArray(schema))
          throw new Error("ajv implementation error");
        const valid = gen.name("valid");
        schema.forEach((sch, i) => {
          if ((0, util_1.alwaysValidSchema)(it2, sch))
            return;
          const schCxt = cxt.subschema({ keyword: "allOf", schemaProp: i }, valid);
          cxt.ok(valid);
          cxt.mergeEvaluated(schCxt);
        });
      }
    };
    exports2.default = def;
  }
});

// node_modules/ajv/dist/vocabularies/applicator/if.js
var require_if = __commonJS({
  "node_modules/ajv/dist/vocabularies/applicator/if.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var codegen_1 = require_codegen();
    var util_1 = require_util2();
    var error = {
      message: ({ params }) => (0, codegen_1.str)`must match "${params.ifClause}" schema`,
      params: ({ params }) => (0, codegen_1._)`{failingKeyword: ${params.ifClause}}`
    };
    var def = {
      keyword: "if",
      schemaType: ["object", "boolean"],
      trackErrors: true,
      error,
      code(cxt) {
        const { gen, parentSchema, it: it2 } = cxt;
        if (parentSchema.then === void 0 && parentSchema.else === void 0) {
          (0, util_1.checkStrictMode)(it2, '"if" without "then" and "else" is ignored');
        }
        const hasThen = hasSchema(it2, "then");
        const hasElse = hasSchema(it2, "else");
        if (!hasThen && !hasElse)
          return;
        const valid = gen.let("valid", true);
        const schValid = gen.name("_valid");
        validateIf();
        cxt.reset();
        if (hasThen && hasElse) {
          const ifClause = gen.let("ifClause");
          cxt.setParams({ ifClause });
          gen.if(schValid, validateClause("then", ifClause), validateClause("else", ifClause));
        } else if (hasThen) {
          gen.if(schValid, validateClause("then"));
        } else {
          gen.if((0, codegen_1.not)(schValid), validateClause("else"));
        }
        cxt.pass(valid, () => cxt.error(true));
        function validateIf() {
          const schCxt = cxt.subschema({
            keyword: "if",
            compositeRule: true,
            createErrors: false,
            allErrors: false
          }, schValid);
          cxt.mergeEvaluated(schCxt);
        }
        function validateClause(keyword, ifClause) {
          return () => {
            const schCxt = cxt.subschema({ keyword }, schValid);
            gen.assign(valid, schValid);
            cxt.mergeValidEvaluated(schCxt, valid);
            if (ifClause)
              gen.assign(ifClause, (0, codegen_1._)`${keyword}`);
            else
              cxt.setParams({ ifClause: keyword });
          };
        }
      }
    };
    function hasSchema(it2, keyword) {
      const schema = it2.schema[keyword];
      return schema !== void 0 && !(0, util_1.alwaysValidSchema)(it2, schema);
    }
    exports2.default = def;
  }
});

// node_modules/ajv/dist/vocabularies/applicator/thenElse.js
var require_thenElse = __commonJS({
  "node_modules/ajv/dist/vocabularies/applicator/thenElse.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var util_1 = require_util2();
    var def = {
      keyword: ["then", "else"],
      schemaType: ["object", "boolean"],
      code({ keyword, parentSchema, it: it2 }) {
        if (parentSchema.if === void 0)
          (0, util_1.checkStrictMode)(it2, `"${keyword}" without "if" is ignored`);
      }
    };
    exports2.default = def;
  }
});

// node_modules/ajv/dist/vocabularies/applicator/index.js
var require_applicator = __commonJS({
  "node_modules/ajv/dist/vocabularies/applicator/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var additionalItems_1 = require_additionalItems();
    var prefixItems_1 = require_prefixItems();
    var items_1 = require_items();
    var items2020_1 = require_items2020();
    var contains_1 = require_contains();
    var dependencies_1 = require_dependencies();
    var propertyNames_1 = require_propertyNames();
    var additionalProperties_1 = require_additionalProperties();
    var properties_1 = require_properties();
    var patternProperties_1 = require_patternProperties();
    var not_1 = require_not();
    var anyOf_1 = require_anyOf();
    var oneOf_1 = require_oneOf();
    var allOf_1 = require_allOf();
    var if_1 = require_if();
    var thenElse_1 = require_thenElse();
    function getApplicator(draft2020 = false) {
      const applicator = [
        // any
        not_1.default,
        anyOf_1.default,
        oneOf_1.default,
        allOf_1.default,
        if_1.default,
        thenElse_1.default,
        // object
        propertyNames_1.default,
        additionalProperties_1.default,
        dependencies_1.default,
        properties_1.default,
        patternProperties_1.default
      ];
      if (draft2020)
        applicator.push(prefixItems_1.default, items2020_1.default);
      else
        applicator.push(additionalItems_1.default, items_1.default);
      applicator.push(contains_1.default);
      return applicator;
    }
    exports2.default = getApplicator;
  }
});

// node_modules/ajv/dist/vocabularies/format/format.js
var require_format = __commonJS({
  "node_modules/ajv/dist/vocabularies/format/format.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var codegen_1 = require_codegen();
    var error = {
      message: ({ schemaCode }) => (0, codegen_1.str)`must match format "${schemaCode}"`,
      params: ({ schemaCode }) => (0, codegen_1._)`{format: ${schemaCode}}`
    };
    var def = {
      keyword: "format",
      type: ["number", "string"],
      schemaType: "string",
      $data: true,
      error,
      code(cxt, ruleType) {
        const { gen, data, $data, schema, schemaCode, it: it2 } = cxt;
        const { opts, errSchemaPath, schemaEnv, self: self2 } = it2;
        if (!opts.validateFormats)
          return;
        if ($data)
          validate$DataFormat();
        else
          validateFormat();
        function validate$DataFormat() {
          const fmts = gen.scopeValue("formats", {
            ref: self2.formats,
            code: opts.code.formats
          });
          const fDef = gen.const("fDef", (0, codegen_1._)`${fmts}[${schemaCode}]`);
          const fType = gen.let("fType");
          const format = gen.let("format");
          gen.if((0, codegen_1._)`typeof ${fDef} == "object" && !(${fDef} instanceof RegExp)`, () => gen.assign(fType, (0, codegen_1._)`${fDef}.type || "string"`).assign(format, (0, codegen_1._)`${fDef}.validate`), () => gen.assign(fType, (0, codegen_1._)`"string"`).assign(format, fDef));
          cxt.fail$data((0, codegen_1.or)(unknownFmt(), invalidFmt()));
          function unknownFmt() {
            if (opts.strictSchema === false)
              return codegen_1.nil;
            return (0, codegen_1._)`${schemaCode} && !${format}`;
          }
          function invalidFmt() {
            const callFormat = schemaEnv.$async ? (0, codegen_1._)`(${fDef}.async ? await ${format}(${data}) : ${format}(${data}))` : (0, codegen_1._)`${format}(${data})`;
            const validData = (0, codegen_1._)`(typeof ${format} == "function" ? ${callFormat} : ${format}.test(${data}))`;
            return (0, codegen_1._)`${format} && ${format} !== true && ${fType} === ${ruleType} && !${validData}`;
          }
        }
        function validateFormat() {
          const formatDef = self2.formats[schema];
          if (!formatDef) {
            unknownFormat();
            return;
          }
          if (formatDef === true)
            return;
          const [fmtType, format, fmtRef] = getFormat(formatDef);
          if (fmtType === ruleType)
            cxt.pass(validCondition());
          function unknownFormat() {
            if (opts.strictSchema === false) {
              self2.logger.warn(unknownMsg());
              return;
            }
            throw new Error(unknownMsg());
            function unknownMsg() {
              return `unknown format "${schema}" ignored in schema at path "${errSchemaPath}"`;
            }
          }
          function getFormat(fmtDef) {
            const code = fmtDef instanceof RegExp ? (0, codegen_1.regexpCode)(fmtDef) : opts.code.formats ? (0, codegen_1._)`${opts.code.formats}${(0, codegen_1.getProperty)(schema)}` : void 0;
            const fmt = gen.scopeValue("formats", { key: schema, ref: fmtDef, code });
            if (typeof fmtDef == "object" && !(fmtDef instanceof RegExp)) {
              return [fmtDef.type || "string", fmtDef.validate, (0, codegen_1._)`${fmt}.validate`];
            }
            return ["string", fmtDef, fmt];
          }
          function validCondition() {
            if (typeof formatDef == "object" && !(formatDef instanceof RegExp) && formatDef.async) {
              if (!schemaEnv.$async)
                throw new Error("async format in sync schema");
              return (0, codegen_1._)`await ${fmtRef}(${data})`;
            }
            return typeof format == "function" ? (0, codegen_1._)`${fmtRef}(${data})` : (0, codegen_1._)`${fmtRef}.test(${data})`;
          }
        }
      }
    };
    exports2.default = def;
  }
});

// node_modules/ajv/dist/vocabularies/format/index.js
var require_format2 = __commonJS({
  "node_modules/ajv/dist/vocabularies/format/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var format_1 = require_format();
    var format = [format_1.default];
    exports2.default = format;
  }
});

// node_modules/ajv/dist/vocabularies/metadata.js
var require_metadata = __commonJS({
  "node_modules/ajv/dist/vocabularies/metadata.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.contentVocabulary = exports2.metadataVocabulary = void 0;
    exports2.metadataVocabulary = [
      "title",
      "description",
      "default",
      "deprecated",
      "readOnly",
      "writeOnly",
      "examples"
    ];
    exports2.contentVocabulary = [
      "contentMediaType",
      "contentEncoding",
      "contentSchema"
    ];
  }
});

// node_modules/ajv/dist/vocabularies/draft7.js
var require_draft7 = __commonJS({
  "node_modules/ajv/dist/vocabularies/draft7.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var core_1 = require_core2();
    var validation_1 = require_validation2();
    var applicator_1 = require_applicator();
    var format_1 = require_format2();
    var metadata_1 = require_metadata();
    var draft7Vocabularies = [
      core_1.default,
      validation_1.default,
      (0, applicator_1.default)(),
      format_1.default,
      metadata_1.metadataVocabulary,
      metadata_1.contentVocabulary
    ];
    exports2.default = draft7Vocabularies;
  }
});

// node_modules/ajv/dist/vocabularies/discriminator/types.js
var require_types = __commonJS({
  "node_modules/ajv/dist/vocabularies/discriminator/types.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.DiscrError = void 0;
    var DiscrError;
    (function(DiscrError2) {
      DiscrError2["Tag"] = "tag";
      DiscrError2["Mapping"] = "mapping";
    })(DiscrError || (exports2.DiscrError = DiscrError = {}));
  }
});

// node_modules/ajv/dist/vocabularies/discriminator/index.js
var require_discriminator = __commonJS({
  "node_modules/ajv/dist/vocabularies/discriminator/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var codegen_1 = require_codegen();
    var types_1 = require_types();
    var compile_1 = require_compile();
    var ref_error_1 = require_ref_error();
    var util_1 = require_util2();
    var error = {
      message: ({ params: { discrError, tagName } }) => discrError === types_1.DiscrError.Tag ? `tag "${tagName}" must be string` : `value of tag "${tagName}" must be in oneOf`,
      params: ({ params: { discrError, tag, tagName } }) => (0, codegen_1._)`{error: ${discrError}, tag: ${tagName}, tagValue: ${tag}}`
    };
    var def = {
      keyword: "discriminator",
      type: "object",
      schemaType: "object",
      error,
      code(cxt) {
        const { gen, data, schema, parentSchema, it: it2 } = cxt;
        const { oneOf } = parentSchema;
        if (!it2.opts.discriminator) {
          throw new Error("discriminator: requires discriminator option");
        }
        const tagName = schema.propertyName;
        if (typeof tagName != "string")
          throw new Error("discriminator: requires propertyName");
        if (schema.mapping)
          throw new Error("discriminator: mapping is not supported");
        if (!oneOf)
          throw new Error("discriminator: requires oneOf keyword");
        const valid = gen.let("valid", false);
        const tag = gen.const("tag", (0, codegen_1._)`${data}${(0, codegen_1.getProperty)(tagName)}`);
        gen.if((0, codegen_1._)`typeof ${tag} == "string"`, () => validateMapping(), () => cxt.error(false, { discrError: types_1.DiscrError.Tag, tag, tagName }));
        cxt.ok(valid);
        function validateMapping() {
          const mapping = getMapping();
          gen.if(false);
          for (const tagValue in mapping) {
            gen.elseIf((0, codegen_1._)`${tag} === ${tagValue}`);
            gen.assign(valid, applyTagSchema(mapping[tagValue]));
          }
          gen.else();
          cxt.error(false, { discrError: types_1.DiscrError.Mapping, tag, tagName });
          gen.endIf();
        }
        function applyTagSchema(schemaProp) {
          const _valid = gen.name("valid");
          const schCxt = cxt.subschema({ keyword: "oneOf", schemaProp }, _valid);
          cxt.mergeEvaluated(schCxt, codegen_1.Name);
          return _valid;
        }
        function getMapping() {
          var _a;
          const oneOfMapping = {};
          const topRequired = hasRequired(parentSchema);
          let tagRequired = true;
          for (let i = 0; i < oneOf.length; i++) {
            let sch = oneOf[i];
            if ((sch === null || sch === void 0 ? void 0 : sch.$ref) && !(0, util_1.schemaHasRulesButRef)(sch, it2.self.RULES)) {
              const ref = sch.$ref;
              sch = compile_1.resolveRef.call(it2.self, it2.schemaEnv.root, it2.baseId, ref);
              if (sch instanceof compile_1.SchemaEnv)
                sch = sch.schema;
              if (sch === void 0)
                throw new ref_error_1.default(it2.opts.uriResolver, it2.baseId, ref);
            }
            const propSch = (_a = sch === null || sch === void 0 ? void 0 : sch.properties) === null || _a === void 0 ? void 0 : _a[tagName];
            if (typeof propSch != "object") {
              throw new Error(`discriminator: oneOf subschemas (or referenced schemas) must have "properties/${tagName}"`);
            }
            tagRequired = tagRequired && (topRequired || hasRequired(sch));
            addMappings(propSch, i);
          }
          if (!tagRequired)
            throw new Error(`discriminator: "${tagName}" must be required`);
          return oneOfMapping;
          function hasRequired({ required }) {
            return Array.isArray(required) && required.includes(tagName);
          }
          function addMappings(sch, i) {
            if (sch.const) {
              addMapping(sch.const, i);
            } else if (sch.enum) {
              for (const tagValue of sch.enum) {
                addMapping(tagValue, i);
              }
            } else {
              throw new Error(`discriminator: "properties/${tagName}" must have "const" or "enum"`);
            }
          }
          function addMapping(tagValue, i) {
            if (typeof tagValue != "string" || tagValue in oneOfMapping) {
              throw new Error(`discriminator: "${tagName}" values must be unique strings`);
            }
            oneOfMapping[tagValue] = i;
          }
        }
      }
    };
    exports2.default = def;
  }
});

// node_modules/ajv/dist/refs/json-schema-draft-07.json
var require_json_schema_draft_07 = __commonJS({
  "node_modules/ajv/dist/refs/json-schema-draft-07.json"(exports2, module2) {
    module2.exports = {
      $schema: "http://json-schema.org/draft-07/schema#",
      $id: "http://json-schema.org/draft-07/schema#",
      title: "Core schema meta-schema",
      definitions: {
        schemaArray: {
          type: "array",
          minItems: 1,
          items: { $ref: "#" }
        },
        nonNegativeInteger: {
          type: "integer",
          minimum: 0
        },
        nonNegativeIntegerDefault0: {
          allOf: [{ $ref: "#/definitions/nonNegativeInteger" }, { default: 0 }]
        },
        simpleTypes: {
          enum: ["array", "boolean", "integer", "null", "number", "object", "string"]
        },
        stringArray: {
          type: "array",
          items: { type: "string" },
          uniqueItems: true,
          default: []
        }
      },
      type: ["object", "boolean"],
      properties: {
        $id: {
          type: "string",
          format: "uri-reference"
        },
        $schema: {
          type: "string",
          format: "uri"
        },
        $ref: {
          type: "string",
          format: "uri-reference"
        },
        $comment: {
          type: "string"
        },
        title: {
          type: "string"
        },
        description: {
          type: "string"
        },
        default: true,
        readOnly: {
          type: "boolean",
          default: false
        },
        examples: {
          type: "array",
          items: true
        },
        multipleOf: {
          type: "number",
          exclusiveMinimum: 0
        },
        maximum: {
          type: "number"
        },
        exclusiveMaximum: {
          type: "number"
        },
        minimum: {
          type: "number"
        },
        exclusiveMinimum: {
          type: "number"
        },
        maxLength: { $ref: "#/definitions/nonNegativeInteger" },
        minLength: { $ref: "#/definitions/nonNegativeIntegerDefault0" },
        pattern: {
          type: "string",
          format: "regex"
        },
        additionalItems: { $ref: "#" },
        items: {
          anyOf: [{ $ref: "#" }, { $ref: "#/definitions/schemaArray" }],
          default: true
        },
        maxItems: { $ref: "#/definitions/nonNegativeInteger" },
        minItems: { $ref: "#/definitions/nonNegativeIntegerDefault0" },
        uniqueItems: {
          type: "boolean",
          default: false
        },
        contains: { $ref: "#" },
        maxProperties: { $ref: "#/definitions/nonNegativeInteger" },
        minProperties: { $ref: "#/definitions/nonNegativeIntegerDefault0" },
        required: { $ref: "#/definitions/stringArray" },
        additionalProperties: { $ref: "#" },
        definitions: {
          type: "object",
          additionalProperties: { $ref: "#" },
          default: {}
        },
        properties: {
          type: "object",
          additionalProperties: { $ref: "#" },
          default: {}
        },
        patternProperties: {
          type: "object",
          additionalProperties: { $ref: "#" },
          propertyNames: { format: "regex" },
          default: {}
        },
        dependencies: {
          type: "object",
          additionalProperties: {
            anyOf: [{ $ref: "#" }, { $ref: "#/definitions/stringArray" }]
          }
        },
        propertyNames: { $ref: "#" },
        const: true,
        enum: {
          type: "array",
          items: true,
          minItems: 1,
          uniqueItems: true
        },
        type: {
          anyOf: [
            { $ref: "#/definitions/simpleTypes" },
            {
              type: "array",
              items: { $ref: "#/definitions/simpleTypes" },
              minItems: 1,
              uniqueItems: true
            }
          ]
        },
        format: { type: "string" },
        contentMediaType: { type: "string" },
        contentEncoding: { type: "string" },
        if: { $ref: "#" },
        then: { $ref: "#" },
        else: { $ref: "#" },
        allOf: { $ref: "#/definitions/schemaArray" },
        anyOf: { $ref: "#/definitions/schemaArray" },
        oneOf: { $ref: "#/definitions/schemaArray" },
        not: { $ref: "#" }
      },
      default: true
    };
  }
});

// node_modules/ajv/dist/ajv.js
var require_ajv = __commonJS({
  "node_modules/ajv/dist/ajv.js"(exports2, module2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.MissingRefError = exports2.ValidationError = exports2.CodeGen = exports2.Name = exports2.nil = exports2.stringify = exports2.str = exports2._ = exports2.KeywordCxt = exports2.Ajv = void 0;
    var core_1 = require_core();
    var draft7_1 = require_draft7();
    var discriminator_1 = require_discriminator();
    var draft7MetaSchema = require_json_schema_draft_07();
    var META_SUPPORT_DATA = ["/properties"];
    var META_SCHEMA_ID = "http://json-schema.org/draft-07/schema";
    var Ajv = class extends core_1.default {
      _addVocabularies() {
        super._addVocabularies();
        draft7_1.default.forEach((v) => this.addVocabulary(v));
        if (this.opts.discriminator)
          this.addKeyword(discriminator_1.default);
      }
      _addDefaultMetaSchema() {
        super._addDefaultMetaSchema();
        if (!this.opts.meta)
          return;
        const metaSchema = this.opts.$data ? this.$dataMetaSchema(draft7MetaSchema, META_SUPPORT_DATA) : draft7MetaSchema;
        this.addMetaSchema(metaSchema, META_SCHEMA_ID, false);
        this.refs["http://json-schema.org/schema"] = META_SCHEMA_ID;
      }
      defaultMeta() {
        return this.opts.defaultMeta = super.defaultMeta() || (this.getSchema(META_SCHEMA_ID) ? META_SCHEMA_ID : void 0);
      }
    };
    exports2.Ajv = Ajv;
    module2.exports = exports2 = Ajv;
    module2.exports.Ajv = Ajv;
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.default = Ajv;
    var validate_1 = require_validate();
    Object.defineProperty(exports2, "KeywordCxt", { enumerable: true, get: function() {
      return validate_1.KeywordCxt;
    } });
    var codegen_1 = require_codegen();
    Object.defineProperty(exports2, "_", { enumerable: true, get: function() {
      return codegen_1._;
    } });
    Object.defineProperty(exports2, "str", { enumerable: true, get: function() {
      return codegen_1.str;
    } });
    Object.defineProperty(exports2, "stringify", { enumerable: true, get: function() {
      return codegen_1.stringify;
    } });
    Object.defineProperty(exports2, "nil", { enumerable: true, get: function() {
      return codegen_1.nil;
    } });
    Object.defineProperty(exports2, "Name", { enumerable: true, get: function() {
      return codegen_1.Name;
    } });
    Object.defineProperty(exports2, "CodeGen", { enumerable: true, get: function() {
      return codegen_1.CodeGen;
    } });
    var validation_error_1 = require_validation_error();
    Object.defineProperty(exports2, "ValidationError", { enumerable: true, get: function() {
      return validation_error_1.default;
    } });
    var ref_error_1 = require_ref_error();
    Object.defineProperty(exports2, "MissingRefError", { enumerable: true, get: function() {
      return ref_error_1.default;
    } });
  }
});

// node_modules/ajv-formats/dist/formats.js
var require_formats = __commonJS({
  "node_modules/ajv-formats/dist/formats.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.formatNames = exports2.fastFormats = exports2.fullFormats = void 0;
    function fmtDef(validate, compare) {
      return { validate, compare };
    }
    exports2.fullFormats = {
      // date: http://tools.ietf.org/html/rfc3339#section-5.6
      date: fmtDef(date, compareDate),
      // date-time: http://tools.ietf.org/html/rfc3339#section-5.6
      time: fmtDef(getTime(true), compareTime),
      "date-time": fmtDef(getDateTime(true), compareDateTime),
      "iso-time": fmtDef(getTime(), compareIsoTime),
      "iso-date-time": fmtDef(getDateTime(), compareIsoDateTime),
      // duration: https://tools.ietf.org/html/rfc3339#appendix-A
      duration: /^P(?!$)((\d+Y)?(\d+M)?(\d+D)?(T(?=\d)(\d+H)?(\d+M)?(\d+S)?)?|(\d+W)?)$/,
      uri,
      "uri-reference": /^(?:[a-z][a-z0-9+\-.]*:)?(?:\/?\/(?:(?:[a-z0-9\-._~!$&'()*+,;=:]|%[0-9a-f]{2})*@)?(?:\[(?:(?:(?:(?:[0-9a-f]{1,4}:){6}|::(?:[0-9a-f]{1,4}:){5}|(?:[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){4}|(?:(?:[0-9a-f]{1,4}:){0,1}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){3}|(?:(?:[0-9a-f]{1,4}:){0,2}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){2}|(?:(?:[0-9a-f]{1,4}:){0,3}[0-9a-f]{1,4})?::[0-9a-f]{1,4}:|(?:(?:[0-9a-f]{1,4}:){0,4}[0-9a-f]{1,4})?::)(?:[0-9a-f]{1,4}:[0-9a-f]{1,4}|(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?))|(?:(?:[0-9a-f]{1,4}:){0,5}[0-9a-f]{1,4})?::[0-9a-f]{1,4}|(?:(?:[0-9a-f]{1,4}:){0,6}[0-9a-f]{1,4})?::)|[Vv][0-9a-f]+\.[a-z0-9\-._~!$&'()*+,;=:]+)\]|(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?)|(?:[a-z0-9\-._~!$&'"()*+,;=]|%[0-9a-f]{2})*)(?::\d*)?(?:\/(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})*)*|\/(?:(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})+(?:\/(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})*)*)?|(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})+(?:\/(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})*)*)?(?:\?(?:[a-z0-9\-._~!$&'"()*+,;=:@/?]|%[0-9a-f]{2})*)?(?:#(?:[a-z0-9\-._~!$&'"()*+,;=:@/?]|%[0-9a-f]{2})*)?$/i,
      // uri-template: https://tools.ietf.org/html/rfc6570
      "uri-template": /^(?:(?:[^\x00-\x20"'<>%\\^`{|}]|%[0-9a-f]{2})|\{[+#./;?&=,!@|]?(?:[a-z0-9_]|%[0-9a-f]{2})+(?::[1-9][0-9]{0,3}|\*)?(?:,(?:[a-z0-9_]|%[0-9a-f]{2})+(?::[1-9][0-9]{0,3}|\*)?)*\})*$/i,
      // For the source: https://gist.github.com/dperini/729294
      // For test cases: https://mathiasbynens.be/demo/url-regex
      url: /^(?:https?|ftp):\/\/(?:\S+(?::\S*)?@)?(?:(?!(?:10|127)(?:\.\d{1,3}){3})(?!(?:169\.254|192\.168)(?:\.\d{1,3}){2})(?!172\.(?:1[6-9]|2\d|3[0-1])(?:\.\d{1,3}){2})(?:[1-9]\d?|1\d\d|2[01]\d|22[0-3])(?:\.(?:1?\d{1,2}|2[0-4]\d|25[0-5])){2}(?:\.(?:[1-9]\d?|1\d\d|2[0-4]\d|25[0-4]))|(?:(?:[a-z0-9\u{00a1}-\u{ffff}]+-)*[a-z0-9\u{00a1}-\u{ffff}]+)(?:\.(?:[a-z0-9\u{00a1}-\u{ffff}]+-)*[a-z0-9\u{00a1}-\u{ffff}]+)*(?:\.(?:[a-z\u{00a1}-\u{ffff}]{2,})))(?::\d{2,5})?(?:\/[^\s]*)?$/iu,
      email: /^[a-z0-9!#$%&'*+/=?^_`{|}~-]+(?:\.[a-z0-9!#$%&'*+/=?^_`{|}~-]+)*@(?:[a-z0-9](?:[a-z0-9-]*[a-z0-9])?\.)+[a-z0-9](?:[a-z0-9-]*[a-z0-9])?$/i,
      hostname: /^(?=.{1,253}\.?$)[a-z0-9](?:[a-z0-9-]{0,61}[a-z0-9])?(?:\.[a-z0-9](?:[-0-9a-z]{0,61}[0-9a-z])?)*\.?$/i,
      // optimized https://www.safaribooksonline.com/library/view/regular-expressions-cookbook/9780596802837/ch07s16.html
      ipv4: /^(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)\.){3}(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)$/,
      ipv6: /^((([0-9a-f]{1,4}:){7}([0-9a-f]{1,4}|:))|(([0-9a-f]{1,4}:){6}(:[0-9a-f]{1,4}|((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3})|:))|(([0-9a-f]{1,4}:){5}(((:[0-9a-f]{1,4}){1,2})|:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3})|:))|(([0-9a-f]{1,4}:){4}(((:[0-9a-f]{1,4}){1,3})|((:[0-9a-f]{1,4})?:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(([0-9a-f]{1,4}:){3}(((:[0-9a-f]{1,4}){1,4})|((:[0-9a-f]{1,4}){0,2}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(([0-9a-f]{1,4}:){2}(((:[0-9a-f]{1,4}){1,5})|((:[0-9a-f]{1,4}){0,3}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(([0-9a-f]{1,4}:){1}(((:[0-9a-f]{1,4}){1,6})|((:[0-9a-f]{1,4}){0,4}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(:(((:[0-9a-f]{1,4}){1,7})|((:[0-9a-f]{1,4}){0,5}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:)))$/i,
      regex,
      // uuid: http://tools.ietf.org/html/rfc4122
      uuid: /^(?:urn:uuid:)?[0-9a-f]{8}-(?:[0-9a-f]{4}-){3}[0-9a-f]{12}$/i,
      // JSON-pointer: https://tools.ietf.org/html/rfc6901
      // uri fragment: https://tools.ietf.org/html/rfc3986#appendix-A
      "json-pointer": /^(?:\/(?:[^~/]|~0|~1)*)*$/,
      "json-pointer-uri-fragment": /^#(?:\/(?:[a-z0-9_\-.!$&'()*+,;:=@]|%[0-9a-f]{2}|~0|~1)*)*$/i,
      // relative JSON-pointer: http://tools.ietf.org/html/draft-luff-relative-json-pointer-00
      "relative-json-pointer": /^(?:0|[1-9][0-9]*)(?:#|(?:\/(?:[^~/]|~0|~1)*)*)$/,
      // the following formats are used by the openapi specification: https://spec.openapis.org/oas/v3.0.0#data-types
      // byte: https://github.com/miguelmota/is-base64
      byte,
      // signed 32 bit integer
      int32: { type: "number", validate: validateInt32 },
      // signed 64 bit integer
      int64: { type: "number", validate: validateInt64 },
      // C-type float
      float: { type: "number", validate: validateNumber },
      // C-type double
      double: { type: "number", validate: validateNumber },
      // hint to the UI to hide input strings
      password: true,
      // unchecked string payload
      binary: true
    };
    exports2.fastFormats = {
      ...exports2.fullFormats,
      date: fmtDef(/^\d\d\d\d-[0-1]\d-[0-3]\d$/, compareDate),
      time: fmtDef(/^(?:[0-2]\d:[0-5]\d:[0-5]\d|23:59:60)(?:\.\d+)?(?:z|[+-]\d\d(?::?\d\d)?)$/i, compareTime),
      "date-time": fmtDef(/^\d\d\d\d-[0-1]\d-[0-3]\dt(?:[0-2]\d:[0-5]\d:[0-5]\d|23:59:60)(?:\.\d+)?(?:z|[+-]\d\d(?::?\d\d)?)$/i, compareDateTime),
      "iso-time": fmtDef(/^(?:[0-2]\d:[0-5]\d:[0-5]\d|23:59:60)(?:\.\d+)?(?:z|[+-]\d\d(?::?\d\d)?)?$/i, compareIsoTime),
      "iso-date-time": fmtDef(/^\d\d\d\d-[0-1]\d-[0-3]\d[t\s](?:[0-2]\d:[0-5]\d:[0-5]\d|23:59:60)(?:\.\d+)?(?:z|[+-]\d\d(?::?\d\d)?)?$/i, compareIsoDateTime),
      // uri: https://github.com/mafintosh/is-my-json-valid/blob/master/formats.js
      uri: /^(?:[a-z][a-z0-9+\-.]*:)(?:\/?\/)?[^\s]*$/i,
      "uri-reference": /^(?:(?:[a-z][a-z0-9+\-.]*:)?\/?\/)?(?:[^\\\s#][^\s#]*)?(?:#[^\\\s]*)?$/i,
      // email (sources from jsen validator):
      // http://stackoverflow.com/questions/201323/using-a-regular-expression-to-validate-an-email-address#answer-8829363
      // http://www.w3.org/TR/html5/forms.html#valid-e-mail-address (search for 'wilful violation')
      email: /^[a-z0-9.!#$%&'*+/=?^_`{|}~-]+@[a-z0-9](?:[a-z0-9-]{0,61}[a-z0-9])?(?:\.[a-z0-9](?:[a-z0-9-]{0,61}[a-z0-9])?)*$/i
    };
    exports2.formatNames = Object.keys(exports2.fullFormats);
    function isLeapYear(year) {
      return year % 4 === 0 && (year % 100 !== 0 || year % 400 === 0);
    }
    var DATE = /^(\d\d\d\d)-(\d\d)-(\d\d)$/;
    var DAYS = [0, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];
    function date(str) {
      const matches = DATE.exec(str);
      if (!matches)
        return false;
      const year = +matches[1];
      const month = +matches[2];
      const day = +matches[3];
      return month >= 1 && month <= 12 && day >= 1 && day <= (month === 2 && isLeapYear(year) ? 29 : DAYS[month]);
    }
    function compareDate(d1, d2) {
      if (!(d1 && d2))
        return void 0;
      if (d1 > d2)
        return 1;
      if (d1 < d2)
        return -1;
      return 0;
    }
    var TIME = /^(\d\d):(\d\d):(\d\d(?:\.\d+)?)(z|([+-])(\d\d)(?::?(\d\d))?)?$/i;
    function getTime(strictTimeZone) {
      return function time(str) {
        const matches = TIME.exec(str);
        if (!matches)
          return false;
        const hr = +matches[1];
        const min = +matches[2];
        const sec = +matches[3];
        const tz = matches[4];
        const tzSign = matches[5] === "-" ? -1 : 1;
        const tzH = +(matches[6] || 0);
        const tzM = +(matches[7] || 0);
        if (tzH > 23 || tzM > 59 || strictTimeZone && !tz)
          return false;
        if (hr <= 23 && min <= 59 && sec < 60)
          return true;
        const utcMin = min - tzM * tzSign;
        const utcHr = hr - tzH * tzSign - (utcMin < 0 ? 1 : 0);
        return (utcHr === 23 || utcHr === -1) && (utcMin === 59 || utcMin === -1) && sec < 61;
      };
    }
    function compareTime(s1, s2) {
      if (!(s1 && s2))
        return void 0;
      const t1 = (/* @__PURE__ */ new Date("2020-01-01T" + s1)).valueOf();
      const t2 = (/* @__PURE__ */ new Date("2020-01-01T" + s2)).valueOf();
      if (!(t1 && t2))
        return void 0;
      return t1 - t2;
    }
    function compareIsoTime(t1, t2) {
      if (!(t1 && t2))
        return void 0;
      const a1 = TIME.exec(t1);
      const a2 = TIME.exec(t2);
      if (!(a1 && a2))
        return void 0;
      t1 = a1[1] + a1[2] + a1[3];
      t2 = a2[1] + a2[2] + a2[3];
      if (t1 > t2)
        return 1;
      if (t1 < t2)
        return -1;
      return 0;
    }
    var DATE_TIME_SEPARATOR = /t|\s/i;
    function getDateTime(strictTimeZone) {
      const time = getTime(strictTimeZone);
      return function date_time(str) {
        const dateTime = str.split(DATE_TIME_SEPARATOR);
        return dateTime.length === 2 && date(dateTime[0]) && time(dateTime[1]);
      };
    }
    function compareDateTime(dt1, dt2) {
      if (!(dt1 && dt2))
        return void 0;
      const d1 = new Date(dt1).valueOf();
      const d2 = new Date(dt2).valueOf();
      if (!(d1 && d2))
        return void 0;
      return d1 - d2;
    }
    function compareIsoDateTime(dt1, dt2) {
      if (!(dt1 && dt2))
        return void 0;
      const [d1, t1] = dt1.split(DATE_TIME_SEPARATOR);
      const [d2, t2] = dt2.split(DATE_TIME_SEPARATOR);
      const res = compareDate(d1, d2);
      if (res === void 0)
        return void 0;
      return res || compareTime(t1, t2);
    }
    var NOT_URI_FRAGMENT = /\/|:/;
    var URI = /^(?:[a-z][a-z0-9+\-.]*:)(?:\/?\/(?:(?:[a-z0-9\-._~!$&'()*+,;=:]|%[0-9a-f]{2})*@)?(?:\[(?:(?:(?:(?:[0-9a-f]{1,4}:){6}|::(?:[0-9a-f]{1,4}:){5}|(?:[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){4}|(?:(?:[0-9a-f]{1,4}:){0,1}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){3}|(?:(?:[0-9a-f]{1,4}:){0,2}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){2}|(?:(?:[0-9a-f]{1,4}:){0,3}[0-9a-f]{1,4})?::[0-9a-f]{1,4}:|(?:(?:[0-9a-f]{1,4}:){0,4}[0-9a-f]{1,4})?::)(?:[0-9a-f]{1,4}:[0-9a-f]{1,4}|(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?))|(?:(?:[0-9a-f]{1,4}:){0,5}[0-9a-f]{1,4})?::[0-9a-f]{1,4}|(?:(?:[0-9a-f]{1,4}:){0,6}[0-9a-f]{1,4})?::)|[Vv][0-9a-f]+\.[a-z0-9\-._~!$&'()*+,;=:]+)\]|(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?)|(?:[a-z0-9\-._~!$&'()*+,;=]|%[0-9a-f]{2})*)(?::\d*)?(?:\/(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})*)*|\/(?:(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})+(?:\/(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})*)*)?|(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})+(?:\/(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})*)*)(?:\?(?:[a-z0-9\-._~!$&'()*+,;=:@/?]|%[0-9a-f]{2})*)?(?:#(?:[a-z0-9\-._~!$&'()*+,;=:@/?]|%[0-9a-f]{2})*)?$/i;
    function uri(str) {
      return NOT_URI_FRAGMENT.test(str) && URI.test(str);
    }
    var BYTE = /^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$/gm;
    function byte(str) {
      BYTE.lastIndex = 0;
      return BYTE.test(str);
    }
    var MIN_INT32 = -(2 ** 31);
    var MAX_INT32 = 2 ** 31 - 1;
    function validateInt32(value) {
      return Number.isInteger(value) && value <= MAX_INT32 && value >= MIN_INT32;
    }
    function validateInt64(value) {
      return Number.isInteger(value);
    }
    function validateNumber() {
      return true;
    }
    var Z_ANCHOR = /[^\\]\\Z/;
    function regex(str) {
      if (Z_ANCHOR.test(str))
        return false;
      try {
        new RegExp(str);
        return true;
      } catch (e) {
        return false;
      }
    }
  }
});

// node_modules/ajv-formats/dist/limit.js
var require_limit = __commonJS({
  "node_modules/ajv-formats/dist/limit.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.formatLimitDefinition = void 0;
    var ajv_1 = require_ajv();
    var codegen_1 = require_codegen();
    var ops = codegen_1.operators;
    var KWDs = {
      formatMaximum: { okStr: "<=", ok: ops.LTE, fail: ops.GT },
      formatMinimum: { okStr: ">=", ok: ops.GTE, fail: ops.LT },
      formatExclusiveMaximum: { okStr: "<", ok: ops.LT, fail: ops.GTE },
      formatExclusiveMinimum: { okStr: ">", ok: ops.GT, fail: ops.LTE }
    };
    var error = {
      message: ({ keyword, schemaCode }) => (0, codegen_1.str)`should be ${KWDs[keyword].okStr} ${schemaCode}`,
      params: ({ keyword, schemaCode }) => (0, codegen_1._)`{comparison: ${KWDs[keyword].okStr}, limit: ${schemaCode}}`
    };
    exports2.formatLimitDefinition = {
      keyword: Object.keys(KWDs),
      type: "string",
      schemaType: "string",
      $data: true,
      error,
      code(cxt) {
        const { gen, data, schemaCode, keyword, it: it2 } = cxt;
        const { opts, self: self2 } = it2;
        if (!opts.validateFormats)
          return;
        const fCxt = new ajv_1.KeywordCxt(it2, self2.RULES.all.format.definition, "format");
        if (fCxt.$data)
          validate$DataFormat();
        else
          validateFormat();
        function validate$DataFormat() {
          const fmts = gen.scopeValue("formats", {
            ref: self2.formats,
            code: opts.code.formats
          });
          const fmt = gen.const("fmt", (0, codegen_1._)`${fmts}[${fCxt.schemaCode}]`);
          cxt.fail$data((0, codegen_1.or)((0, codegen_1._)`typeof ${fmt} != "object"`, (0, codegen_1._)`${fmt} instanceof RegExp`, (0, codegen_1._)`typeof ${fmt}.compare != "function"`, compareCode(fmt)));
        }
        function validateFormat() {
          const format = fCxt.schema;
          const fmtDef = self2.formats[format];
          if (!fmtDef || fmtDef === true)
            return;
          if (typeof fmtDef != "object" || fmtDef instanceof RegExp || typeof fmtDef.compare != "function") {
            throw new Error(`"${keyword}": format "${format}" does not define "compare" function`);
          }
          const fmt = gen.scopeValue("formats", {
            key: format,
            ref: fmtDef,
            code: opts.code.formats ? (0, codegen_1._)`${opts.code.formats}${(0, codegen_1.getProperty)(format)}` : void 0
          });
          cxt.fail$data(compareCode(fmt));
        }
        function compareCode(fmt) {
          return (0, codegen_1._)`${fmt}.compare(${data}, ${schemaCode}) ${KWDs[keyword].fail} 0`;
        }
      },
      dependencies: ["format"]
    };
    var formatLimitPlugin = (ajv) => {
      ajv.addKeyword(exports2.formatLimitDefinition);
      return ajv;
    };
    exports2.default = formatLimitPlugin;
  }
});

// node_modules/ajv-formats/dist/index.js
var require_dist2 = __commonJS({
  "node_modules/ajv-formats/dist/index.js"(exports2, module2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var formats_1 = require_formats();
    var limit_1 = require_limit();
    var codegen_1 = require_codegen();
    var fullName = new codegen_1.Name("fullFormats");
    var fastName = new codegen_1.Name("fastFormats");
    var formatsPlugin = (ajv, opts = { keywords: true }) => {
      if (Array.isArray(opts)) {
        addFormats(ajv, opts, formats_1.fullFormats, fullName);
        return ajv;
      }
      const [formats, exportName] = opts.mode === "fast" ? [formats_1.fastFormats, fastName] : [formats_1.fullFormats, fullName];
      const list = opts.formats || formats_1.formatNames;
      addFormats(ajv, list, formats, exportName);
      if (opts.keywords)
        (0, limit_1.default)(ajv);
      return ajv;
    };
    formatsPlugin.get = (name, mode = "full") => {
      const formats = mode === "fast" ? formats_1.fastFormats : formats_1.fullFormats;
      const f = formats[name];
      if (!f)
        throw new Error(`Unknown format "${name}"`);
      return f;
    };
    function addFormats(ajv, list, fs5, exportName) {
      var _a;
      var _b;
      (_a = (_b = ajv.opts.code).formats) !== null && _a !== void 0 ? _a : _b.formats = (0, codegen_1._)`require("ajv-formats/dist/formats").${exportName}`;
      for (const f of list)
        ajv.addFormat(f, fs5[f]);
    }
    module2.exports = exports2 = formatsPlugin;
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.default = formatsPlugin;
  }
});

// node_modules/fast-json-stringify/lib/validator.js
var require_validator2 = __commonJS({
  "node_modules/fast-json-stringify/lib/validator.js"(exports2, module2) {
    "use strict";
    var Ajv = require_ajv();
    var fastUri = require_fast_uri();
    var ajvFormats = require_dist2();
    var clone = require_rfdc()({ proto: true });
    var Validator = class _Validator {
      constructor(ajvOptions) {
        this.ajv = new Ajv({
          ...ajvOptions,
          strictSchema: false,
          validateSchema: false,
          allowUnionTypes: true,
          uriResolver: fastUri
        });
        ajvFormats(this.ajv);
        this.ajv.addKeyword({
          keyword: "fjs_type",
          type: "object",
          errors: false,
          validate: (_type, date) => {
            return date instanceof Date;
          }
        });
        this._ajvSchemas = {};
        this._ajvOptions = ajvOptions || {};
      }
      addSchema(schema, schemaName) {
        let schemaKey = schema.$id || schemaName;
        if (schema.$id !== void 0 && schema.$id[0] === "#") {
          schemaKey = schemaName + schema.$id;
        }
        if (this.ajv.refs[schemaKey] === void 0 && this.ajv.schemas[schemaKey] === void 0) {
          const ajvSchema = clone(schema);
          this.convertSchemaToAjvFormat(ajvSchema);
          this.ajv.addSchema(ajvSchema, schemaKey);
          this._ajvSchemas[schemaKey] = schema;
        }
      }
      validate(schemaRef, data) {
        return this.ajv.validate(schemaRef, data);
      }
      // Ajv does not support js date format. In order to properly validate objects containing a date,
      // it needs to replace all occurrences of the string date format with a custom keyword fjs_type.
      // (see https://github.com/fastify/fast-json-stringify/pull/441)
      convertSchemaToAjvFormat(schema) {
        if (schema === null) return;
        if (schema.type === "string") {
          schema.fjs_type = "string";
          schema.type = ["string", "object"];
        } else if (Array.isArray(schema.type) && schema.type.includes("string") && !schema.type.includes("object")) {
          schema.fjs_type = "string";
          schema.type.push("object");
        }
        for (const property in schema) {
          if (typeof schema[property] === "object") {
            this.convertSchemaToAjvFormat(schema[property]);
          }
        }
      }
      getState() {
        return {
          ajvOptions: this._ajvOptions,
          ajvSchemas: this._ajvSchemas
        };
      }
      static restoreFromState(state) {
        const validator = new _Validator(state.ajvOptions);
        for (const [id2, ajvSchema] of Object.entries(state.ajvSchemas)) {
          validator.ajv.addSchema(ajvSchema, id2);
        }
        return validator;
      }
    };
    module2.exports = Validator;
  }
});

// node_modules/fast-json-stringify/lib/location.js
var require_location = __commonJS({
  "node_modules/fast-json-stringify/lib/location.js"(exports2, module2) {
    "use strict";
    var Location = class _Location {
      constructor(schema, schemaId, jsonPointer = "#") {
        this.schema = schema;
        this.schemaId = schemaId;
        this.jsonPointer = jsonPointer;
      }
      getPropertyLocation(propertyName) {
        const propertyLocation = new _Location(
          this.schema[propertyName],
          this.schemaId,
          this.jsonPointer + "/" + propertyName
        );
        return propertyLocation;
      }
      getSchemaRef() {
        return this.schemaId + this.jsonPointer;
      }
    };
    module2.exports = Location;
  }
});

// node_modules/fast-json-stringify/lib/schema-validator.js
var require_schema_validator = __commonJS({
  "node_modules/fast-json-stringify/lib/schema-validator.js"(exports2, module2) {
    "use strict";
    module2.exports = validate10;
    module2.exports.default = validate10;
    var schema11 = { "$schema": "http://json-schema.org/draft-07/schema#", "$id": "http://json-schema.org/draft-07/schema#", "title": "Core schema meta-schema", "definitions": { "schemaArray": { "type": "array", "minItems": 1, "items": { "$ref": "#" } }, "nonNegativeInteger": { "type": "integer", "minimum": 0 }, "nonNegativeIntegerDefault0": { "allOf": [{ "$ref": "#/definitions/nonNegativeInteger" }, { "default": 0 }] }, "simpleTypes": { "enum": ["array", "boolean", "integer", "null", "number", "object", "string"] }, "stringArray": { "type": "array", "items": { "type": "string" }, "uniqueItems": true, "default": [] } }, "type": ["object", "boolean"], "properties": { "$id": { "type": "string", "format": "uri-reference" }, "$schema": { "type": "string", "format": "uri" }, "$ref": { "type": "string", "format": "uri-reference" }, "$comment": { "type": "string" }, "title": { "type": "string" }, "description": { "type": "string" }, "default": true, "readOnly": { "type": "boolean", "default": false }, "examples": { "type": "array", "items": true }, "multipleOf": { "type": "number", "exclusiveMinimum": 0 }, "maximum": { "type": "number" }, "exclusiveMaximum": { "type": "number" }, "minimum": { "type": "number" }, "exclusiveMinimum": { "type": "number" }, "maxLength": { "$ref": "#/definitions/nonNegativeInteger" }, "minLength": { "$ref": "#/definitions/nonNegativeIntegerDefault0" }, "pattern": { "type": "string", "format": "regex" }, "additionalItems": { "$ref": "#" }, "items": { "anyOf": [{ "$ref": "#" }, { "$ref": "#/definitions/schemaArray" }], "default": true }, "maxItems": { "$ref": "#/definitions/nonNegativeInteger" }, "minItems": { "$ref": "#/definitions/nonNegativeIntegerDefault0" }, "uniqueItems": { "type": "boolean", "default": false }, "contains": { "$ref": "#" }, "maxProperties": { "$ref": "#/definitions/nonNegativeInteger" }, "minProperties": { "$ref": "#/definitions/nonNegativeIntegerDefault0" }, "required": { "$ref": "#/definitions/stringArray" }, "additionalProperties": { "$ref": "#" }, "definitions": { "type": "object", "additionalProperties": { "$ref": "#" }, "default": {} }, "properties": { "type": "object", "additionalProperties": { "$ref": "#" }, "default": {} }, "patternProperties": { "type": "object", "additionalProperties": { "$ref": "#" }, "propertyNames": { "format": "regex" }, "default": {} }, "dependencies": { "type": "object", "additionalProperties": { "anyOf": [{ "$ref": "#" }, { "$ref": "#/definitions/stringArray" }] } }, "propertyNames": { "$ref": "#" }, "const": true, "enum": { "type": "array", "items": true, "minItems": 1, "uniqueItems": true }, "type": { "anyOf": [{ "$ref": "#/definitions/simpleTypes" }, { "type": "array", "items": { "$ref": "#/definitions/simpleTypes" }, "minItems": 1, "uniqueItems": true }] }, "format": { "type": "string" }, "contentMediaType": { "type": "string" }, "contentEncoding": { "type": "string" }, "if": { "$ref": "#" }, "then": { "$ref": "#" }, "else": { "$ref": "#" }, "allOf": { "$ref": "#/definitions/schemaArray" }, "anyOf": { "$ref": "#/definitions/schemaArray" }, "oneOf": { "$ref": "#/definitions/schemaArray" }, "not": { "$ref": "#" } }, "default": true };
    var schema20 = { "enum": ["array", "boolean", "integer", "null", "number", "object", "string"] };
    var formats0 = /^(?:[a-z][a-z0-9+\-.]*:)?(?:\/?\/(?:(?:[a-z0-9\-._~!$&'()*+,;=:]|%[0-9a-f]{2})*@)?(?:\[(?:(?:(?:(?:[0-9a-f]{1,4}:){6}|::(?:[0-9a-f]{1,4}:){5}|(?:[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){4}|(?:(?:[0-9a-f]{1,4}:){0,1}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){3}|(?:(?:[0-9a-f]{1,4}:){0,2}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){2}|(?:(?:[0-9a-f]{1,4}:){0,3}[0-9a-f]{1,4})?::[0-9a-f]{1,4}:|(?:(?:[0-9a-f]{1,4}:){0,4}[0-9a-f]{1,4})?::)(?:[0-9a-f]{1,4}:[0-9a-f]{1,4}|(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?))|(?:(?:[0-9a-f]{1,4}:){0,5}[0-9a-f]{1,4})?::[0-9a-f]{1,4}|(?:(?:[0-9a-f]{1,4}:){0,6}[0-9a-f]{1,4})?::)|[Vv][0-9a-f]+\.[a-z0-9\-._~!$&'()*+,;=:]+)\]|(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?)|(?:[a-z0-9\-._~!$&'"()*+,;=]|%[0-9a-f]{2})*)(?::\d*)?(?:\/(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})*)*|\/(?:(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})+(?:\/(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})*)*)?|(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})+(?:\/(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})*)*)?(?:\?(?:[a-z0-9\-._~!$&'"()*+,;=:@/?]|%[0-9a-f]{2})*)?(?:#(?:[a-z0-9\-._~!$&'"()*+,;=:@/?]|%[0-9a-f]{2})*)?$/i;
    var formats2 = require_formats().fullFormats.uri;
    var formats6 = require_formats().fullFormats.regex;
    function validate11(data, { instancePath = "", parentData, parentDataProperty, rootData = data } = {}) {
      let vErrors = null;
      let errors = 0;
      const _errs1 = errors;
      if (!(typeof data == "number" && (!(data % 1) && !isNaN(data)) && isFinite(data))) {
        validate11.errors = [{ instancePath, schemaPath: "#/definitions/nonNegativeInteger/type", keyword: "type", params: { type: "integer" }, message: "must be integer" }];
        return false;
      }
      if (errors === _errs1) {
        if (typeof data == "number" && isFinite(data)) {
          if (data < 0 || isNaN(data)) {
            validate11.errors = [{ instancePath, schemaPath: "#/definitions/nonNegativeInteger/minimum", keyword: "minimum", params: { comparison: ">=", limit: 0 }, message: "must be >= 0" }];
            return false;
          }
        }
      }
      validate11.errors = vErrors;
      return errors === 0;
    }
    var root1 = { validate: validate10 };
    function validate13(data, { instancePath = "", parentData, parentDataProperty, rootData = data } = {}) {
      let vErrors = null;
      let errors = 0;
      if (errors === 0) {
        if (Array.isArray(data)) {
          if (data.length < 1) {
            validate13.errors = [{ instancePath, schemaPath: "#/minItems", keyword: "minItems", params: { limit: 1 }, message: "must NOT have fewer than 1 items" }];
            return false;
          } else {
            var valid0 = true;
            const len0 = data.length;
            for (let i02 = 0; i02 < len0; i02++) {
              const _errs1 = errors;
              if (!root1.validate(data[i02], { instancePath: instancePath + "/" + i02, parentData: data, parentDataProperty: i02, rootData })) {
                vErrors = vErrors === null ? root1.validate.errors : vErrors.concat(root1.validate.errors);
                errors = vErrors.length;
              }
              var valid0 = _errs1 === errors;
              if (!valid0) {
                break;
              }
            }
          }
        } else {
          validate13.errors = [{ instancePath, schemaPath: "#/type", keyword: "type", params: { type: "array" }, message: "must be array" }];
          return false;
        }
      }
      validate13.errors = vErrors;
      return errors === 0;
    }
    var func0 = require_equal().default;
    function validate10(data, { instancePath = "", parentData, parentDataProperty, rootData = data } = {}) {
      ;
      let vErrors = null;
      let errors = 0;
      if (!(data && typeof data == "object" && !Array.isArray(data)) && typeof data !== "boolean") {
        validate10.errors = [{ instancePath, schemaPath: "#/type", keyword: "type", params: { type: schema11.type }, message: "must be object,boolean" }];
        return false;
      }
      if (errors === 0) {
        if (data && typeof data == "object" && !Array.isArray(data)) {
          if (data.$id !== void 0) {
            let data0 = data.$id;
            const _errs1 = errors;
            if (errors === _errs1) {
              if (errors === _errs1) {
                if (typeof data0 === "string") {
                  if (!formats0.test(data0)) {
                    validate10.errors = [{ instancePath: instancePath + "/$id", schemaPath: "#/properties/%24id/format", keyword: "format", params: { format: "uri-reference" }, message: 'must match format "uri-reference"' }];
                    return false;
                  }
                } else {
                  validate10.errors = [{ instancePath: instancePath + "/$id", schemaPath: "#/properties/%24id/type", keyword: "type", params: { type: "string" }, message: "must be string" }];
                  return false;
                }
              }
            }
            var valid0 = _errs1 === errors;
          } else {
            var valid0 = true;
          }
          if (valid0) {
            if (data.$schema !== void 0) {
              let data1 = data.$schema;
              const _errs3 = errors;
              if (errors === _errs3) {
                if (errors === _errs3) {
                  if (typeof data1 === "string") {
                    if (!formats2(data1)) {
                      validate10.errors = [{ instancePath: instancePath + "/$schema", schemaPath: "#/properties/%24schema/format", keyword: "format", params: { format: "uri" }, message: 'must match format "uri"' }];
                      return false;
                    }
                  } else {
                    validate10.errors = [{ instancePath: instancePath + "/$schema", schemaPath: "#/properties/%24schema/type", keyword: "type", params: { type: "string" }, message: "must be string" }];
                    return false;
                  }
                }
              }
              var valid0 = _errs3 === errors;
            } else {
              var valid0 = true;
            }
            if (valid0) {
              if (data.$ref !== void 0) {
                let data2 = data.$ref;
                const _errs5 = errors;
                if (errors === _errs5) {
                  if (errors === _errs5) {
                    if (typeof data2 === "string") {
                      if (!formats0.test(data2)) {
                        validate10.errors = [{ instancePath: instancePath + "/$ref", schemaPath: "#/properties/%24ref/format", keyword: "format", params: { format: "uri-reference" }, message: 'must match format "uri-reference"' }];
                        return false;
                      }
                    } else {
                      validate10.errors = [{ instancePath: instancePath + "/$ref", schemaPath: "#/properties/%24ref/type", keyword: "type", params: { type: "string" }, message: "must be string" }];
                      return false;
                    }
                  }
                }
                var valid0 = _errs5 === errors;
              } else {
                var valid0 = true;
              }
              if (valid0) {
                if (data.$comment !== void 0) {
                  const _errs7 = errors;
                  if (typeof data.$comment !== "string") {
                    validate10.errors = [{ instancePath: instancePath + "/$comment", schemaPath: "#/properties/%24comment/type", keyword: "type", params: { type: "string" }, message: "must be string" }];
                    return false;
                  }
                  var valid0 = _errs7 === errors;
                } else {
                  var valid0 = true;
                }
                if (valid0) {
                  if (data.title !== void 0) {
                    const _errs9 = errors;
                    if (typeof data.title !== "string") {
                      validate10.errors = [{ instancePath: instancePath + "/title", schemaPath: "#/properties/title/type", keyword: "type", params: { type: "string" }, message: "must be string" }];
                      return false;
                    }
                    var valid0 = _errs9 === errors;
                  } else {
                    var valid0 = true;
                  }
                  if (valid0) {
                    if (data.description !== void 0) {
                      const _errs11 = errors;
                      if (typeof data.description !== "string") {
                        validate10.errors = [{ instancePath: instancePath + "/description", schemaPath: "#/properties/description/type", keyword: "type", params: { type: "string" }, message: "must be string" }];
                        return false;
                      }
                      var valid0 = _errs11 === errors;
                    } else {
                      var valid0 = true;
                    }
                    if (valid0) {
                      if (data.readOnly !== void 0) {
                        const _errs13 = errors;
                        if (typeof data.readOnly !== "boolean") {
                          validate10.errors = [{ instancePath: instancePath + "/readOnly", schemaPath: "#/properties/readOnly/type", keyword: "type", params: { type: "boolean" }, message: "must be boolean" }];
                          return false;
                        }
                        var valid0 = _errs13 === errors;
                      } else {
                        var valid0 = true;
                      }
                      if (valid0) {
                        if (data.examples !== void 0) {
                          const _errs15 = errors;
                          if (errors === _errs15) {
                            if (!Array.isArray(data.examples)) {
                              validate10.errors = [{ instancePath: instancePath + "/examples", schemaPath: "#/properties/examples/type", keyword: "type", params: { type: "array" }, message: "must be array" }];
                              return false;
                            }
                          }
                          var valid0 = _errs15 === errors;
                        } else {
                          var valid0 = true;
                        }
                        if (valid0) {
                          if (data.multipleOf !== void 0) {
                            let data8 = data.multipleOf;
                            const _errs17 = errors;
                            if (errors === _errs17) {
                              if (typeof data8 == "number" && isFinite(data8)) {
                                if (data8 <= 0 || isNaN(data8)) {
                                  validate10.errors = [{ instancePath: instancePath + "/multipleOf", schemaPath: "#/properties/multipleOf/exclusiveMinimum", keyword: "exclusiveMinimum", params: { comparison: ">", limit: 0 }, message: "must be > 0" }];
                                  return false;
                                }
                              } else {
                                validate10.errors = [{ instancePath: instancePath + "/multipleOf", schemaPath: "#/properties/multipleOf/type", keyword: "type", params: { type: "number" }, message: "must be number" }];
                                return false;
                              }
                            }
                            var valid0 = _errs17 === errors;
                          } else {
                            var valid0 = true;
                          }
                          if (valid0) {
                            if (data.maximum !== void 0) {
                              let data9 = data.maximum;
                              const _errs19 = errors;
                              if (!(typeof data9 == "number" && isFinite(data9))) {
                                validate10.errors = [{ instancePath: instancePath + "/maximum", schemaPath: "#/properties/maximum/type", keyword: "type", params: { type: "number" }, message: "must be number" }];
                                return false;
                              }
                              var valid0 = _errs19 === errors;
                            } else {
                              var valid0 = true;
                            }
                            if (valid0) {
                              if (data.exclusiveMaximum !== void 0) {
                                let data10 = data.exclusiveMaximum;
                                const _errs21 = errors;
                                if (!(typeof data10 == "number" && isFinite(data10))) {
                                  validate10.errors = [{ instancePath: instancePath + "/exclusiveMaximum", schemaPath: "#/properties/exclusiveMaximum/type", keyword: "type", params: { type: "number" }, message: "must be number" }];
                                  return false;
                                }
                                var valid0 = _errs21 === errors;
                              } else {
                                var valid0 = true;
                              }
                              if (valid0) {
                                if (data.minimum !== void 0) {
                                  let data11 = data.minimum;
                                  const _errs23 = errors;
                                  if (!(typeof data11 == "number" && isFinite(data11))) {
                                    validate10.errors = [{ instancePath: instancePath + "/minimum", schemaPath: "#/properties/minimum/type", keyword: "type", params: { type: "number" }, message: "must be number" }];
                                    return false;
                                  }
                                  var valid0 = _errs23 === errors;
                                } else {
                                  var valid0 = true;
                                }
                                if (valid0) {
                                  if (data.exclusiveMinimum !== void 0) {
                                    let data12 = data.exclusiveMinimum;
                                    const _errs25 = errors;
                                    if (!(typeof data12 == "number" && isFinite(data12))) {
                                      validate10.errors = [{ instancePath: instancePath + "/exclusiveMinimum", schemaPath: "#/properties/exclusiveMinimum/type", keyword: "type", params: { type: "number" }, message: "must be number" }];
                                      return false;
                                    }
                                    var valid0 = _errs25 === errors;
                                  } else {
                                    var valid0 = true;
                                  }
                                  if (valid0) {
                                    if (data.maxLength !== void 0) {
                                      let data13 = data.maxLength;
                                      const _errs27 = errors;
                                      const _errs28 = errors;
                                      if (!(typeof data13 == "number" && (!(data13 % 1) && !isNaN(data13)) && isFinite(data13))) {
                                        validate10.errors = [{ instancePath: instancePath + "/maxLength", schemaPath: "#/definitions/nonNegativeInteger/type", keyword: "type", params: { type: "integer" }, message: "must be integer" }];
                                        return false;
                                      }
                                      if (errors === _errs28) {
                                        if (typeof data13 == "number" && isFinite(data13)) {
                                          if (data13 < 0 || isNaN(data13)) {
                                            validate10.errors = [{ instancePath: instancePath + "/maxLength", schemaPath: "#/definitions/nonNegativeInteger/minimum", keyword: "minimum", params: { comparison: ">=", limit: 0 }, message: "must be >= 0" }];
                                            return false;
                                          }
                                        }
                                      }
                                      var valid0 = _errs27 === errors;
                                    } else {
                                      var valid0 = true;
                                    }
                                    if (valid0) {
                                      if (data.minLength !== void 0) {
                                        const _errs30 = errors;
                                        if (!validate11(data.minLength, { instancePath: instancePath + "/minLength", parentData: data, parentDataProperty: "minLength", rootData })) {
                                          vErrors = vErrors === null ? validate11.errors : vErrors.concat(validate11.errors);
                                          errors = vErrors.length;
                                        }
                                        var valid0 = _errs30 === errors;
                                      } else {
                                        var valid0 = true;
                                      }
                                      if (valid0) {
                                        if (data.pattern !== void 0) {
                                          let data15 = data.pattern;
                                          const _errs31 = errors;
                                          if (errors === _errs31) {
                                            if (errors === _errs31) {
                                              if (typeof data15 === "string") {
                                                if (!formats6(data15)) {
                                                  validate10.errors = [{ instancePath: instancePath + "/pattern", schemaPath: "#/properties/pattern/format", keyword: "format", params: { format: "regex" }, message: 'must match format "regex"' }];
                                                  return false;
                                                }
                                              } else {
                                                validate10.errors = [{ instancePath: instancePath + "/pattern", schemaPath: "#/properties/pattern/type", keyword: "type", params: { type: "string" }, message: "must be string" }];
                                                return false;
                                              }
                                            }
                                          }
                                          var valid0 = _errs31 === errors;
                                        } else {
                                          var valid0 = true;
                                        }
                                        if (valid0) {
                                          if (data.additionalItems !== void 0) {
                                            const _errs33 = errors;
                                            if (!validate10(data.additionalItems, { instancePath: instancePath + "/additionalItems", parentData: data, parentDataProperty: "additionalItems", rootData })) {
                                              vErrors = vErrors === null ? validate10.errors : vErrors.concat(validate10.errors);
                                              errors = vErrors.length;
                                            }
                                            var valid0 = _errs33 === errors;
                                          } else {
                                            var valid0 = true;
                                          }
                                          if (valid0) {
                                            if (data.items !== void 0) {
                                              let data17 = data.items;
                                              const _errs34 = errors;
                                              const _errs35 = errors;
                                              let valid2 = false;
                                              const _errs36 = errors;
                                              if (!validate10(data17, { instancePath: instancePath + "/items", parentData: data, parentDataProperty: "items", rootData })) {
                                                vErrors = vErrors === null ? validate10.errors : vErrors.concat(validate10.errors);
                                                errors = vErrors.length;
                                              }
                                              var _valid0 = _errs36 === errors;
                                              valid2 = valid2 || _valid0;
                                              if (!valid2) {
                                                const _errs37 = errors;
                                                if (!validate13(data17, { instancePath: instancePath + "/items", parentData: data, parentDataProperty: "items", rootData })) {
                                                  vErrors = vErrors === null ? validate13.errors : vErrors.concat(validate13.errors);
                                                  errors = vErrors.length;
                                                }
                                                var _valid0 = _errs37 === errors;
                                                valid2 = valid2 || _valid0;
                                              }
                                              if (!valid2) {
                                                const err0 = { instancePath: instancePath + "/items", schemaPath: "#/properties/items/anyOf", keyword: "anyOf", params: {}, message: "must match a schema in anyOf" };
                                                if (vErrors === null) {
                                                  vErrors = [err0];
                                                } else {
                                                  vErrors.push(err0);
                                                }
                                                errors++;
                                                validate10.errors = vErrors;
                                                return false;
                                              } else {
                                                errors = _errs35;
                                                if (vErrors !== null) {
                                                  if (_errs35) {
                                                    vErrors.length = _errs35;
                                                  } else {
                                                    vErrors = null;
                                                  }
                                                }
                                              }
                                              var valid0 = _errs34 === errors;
                                            } else {
                                              var valid0 = true;
                                            }
                                            if (valid0) {
                                              if (data.maxItems !== void 0) {
                                                let data18 = data.maxItems;
                                                const _errs38 = errors;
                                                const _errs39 = errors;
                                                if (!(typeof data18 == "number" && (!(data18 % 1) && !isNaN(data18)) && isFinite(data18))) {
                                                  validate10.errors = [{ instancePath: instancePath + "/maxItems", schemaPath: "#/definitions/nonNegativeInteger/type", keyword: "type", params: { type: "integer" }, message: "must be integer" }];
                                                  return false;
                                                }
                                                if (errors === _errs39) {
                                                  if (typeof data18 == "number" && isFinite(data18)) {
                                                    if (data18 < 0 || isNaN(data18)) {
                                                      validate10.errors = [{ instancePath: instancePath + "/maxItems", schemaPath: "#/definitions/nonNegativeInteger/minimum", keyword: "minimum", params: { comparison: ">=", limit: 0 }, message: "must be >= 0" }];
                                                      return false;
                                                    }
                                                  }
                                                }
                                                var valid0 = _errs38 === errors;
                                              } else {
                                                var valid0 = true;
                                              }
                                              if (valid0) {
                                                if (data.minItems !== void 0) {
                                                  const _errs41 = errors;
                                                  if (!validate11(data.minItems, { instancePath: instancePath + "/minItems", parentData: data, parentDataProperty: "minItems", rootData })) {
                                                    vErrors = vErrors === null ? validate11.errors : vErrors.concat(validate11.errors);
                                                    errors = vErrors.length;
                                                  }
                                                  var valid0 = _errs41 === errors;
                                                } else {
                                                  var valid0 = true;
                                                }
                                                if (valid0) {
                                                  if (data.uniqueItems !== void 0) {
                                                    const _errs42 = errors;
                                                    if (typeof data.uniqueItems !== "boolean") {
                                                      validate10.errors = [{ instancePath: instancePath + "/uniqueItems", schemaPath: "#/properties/uniqueItems/type", keyword: "type", params: { type: "boolean" }, message: "must be boolean" }];
                                                      return false;
                                                    }
                                                    var valid0 = _errs42 === errors;
                                                  } else {
                                                    var valid0 = true;
                                                  }
                                                  if (valid0) {
                                                    if (data.contains !== void 0) {
                                                      const _errs44 = errors;
                                                      if (!validate10(data.contains, { instancePath: instancePath + "/contains", parentData: data, parentDataProperty: "contains", rootData })) {
                                                        vErrors = vErrors === null ? validate10.errors : vErrors.concat(validate10.errors);
                                                        errors = vErrors.length;
                                                      }
                                                      var valid0 = _errs44 === errors;
                                                    } else {
                                                      var valid0 = true;
                                                    }
                                                    if (valid0) {
                                                      if (data.maxProperties !== void 0) {
                                                        let data22 = data.maxProperties;
                                                        const _errs45 = errors;
                                                        const _errs46 = errors;
                                                        if (!(typeof data22 == "number" && (!(data22 % 1) && !isNaN(data22)) && isFinite(data22))) {
                                                          validate10.errors = [{ instancePath: instancePath + "/maxProperties", schemaPath: "#/definitions/nonNegativeInteger/type", keyword: "type", params: { type: "integer" }, message: "must be integer" }];
                                                          return false;
                                                        }
                                                        if (errors === _errs46) {
                                                          if (typeof data22 == "number" && isFinite(data22)) {
                                                            if (data22 < 0 || isNaN(data22)) {
                                                              validate10.errors = [{ instancePath: instancePath + "/maxProperties", schemaPath: "#/definitions/nonNegativeInteger/minimum", keyword: "minimum", params: { comparison: ">=", limit: 0 }, message: "must be >= 0" }];
                                                              return false;
                                                            }
                                                          }
                                                        }
                                                        var valid0 = _errs45 === errors;
                                                      } else {
                                                        var valid0 = true;
                                                      }
                                                      if (valid0) {
                                                        if (data.minProperties !== void 0) {
                                                          const _errs48 = errors;
                                                          if (!validate11(data.minProperties, { instancePath: instancePath + "/minProperties", parentData: data, parentDataProperty: "minProperties", rootData })) {
                                                            vErrors = vErrors === null ? validate11.errors : vErrors.concat(validate11.errors);
                                                            errors = vErrors.length;
                                                          }
                                                          var valid0 = _errs48 === errors;
                                                        } else {
                                                          var valid0 = true;
                                                        }
                                                        if (valid0) {
                                                          if (data.required !== void 0) {
                                                            let data24 = data.required;
                                                            const _errs49 = errors;
                                                            const _errs50 = errors;
                                                            if (errors === _errs50) {
                                                              if (Array.isArray(data24)) {
                                                                var valid6 = true;
                                                                const len0 = data24.length;
                                                                for (let i02 = 0; i02 < len0; i02++) {
                                                                  const _errs52 = errors;
                                                                  if (typeof data24[i02] !== "string") {
                                                                    validate10.errors = [{ instancePath: instancePath + "/required/" + i02, schemaPath: "#/definitions/stringArray/items/type", keyword: "type", params: { type: "string" }, message: "must be string" }];
                                                                    return false;
                                                                  }
                                                                  var valid6 = _errs52 === errors;
                                                                  if (!valid6) {
                                                                    break;
                                                                  }
                                                                }
                                                                if (valid6) {
                                                                  let i1 = data24.length;
                                                                  let j0;
                                                                  if (i1 > 1) {
                                                                    const indices0 = {};
                                                                    for (; i1--; ) {
                                                                      let item0 = data24[i1];
                                                                      if (typeof item0 !== "string") {
                                                                        continue;
                                                                      }
                                                                      if (typeof indices0[item0] == "number") {
                                                                        j0 = indices0[item0];
                                                                        validate10.errors = [{ instancePath: instancePath + "/required", schemaPath: "#/definitions/stringArray/uniqueItems", keyword: "uniqueItems", params: { i: i1, j: j0 }, message: "must NOT have duplicate items (items ## " + j0 + " and " + i1 + " are identical)" }];
                                                                        return false;
                                                                        break;
                                                                      }
                                                                      indices0[item0] = i1;
                                                                    }
                                                                  }
                                                                }
                                                              } else {
                                                                validate10.errors = [{ instancePath: instancePath + "/required", schemaPath: "#/definitions/stringArray/type", keyword: "type", params: { type: "array" }, message: "must be array" }];
                                                                return false;
                                                              }
                                                            }
                                                            var valid0 = _errs49 === errors;
                                                          } else {
                                                            var valid0 = true;
                                                          }
                                                          if (valid0) {
                                                            if (data.additionalProperties !== void 0) {
                                                              const _errs54 = errors;
                                                              if (!validate10(data.additionalProperties, { instancePath: instancePath + "/additionalProperties", parentData: data, parentDataProperty: "additionalProperties", rootData })) {
                                                                vErrors = vErrors === null ? validate10.errors : vErrors.concat(validate10.errors);
                                                                errors = vErrors.length;
                                                              }
                                                              var valid0 = _errs54 === errors;
                                                            } else {
                                                              var valid0 = true;
                                                            }
                                                            if (valid0) {
                                                              if (data.definitions !== void 0) {
                                                                let data27 = data.definitions;
                                                                const _errs55 = errors;
                                                                if (errors === _errs55) {
                                                                  if (data27 && typeof data27 == "object" && !Array.isArray(data27)) {
                                                                    for (const key0 in data27) {
                                                                      const _errs58 = errors;
                                                                      if (!validate10(data27[key0], { instancePath: instancePath + "/definitions/" + key0.replace(/~/g, "~0").replace(/\//g, "~1"), parentData: data27, parentDataProperty: key0, rootData })) {
                                                                        vErrors = vErrors === null ? validate10.errors : vErrors.concat(validate10.errors);
                                                                        errors = vErrors.length;
                                                                      }
                                                                      var valid8 = _errs58 === errors;
                                                                      if (!valid8) {
                                                                        break;
                                                                      }
                                                                    }
                                                                  } else {
                                                                    validate10.errors = [{ instancePath: instancePath + "/definitions", schemaPath: "#/properties/definitions/type", keyword: "type", params: { type: "object" }, message: "must be object" }];
                                                                    return false;
                                                                  }
                                                                }
                                                                var valid0 = _errs55 === errors;
                                                              } else {
                                                                var valid0 = true;
                                                              }
                                                              if (valid0) {
                                                                if (data.properties !== void 0) {
                                                                  let data29 = data.properties;
                                                                  const _errs59 = errors;
                                                                  if (errors === _errs59) {
                                                                    if (data29 && typeof data29 == "object" && !Array.isArray(data29)) {
                                                                      for (const key1 in data29) {
                                                                        const _errs62 = errors;
                                                                        if (!validate10(data29[key1], { instancePath: instancePath + "/properties/" + key1.replace(/~/g, "~0").replace(/\//g, "~1"), parentData: data29, parentDataProperty: key1, rootData })) {
                                                                          vErrors = vErrors === null ? validate10.errors : vErrors.concat(validate10.errors);
                                                                          errors = vErrors.length;
                                                                        }
                                                                        var valid9 = _errs62 === errors;
                                                                        if (!valid9) {
                                                                          break;
                                                                        }
                                                                      }
                                                                    } else {
                                                                      validate10.errors = [{ instancePath: instancePath + "/properties", schemaPath: "#/properties/properties/type", keyword: "type", params: { type: "object" }, message: "must be object" }];
                                                                      return false;
                                                                    }
                                                                  }
                                                                  var valid0 = _errs59 === errors;
                                                                } else {
                                                                  var valid0 = true;
                                                                }
                                                                if (valid0) {
                                                                  if (data.patternProperties !== void 0) {
                                                                    let data31 = data.patternProperties;
                                                                    const _errs63 = errors;
                                                                    if (errors === _errs63) {
                                                                      if (data31 && typeof data31 == "object" && !Array.isArray(data31)) {
                                                                        for (const key2 in data31) {
                                                                          const _errs65 = errors;
                                                                          if (errors === _errs65) {
                                                                            if (typeof key2 === "string") {
                                                                              if (!formats6(key2)) {
                                                                                const err1 = { instancePath: instancePath + "/patternProperties", schemaPath: "#/properties/patternProperties/propertyNames/format", keyword: "format", params: { format: "regex" }, message: 'must match format "regex"', propertyName: key2 };
                                                                                if (vErrors === null) {
                                                                                  vErrors = [err1];
                                                                                } else {
                                                                                  vErrors.push(err1);
                                                                                }
                                                                                errors++;
                                                                              }
                                                                            }
                                                                          }
                                                                          var valid10 = _errs65 === errors;
                                                                          if (!valid10) {
                                                                            const err2 = { instancePath: instancePath + "/patternProperties", schemaPath: "#/properties/patternProperties/propertyNames", keyword: "propertyNames", params: { propertyName: key2 }, message: "property name must be valid" };
                                                                            if (vErrors === null) {
                                                                              vErrors = [err2];
                                                                            } else {
                                                                              vErrors.push(err2);
                                                                            }
                                                                            errors++;
                                                                            validate10.errors = vErrors;
                                                                            return false;
                                                                            break;
                                                                          }
                                                                        }
                                                                        if (valid10) {
                                                                          for (const key3 in data31) {
                                                                            const _errs67 = errors;
                                                                            if (!validate10(data31[key3], { instancePath: instancePath + "/patternProperties/" + key3.replace(/~/g, "~0").replace(/\//g, "~1"), parentData: data31, parentDataProperty: key3, rootData })) {
                                                                              vErrors = vErrors === null ? validate10.errors : vErrors.concat(validate10.errors);
                                                                              errors = vErrors.length;
                                                                            }
                                                                            var valid11 = _errs67 === errors;
                                                                            if (!valid11) {
                                                                              break;
                                                                            }
                                                                          }
                                                                        }
                                                                      } else {
                                                                        validate10.errors = [{ instancePath: instancePath + "/patternProperties", schemaPath: "#/properties/patternProperties/type", keyword: "type", params: { type: "object" }, message: "must be object" }];
                                                                        return false;
                                                                      }
                                                                    }
                                                                    var valid0 = _errs63 === errors;
                                                                  } else {
                                                                    var valid0 = true;
                                                                  }
                                                                  if (valid0) {
                                                                    if (data.dependencies !== void 0) {
                                                                      let data33 = data.dependencies;
                                                                      const _errs68 = errors;
                                                                      if (errors === _errs68) {
                                                                        if (data33 && typeof data33 == "object" && !Array.isArray(data33)) {
                                                                          for (const key4 in data33) {
                                                                            let data34 = data33[key4];
                                                                            const _errs71 = errors;
                                                                            const _errs72 = errors;
                                                                            let valid13 = false;
                                                                            const _errs73 = errors;
                                                                            if (!validate10(data34, { instancePath: instancePath + "/dependencies/" + key4.replace(/~/g, "~0").replace(/\//g, "~1"), parentData: data33, parentDataProperty: key4, rootData })) {
                                                                              vErrors = vErrors === null ? validate10.errors : vErrors.concat(validate10.errors);
                                                                              errors = vErrors.length;
                                                                            }
                                                                            var _valid1 = _errs73 === errors;
                                                                            valid13 = valid13 || _valid1;
                                                                            if (!valid13) {
                                                                              const _errs74 = errors;
                                                                              const _errs75 = errors;
                                                                              if (errors === _errs75) {
                                                                                if (Array.isArray(data34)) {
                                                                                  var valid15 = true;
                                                                                  const len1 = data34.length;
                                                                                  for (let i2 = 0; i2 < len1; i2++) {
                                                                                    const _errs77 = errors;
                                                                                    if (typeof data34[i2] !== "string") {
                                                                                      const err3 = { instancePath: instancePath + "/dependencies/" + key4.replace(/~/g, "~0").replace(/\//g, "~1") + "/" + i2, schemaPath: "#/definitions/stringArray/items/type", keyword: "type", params: { type: "string" }, message: "must be string" };
                                                                                      if (vErrors === null) {
                                                                                        vErrors = [err3];
                                                                                      } else {
                                                                                        vErrors.push(err3);
                                                                                      }
                                                                                      errors++;
                                                                                    }
                                                                                    var valid15 = _errs77 === errors;
                                                                                    if (!valid15) {
                                                                                      break;
                                                                                    }
                                                                                  }
                                                                                  if (valid15) {
                                                                                    let i3 = data34.length;
                                                                                    let j1;
                                                                                    if (i3 > 1) {
                                                                                      const indices1 = {};
                                                                                      for (; i3--; ) {
                                                                                        let item1 = data34[i3];
                                                                                        if (typeof item1 !== "string") {
                                                                                          continue;
                                                                                        }
                                                                                        if (typeof indices1[item1] == "number") {
                                                                                          j1 = indices1[item1];
                                                                                          const err4 = { instancePath: instancePath + "/dependencies/" + key4.replace(/~/g, "~0").replace(/\//g, "~1"), schemaPath: "#/definitions/stringArray/uniqueItems", keyword: "uniqueItems", params: { i: i3, j: j1 }, message: "must NOT have duplicate items (items ## " + j1 + " and " + i3 + " are identical)" };
                                                                                          if (vErrors === null) {
                                                                                            vErrors = [err4];
                                                                                          } else {
                                                                                            vErrors.push(err4);
                                                                                          }
                                                                                          errors++;
                                                                                          break;
                                                                                        }
                                                                                        indices1[item1] = i3;
                                                                                      }
                                                                                    }
                                                                                  }
                                                                                } else {
                                                                                  const err5 = { instancePath: instancePath + "/dependencies/" + key4.replace(/~/g, "~0").replace(/\//g, "~1"), schemaPath: "#/definitions/stringArray/type", keyword: "type", params: { type: "array" }, message: "must be array" };
                                                                                  if (vErrors === null) {
                                                                                    vErrors = [err5];
                                                                                  } else {
                                                                                    vErrors.push(err5);
                                                                                  }
                                                                                  errors++;
                                                                                }
                                                                              }
                                                                              var _valid1 = _errs74 === errors;
                                                                              valid13 = valid13 || _valid1;
                                                                            }
                                                                            if (!valid13) {
                                                                              const err6 = { instancePath: instancePath + "/dependencies/" + key4.replace(/~/g, "~0").replace(/\//g, "~1"), schemaPath: "#/properties/dependencies/additionalProperties/anyOf", keyword: "anyOf", params: {}, message: "must match a schema in anyOf" };
                                                                              if (vErrors === null) {
                                                                                vErrors = [err6];
                                                                              } else {
                                                                                vErrors.push(err6);
                                                                              }
                                                                              errors++;
                                                                              validate10.errors = vErrors;
                                                                              return false;
                                                                            } else {
                                                                              errors = _errs72;
                                                                              if (vErrors !== null) {
                                                                                if (_errs72) {
                                                                                  vErrors.length = _errs72;
                                                                                } else {
                                                                                  vErrors = null;
                                                                                }
                                                                              }
                                                                            }
                                                                            var valid12 = _errs71 === errors;
                                                                            if (!valid12) {
                                                                              break;
                                                                            }
                                                                          }
                                                                        } else {
                                                                          validate10.errors = [{ instancePath: instancePath + "/dependencies", schemaPath: "#/properties/dependencies/type", keyword: "type", params: { type: "object" }, message: "must be object" }];
                                                                          return false;
                                                                        }
                                                                      }
                                                                      var valid0 = _errs68 === errors;
                                                                    } else {
                                                                      var valid0 = true;
                                                                    }
                                                                    if (valid0) {
                                                                      if (data.propertyNames !== void 0) {
                                                                        const _errs79 = errors;
                                                                        if (!validate10(data.propertyNames, { instancePath: instancePath + "/propertyNames", parentData: data, parentDataProperty: "propertyNames", rootData })) {
                                                                          vErrors = vErrors === null ? validate10.errors : vErrors.concat(validate10.errors);
                                                                          errors = vErrors.length;
                                                                        }
                                                                        var valid0 = _errs79 === errors;
                                                                      } else {
                                                                        var valid0 = true;
                                                                      }
                                                                      if (valid0) {
                                                                        if (data.enum !== void 0) {
                                                                          let data37 = data.enum;
                                                                          const _errs80 = errors;
                                                                          if (errors === _errs80) {
                                                                            if (Array.isArray(data37)) {
                                                                              if (data37.length < 1) {
                                                                                validate10.errors = [{ instancePath: instancePath + "/enum", schemaPath: "#/properties/enum/minItems", keyword: "minItems", params: { limit: 1 }, message: "must NOT have fewer than 1 items" }];
                                                                                return false;
                                                                              } else {
                                                                                let i4 = data37.length;
                                                                                let j2;
                                                                                if (i4 > 1) {
                                                                                  outer0:
                                                                                    for (; i4--; ) {
                                                                                      for (j2 = i4; j2--; ) {
                                                                                        if (func0(data37[i4], data37[j2])) {
                                                                                          validate10.errors = [{ instancePath: instancePath + "/enum", schemaPath: "#/properties/enum/uniqueItems", keyword: "uniqueItems", params: { i: i4, j: j2 }, message: "must NOT have duplicate items (items ## " + j2 + " and " + i4 + " are identical)" }];
                                                                                          return false;
                                                                                          break outer0;
                                                                                        }
                                                                                      }
                                                                                    }
                                                                                }
                                                                              }
                                                                            } else {
                                                                              validate10.errors = [{ instancePath: instancePath + "/enum", schemaPath: "#/properties/enum/type", keyword: "type", params: { type: "array" }, message: "must be array" }];
                                                                              return false;
                                                                            }
                                                                          }
                                                                          var valid0 = _errs80 === errors;
                                                                        } else {
                                                                          var valid0 = true;
                                                                        }
                                                                        if (valid0) {
                                                                          if (data.type !== void 0) {
                                                                            let data38 = data.type;
                                                                            const _errs82 = errors;
                                                                            const _errs83 = errors;
                                                                            let valid18 = false;
                                                                            const _errs84 = errors;
                                                                            if (!(data38 === "array" || data38 === "boolean" || data38 === "integer" || data38 === "null" || data38 === "number" || data38 === "object" || data38 === "string")) {
                                                                              const err7 = { instancePath: instancePath + "/type", schemaPath: "#/definitions/simpleTypes/enum", keyword: "enum", params: { allowedValues: schema20.enum }, message: "must be equal to one of the allowed values" };
                                                                              if (vErrors === null) {
                                                                                vErrors = [err7];
                                                                              } else {
                                                                                vErrors.push(err7);
                                                                              }
                                                                              errors++;
                                                                            }
                                                                            var _valid2 = _errs84 === errors;
                                                                            valid18 = valid18 || _valid2;
                                                                            if (!valid18) {
                                                                              const _errs86 = errors;
                                                                              if (errors === _errs86) {
                                                                                if (Array.isArray(data38)) {
                                                                                  if (data38.length < 1) {
                                                                                    const err8 = { instancePath: instancePath + "/type", schemaPath: "#/properties/type/anyOf/1/minItems", keyword: "minItems", params: { limit: 1 }, message: "must NOT have fewer than 1 items" };
                                                                                    if (vErrors === null) {
                                                                                      vErrors = [err8];
                                                                                    } else {
                                                                                      vErrors.push(err8);
                                                                                    }
                                                                                    errors++;
                                                                                  } else {
                                                                                    var valid20 = true;
                                                                                    const len2 = data38.length;
                                                                                    for (let i5 = 0; i5 < len2; i5++) {
                                                                                      let data39 = data38[i5];
                                                                                      const _errs88 = errors;
                                                                                      if (!(data39 === "array" || data39 === "boolean" || data39 === "integer" || data39 === "null" || data39 === "number" || data39 === "object" || data39 === "string")) {
                                                                                        const err9 = { instancePath: instancePath + "/type/" + i5, schemaPath: "#/definitions/simpleTypes/enum", keyword: "enum", params: { allowedValues: schema20.enum }, message: "must be equal to one of the allowed values" };
                                                                                        if (vErrors === null) {
                                                                                          vErrors = [err9];
                                                                                        } else {
                                                                                          vErrors.push(err9);
                                                                                        }
                                                                                        errors++;
                                                                                      }
                                                                                      var valid20 = _errs88 === errors;
                                                                                      if (!valid20) {
                                                                                        break;
                                                                                      }
                                                                                    }
                                                                                    if (valid20) {
                                                                                      let i6 = data38.length;
                                                                                      let j3;
                                                                                      if (i6 > 1) {
                                                                                        outer1:
                                                                                          for (; i6--; ) {
                                                                                            for (j3 = i6; j3--; ) {
                                                                                              if (func0(data38[i6], data38[j3])) {
                                                                                                const err10 = { instancePath: instancePath + "/type", schemaPath: "#/properties/type/anyOf/1/uniqueItems", keyword: "uniqueItems", params: { i: i6, j: j3 }, message: "must NOT have duplicate items (items ## " + j3 + " and " + i6 + " are identical)" };
                                                                                                if (vErrors === null) {
                                                                                                  vErrors = [err10];
                                                                                                } else {
                                                                                                  vErrors.push(err10);
                                                                                                }
                                                                                                errors++;
                                                                                                break outer1;
                                                                                              }
                                                                                            }
                                                                                          }
                                                                                      }
                                                                                    }
                                                                                  }
                                                                                } else {
                                                                                  const err11 = { instancePath: instancePath + "/type", schemaPath: "#/properties/type/anyOf/1/type", keyword: "type", params: { type: "array" }, message: "must be array" };
                                                                                  if (vErrors === null) {
                                                                                    vErrors = [err11];
                                                                                  } else {
                                                                                    vErrors.push(err11);
                                                                                  }
                                                                                  errors++;
                                                                                }
                                                                              }
                                                                              var _valid2 = _errs86 === errors;
                                                                              valid18 = valid18 || _valid2;
                                                                            }
                                                                            if (!valid18) {
                                                                              const err12 = { instancePath: instancePath + "/type", schemaPath: "#/properties/type/anyOf", keyword: "anyOf", params: {}, message: "must match a schema in anyOf" };
                                                                              if (vErrors === null) {
                                                                                vErrors = [err12];
                                                                              } else {
                                                                                vErrors.push(err12);
                                                                              }
                                                                              errors++;
                                                                              validate10.errors = vErrors;
                                                                              return false;
                                                                            } else {
                                                                              errors = _errs83;
                                                                              if (vErrors !== null) {
                                                                                if (_errs83) {
                                                                                  vErrors.length = _errs83;
                                                                                } else {
                                                                                  vErrors = null;
                                                                                }
                                                                              }
                                                                            }
                                                                            var valid0 = _errs82 === errors;
                                                                          } else {
                                                                            var valid0 = true;
                                                                          }
                                                                          if (valid0) {
                                                                            if (data.format !== void 0) {
                                                                              const _errs90 = errors;
                                                                              if (typeof data.format !== "string") {
                                                                                validate10.errors = [{ instancePath: instancePath + "/format", schemaPath: "#/properties/format/type", keyword: "type", params: { type: "string" }, message: "must be string" }];
                                                                                return false;
                                                                              }
                                                                              var valid0 = _errs90 === errors;
                                                                            } else {
                                                                              var valid0 = true;
                                                                            }
                                                                            if (valid0) {
                                                                              if (data.contentMediaType !== void 0) {
                                                                                const _errs92 = errors;
                                                                                if (typeof data.contentMediaType !== "string") {
                                                                                  validate10.errors = [{ instancePath: instancePath + "/contentMediaType", schemaPath: "#/properties/contentMediaType/type", keyword: "type", params: { type: "string" }, message: "must be string" }];
                                                                                  return false;
                                                                                }
                                                                                var valid0 = _errs92 === errors;
                                                                              } else {
                                                                                var valid0 = true;
                                                                              }
                                                                              if (valid0) {
                                                                                if (data.contentEncoding !== void 0) {
                                                                                  const _errs94 = errors;
                                                                                  if (typeof data.contentEncoding !== "string") {
                                                                                    validate10.errors = [{ instancePath: instancePath + "/contentEncoding", schemaPath: "#/properties/contentEncoding/type", keyword: "type", params: { type: "string" }, message: "must be string" }];
                                                                                    return false;
                                                                                  }
                                                                                  var valid0 = _errs94 === errors;
                                                                                } else {
                                                                                  var valid0 = true;
                                                                                }
                                                                                if (valid0) {
                                                                                  if (data.if !== void 0) {
                                                                                    const _errs96 = errors;
                                                                                    if (!validate10(data.if, { instancePath: instancePath + "/if", parentData: data, parentDataProperty: "if", rootData })) {
                                                                                      vErrors = vErrors === null ? validate10.errors : vErrors.concat(validate10.errors);
                                                                                      errors = vErrors.length;
                                                                                    }
                                                                                    var valid0 = _errs96 === errors;
                                                                                  } else {
                                                                                    var valid0 = true;
                                                                                  }
                                                                                  if (valid0) {
                                                                                    if (data.then !== void 0) {
                                                                                      const _errs97 = errors;
                                                                                      if (!validate10(data.then, { instancePath: instancePath + "/then", parentData: data, parentDataProperty: "then", rootData })) {
                                                                                        vErrors = vErrors === null ? validate10.errors : vErrors.concat(validate10.errors);
                                                                                        errors = vErrors.length;
                                                                                      }
                                                                                      var valid0 = _errs97 === errors;
                                                                                    } else {
                                                                                      var valid0 = true;
                                                                                    }
                                                                                    if (valid0) {
                                                                                      if (data.else !== void 0) {
                                                                                        const _errs98 = errors;
                                                                                        if (!validate10(data.else, { instancePath: instancePath + "/else", parentData: data, parentDataProperty: "else", rootData })) {
                                                                                          vErrors = vErrors === null ? validate10.errors : vErrors.concat(validate10.errors);
                                                                                          errors = vErrors.length;
                                                                                        }
                                                                                        var valid0 = _errs98 === errors;
                                                                                      } else {
                                                                                        var valid0 = true;
                                                                                      }
                                                                                      if (valid0) {
                                                                                        if (data.allOf !== void 0) {
                                                                                          const _errs99 = errors;
                                                                                          if (!validate13(data.allOf, { instancePath: instancePath + "/allOf", parentData: data, parentDataProperty: "allOf", rootData })) {
                                                                                            vErrors = vErrors === null ? validate13.errors : vErrors.concat(validate13.errors);
                                                                                            errors = vErrors.length;
                                                                                          }
                                                                                          var valid0 = _errs99 === errors;
                                                                                        } else {
                                                                                          var valid0 = true;
                                                                                        }
                                                                                        if (valid0) {
                                                                                          if (data.anyOf !== void 0) {
                                                                                            const _errs100 = errors;
                                                                                            if (!validate13(data.anyOf, { instancePath: instancePath + "/anyOf", parentData: data, parentDataProperty: "anyOf", rootData })) {
                                                                                              vErrors = vErrors === null ? validate13.errors : vErrors.concat(validate13.errors);
                                                                                              errors = vErrors.length;
                                                                                            }
                                                                                            var valid0 = _errs100 === errors;
                                                                                          } else {
                                                                                            var valid0 = true;
                                                                                          }
                                                                                          if (valid0) {
                                                                                            if (data.oneOf !== void 0) {
                                                                                              const _errs101 = errors;
                                                                                              if (!validate13(data.oneOf, { instancePath: instancePath + "/oneOf", parentData: data, parentDataProperty: "oneOf", rootData })) {
                                                                                                vErrors = vErrors === null ? validate13.errors : vErrors.concat(validate13.errors);
                                                                                                errors = vErrors.length;
                                                                                              }
                                                                                              var valid0 = _errs101 === errors;
                                                                                            } else {
                                                                                              var valid0 = true;
                                                                                            }
                                                                                            if (valid0) {
                                                                                              if (data.not !== void 0) {
                                                                                                const _errs102 = errors;
                                                                                                if (!validate10(data.not, { instancePath: instancePath + "/not", parentData: data, parentDataProperty: "not", rootData })) {
                                                                                                  vErrors = vErrors === null ? validate10.errors : vErrors.concat(validate10.errors);
                                                                                                  errors = vErrors.length;
                                                                                                }
                                                                                                var valid0 = _errs102 === errors;
                                                                                              } else {
                                                                                                var valid0 = true;
                                                                                              }
                                                                                            }
                                                                                          }
                                                                                        }
                                                                                      }
                                                                                    }
                                                                                  }
                                                                                }
                                                                              }
                                                                            }
                                                                          }
                                                                        }
                                                                      }
                                                                    }
                                                                  }
                                                                }
                                                              }
                                                            }
                                                          }
                                                        }
                                                      }
                                                    }
                                                  }
                                                }
                                              }
                                            }
                                          }
                                        }
                                      }
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
      validate10.errors = vErrors;
      return errors === 0;
    }
  }
});

// node_modules/@fastify/merge-json-schemas/lib/errors.js
var require_errors4 = __commonJS({
  "node_modules/@fastify/merge-json-schemas/lib/errors.js"(exports2, module2) {
    "use strict";
    var MergeError = class extends Error {
      constructor(keyword, schemas) {
        super();
        this.name = "JsonSchemaMergeError";
        this.code = "JSON_SCHEMA_MERGE_ERROR";
        this.message = `Failed to merge "${keyword}" keyword schemas.`;
        this.schemas = schemas;
      }
    };
    var ResolverNotFoundError = class extends Error {
      constructor(keyword, schemas) {
        super();
        this.name = "JsonSchemaMergeError";
        this.code = "JSON_SCHEMA_MERGE_ERROR";
        this.message = `Resolver for "${keyword}" keyword not found.`;
        this.schemas = schemas;
      }
    };
    var InvalidOnConflictOptionError = class extends Error {
      constructor(onConflict) {
        super();
        this.name = "JsonSchemaMergeError";
        this.code = "JSON_SCHEMA_MERGE_ERROR";
        this.message = `Invalid "onConflict" option: "${onConflict}".`;
      }
    };
    module2.exports = {
      MergeError,
      ResolverNotFoundError,
      InvalidOnConflictOptionError
    };
  }
});

// node_modules/@fastify/merge-json-schemas/lib/resolvers.js
var require_resolvers = __commonJS({
  "node_modules/@fastify/merge-json-schemas/lib/resolvers.js"(exports2, module2) {
    "use strict";
    var { dequal: deepEqual } = require_dist();
    var { MergeError } = require_errors4();
    function _arraysIntersection(arrays) {
      let intersection = arrays[0];
      for (let i = 1; i < arrays.length; i++) {
        intersection = intersection.filter(
          (value) => arrays[i].includes(value)
        );
      }
      return intersection;
    }
    function arraysIntersection(keyword, values, mergedSchema) {
      const intersection = _arraysIntersection(values);
      if (intersection.length === 0) {
        throw new MergeError(keyword, values);
      }
      mergedSchema[keyword] = intersection;
    }
    function hybridArraysIntersection(keyword, values, mergedSchema) {
      for (let i = 0; i < values.length; i++) {
        if (!Array.isArray(values[i])) {
          values[i] = [values[i]];
        }
      }
      const intersection = _arraysIntersection(values);
      if (intersection.length === 0) {
        throw new MergeError(keyword, values);
      }
      if (intersection.length === 1) {
        mergedSchema[keyword] = intersection[0];
      } else {
        mergedSchema[keyword] = intersection;
      }
    }
    function arraysUnion(keyword, values, mergedSchema) {
      const union = [];
      for (const array of values) {
        for (const value of array) {
          if (!union.includes(value)) {
            union.push(value);
          }
        }
      }
      mergedSchema[keyword] = union;
    }
    function minNumber(keyword, values, mergedSchema) {
      mergedSchema[keyword] = Math.min(...values);
    }
    function maxNumber(keyword, values, mergedSchema) {
      mergedSchema[keyword] = Math.max(...values);
    }
    function commonMultiple(keyword, values, mergedSchema) {
      const gcd = (a, b) => !b ? a : gcd(b, a % b);
      const lcm = (a, b) => a * b / gcd(a, b);
      let scale = 1;
      for (const value of values) {
        while (value * scale % 1 !== 0) {
          scale *= 10;
        }
      }
      let multiple = values[0] * scale;
      for (const value of values) {
        multiple = lcm(multiple, value * scale);
      }
      mergedSchema[keyword] = multiple / scale;
    }
    function allEqual(keyword, values, mergedSchema) {
      const firstValue = values[0];
      for (let i = 1; i < values.length; i++) {
        if (!deepEqual(values[i], firstValue)) {
          throw new MergeError(keyword, values);
        }
      }
      mergedSchema[keyword] = firstValue;
    }
    function skip() {
    }
    function booleanAnd(keyword, values, mergedSchema) {
      for (const value of values) {
        if (value === false) {
          mergedSchema[keyword] = false;
          return;
        }
      }
      mergedSchema[keyword] = true;
    }
    function booleanOr(keyword, values, mergedSchema) {
      for (const value of values) {
        if (value === true) {
          mergedSchema[keyword] = true;
          return;
        }
      }
      mergedSchema[keyword] = false;
    }
    module2.exports = {
      arraysIntersection,
      hybridArraysIntersection,
      arraysUnion,
      minNumber,
      maxNumber,
      commonMultiple,
      allEqual,
      booleanAnd,
      booleanOr,
      skip
    };
  }
});

// node_modules/@fastify/merge-json-schemas/index.js
var require_merge_json_schemas = __commonJS({
  "node_modules/@fastify/merge-json-schemas/index.js"(exports2, module2) {
    "use strict";
    var { dequal: deepEqual } = require_dist();
    var resolvers = require_resolvers();
    var errors = require_errors4();
    var keywordsResolvers = {
      $id: resolvers.skip,
      type: resolvers.hybridArraysIntersection,
      enum: resolvers.arraysIntersection,
      minLength: resolvers.maxNumber,
      maxLength: resolvers.minNumber,
      minimum: resolvers.maxNumber,
      maximum: resolvers.minNumber,
      multipleOf: resolvers.commonMultiple,
      exclusiveMinimum: resolvers.maxNumber,
      exclusiveMaximum: resolvers.minNumber,
      minItems: resolvers.maxNumber,
      maxItems: resolvers.minNumber,
      maxProperties: resolvers.minNumber,
      minProperties: resolvers.maxNumber,
      const: resolvers.allEqual,
      default: resolvers.allEqual,
      format: resolvers.allEqual,
      required: resolvers.arraysUnion,
      properties: mergeProperties,
      patternProperties: mergeObjects,
      additionalProperties: mergeSchemasResolver,
      items: mergeItems,
      additionalItems: mergeAdditionalItems,
      definitions: mergeObjects,
      $defs: mergeObjects,
      nullable: resolvers.booleanAnd,
      oneOf: mergeOneOf,
      anyOf: mergeOneOf,
      allOf: resolvers.arraysUnion,
      not: mergeSchemasResolver,
      if: mergeIfThenElseSchemas,
      then: resolvers.skip,
      else: resolvers.skip,
      dependencies: mergeDependencies,
      dependentRequired: mergeDependencies,
      dependentSchemas: mergeObjects,
      propertyNames: mergeSchemasResolver,
      uniqueItems: resolvers.booleanOr,
      contains: mergeSchemasResolver
    };
    function mergeSchemasResolver(keyword, values, mergedSchema, _schemas, options) {
      mergedSchema[keyword] = _mergeSchemas(values, options);
    }
    function cartesianProduct(arrays) {
      let result = [[]];
      for (const array of arrays) {
        const temp = [];
        for (const x of result) {
          for (const y of array) {
            temp.push([...x, y]);
          }
        }
        result = temp;
      }
      return result;
    }
    function mergeOneOf(keyword, values, mergedSchema, _schemas, options) {
      if (values.length === 1) {
        mergedSchema[keyword] = values[0];
        return;
      }
      const product = cartesianProduct(values);
      const mergedOneOf = [];
      for (const combination of product) {
        try {
          const mergedSchema2 = _mergeSchemas(combination, options);
          if (mergedSchema2 !== void 0) {
            mergedOneOf.push(mergedSchema2);
          }
        } catch (error) {
          if (error instanceof errors.MergeError) continue;
          throw error;
        }
      }
      mergedSchema[keyword] = mergedOneOf;
    }
    function getSchemaForItem(schema, index) {
      const { items, additionalItems } = schema;
      if (Array.isArray(items)) {
        if (index < items.length) {
          return items[index];
        }
        return additionalItems;
      }
      if (items !== void 0) {
        return items;
      }
      return additionalItems;
    }
    function mergeItems(keyword, values, mergedSchema, schemas, options) {
      let maxArrayItemsLength = 0;
      for (const itemsSchema of values) {
        if (Array.isArray(itemsSchema)) {
          maxArrayItemsLength = Math.max(maxArrayItemsLength, itemsSchema.length);
        }
      }
      if (maxArrayItemsLength === 0) {
        mergedSchema[keyword] = _mergeSchemas(values, options);
        return;
      }
      const mergedItemsSchemas = [];
      for (let i = 0; i < maxArrayItemsLength; i++) {
        const indexItemSchemas = [];
        for (const schema of schemas) {
          const itemSchema = getSchemaForItem(schema, i);
          if (itemSchema !== void 0) {
            indexItemSchemas.push(itemSchema);
          }
        }
        mergedItemsSchemas[i] = _mergeSchemas(indexItemSchemas, options);
      }
      mergedSchema[keyword] = mergedItemsSchemas;
    }
    function mergeAdditionalItems(keyword, values, mergedSchema, schemas, options) {
      let hasArrayItems = false;
      for (const schema of schemas) {
        if (Array.isArray(schema.items)) {
          hasArrayItems = true;
          break;
        }
      }
      if (!hasArrayItems) {
        mergedSchema[keyword] = _mergeSchemas(values, options);
        return;
      }
      const mergedAdditionalItemsSchemas = [];
      for (const schema of schemas) {
        let additionalItemsSchema = schema.additionalItems;
        if (additionalItemsSchema === void 0 && !Array.isArray(schema.items)) {
          additionalItemsSchema = schema.items;
        }
        if (additionalItemsSchema !== void 0) {
          mergedAdditionalItemsSchemas.push(additionalItemsSchema);
        }
      }
      mergedSchema[keyword] = _mergeSchemas(mergedAdditionalItemsSchemas, options);
    }
    function getSchemaForProperty(schema, propertyName) {
      const { properties, patternProperties, additionalProperties } = schema;
      if (properties?.[propertyName] !== void 0) {
        return properties[propertyName];
      }
      for (const pattern of Object.keys(patternProperties ?? {})) {
        const regexp = new RegExp(pattern);
        if (regexp.test(propertyName)) {
          return patternProperties[pattern];
        }
      }
      return additionalProperties;
    }
    function mergeProperties(keyword, _values, mergedSchema, schemas, options) {
      const foundProperties = {};
      for (const currentSchema of schemas) {
        const properties = currentSchema.properties ?? {};
        for (const propertyName of Object.keys(properties)) {
          if (foundProperties[propertyName] !== void 0) continue;
          const propertySchema = properties[propertyName];
          foundProperties[propertyName] = [propertySchema];
          for (const anotherSchema of schemas) {
            if (currentSchema === anotherSchema) continue;
            const propertySchema2 = getSchemaForProperty(anotherSchema, propertyName);
            if (propertySchema2 !== void 0) {
              foundProperties[propertyName].push(propertySchema2);
            }
          }
        }
      }
      const mergedProperties = {};
      for (const property of Object.keys(foundProperties)) {
        const propertySchemas = foundProperties[property];
        mergedProperties[property] = _mergeSchemas(propertySchemas, options);
      }
      mergedSchema[keyword] = mergedProperties;
    }
    function mergeObjects(keyword, values, mergedSchema, _schemas, options) {
      const objectsProperties = {};
      for (const properties of values) {
        for (const propertyName of Object.keys(properties)) {
          if (objectsProperties[propertyName] === void 0) {
            objectsProperties[propertyName] = [];
          }
          objectsProperties[propertyName].push(properties[propertyName]);
        }
      }
      const mergedProperties = {};
      for (const propertyName of Object.keys(objectsProperties)) {
        const propertySchemas = objectsProperties[propertyName];
        const mergedPropertySchema = _mergeSchemas(propertySchemas, options);
        mergedProperties[propertyName] = mergedPropertySchema;
      }
      mergedSchema[keyword] = mergedProperties;
    }
    function mergeIfThenElseSchemas(_keyword, _values, mergedSchema, schemas, options) {
      for (let i = 0; i < schemas.length; i++) {
        const subSchema = {
          if: schemas[i].if,
          then: schemas[i].then,
          else: schemas[i].else
        };
        if (subSchema.if === void 0) continue;
        if (mergedSchema.if === void 0) {
          mergedSchema.if = subSchema.if;
          if (subSchema.then !== void 0) {
            mergedSchema.then = subSchema.then;
          }
          if (subSchema.else !== void 0) {
            mergedSchema.else = subSchema.else;
          }
          continue;
        }
        if (mergedSchema.then !== void 0) {
          mergedSchema.then = _mergeSchemas([mergedSchema.then, subSchema], options);
        }
        if (mergedSchema.else !== void 0) {
          mergedSchema.else = _mergeSchemas([mergedSchema.else, subSchema], options);
        }
      }
    }
    function mergeDependencies(keyword, values, mergedSchema) {
      const mergedDependencies = {};
      for (const dependencies of values) {
        for (const propertyName of Object.keys(dependencies)) {
          if (mergedDependencies[propertyName] === void 0) {
            mergedDependencies[propertyName] = [];
          }
          const mergedPropertyDependencies = mergedDependencies[propertyName];
          for (const propertyDependency of dependencies[propertyName]) {
            if (!mergedPropertyDependencies.includes(propertyDependency)) {
              mergedPropertyDependencies.push(propertyDependency);
            }
          }
        }
      }
      mergedSchema[keyword] = mergedDependencies;
    }
    function _mergeSchemas(schemas, options) {
      if (schemas.length === 0) return {};
      if (schemas.length === 1) return schemas[0];
      const mergedSchema = {};
      const keywords = {};
      let allSchemasAreTrue = true;
      for (const schema of schemas) {
        if (schema === false) return false;
        if (schema === true) continue;
        allSchemasAreTrue = false;
        for (const keyword of Object.keys(schema)) {
          if (keywords[keyword] === void 0) {
            keywords[keyword] = [];
          }
          keywords[keyword].push(schema[keyword]);
        }
      }
      if (allSchemasAreTrue) return true;
      for (const keyword of Object.keys(keywords)) {
        const keywordValues = keywords[keyword];
        const resolver = options.resolvers[keyword] ?? options.defaultResolver;
        resolver(keyword, keywordValues, mergedSchema, schemas, options);
      }
      return mergedSchema;
    }
    function defaultResolver(keyword, values, mergedSchema, _schemas, options) {
      const onConflict = options.onConflict ?? "throw";
      if (values.length === 1 || onConflict === "first") {
        mergedSchema[keyword] = values[0];
        return;
      }
      let allValuesEqual = true;
      for (let i = 1; i < values.length; i++) {
        if (!deepEqual(values[i], values[0])) {
          allValuesEqual = false;
          break;
        }
      }
      if (allValuesEqual) {
        mergedSchema[keyword] = values[0];
        return;
      }
      if (onConflict === "throw") {
        throw new errors.ResolverNotFoundError(keyword, values);
      }
      if (onConflict === "skip") {
        return;
      }
      throw new errors.InvalidOnConflictOptionError(onConflict);
    }
    function mergeSchemas(schemas, options = {}) {
      if (options.defaultResolver === void 0) {
        options.defaultResolver = defaultResolver;
      }
      options.resolvers = { ...keywordsResolvers, ...options.resolvers };
      const mergedSchema = _mergeSchemas(schemas, options);
      return mergedSchema;
    }
    module2.exports = { mergeSchemas, keywordsResolvers, defaultResolver, ...errors };
  }
});

// node_modules/fast-json-stringify/lib/merge-schemas.js
var require_merge_schemas = __commonJS({
  "node_modules/fast-json-stringify/lib/merge-schemas.js"(exports2, module2) {
    "use strict";
    var { mergeSchemas: _mergeSchemas } = require_merge_json_schemas();
    function mergeSchemas(schemas) {
      return _mergeSchemas(schemas, { onConflict: "skip" });
    }
    module2.exports = mergeSchemas;
  }
});

// node_modules/fast-json-stringify/lib/standalone.js
var require_standalone = __commonJS({
  "node_modules/fast-json-stringify/lib/standalone.js"(exports2, module2) {
    "use strict";
    function buildStandaloneCode(contextFunc, context, serializer, validator) {
      let ajvDependencyCode = "";
      if (context.validatorSchemasIds.size > 0) {
        ajvDependencyCode += "const Validator = require('fast-json-stringify/lib/validator')\n";
        ajvDependencyCode += `const validatorState = ${JSON.stringify(validator.getState())}
`;
        ajvDependencyCode += "const validator = Validator.restoreFromState(validatorState)\n";
      } else {
        ajvDependencyCode += "const validator = null\n";
      }
      const { schema, ...serializerState } = serializer.getState();
      return `
  'use strict'

  const Serializer = require('fast-json-stringify/lib/serializer')
  const serializerState = ${JSON.stringify(serializerState)}
  const serializer = Serializer.restoreFromState(serializerState)

  ${ajvDependencyCode}

  module.exports = ${contextFunc.toString()}(validator, serializer)`;
    }
    module2.exports = buildStandaloneCode;
    module2.exports.dependencies = {
      Serializer: require_serializer(),
      Validator: require_validator2()
    };
  }
});

// node_modules/fast-json-stringify/index.js
var require_fast_json_stringify = __commonJS({
  "node_modules/fast-json-stringify/index.js"(exports2, module2) {
    "use strict";
    var { RefResolver } = require_json_schema_ref_resolver();
    var Serializer = require_serializer();
    var Validator = require_validator2();
    var Location = require_location();
    var validate = require_schema_validator();
    var mergeSchemas = require_merge_schemas();
    var SINGLE_TICK = /'/g;
    var largeArraySize = 2e4;
    var largeArrayMechanism = "default";
    var validRoundingMethods = [
      "floor",
      "ceil",
      "round",
      "trunc"
    ];
    var validLargeArrayMechanisms = [
      "default",
      "json-stringify"
    ];
    var schemaIdCounter = 0;
    function isValidSchema(schema, name) {
      if (!validate(schema)) {
        if (name) {
          name = `"${name}" `;
        } else {
          name = "";
        }
        const first = validate.errors[0];
        const err = new Error(`${name}schema is invalid: data${first.instancePath} ${first.message}`);
        err.errors = isValidSchema.errors;
        throw err;
      }
    }
    function resolveRef(context, location) {
      const ref = location.schema.$ref;
      let hashIndex = ref.indexOf("#");
      if (hashIndex === -1) {
        hashIndex = ref.length;
      }
      const schemaId = ref.slice(0, hashIndex) || location.schemaId;
      const jsonPointer = ref.slice(hashIndex) || "#";
      const schema = context.refResolver.getSchema(schemaId, jsonPointer);
      if (schema === null) {
        throw new Error(`Cannot find reference "${ref}"`);
      }
      const newLocation = new Location(schema, schemaId, jsonPointer);
      if (schema.$ref !== void 0) {
        return resolveRef(context, newLocation);
      }
      return newLocation;
    }
    function getMergedLocation(context, mergedSchemaId) {
      const mergedSchema = context.refResolver.getSchema(mergedSchemaId, "#");
      return new Location(mergedSchema, mergedSchemaId, "#");
    }
    function getSchemaId(schema, rootSchemaId) {
      if (schema.$id && schema.$id.charAt(0) !== "#") {
        return schema.$id;
      }
      return rootSchemaId;
    }
    function build(schema, options) {
      isValidSchema(schema);
      options = options || {};
      const context = {
        functions: [],
        functionsCounter: 0,
        functionsNamesBySchema: /* @__PURE__ */ new Map(),
        options,
        refResolver: new RefResolver(),
        rootSchemaId: schema.$id || `__fjs_root_${schemaIdCounter++}`,
        validatorSchemasIds: /* @__PURE__ */ new Set(),
        mergedSchemasIds: /* @__PURE__ */ new Map()
      };
      const schemaId = getSchemaId(schema, context.rootSchemaId);
      if (!context.refResolver.hasSchema(schemaId)) {
        context.refResolver.addSchema(schema, context.rootSchemaId);
      }
      if (options.schema) {
        for (const key in options.schema) {
          const schema2 = options.schema[key];
          const schemaId2 = getSchemaId(schema2, key);
          if (!context.refResolver.hasSchema(schemaId2)) {
            isValidSchema(schema2, key);
            context.refResolver.addSchema(schema2, key);
          }
        }
      }
      if (options.rounding) {
        if (!validRoundingMethods.includes(options.rounding)) {
          throw new Error(`Unsupported integer rounding method ${options.rounding}`);
        }
      }
      if (options.largeArrayMechanism) {
        if (validLargeArrayMechanisms.includes(options.largeArrayMechanism)) {
          largeArrayMechanism = options.largeArrayMechanism;
        } else {
          throw new Error(`Unsupported large array mechanism ${options.largeArrayMechanism}`);
        }
      }
      if (options.largeArraySize) {
        if (typeof options.largeArraySize === "string" && Number.isFinite(Number.parseInt(options.largeArraySize, 10))) {
          largeArraySize = Number.parseInt(options.largeArraySize, 10);
        } else if (typeof options.largeArraySize === "number" && Number.isInteger(options.largeArraySize)) {
          largeArraySize = options.largeArraySize;
        } else if (typeof options.largeArraySize === "bigint") {
          largeArraySize = Number(options.largeArraySize);
        } else {
          throw new Error(`Unsupported large array size. Expected integer-like, got ${typeof options.largeArraySize} with value ${options.largeArraySize}`);
        }
      }
      const location = new Location(schema, context.rootSchemaId);
      const code = buildValue(context, location, "input");
      let contextFunctionCode = `
    const JSON_STR_BEGIN_OBJECT = '{'
    const JSON_STR_END_OBJECT = '}'
    const JSON_STR_BEGIN_ARRAY = '['
    const JSON_STR_END_ARRAY = ']'
    const JSON_STR_COMMA = ','
    const JSON_STR_COLONS = ':'
    const JSON_STR_QUOTE = '"'
    const JSON_STR_EMPTY_OBJECT = JSON_STR_BEGIN_OBJECT + JSON_STR_END_OBJECT
    const JSON_STR_EMPTY_ARRAY = JSON_STR_BEGIN_ARRAY + JSON_STR_END_ARRAY
    const JSON_STR_EMPTY_STRING = JSON_STR_QUOTE + JSON_STR_QUOTE
    const JSON_STR_NULL = 'null'
  `;
      if (code === "json += anonymous0(input)") {
        contextFunctionCode += `
    ${context.functions.join("\n")}
    const main = anonymous0
    return main
    `;
      } else {
        contextFunctionCode += `
    function main (input) {
      let json = ''
      ${code}
      return json
    }
    ${context.functions.join("\n")}
    return main
    `;
      }
      const serializer = new Serializer(options);
      const validator = new Validator(options.ajv);
      for (const schemaId2 of context.validatorSchemasIds) {
        const schema2 = context.refResolver.getSchema(schemaId2);
        validator.addSchema(schema2, schemaId2);
        const dependencies = context.refResolver.getSchemaDependencies(schemaId2);
        for (const [schemaId3, schema3] of Object.entries(dependencies)) {
          validator.addSchema(schema3, schemaId3);
        }
      }
      if (options.debugMode) {
        options.mode = "debug";
      }
      if (options.mode === "debug") {
        return {
          validator,
          serializer,
          code: `validator
serializer
${contextFunctionCode}`,
          ajv: validator.ajv
        };
      }
      const contextFunc = new Function("validator", "serializer", contextFunctionCode);
      if (options.mode === "standalone") {
        const buildStandaloneCode = require_standalone();
        return buildStandaloneCode(contextFunc, context, serializer, validator);
      }
      return contextFunc(validator, serializer);
    }
    var objectKeywords = [
      "properties",
      "required",
      "additionalProperties",
      "patternProperties",
      "maxProperties",
      "minProperties",
      "dependencies"
    ];
    var arrayKeywords = [
      "items",
      "additionalItems",
      "maxItems",
      "minItems",
      "uniqueItems",
      "contains"
    ];
    var stringKeywords = [
      "maxLength",
      "minLength",
      "pattern"
    ];
    var numberKeywords = [
      "multipleOf",
      "maximum",
      "exclusiveMaximum",
      "minimum",
      "exclusiveMinimum"
    ];
    function inferTypeByKeyword(schema) {
      for (const keyword of objectKeywords) {
        if (keyword in schema) return "object";
      }
      for (const keyword of arrayKeywords) {
        if (keyword in schema) return "array";
      }
      for (const keyword of stringKeywords) {
        if (keyword in schema) return "string";
      }
      for (const keyword of numberKeywords) {
        if (keyword in schema) return "number";
      }
      return schema.type;
    }
    function buildExtraObjectPropertiesSerializer(context, location, addComma) {
      const schema = location.schema;
      const propertiesKeys = Object.keys(schema.properties || {});
      let code = `
    const propertiesKeys = ${JSON.stringify(propertiesKeys)}
    for (const [key, value] of Object.entries(obj)) {
      if (
        propertiesKeys.includes(key) ||
        value === undefined ||
        typeof value === 'function' ||
        typeof value === 'symbol'
      ) continue
  `;
      const patternPropertiesLocation = location.getPropertyLocation("patternProperties");
      const patternPropertiesSchema = patternPropertiesLocation.schema;
      if (patternPropertiesSchema !== void 0) {
        for (const propertyKey in patternPropertiesSchema) {
          const propertyLocation = patternPropertiesLocation.getPropertyLocation(propertyKey);
          code += `
        if (/${propertyKey.replace(/\\*\//g, "\\/")}/.test(key)) {
          ${addComma}
          json += serializer.asString(key) + JSON_STR_COLONS
          ${buildValue(context, propertyLocation, "value")}
          continue
        }
      `;
        }
      }
      const additionalPropertiesLocation = location.getPropertyLocation("additionalProperties");
      const additionalPropertiesSchema = additionalPropertiesLocation.schema;
      if (additionalPropertiesSchema !== void 0) {
        if (additionalPropertiesSchema === true) {
          code += `
        ${addComma}
        json += serializer.asString(key) + JSON_STR_COLONS + JSON.stringify(value)
      `;
        } else {
          const propertyLocation = location.getPropertyLocation("additionalProperties");
          code += `
        ${addComma}
        json += serializer.asString(key) + JSON_STR_COLONS
        ${buildValue(context, propertyLocation, "value")}
      `;
        }
      }
      code += `
    }
  `;
      return code;
    }
    function buildInnerObject(context, location) {
      const schema = location.schema;
      const propertiesLocation = location.getPropertyLocation("properties");
      const requiredProperties = schema.required || [];
      const propertiesKeys = Object.keys(schema.properties || {}).sort(
        (key1, key2) => {
          const required1 = requiredProperties.includes(key1);
          const required2 = requiredProperties.includes(key2);
          return required1 === required2 ? 0 : required1 ? -1 : 1;
        }
      );
      const hasRequiredProperties = requiredProperties.includes(propertiesKeys[0]);
      let code = "let value\n";
      for (const key of requiredProperties) {
        if (!propertiesKeys.includes(key)) {
          const sanitizedKey = JSON.stringify(key);
          code += `if (obj[${sanitizedKey}] === undefined) throw new Error('${sanitizedKey.replace(/'/g, "\\'")} is required!')
`;
        }
      }
      code += "let json = JSON_STR_BEGIN_OBJECT\n";
      let addComma = "";
      if (!hasRequiredProperties) {
        code += "let addComma = false\n";
        addComma = "!addComma && (addComma = true) || (json += JSON_STR_COMMA)";
      }
      for (const key of propertiesKeys) {
        let propertyLocation = propertiesLocation.getPropertyLocation(key);
        if (propertyLocation.schema.$ref) {
          propertyLocation = resolveRef(context, propertyLocation);
        }
        const sanitizedKey = JSON.stringify(key);
        const defaultValue = propertyLocation.schema.default;
        const isRequired = requiredProperties.includes(key);
        code += `
      value = obj[${sanitizedKey}]
      if (value !== undefined) {
        ${addComma}
        json += ${JSON.stringify(sanitizedKey + ":")}
        ${buildValue(context, propertyLocation, "value")}
      }`;
        if (defaultValue !== void 0) {
          code += ` else {
        ${addComma}
        json += ${JSON.stringify(sanitizedKey + ":" + JSON.stringify(defaultValue))}
      }
      `;
        } else if (isRequired) {
          code += ` else {
        throw new Error('${sanitizedKey.replace(/'/g, "\\'")} is required!')
      }
      `;
        } else {
          code += "\n";
        }
        if (hasRequiredProperties) {
          addComma = "json += ','";
        }
      }
      if (schema.patternProperties || schema.additionalProperties) {
        code += buildExtraObjectPropertiesSerializer(context, location, addComma);
      }
      code += `
    return json + JSON_STR_END_OBJECT
  `;
      return code;
    }
    function mergeLocations(context, mergedSchemaId, mergedLocations) {
      for (let i = 0; i < mergedLocations.length; i++) {
        const location = mergedLocations[i];
        const schema = location.schema;
        if (schema.$ref) {
          mergedLocations[i] = resolveRef(context, location);
        }
      }
      const mergedSchemas = [];
      for (const location of mergedLocations) {
        const schema = cloneOriginSchema(context, location.schema, location.schemaId);
        delete schema.$id;
        mergedSchemas.push(schema);
      }
      const mergedSchema = mergeSchemas(mergedSchemas);
      const mergedLocation = new Location(mergedSchema, mergedSchemaId);
      context.refResolver.addSchema(mergedSchema, mergedSchemaId);
      return mergedLocation;
    }
    function cloneOriginSchema(context, schema, schemaId) {
      const clonedSchema = Array.isArray(schema) ? [] : {};
      if (schema.$id !== void 0 && schema.$id.charAt(0) !== "#") {
        schemaId = schema.$id;
      }
      const mergedSchemaRef = context.mergedSchemasIds.get(schema);
      if (mergedSchemaRef) {
        context.mergedSchemasIds.set(clonedSchema, mergedSchemaRef);
      }
      for (const key in schema) {
        let value = schema[key];
        if (key === "$ref" && typeof value === "string" && value.charAt(0) === "#") {
          value = schemaId + value;
        }
        if (typeof value === "object" && value !== null) {
          value = cloneOriginSchema(context, value, schemaId);
        }
        clonedSchema[key] = value;
      }
      return clonedSchema;
    }
    function toJSON(variableName) {
      return `(${variableName} && typeof ${variableName}.toJSON === 'function')
    ? ${variableName}.toJSON()
    : ${variableName}
  `;
    }
    function buildObject(context, location) {
      const schema = location.schema;
      if (context.functionsNamesBySchema.has(schema)) {
        return context.functionsNamesBySchema.get(schema);
      }
      const functionName = generateFuncName(context);
      context.functionsNamesBySchema.set(schema, functionName);
      let schemaRef = location.getSchemaRef();
      if (schemaRef.startsWith(context.rootSchemaId)) {
        schemaRef = schemaRef.replace(context.rootSchemaId, "");
      }
      let functionCode = `
  `;
      const nullable = schema.nullable === true;
      functionCode += `
    // ${schemaRef}
    function ${functionName} (input) {
      const obj = ${toJSON("input")}
      ${!nullable ? "if (obj === null) return JSON_STR_EMPTY_OBJECT" : ""}

      ${buildInnerObject(context, location)}
    }
  `;
      context.functions.push(functionCode);
      return functionName;
    }
    function buildArray(context, location) {
      const schema = location.schema;
      let itemsLocation = location.getPropertyLocation("items");
      itemsLocation.schema = itemsLocation.schema || {};
      if (itemsLocation.schema.$ref) {
        itemsLocation = resolveRef(context, itemsLocation);
      }
      const itemsSchema = itemsLocation.schema;
      if (context.functionsNamesBySchema.has(schema)) {
        return context.functionsNamesBySchema.get(schema);
      }
      const functionName = generateFuncName(context);
      context.functionsNamesBySchema.set(schema, functionName);
      let schemaRef = location.getSchemaRef();
      if (schemaRef.startsWith(context.rootSchemaId)) {
        schemaRef = schemaRef.replace(context.rootSchemaId, "");
      }
      let functionCode = `
    function ${functionName} (obj) {
      // ${schemaRef}
  `;
      const nullable = schema.nullable === true;
      functionCode += `
    ${!nullable ? "if (obj === null) return JSON_STR_EMPTY_ARRAY" : ""}
    if (!Array.isArray(obj)) {
      throw new TypeError(\`The value of '${schemaRef}' does not match schema definition.\`)
    }
    const arrayLength = obj.length
  `;
      if (!schema.additionalItems && Array.isArray(itemsSchema)) {
        functionCode += `
      if (arrayLength > ${itemsSchema.length}) {
        throw new Error(\`Item at ${itemsSchema.length} does not match schema definition.\`)
      }
    `;
      }
      if (largeArrayMechanism === "json-stringify") {
        functionCode += `if (arrayLength >= ${largeArraySize}) return JSON.stringify(obj)
`;
      }
      functionCode += `
    const arrayEnd = arrayLength - 1
    let value
    let json = ''
  `;
      if (Array.isArray(itemsSchema)) {
        for (let i = 0; i < itemsSchema.length; i++) {
          const item = itemsSchema[i];
          functionCode += `value = obj[${i}]`;
          const tmpRes = buildValue(context, itemsLocation.getPropertyLocation(i), "value");
          functionCode += `
        if (${i} < arrayLength) {
          if (${buildArrayTypeCondition(item.type, `[${i}]`)}) {
            ${tmpRes}
            if (${i} < arrayEnd) {
              json += JSON_STR_COMMA
            }
          } else {
            throw new Error(\`Item at ${i} does not match schema definition.\`)
          }
        }
        `;
        }
        if (schema.additionalItems) {
          functionCode += `
        for (let i = ${itemsSchema.length}; i < arrayLength; i++) {
          json += JSON.stringify(obj[i])
          if (i < arrayEnd) {
            json += JSON_STR_COMMA
          }
        }`;
        }
      } else {
        const code = buildValue(context, itemsLocation, "obj[i]");
        functionCode += `
      for (let i = 0; i < arrayLength; i++) {
        ${code}
        if (i < arrayEnd) {
          json += JSON_STR_COMMA
        }
      }`;
      }
      functionCode += `
    return JSON_STR_BEGIN_ARRAY + json + JSON_STR_END_ARRAY
  }`;
      context.functions.push(functionCode);
      return functionName;
    }
    function buildArrayTypeCondition(type, accessor) {
      let condition;
      switch (type) {
        case "null":
          condition = "value === null";
          break;
        case "string":
          condition = `typeof value === 'string' ||
      value === null ||
      value instanceof Date ||
      value instanceof RegExp ||
      (
        typeof value === "object" &&
        typeof value.toString === "function" &&
        value.toString !== Object.prototype.toString
      )`;
          break;
        case "integer":
          condition = "Number.isInteger(value)";
          break;
        case "number":
          condition = "Number.isFinite(value)";
          break;
        case "boolean":
          condition = "typeof value === 'boolean'";
          break;
        case "object":
          condition = "value && typeof value === 'object' && value.constructor === Object";
          break;
        case "array":
          condition = "Array.isArray(value)";
          break;
        default:
          if (Array.isArray(type)) {
            const conditions = type.map((subType) => {
              return buildArrayTypeCondition(subType, accessor);
            });
            condition = `(${conditions.join(" || ")})`;
          }
      }
      return condition;
    }
    function generateFuncName(context) {
      return "anonymous" + context.functionsCounter++;
    }
    function buildMultiTypeSerializer(context, location, input) {
      const schema = location.schema;
      const types = schema.type.sort((t1) => t1 === "null" ? -1 : 1);
      let code = "";
      types.forEach((type, index) => {
        location.schema = { ...location.schema, type };
        const nestedResult = buildSingleTypeSerializer(context, location, input);
        const statement = index === 0 ? "if" : "else if";
        switch (type) {
          case "null":
            code += `
          ${statement} (${input} === null)
            ${nestedResult}
          `;
            break;
          case "string": {
            code += `
          ${statement}(
            typeof ${input} === "string" ||
            ${input} === null ||
            ${input} instanceof Date ||
            ${input} instanceof RegExp ||
            (
              typeof ${input} === "object" &&
              typeof ${input}.toString === "function" &&
              ${input}.toString !== Object.prototype.toString
            )
          )
            ${nestedResult}
        `;
            break;
          }
          case "array": {
            code += `
          ${statement}(Array.isArray(${input}))
            ${nestedResult}
        `;
            break;
          }
          case "integer": {
            code += `
          ${statement}(Number.isInteger(${input}) || ${input} === null)
            ${nestedResult}
        `;
            break;
          }
          default: {
            code += `
          ${statement}(typeof ${input} === "${type}" || ${input} === null)
            ${nestedResult}
        `;
            break;
          }
        }
      });
      let schemaRef = location.getSchemaRef();
      if (schemaRef.startsWith(context.rootSchemaId)) {
        schemaRef = schemaRef.replace(context.rootSchemaId, "");
      }
      code += `
    else throw new TypeError(\`The value of '${schemaRef}' does not match schema definition.\`)
  `;
      return code;
    }
    function buildSingleTypeSerializer(context, location, input) {
      const schema = location.schema;
      switch (schema.type) {
        case "null":
          return "json += JSON_STR_NULL";
        case "string": {
          if (schema.format === "date-time") {
            return `json += serializer.asDateTime(${input})`;
          } else if (schema.format === "date") {
            return `json += serializer.asDate(${input})`;
          } else if (schema.format === "time") {
            return `json += serializer.asTime(${input})`;
          } else if (schema.format === "unsafe") {
            return `json += serializer.asUnsafeString(${input})`;
          } else {
            return `
        if (typeof ${input} !== 'string') {
          if (${input} === null) {
            json += JSON_STR_EMPTY_STRING
          } else if (${input} instanceof Date) {
            json += JSON_STR_QUOTE + ${input}.toISOString() + JSON_STR_QUOTE
          } else if (${input} instanceof RegExp) {
            json += serializer.asString(${input}.source)
          } else {
            json += serializer.asString(${input}.toString())
          }
        } else {
          json += serializer.asString(${input})
        }
        `;
          }
        }
        case "integer":
          return `json += serializer.asInteger(${input})`;
        case "number":
          return `json += serializer.asNumber(${input})`;
        case "boolean":
          return `json += serializer.asBoolean(${input})`;
        case "object": {
          const funcName = buildObject(context, location);
          return `json += ${funcName}(${input})`;
        }
        case "array": {
          const funcName = buildArray(context, location);
          return `json += ${funcName}(${input})`;
        }
        case void 0:
          return `json += JSON.stringify(${input})`;
        default:
          throw new Error(`${schema.type} unsupported`);
      }
    }
    function buildConstSerializer(location, input) {
      const schema = location.schema;
      const type = schema.type;
      const hasNullType = Array.isArray(type) && type.includes("null");
      let code = "";
      if (hasNullType) {
        code += `
      if (${input} === null) {
        json += JSON_STR_NULL
      } else {
    `;
      }
      code += `json += '${JSON.stringify(schema.const).replace(SINGLE_TICK, "\\'")}'`;
      if (hasNullType) {
        code += `
      }
    `;
      }
      return code;
    }
    function buildAllOf(context, location, input) {
      const schema = location.schema;
      let mergedSchemaId = context.mergedSchemasIds.get(schema);
      if (mergedSchemaId) {
        const mergedLocation2 = getMergedLocation(context, mergedSchemaId);
        return buildValue(context, mergedLocation2, input);
      }
      mergedSchemaId = `__fjs_merged_${schemaIdCounter++}`;
      context.mergedSchemasIds.set(schema, mergedSchemaId);
      const { allOf, ...schemaWithoutAllOf } = location.schema;
      const locations = [
        new Location(
          schemaWithoutAllOf,
          location.schemaId,
          location.jsonPointer
        )
      ];
      const allOfsLocation = location.getPropertyLocation("allOf");
      for (let i = 0; i < allOf.length; i++) {
        locations.push(allOfsLocation.getPropertyLocation(i));
      }
      const mergedLocation = mergeLocations(context, mergedSchemaId, locations);
      return buildValue(context, mergedLocation, input);
    }
    function buildOneOf(context, location, input) {
      context.validatorSchemasIds.add(location.schemaId);
      const schema = location.schema;
      const type = schema.anyOf ? "anyOf" : "oneOf";
      const { [type]: oneOfs, ...schemaWithoutAnyOf } = location.schema;
      const locationWithoutOneOf = new Location(
        schemaWithoutAnyOf,
        location.schemaId,
        location.jsonPointer
      );
      const oneOfsLocation = location.getPropertyLocation(type);
      let code = "";
      for (let index = 0; index < oneOfs.length; index++) {
        const optionLocation = oneOfsLocation.getPropertyLocation(index);
        const optionSchema = optionLocation.schema;
        let mergedSchemaId = context.mergedSchemasIds.get(optionSchema);
        let mergedLocation = null;
        if (mergedSchemaId) {
          mergedLocation = getMergedLocation(context, mergedSchemaId);
        } else {
          mergedSchemaId = `__fjs_merged_${schemaIdCounter++}`;
          context.mergedSchemasIds.set(optionSchema, mergedSchemaId);
          mergedLocation = mergeLocations(context, mergedSchemaId, [
            locationWithoutOneOf,
            optionLocation
          ]);
        }
        const nestedResult = buildValue(context, mergedLocation, input);
        const schemaRef2 = optionLocation.getSchemaRef();
        code += `
      ${index === 0 ? "if" : "else if"}(validator.validate("${schemaRef2}", ${input}))
        ${nestedResult}
    `;
      }
      let schemaRef = location.getSchemaRef();
      if (schemaRef.startsWith(context.rootSchemaId)) {
        schemaRef = schemaRef.replace(context.rootSchemaId, "");
      }
      code += `
    else throw new TypeError(\`The value of '${schemaRef}' does not match schema definition.\`)
  `;
      return code;
    }
    function buildIfThenElse(context, location, input) {
      context.validatorSchemasIds.add(location.schemaId);
      const {
        if: ifSchema,
        then: thenSchema,
        else: elseSchema,
        ...schemaWithoutIfThenElse
      } = location.schema;
      const rootLocation = new Location(
        schemaWithoutIfThenElse,
        location.schemaId,
        location.jsonPointer
      );
      const ifLocation = location.getPropertyLocation("if");
      const ifSchemaRef = ifLocation.getSchemaRef();
      const thenLocation = location.getPropertyLocation("then");
      let thenMergedSchemaId = context.mergedSchemasIds.get(thenSchema);
      let thenMergedLocation = null;
      if (thenMergedSchemaId) {
        thenMergedLocation = getMergedLocation(context, thenMergedSchemaId);
      } else {
        thenMergedSchemaId = `__fjs_merged_${schemaIdCounter++}`;
        context.mergedSchemasIds.set(thenSchema, thenMergedSchemaId);
        thenMergedLocation = mergeLocations(context, thenMergedSchemaId, [
          rootLocation,
          thenLocation
        ]);
      }
      if (!elseSchema) {
        return `
      if (validator.validate("${ifSchemaRef}", ${input})) {
        ${buildValue(context, thenMergedLocation, input)}
      } else {
        ${buildValue(context, rootLocation, input)}
      }
    `;
      }
      const elseLocation = location.getPropertyLocation("else");
      let elseMergedSchemaId = context.mergedSchemasIds.get(elseSchema);
      let elseMergedLocation = null;
      if (elseMergedSchemaId) {
        elseMergedLocation = getMergedLocation(context, elseMergedSchemaId);
      } else {
        elseMergedSchemaId = `__fjs_merged_${schemaIdCounter++}`;
        context.mergedSchemasIds.set(elseSchema, elseMergedSchemaId);
        elseMergedLocation = mergeLocations(context, elseMergedSchemaId, [
          rootLocation,
          elseLocation
        ]);
      }
      return `
    if (validator.validate("${ifSchemaRef}", ${input})) {
      ${buildValue(context, thenMergedLocation, input)}
    } else {
      ${buildValue(context, elseMergedLocation, input)}
    }
  `;
    }
    function buildValue(context, location, input) {
      let schema = location.schema;
      if (typeof schema === "boolean") {
        return `json += JSON.stringify(${input})`;
      }
      if (schema.$ref) {
        location = resolveRef(context, location);
        schema = location.schema;
      }
      if (schema.allOf) {
        return buildAllOf(context, location, input);
      }
      if (schema.anyOf || schema.oneOf) {
        return buildOneOf(context, location, input);
      }
      if (schema.if && schema.then) {
        return buildIfThenElse(context, location, input);
      }
      if (schema.type === void 0) {
        const inferredType = inferTypeByKeyword(schema);
        if (inferredType) {
          schema.type = inferredType;
        }
      }
      let code = "";
      const type = schema.type;
      const nullable = schema.nullable === true;
      if (nullable) {
        code += `
      if (${input} === null) {
        json += JSON_STR_NULL
      } else {
    `;
      }
      if (schema.const !== void 0) {
        code += buildConstSerializer(location, input);
      } else if (Array.isArray(type)) {
        code += buildMultiTypeSerializer(context, location, input);
      } else {
        code += buildSingleTypeSerializer(context, location, input);
      }
      if (nullable) {
        code += `
      }
    `;
      }
      return code;
    }
    module2.exports = build;
    module2.exports.default = build;
    module2.exports.build = build;
    module2.exports.validLargeArrayMechanisms = validLargeArrayMechanisms;
    module2.exports.restore = function({ code, validator, serializer }) {
      return Function.apply(null, ["validator", "serializer", code]).apply(null, [validator, serializer]);
    };
  }
});

// node_modules/@fastify/fast-json-stringify-compiler/standalone.js
var require_standalone2 = __commonJS({
  "node_modules/@fastify/fast-json-stringify-compiler/standalone.js"(exports2, module2) {
    "use strict";
    var fastJsonStringify = require_fast_json_stringify();
    function SerializerSelector() {
      return function buildSerializerFactory(externalSchemas, serializerOpts) {
        const fjsOpts = Object.assign({}, serializerOpts, { schema: externalSchemas });
        return responseSchemaCompiler.bind(null, fjsOpts);
      };
    }
    function responseSchemaCompiler(fjsOpts, {
      schema
      /* method, url, httpStatus */
    }) {
      if (fjsOpts.schema && schema.$id && fjsOpts.schema[schema.$id]) {
        fjsOpts.schema = { ...fjsOpts.schema };
        delete fjsOpts.schema[schema.$id];
      }
      return fastJsonStringify(schema, fjsOpts);
    }
    function StandaloneSerializer(options = { readMode: true }) {
      if (options.readMode === true && typeof options.restoreFunction !== "function") {
        throw new Error("You must provide a function for the restoreFunction-option when readMode ON");
      }
      if (options.readMode !== true && typeof options.storeFunction !== "function") {
        throw new Error("You must provide a function for the storeFunction-option when readMode OFF");
      }
      if (options.readMode === true) {
        return function wrapper() {
          return function(opts) {
            return options.restoreFunction(opts);
          };
        };
      }
      const factory = SerializerSelector();
      return function wrapper(externalSchemas, serializerOpts = {}) {
        serializerOpts.mode = "standalone";
        const compiler = factory(externalSchemas, serializerOpts);
        return function(opts) {
          const serializeFuncCode = compiler(opts);
          options.storeFunction(opts, serializeFuncCode);
          return new Function(serializeFuncCode);
        };
      };
    }
    module2.exports.SerializerSelector = SerializerSelector;
    module2.exports.StandaloneSerializer = StandaloneSerializer;
    module2.exports.default = StandaloneSerializer;
  }
});

// node_modules/@fastify/fast-json-stringify-compiler/index.js
var require_fast_json_stringify_compiler = __commonJS({
  "node_modules/@fastify/fast-json-stringify-compiler/index.js"(exports2, module2) {
    "use strict";
    var { SerializerSelector, StandaloneSerializer } = require_standalone2();
    module2.exports = SerializerSelector;
    module2.exports.default = SerializerSelector;
    module2.exports.SerializerSelector = SerializerSelector;
    module2.exports.StandaloneSerializer = StandaloneSerializer;
  }
});

// node_modules/ajv/dist/vocabularies/jtd/metadata.js
var require_metadata2 = __commonJS({
  "node_modules/ajv/dist/vocabularies/jtd/metadata.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.checkMetadata = void 0;
    var util_1 = require_util2();
    var def = {
      keyword: "metadata",
      schemaType: "object",
      code(cxt) {
        checkMetadata(cxt);
        const { gen, schema, it: it2 } = cxt;
        if ((0, util_1.alwaysValidSchema)(it2, schema))
          return;
        const valid = gen.name("valid");
        cxt.subschema({ keyword: "metadata", jtdMetadata: true }, valid);
        cxt.ok(valid);
      }
    };
    function checkMetadata({ it: it2, keyword }, metadata) {
      if (it2.jtdMetadata !== metadata) {
        throw new Error(`JTD: "${keyword}" cannot be used in this schema location`);
      }
    }
    exports2.checkMetadata = checkMetadata;
    exports2.default = def;
  }
});

// node_modules/ajv/dist/vocabularies/jtd/ref.js
var require_ref2 = __commonJS({
  "node_modules/ajv/dist/vocabularies/jtd/ref.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.hasRef = void 0;
    var compile_1 = require_compile();
    var codegen_1 = require_codegen();
    var ref_error_1 = require_ref_error();
    var names_1 = require_names();
    var ref_1 = require_ref();
    var metadata_1 = require_metadata2();
    var def = {
      keyword: "ref",
      schemaType: "string",
      code(cxt) {
        (0, metadata_1.checkMetadata)(cxt);
        const { gen, data, schema: ref, parentSchema, it: it2 } = cxt;
        const { schemaEnv: { root } } = it2;
        const valid = gen.name("valid");
        if (parentSchema.nullable) {
          gen.var(valid, (0, codegen_1._)`${data} === null`);
          gen.if((0, codegen_1.not)(valid), validateJtdRef);
        } else {
          gen.var(valid, false);
          validateJtdRef();
        }
        cxt.ok(valid);
        function validateJtdRef() {
          var _a;
          const refSchema = (_a = root.schema.definitions) === null || _a === void 0 ? void 0 : _a[ref];
          if (!refSchema) {
            throw new ref_error_1.default(it2.opts.uriResolver, "", ref, `No definition ${ref}`);
          }
          if (hasRef(refSchema) || !it2.opts.inlineRefs)
            callValidate(refSchema);
          else
            inlineRefSchema(refSchema);
        }
        function callValidate(schema) {
          const sch = compile_1.compileSchema.call(it2.self, new compile_1.SchemaEnv({ schema, root, schemaPath: `/definitions/${ref}` }));
          const v = (0, ref_1.getValidate)(cxt, sch);
          const errsCount = gen.const("_errs", names_1.default.errors);
          (0, ref_1.callRef)(cxt, v, sch, sch.$async);
          gen.assign(valid, (0, codegen_1._)`${errsCount} === ${names_1.default.errors}`);
        }
        function inlineRefSchema(schema) {
          const schName = gen.scopeValue("schema", it2.opts.code.source === true ? { ref: schema, code: (0, codegen_1.stringify)(schema) } : { ref: schema });
          cxt.subschema({
            schema,
            dataTypes: [],
            schemaPath: codegen_1.nil,
            topSchemaRef: schName,
            errSchemaPath: `/definitions/${ref}`
          }, valid);
        }
      }
    };
    function hasRef(schema) {
      for (const key in schema) {
        let sch;
        if (key === "ref" || typeof (sch = schema[key]) == "object" && hasRef(sch))
          return true;
      }
      return false;
    }
    exports2.hasRef = hasRef;
    exports2.default = def;
  }
});

// node_modules/ajv/dist/runtime/timestamp.js
var require_timestamp = __commonJS({
  "node_modules/ajv/dist/runtime/timestamp.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var DT_SEPARATOR = /t|\s/i;
    var DATE = /^(\d\d\d\d)-(\d\d)-(\d\d)$/;
    var TIME = /^(\d\d):(\d\d):(\d\d)(?:\.\d+)?(?:z|([+-]\d\d)(?::?(\d\d))?)$/i;
    var DAYS = [0, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];
    function validTimestamp(str, allowDate) {
      const dt = str.split(DT_SEPARATOR);
      return dt.length === 2 && validDate(dt[0]) && validTime(dt[1]) || allowDate && dt.length === 1 && validDate(dt[0]);
    }
    exports2.default = validTimestamp;
    function validDate(str) {
      const matches = DATE.exec(str);
      if (!matches)
        return false;
      const y = +matches[1];
      const m = +matches[2];
      const d = +matches[3];
      return m >= 1 && m <= 12 && d >= 1 && (d <= DAYS[m] || // leap year: https://tools.ietf.org/html/rfc3339#appendix-C
      m === 2 && d === 29 && (y % 100 === 0 ? y % 400 === 0 : y % 4 === 0));
    }
    function validTime(str) {
      const matches = TIME.exec(str);
      if (!matches)
        return false;
      const hr = +matches[1];
      const min = +matches[2];
      const sec = +matches[3];
      const tzH = +(matches[4] || 0);
      const tzM = +(matches[5] || 0);
      return hr <= 23 && min <= 59 && sec <= 59 || // leap second
      hr - tzH === 23 && min - tzM === 59 && sec === 60;
    }
    validTimestamp.code = 'require("ajv/dist/runtime/timestamp").default';
  }
});

// node_modules/ajv/dist/vocabularies/jtd/error.js
var require_error2 = __commonJS({
  "node_modules/ajv/dist/vocabularies/jtd/error.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.typeErrorParams = exports2.typeErrorMessage = exports2.typeError = void 0;
    var codegen_1 = require_codegen();
    function typeError(t) {
      return {
        message: (cxt) => typeErrorMessage(cxt, t),
        params: (cxt) => typeErrorParams(cxt, t)
      };
    }
    exports2.typeError = typeError;
    function typeErrorMessage({ parentSchema }, t) {
      return (parentSchema === null || parentSchema === void 0 ? void 0 : parentSchema.nullable) ? `must be ${t} or null` : `must be ${t}`;
    }
    exports2.typeErrorMessage = typeErrorMessage;
    function typeErrorParams({ parentSchema }, t) {
      return (0, codegen_1._)`{type: ${t}, nullable: ${!!(parentSchema === null || parentSchema === void 0 ? void 0 : parentSchema.nullable)}}`;
    }
    exports2.typeErrorParams = typeErrorParams;
  }
});

// node_modules/ajv/dist/vocabularies/jtd/type.js
var require_type = __commonJS({
  "node_modules/ajv/dist/vocabularies/jtd/type.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.intRange = void 0;
    var codegen_1 = require_codegen();
    var timestamp_1 = require_timestamp();
    var util_1 = require_util2();
    var metadata_1 = require_metadata2();
    var error_1 = require_error2();
    exports2.intRange = {
      int8: [-128, 127, 3],
      uint8: [0, 255, 3],
      int16: [-32768, 32767, 5],
      uint16: [0, 65535, 5],
      int32: [-2147483648, 2147483647, 10],
      uint32: [0, 4294967295, 10]
    };
    var error = {
      message: (cxt) => (0, error_1.typeErrorMessage)(cxt, cxt.schema),
      params: (cxt) => (0, error_1.typeErrorParams)(cxt, cxt.schema)
    };
    function timestampCode(cxt) {
      const { gen, data, it: it2 } = cxt;
      const { timestamp, allowDate } = it2.opts;
      if (timestamp === "date")
        return (0, codegen_1._)`${data} instanceof Date `;
      const vts = (0, util_1.useFunc)(gen, timestamp_1.default);
      const allowDateArg = allowDate ? (0, codegen_1._)`, true` : codegen_1.nil;
      const validString = (0, codegen_1._)`typeof ${data} == "string" && ${vts}(${data}${allowDateArg})`;
      return timestamp === "string" ? validString : (0, codegen_1.or)((0, codegen_1._)`${data} instanceof Date`, validString);
    }
    var def = {
      keyword: "type",
      schemaType: "string",
      error,
      code(cxt) {
        (0, metadata_1.checkMetadata)(cxt);
        const { data, schema, parentSchema, it: it2 } = cxt;
        let cond;
        switch (schema) {
          case "boolean":
          case "string":
            cond = (0, codegen_1._)`typeof ${data} == ${schema}`;
            break;
          case "timestamp": {
            cond = timestampCode(cxt);
            break;
          }
          case "float32":
          case "float64":
            cond = (0, codegen_1._)`typeof ${data} == "number"`;
            break;
          default: {
            const sch = schema;
            cond = (0, codegen_1._)`typeof ${data} == "number" && isFinite(${data}) && !(${data} % 1)`;
            if (!it2.opts.int32range && (sch === "int32" || sch === "uint32")) {
              if (sch === "uint32")
                cond = (0, codegen_1._)`${cond} && ${data} >= 0`;
            } else {
              const [min, max] = exports2.intRange[sch];
              cond = (0, codegen_1._)`${cond} && ${data} >= ${min} && ${data} <= ${max}`;
            }
          }
        }
        cxt.pass(parentSchema.nullable ? (0, codegen_1.or)((0, codegen_1._)`${data} === null`, cond) : cond);
      }
    };
    exports2.default = def;
  }
});

// node_modules/ajv/dist/vocabularies/jtd/nullable.js
var require_nullable = __commonJS({
  "node_modules/ajv/dist/vocabularies/jtd/nullable.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.checkNullableObject = exports2.checkNullable = void 0;
    var codegen_1 = require_codegen();
    function checkNullable({ gen, data, parentSchema }, cond = codegen_1.nil) {
      const valid = gen.name("valid");
      if (parentSchema.nullable) {
        gen.let(valid, (0, codegen_1._)`${data} === null`);
        cond = (0, codegen_1.not)(valid);
      } else {
        gen.let(valid, false);
      }
      return [valid, cond];
    }
    exports2.checkNullable = checkNullable;
    function checkNullableObject(cxt, cond) {
      const [valid, cond_] = checkNullable(cxt, cond);
      return [valid, (0, codegen_1._)`${cond_} && typeof ${cxt.data} == "object" && !Array.isArray(${cxt.data})`];
    }
    exports2.checkNullableObject = checkNullableObject;
  }
});

// node_modules/ajv/dist/vocabularies/jtd/enum.js
var require_enum2 = __commonJS({
  "node_modules/ajv/dist/vocabularies/jtd/enum.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var codegen_1 = require_codegen();
    var metadata_1 = require_metadata2();
    var nullable_1 = require_nullable();
    var error = {
      message: "must be equal to one of the allowed values",
      params: ({ schemaCode }) => (0, codegen_1._)`{allowedValues: ${schemaCode}}`
    };
    var def = {
      keyword: "enum",
      schemaType: "array",
      error,
      code(cxt) {
        (0, metadata_1.checkMetadata)(cxt);
        const { gen, data, schema, schemaValue, parentSchema, it: it2 } = cxt;
        if (schema.length === 0)
          throw new Error("enum must have non-empty array");
        if (schema.length !== new Set(schema).size)
          throw new Error("enum items must be unique");
        let valid;
        const isString = (0, codegen_1._)`typeof ${data} == "string"`;
        if (schema.length >= it2.opts.loopEnum) {
          let cond;
          [valid, cond] = (0, nullable_1.checkNullable)(cxt, isString);
          gen.if(cond, loopEnum);
        } else {
          if (!Array.isArray(schema))
            throw new Error("ajv implementation error");
          valid = (0, codegen_1.and)(isString, (0, codegen_1.or)(...schema.map((value) => (0, codegen_1._)`${data} === ${value}`)));
          if (parentSchema.nullable)
            valid = (0, codegen_1.or)((0, codegen_1._)`${data} === null`, valid);
        }
        cxt.pass(valid);
        function loopEnum() {
          gen.forOf("v", schemaValue, (v) => gen.if((0, codegen_1._)`${valid} = ${data} === ${v}`, () => gen.break()));
        }
      }
    };
    exports2.default = def;
  }
});

// node_modules/ajv/dist/vocabularies/jtd/elements.js
var require_elements = __commonJS({
  "node_modules/ajv/dist/vocabularies/jtd/elements.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var util_1 = require_util2();
    var code_1 = require_code2();
    var codegen_1 = require_codegen();
    var metadata_1 = require_metadata2();
    var nullable_1 = require_nullable();
    var error_1 = require_error2();
    var def = {
      keyword: "elements",
      schemaType: "object",
      error: (0, error_1.typeError)("array"),
      code(cxt) {
        (0, metadata_1.checkMetadata)(cxt);
        const { gen, data, schema, it: it2 } = cxt;
        if ((0, util_1.alwaysValidSchema)(it2, schema))
          return;
        const [valid] = (0, nullable_1.checkNullable)(cxt);
        gen.if((0, codegen_1.not)(valid), () => gen.if((0, codegen_1._)`Array.isArray(${data})`, () => gen.assign(valid, (0, code_1.validateArray)(cxt)), () => cxt.error()));
        cxt.ok(valid);
      }
    };
    exports2.default = def;
  }
});

// node_modules/ajv/dist/vocabularies/jtd/properties.js
var require_properties2 = __commonJS({
  "node_modules/ajv/dist/vocabularies/jtd/properties.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.validateProperties = exports2.error = void 0;
    var code_1 = require_code2();
    var util_1 = require_util2();
    var codegen_1 = require_codegen();
    var metadata_1 = require_metadata2();
    var nullable_1 = require_nullable();
    var error_1 = require_error2();
    var PropError;
    (function(PropError2) {
      PropError2["Additional"] = "additional";
      PropError2["Missing"] = "missing";
    })(PropError || (PropError = {}));
    exports2.error = {
      message: (cxt) => {
        const { params } = cxt;
        return params.propError ? params.propError === PropError.Additional ? "must NOT have additional properties" : `must have property '${params.missingProperty}'` : (0, error_1.typeErrorMessage)(cxt, "object");
      },
      params: (cxt) => {
        const { params } = cxt;
        return params.propError ? params.propError === PropError.Additional ? (0, codegen_1._)`{error: ${params.propError}, additionalProperty: ${params.additionalProperty}}` : (0, codegen_1._)`{error: ${params.propError}, missingProperty: ${params.missingProperty}}` : (0, error_1.typeErrorParams)(cxt, "object");
      }
    };
    var def = {
      keyword: "properties",
      schemaType: "object",
      error: exports2.error,
      code: validateProperties
    };
    function validateProperties(cxt) {
      (0, metadata_1.checkMetadata)(cxt);
      const { gen, data, parentSchema, it: it2 } = cxt;
      const { additionalProperties, nullable } = parentSchema;
      if (it2.jtdDiscriminator && nullable)
        throw new Error("JTD: nullable inside discriminator mapping");
      if (commonProperties()) {
        throw new Error("JTD: properties and optionalProperties have common members");
      }
      const [allProps, properties] = schemaProperties("properties");
      const [allOptProps, optProperties] = schemaProperties("optionalProperties");
      if (properties.length === 0 && optProperties.length === 0 && additionalProperties) {
        return;
      }
      const [valid, cond] = it2.jtdDiscriminator === void 0 ? (0, nullable_1.checkNullableObject)(cxt, data) : [gen.let("valid", false), true];
      gen.if(cond, () => gen.assign(valid, true).block(() => {
        validateProps(properties, "properties", true);
        validateProps(optProperties, "optionalProperties");
        if (!additionalProperties)
          validateAdditional();
      }));
      cxt.pass(valid);
      function commonProperties() {
        const props = parentSchema.properties;
        const optProps = parentSchema.optionalProperties;
        if (!(props && optProps))
          return false;
        for (const p in props) {
          if (Object.prototype.hasOwnProperty.call(optProps, p))
            return true;
        }
        return false;
      }
      function schemaProperties(keyword) {
        const schema = parentSchema[keyword];
        const allPs = schema ? (0, code_1.allSchemaProperties)(schema) : [];
        if (it2.jtdDiscriminator && allPs.some((p) => p === it2.jtdDiscriminator)) {
          throw new Error(`JTD: discriminator tag used in ${keyword}`);
        }
        const ps = allPs.filter((p) => !(0, util_1.alwaysValidSchema)(it2, schema[p]));
        return [allPs, ps];
      }
      function validateProps(props, keyword, required) {
        const _valid = gen.var("valid");
        for (const prop of props) {
          gen.if((0, code_1.propertyInData)(gen, data, prop, it2.opts.ownProperties), () => applyPropertySchema(prop, keyword, _valid), () => missingProperty(prop));
          cxt.ok(_valid);
        }
        function missingProperty(prop) {
          if (required) {
            gen.assign(_valid, false);
            cxt.error(false, { propError: PropError.Missing, missingProperty: prop }, { schemaPath: prop });
          } else {
            gen.assign(_valid, true);
          }
        }
      }
      function applyPropertySchema(prop, keyword, _valid) {
        cxt.subschema({
          keyword,
          schemaProp: prop,
          dataProp: prop
        }, _valid);
      }
      function validateAdditional() {
        gen.forIn("key", data, (key) => {
          const addProp = isAdditional(key, allProps, "properties", it2.jtdDiscriminator);
          const addOptProp = isAdditional(key, allOptProps, "optionalProperties");
          const extra = addProp === true ? addOptProp : addOptProp === true ? addProp : (0, codegen_1.and)(addProp, addOptProp);
          gen.if(extra, () => {
            if (it2.opts.removeAdditional) {
              gen.code((0, codegen_1._)`delete ${data}[${key}]`);
            } else {
              cxt.error(false, { propError: PropError.Additional, additionalProperty: key }, { instancePath: key, parentSchema: true });
              if (!it2.opts.allErrors)
                gen.break();
            }
          });
        });
      }
      function isAdditional(key, props, keyword, jtdDiscriminator) {
        let additional;
        if (props.length > 8) {
          const propsSchema = (0, util_1.schemaRefOrVal)(it2, parentSchema[keyword], keyword);
          additional = (0, codegen_1.not)((0, code_1.isOwnProperty)(gen, propsSchema, key));
          if (jtdDiscriminator !== void 0) {
            additional = (0, codegen_1.and)(additional, (0, codegen_1._)`${key} !== ${jtdDiscriminator}`);
          }
        } else if (props.length || jtdDiscriminator !== void 0) {
          const ps = jtdDiscriminator === void 0 ? props : [jtdDiscriminator].concat(props);
          additional = (0, codegen_1.and)(...ps.map((p) => (0, codegen_1._)`${key} !== ${p}`));
        } else {
          additional = true;
        }
        return additional;
      }
    }
    exports2.validateProperties = validateProperties;
    exports2.default = def;
  }
});

// node_modules/ajv/dist/vocabularies/jtd/optionalProperties.js
var require_optionalProperties = __commonJS({
  "node_modules/ajv/dist/vocabularies/jtd/optionalProperties.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var properties_1 = require_properties2();
    var def = {
      keyword: "optionalProperties",
      schemaType: "object",
      error: properties_1.error,
      code(cxt) {
        if (cxt.parentSchema.properties)
          return;
        (0, properties_1.validateProperties)(cxt);
      }
    };
    exports2.default = def;
  }
});

// node_modules/ajv/dist/vocabularies/jtd/discriminator.js
var require_discriminator2 = __commonJS({
  "node_modules/ajv/dist/vocabularies/jtd/discriminator.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var codegen_1 = require_codegen();
    var metadata_1 = require_metadata2();
    var nullable_1 = require_nullable();
    var error_1 = require_error2();
    var types_1 = require_types();
    var error = {
      message: (cxt) => {
        const { schema, params } = cxt;
        return params.discrError ? params.discrError === types_1.DiscrError.Tag ? `tag "${schema}" must be string` : `value of tag "${schema}" must be in mapping` : (0, error_1.typeErrorMessage)(cxt, "object");
      },
      params: (cxt) => {
        const { schema, params } = cxt;
        return params.discrError ? (0, codegen_1._)`{error: ${params.discrError}, tag: ${schema}, tagValue: ${params.tag}}` : (0, error_1.typeErrorParams)(cxt, "object");
      }
    };
    var def = {
      keyword: "discriminator",
      schemaType: "string",
      implements: ["mapping"],
      error,
      code(cxt) {
        (0, metadata_1.checkMetadata)(cxt);
        const { gen, data, schema, parentSchema } = cxt;
        const [valid, cond] = (0, nullable_1.checkNullableObject)(cxt, data);
        gen.if(cond);
        validateDiscriminator();
        gen.elseIf((0, codegen_1.not)(valid));
        cxt.error();
        gen.endIf();
        cxt.ok(valid);
        function validateDiscriminator() {
          const tag = gen.const("tag", (0, codegen_1._)`${data}${(0, codegen_1.getProperty)(schema)}`);
          gen.if((0, codegen_1._)`${tag} === undefined`);
          cxt.error(false, { discrError: types_1.DiscrError.Tag, tag });
          gen.elseIf((0, codegen_1._)`typeof ${tag} == "string"`);
          validateMapping(tag);
          gen.else();
          cxt.error(false, { discrError: types_1.DiscrError.Tag, tag }, { instancePath: schema });
          gen.endIf();
        }
        function validateMapping(tag) {
          gen.if(false);
          for (const tagValue in parentSchema.mapping) {
            gen.elseIf((0, codegen_1._)`${tag} === ${tagValue}`);
            gen.assign(valid, applyTagSchema(tagValue));
          }
          gen.else();
          cxt.error(false, { discrError: types_1.DiscrError.Mapping, tag }, { instancePath: schema, schemaPath: "mapping", parentSchema: true });
          gen.endIf();
        }
        function applyTagSchema(schemaProp) {
          const _valid = gen.name("valid");
          cxt.subschema({
            keyword: "mapping",
            schemaProp,
            jtdDiscriminator: schema
          }, _valid);
          return _valid;
        }
      }
    };
    exports2.default = def;
  }
});

// node_modules/ajv/dist/vocabularies/jtd/values.js
var require_values = __commonJS({
  "node_modules/ajv/dist/vocabularies/jtd/values.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var util_1 = require_util2();
    var codegen_1 = require_codegen();
    var metadata_1 = require_metadata2();
    var nullable_1 = require_nullable();
    var error_1 = require_error2();
    var def = {
      keyword: "values",
      schemaType: "object",
      error: (0, error_1.typeError)("object"),
      code(cxt) {
        (0, metadata_1.checkMetadata)(cxt);
        const { gen, data, schema, it: it2 } = cxt;
        const [valid, cond] = (0, nullable_1.checkNullableObject)(cxt, data);
        if ((0, util_1.alwaysValidSchema)(it2, schema)) {
          gen.if((0, codegen_1.not)((0, codegen_1.or)(cond, valid)), () => cxt.error());
        } else {
          gen.if(cond);
          gen.assign(valid, validateMap());
          gen.elseIf((0, codegen_1.not)(valid));
          cxt.error();
          gen.endIf();
        }
        cxt.ok(valid);
        function validateMap() {
          const _valid = gen.name("valid");
          if (it2.allErrors) {
            const validMap = gen.let("valid", true);
            validateValues(() => gen.assign(validMap, false));
            return validMap;
          }
          gen.var(_valid, true);
          validateValues(() => gen.break());
          return _valid;
          function validateValues(notValid) {
            gen.forIn("key", data, (key) => {
              cxt.subschema({
                keyword: "values",
                dataProp: key,
                dataPropType: util_1.Type.Str
              }, _valid);
              gen.if((0, codegen_1.not)(_valid), notValid);
            });
          }
        }
      }
    };
    exports2.default = def;
  }
});

// node_modules/ajv/dist/vocabularies/jtd/union.js
var require_union = __commonJS({
  "node_modules/ajv/dist/vocabularies/jtd/union.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var code_1 = require_code2();
    var def = {
      keyword: "union",
      schemaType: "array",
      trackErrors: true,
      code: code_1.validateUnion,
      error: { message: "must match a schema in union" }
    };
    exports2.default = def;
  }
});

// node_modules/ajv/dist/vocabularies/jtd/index.js
var require_jtd = __commonJS({
  "node_modules/ajv/dist/vocabularies/jtd/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var ref_1 = require_ref2();
    var type_1 = require_type();
    var enum_1 = require_enum2();
    var elements_1 = require_elements();
    var properties_1 = require_properties2();
    var optionalProperties_1 = require_optionalProperties();
    var discriminator_1 = require_discriminator2();
    var values_1 = require_values();
    var union_1 = require_union();
    var metadata_1 = require_metadata2();
    var jtdVocabulary = [
      "definitions",
      ref_1.default,
      type_1.default,
      enum_1.default,
      elements_1.default,
      properties_1.default,
      optionalProperties_1.default,
      discriminator_1.default,
      values_1.default,
      union_1.default,
      metadata_1.default,
      { keyword: "additionalProperties", schemaType: "boolean" },
      { keyword: "nullable", schemaType: "boolean" }
    ];
    exports2.default = jtdVocabulary;
  }
});

// node_modules/ajv/dist/refs/jtd-schema.js
var require_jtd_schema = __commonJS({
  "node_modules/ajv/dist/refs/jtd-schema.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var shared = (root) => {
      const sch = {
        nullable: { type: "boolean" },
        metadata: {
          optionalProperties: {
            union: { elements: { ref: "schema" } }
          },
          additionalProperties: true
        }
      };
      if (root)
        sch.definitions = { values: { ref: "schema" } };
      return sch;
    };
    var emptyForm = (root) => ({
      optionalProperties: shared(root)
    });
    var refForm = (root) => ({
      properties: {
        ref: { type: "string" }
      },
      optionalProperties: shared(root)
    });
    var typeForm = (root) => ({
      properties: {
        type: {
          enum: [
            "boolean",
            "timestamp",
            "string",
            "float32",
            "float64",
            "int8",
            "uint8",
            "int16",
            "uint16",
            "int32",
            "uint32"
          ]
        }
      },
      optionalProperties: shared(root)
    });
    var enumForm = (root) => ({
      properties: {
        enum: { elements: { type: "string" } }
      },
      optionalProperties: shared(root)
    });
    var elementsForm = (root) => ({
      properties: {
        elements: { ref: "schema" }
      },
      optionalProperties: shared(root)
    });
    var propertiesForm = (root) => ({
      properties: {
        properties: { values: { ref: "schema" } }
      },
      optionalProperties: {
        optionalProperties: { values: { ref: "schema" } },
        additionalProperties: { type: "boolean" },
        ...shared(root)
      }
    });
    var optionalPropertiesForm = (root) => ({
      properties: {
        optionalProperties: { values: { ref: "schema" } }
      },
      optionalProperties: {
        additionalProperties: { type: "boolean" },
        ...shared(root)
      }
    });
    var discriminatorForm = (root) => ({
      properties: {
        discriminator: { type: "string" },
        mapping: {
          values: {
            metadata: {
              union: [propertiesForm(false), optionalPropertiesForm(false)]
            }
          }
        }
      },
      optionalProperties: shared(root)
    });
    var valuesForm = (root) => ({
      properties: {
        values: { ref: "schema" }
      },
      optionalProperties: shared(root)
    });
    var schema = (root) => ({
      metadata: {
        union: [
          emptyForm,
          refForm,
          typeForm,
          enumForm,
          elementsForm,
          propertiesForm,
          optionalPropertiesForm,
          discriminatorForm,
          valuesForm
        ].map((s) => s(root))
      }
    });
    var jtdMetaSchema = {
      definitions: {
        schema: schema(false)
      },
      ...schema(true)
    };
    exports2.default = jtdMetaSchema;
  }
});

// node_modules/ajv/dist/compile/jtd/types.js
var require_types2 = __commonJS({
  "node_modules/ajv/dist/compile/jtd/types.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.jtdForms = void 0;
    exports2.jtdForms = [
      "elements",
      "values",
      "discriminator",
      "properties",
      "optionalProperties",
      "enum",
      "type",
      "ref"
    ];
  }
});

// node_modules/ajv/dist/runtime/quote.js
var require_quote = __commonJS({
  "node_modules/ajv/dist/runtime/quote.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var rxEscapable = (
      // eslint-disable-next-line no-control-regex, no-misleading-character-class
      /[\\"\u0000-\u001f\u007f-\u009f\u00ad\u0600-\u0604\u070f\u17b4\u17b5\u200c-\u200f\u2028-\u202f\u2060-\u206f\ufeff\ufff0-\uffff]/g
    );
    var escaped = {
      "\b": "\\b",
      "	": "\\t",
      "\n": "\\n",
      "\f": "\\f",
      "\r": "\\r",
      '"': '\\"',
      "\\": "\\\\"
    };
    function quote(s) {
      rxEscapable.lastIndex = 0;
      return '"' + (rxEscapable.test(s) ? s.replace(rxEscapable, (a) => {
        const c = escaped[a];
        return typeof c === "string" ? c : "\\u" + ("0000" + a.charCodeAt(0).toString(16)).slice(-4);
      }) : s) + '"';
    }
    exports2.default = quote;
    quote.code = 'require("ajv/dist/runtime/quote").default';
  }
});

// node_modules/ajv/dist/compile/jtd/serialize.js
var require_serialize = __commonJS({
  "node_modules/ajv/dist/compile/jtd/serialize.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var types_1 = require_types2();
    var __1 = require_compile();
    var codegen_1 = require_codegen();
    var ref_error_1 = require_ref_error();
    var names_1 = require_names();
    var code_1 = require_code2();
    var ref_1 = require_ref2();
    var util_1 = require_util2();
    var quote_1 = require_quote();
    var genSerialize = {
      elements: serializeElements,
      values: serializeValues,
      discriminator: serializeDiscriminator,
      properties: serializeProperties,
      optionalProperties: serializeProperties,
      enum: serializeString,
      type: serializeType,
      ref: serializeRef
    };
    function compileSerializer(sch, definitions) {
      const _sch = __1.getCompilingSchema.call(this, sch);
      if (_sch)
        return _sch;
      const { es5, lines } = this.opts.code;
      const { ownProperties } = this.opts;
      const gen = new codegen_1.CodeGen(this.scope, { es5, lines, ownProperties });
      const serializeName = gen.scopeName("serialize");
      const cxt = {
        self: this,
        gen,
        schema: sch.schema,
        schemaEnv: sch,
        definitions,
        data: names_1.default.data
      };
      let sourceCode;
      try {
        this._compilations.add(sch);
        sch.serializeName = serializeName;
        gen.func(serializeName, names_1.default.data, false, () => {
          gen.let(names_1.default.json, (0, codegen_1.str)``);
          serializeCode(cxt);
          gen.return(names_1.default.json);
        });
        gen.optimize(this.opts.code.optimize);
        const serializeFuncCode = gen.toString();
        sourceCode = `${gen.scopeRefs(names_1.default.scope)}return ${serializeFuncCode}`;
        const makeSerialize = new Function(`${names_1.default.scope}`, sourceCode);
        const serialize = makeSerialize(this.scope.get());
        this.scope.value(serializeName, { ref: serialize });
        sch.serialize = serialize;
      } catch (e) {
        if (sourceCode)
          this.logger.error("Error compiling serializer, function code:", sourceCode);
        delete sch.serialize;
        delete sch.serializeName;
        throw e;
      } finally {
        this._compilations.delete(sch);
      }
      return sch;
    }
    exports2.default = compileSerializer;
    function serializeCode(cxt) {
      let form;
      for (const key of types_1.jtdForms) {
        if (key in cxt.schema) {
          form = key;
          break;
        }
      }
      serializeNullable(cxt, form ? genSerialize[form] : serializeEmpty);
    }
    function serializeNullable(cxt, serializeForm) {
      const { gen, schema, data } = cxt;
      if (!schema.nullable)
        return serializeForm(cxt);
      gen.if((0, codegen_1._)`${data} === undefined || ${data} === null`, () => gen.add(names_1.default.json, (0, codegen_1._)`"null"`), () => serializeForm(cxt));
    }
    function serializeElements(cxt) {
      const { gen, schema, data } = cxt;
      gen.add(names_1.default.json, (0, codegen_1.str)`[`);
      const first = gen.let("first", true);
      gen.forOf("el", data, (el) => {
        addComma(cxt, first);
        serializeCode({ ...cxt, schema: schema.elements, data: el });
      });
      gen.add(names_1.default.json, (0, codegen_1.str)`]`);
    }
    function serializeValues(cxt) {
      const { gen, schema, data } = cxt;
      gen.add(names_1.default.json, (0, codegen_1.str)`{`);
      const first = gen.let("first", true);
      gen.forIn("key", data, (key) => serializeKeyValue(cxt, key, schema.values, first));
      gen.add(names_1.default.json, (0, codegen_1.str)`}`);
    }
    function serializeKeyValue(cxt, key, schema, first) {
      const { gen, data } = cxt;
      addComma(cxt, first);
      serializeString({ ...cxt, data: key });
      gen.add(names_1.default.json, (0, codegen_1.str)`:`);
      const value = gen.const("value", (0, codegen_1._)`${data}${(0, codegen_1.getProperty)(key)}`);
      serializeCode({ ...cxt, schema, data: value });
    }
    function serializeDiscriminator(cxt) {
      const { gen, schema, data } = cxt;
      const { discriminator } = schema;
      gen.add(names_1.default.json, (0, codegen_1.str)`{${JSON.stringify(discriminator)}:`);
      const tag = gen.const("tag", (0, codegen_1._)`${data}${(0, codegen_1.getProperty)(discriminator)}`);
      serializeString({ ...cxt, data: tag });
      gen.if(false);
      for (const tagValue in schema.mapping) {
        gen.elseIf((0, codegen_1._)`${tag} === ${tagValue}`);
        const sch = schema.mapping[tagValue];
        serializeSchemaProperties({ ...cxt, schema: sch }, discriminator);
      }
      gen.endIf();
      gen.add(names_1.default.json, (0, codegen_1.str)`}`);
    }
    function serializeProperties(cxt) {
      const { gen } = cxt;
      gen.add(names_1.default.json, (0, codegen_1.str)`{`);
      serializeSchemaProperties(cxt);
      gen.add(names_1.default.json, (0, codegen_1.str)`}`);
    }
    function serializeSchemaProperties(cxt, discriminator) {
      const { gen, schema, data } = cxt;
      const { properties, optionalProperties } = schema;
      const props = keys(properties);
      const optProps = keys(optionalProperties);
      const allProps = allProperties(props.concat(optProps));
      let first = !discriminator;
      let firstProp;
      for (const key of props) {
        if (first)
          first = false;
        else
          gen.add(names_1.default.json, (0, codegen_1.str)`,`);
        serializeProperty(key, properties[key], keyValue(key));
      }
      if (first)
        firstProp = gen.let("first", true);
      for (const key of optProps) {
        const value = keyValue(key);
        gen.if((0, codegen_1.and)((0, codegen_1._)`${value} !== undefined`, (0, code_1.isOwnProperty)(gen, data, key)), () => {
          addComma(cxt, firstProp);
          serializeProperty(key, optionalProperties[key], value);
        });
      }
      if (schema.additionalProperties) {
        gen.forIn("key", data, (key) => gen.if(isAdditional(key, allProps), () => serializeKeyValue(cxt, key, {}, firstProp)));
      }
      function keys(ps) {
        return ps ? Object.keys(ps) : [];
      }
      function allProperties(ps) {
        if (discriminator)
          ps.push(discriminator);
        if (new Set(ps).size !== ps.length) {
          throw new Error("JTD: properties/optionalProperties/disciminator overlap");
        }
        return ps;
      }
      function keyValue(key) {
        return gen.const("value", (0, codegen_1._)`${data}${(0, codegen_1.getProperty)(key)}`);
      }
      function serializeProperty(key, propSchema, value) {
        gen.add(names_1.default.json, (0, codegen_1.str)`${JSON.stringify(key)}:`);
        serializeCode({ ...cxt, schema: propSchema, data: value });
      }
      function isAdditional(key, ps) {
        return ps.length ? (0, codegen_1.and)(...ps.map((p) => (0, codegen_1._)`${key} !== ${p}`)) : true;
      }
    }
    function serializeType(cxt) {
      const { gen, schema, data } = cxt;
      switch (schema.type) {
        case "boolean":
          gen.add(names_1.default.json, (0, codegen_1._)`${data} ? "true" : "false"`);
          break;
        case "string":
          serializeString(cxt);
          break;
        case "timestamp":
          gen.if((0, codegen_1._)`${data} instanceof Date`, () => gen.add(names_1.default.json, (0, codegen_1._)`'"' + ${data}.toISOString() + '"'`), () => serializeString(cxt));
          break;
        default:
          serializeNumber(cxt);
      }
    }
    function serializeString({ gen, data }) {
      gen.add(names_1.default.json, (0, codegen_1._)`${(0, util_1.useFunc)(gen, quote_1.default)}(${data})`);
    }
    function serializeNumber({ gen, data }) {
      gen.add(names_1.default.json, (0, codegen_1._)`"" + ${data}`);
    }
    function serializeRef(cxt) {
      const { gen, self: self2, data, definitions, schema, schemaEnv } = cxt;
      const { ref } = schema;
      const refSchema = definitions[ref];
      if (!refSchema)
        throw new ref_error_1.default(self2.opts.uriResolver, "", ref, `No definition ${ref}`);
      if (!(0, ref_1.hasRef)(refSchema))
        return serializeCode({ ...cxt, schema: refSchema });
      const { root } = schemaEnv;
      const sch = compileSerializer.call(self2, new __1.SchemaEnv({ schema: refSchema, root }), definitions);
      gen.add(names_1.default.json, (0, codegen_1._)`${getSerialize(gen, sch)}(${data})`);
    }
    function getSerialize(gen, sch) {
      return sch.serialize ? gen.scopeValue("serialize", { ref: sch.serialize }) : (0, codegen_1._)`${gen.scopeValue("wrapper", { ref: sch })}.serialize`;
    }
    function serializeEmpty({ gen, data }) {
      gen.add(names_1.default.json, (0, codegen_1._)`JSON.stringify(${data})`);
    }
    function addComma({ gen }, first) {
      if (first) {
        gen.if(first, () => gen.assign(first, false), () => gen.add(names_1.default.json, (0, codegen_1.str)`,`));
      } else {
        gen.add(names_1.default.json, (0, codegen_1.str)`,`);
      }
    }
  }
});

// node_modules/ajv/dist/runtime/parseJson.js
var require_parseJson = __commonJS({
  "node_modules/ajv/dist/runtime/parseJson.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.parseJsonString = exports2.parseJsonNumber = exports2.parseJson = void 0;
    var rxParseJson = /position\s(\d+)(?: \(line \d+ column \d+\))?$/;
    function parseJson(s, pos) {
      let endPos;
      parseJson.message = void 0;
      let matches;
      if (pos)
        s = s.slice(pos);
      try {
        parseJson.position = pos + s.length;
        return JSON.parse(s);
      } catch (e) {
        matches = rxParseJson.exec(e.message);
        if (!matches) {
          parseJson.message = "unexpected end";
          return void 0;
        }
        endPos = +matches[1];
        const c = s[endPos];
        s = s.slice(0, endPos);
        parseJson.position = pos + endPos;
        try {
          return JSON.parse(s);
        } catch (e1) {
          parseJson.message = `unexpected token ${c}`;
          return void 0;
        }
      }
    }
    exports2.parseJson = parseJson;
    parseJson.message = void 0;
    parseJson.position = 0;
    parseJson.code = 'require("ajv/dist/runtime/parseJson").parseJson';
    function parseJsonNumber(s, pos, maxDigits) {
      let numStr = "";
      let c;
      parseJsonNumber.message = void 0;
      if (s[pos] === "-") {
        numStr += "-";
        pos++;
      }
      if (s[pos] === "0") {
        numStr += "0";
        pos++;
      } else {
        if (!parseDigits(maxDigits)) {
          errorMessage();
          return void 0;
        }
      }
      if (maxDigits) {
        parseJsonNumber.position = pos;
        return +numStr;
      }
      if (s[pos] === ".") {
        numStr += ".";
        pos++;
        if (!parseDigits()) {
          errorMessage();
          return void 0;
        }
      }
      if (c = s[pos], c === "e" || c === "E") {
        numStr += "e";
        pos++;
        if (c = s[pos], c === "+" || c === "-") {
          numStr += c;
          pos++;
        }
        if (!parseDigits()) {
          errorMessage();
          return void 0;
        }
      }
      parseJsonNumber.position = pos;
      return +numStr;
      function parseDigits(maxLen) {
        let digit = false;
        while (c = s[pos], c >= "0" && c <= "9" && (maxLen === void 0 || maxLen-- > 0)) {
          digit = true;
          numStr += c;
          pos++;
        }
        return digit;
      }
      function errorMessage() {
        parseJsonNumber.position = pos;
        parseJsonNumber.message = pos < s.length ? `unexpected token ${s[pos]}` : "unexpected end";
      }
    }
    exports2.parseJsonNumber = parseJsonNumber;
    parseJsonNumber.message = void 0;
    parseJsonNumber.position = 0;
    parseJsonNumber.code = 'require("ajv/dist/runtime/parseJson").parseJsonNumber';
    var escapedChars = {
      b: "\b",
      f: "\f",
      n: "\n",
      r: "\r",
      t: "	",
      '"': '"',
      "/": "/",
      "\\": "\\"
    };
    var CODE_A = "a".charCodeAt(0);
    var CODE_0 = "0".charCodeAt(0);
    function parseJsonString(s, pos) {
      let str = "";
      let c;
      parseJsonString.message = void 0;
      while (true) {
        c = s[pos++];
        if (c === '"')
          break;
        if (c === "\\") {
          c = s[pos];
          if (c in escapedChars) {
            str += escapedChars[c];
            pos++;
          } else if (c === "u") {
            pos++;
            let count = 4;
            let code = 0;
            while (count--) {
              code <<= 4;
              c = s[pos];
              if (c === void 0) {
                errorMessage("unexpected end");
                return void 0;
              }
              c = c.toLowerCase();
              if (c >= "a" && c <= "f") {
                code += c.charCodeAt(0) - CODE_A + 10;
              } else if (c >= "0" && c <= "9") {
                code += c.charCodeAt(0) - CODE_0;
              } else {
                errorMessage(`unexpected token ${c}`);
                return void 0;
              }
              pos++;
            }
            str += String.fromCharCode(code);
          } else {
            errorMessage(`unexpected token ${c}`);
            return void 0;
          }
        } else if (c === void 0) {
          errorMessage("unexpected end");
          return void 0;
        } else {
          if (c.charCodeAt(0) >= 32) {
            str += c;
          } else {
            errorMessage(`unexpected token ${c}`);
            return void 0;
          }
        }
      }
      parseJsonString.position = pos;
      return str;
      function errorMessage(msg) {
        parseJsonString.position = pos;
        parseJsonString.message = msg;
      }
    }
    exports2.parseJsonString = parseJsonString;
    parseJsonString.message = void 0;
    parseJsonString.position = 0;
    parseJsonString.code = 'require("ajv/dist/runtime/parseJson").parseJsonString';
  }
});

// node_modules/ajv/dist/compile/jtd/parse.js
var require_parse3 = __commonJS({
  "node_modules/ajv/dist/compile/jtd/parse.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var types_1 = require_types2();
    var __1 = require_compile();
    var codegen_1 = require_codegen();
    var ref_error_1 = require_ref_error();
    var names_1 = require_names();
    var code_1 = require_code2();
    var ref_1 = require_ref2();
    var type_1 = require_type();
    var parseJson_1 = require_parseJson();
    var util_1 = require_util2();
    var timestamp_1 = require_timestamp();
    var genParse = {
      elements: parseElements,
      values: parseValues,
      discriminator: parseDiscriminator,
      properties: parseProperties,
      optionalProperties: parseProperties,
      enum: parseEnum,
      type: parseType,
      ref: parseRef
    };
    function compileParser(sch, definitions) {
      const _sch = __1.getCompilingSchema.call(this, sch);
      if (_sch)
        return _sch;
      const { es5, lines } = this.opts.code;
      const { ownProperties } = this.opts;
      const gen = new codegen_1.CodeGen(this.scope, { es5, lines, ownProperties });
      const parseName = gen.scopeName("parse");
      const cxt = {
        self: this,
        gen,
        schema: sch.schema,
        schemaEnv: sch,
        definitions,
        data: names_1.default.data,
        parseName,
        char: gen.name("c")
      };
      let sourceCode;
      try {
        this._compilations.add(sch);
        sch.parseName = parseName;
        parserFunction(cxt);
        gen.optimize(this.opts.code.optimize);
        const parseFuncCode = gen.toString();
        sourceCode = `${gen.scopeRefs(names_1.default.scope)}return ${parseFuncCode}`;
        const makeParse = new Function(`${names_1.default.scope}`, sourceCode);
        const parse = makeParse(this.scope.get());
        this.scope.value(parseName, { ref: parse });
        sch.parse = parse;
      } catch (e) {
        if (sourceCode)
          this.logger.error("Error compiling parser, function code:", sourceCode);
        delete sch.parse;
        delete sch.parseName;
        throw e;
      } finally {
        this._compilations.delete(sch);
      }
      return sch;
    }
    exports2.default = compileParser;
    var undef = (0, codegen_1._)`undefined`;
    function parserFunction(cxt) {
      const { gen, parseName, char } = cxt;
      gen.func(parseName, (0, codegen_1._)`${names_1.default.json}, ${names_1.default.jsonPos}, ${names_1.default.jsonPart}`, false, () => {
        gen.let(names_1.default.data);
        gen.let(char);
        gen.assign((0, codegen_1._)`${parseName}.message`, undef);
        gen.assign((0, codegen_1._)`${parseName}.position`, undef);
        gen.assign(names_1.default.jsonPos, (0, codegen_1._)`${names_1.default.jsonPos} || 0`);
        gen.const(names_1.default.jsonLen, (0, codegen_1._)`${names_1.default.json}.length`);
        parseCode(cxt);
        skipWhitespace(cxt);
        gen.if(names_1.default.jsonPart, () => {
          gen.assign((0, codegen_1._)`${parseName}.position`, names_1.default.jsonPos);
          gen.return(names_1.default.data);
        });
        gen.if((0, codegen_1._)`${names_1.default.jsonPos} === ${names_1.default.jsonLen}`, () => gen.return(names_1.default.data));
        jsonSyntaxError(cxt);
      });
    }
    function parseCode(cxt) {
      let form;
      for (const key of types_1.jtdForms) {
        if (key in cxt.schema) {
          form = key;
          break;
        }
      }
      if (form)
        parseNullable(cxt, genParse[form]);
      else
        parseEmpty(cxt);
    }
    var parseBoolean = parseBooleanToken(true, parseBooleanToken(false, jsonSyntaxError));
    function parseNullable(cxt, parseForm) {
      const { gen, schema, data } = cxt;
      if (!schema.nullable)
        return parseForm(cxt);
      tryParseToken(cxt, "null", parseForm, () => gen.assign(data, null));
    }
    function parseElements(cxt) {
      const { gen, schema, data } = cxt;
      parseToken(cxt, "[");
      const ix = gen.let("i", 0);
      gen.assign(data, (0, codegen_1._)`[]`);
      parseItems(cxt, "]", () => {
        const el = gen.let("el");
        parseCode({ ...cxt, schema: schema.elements, data: el });
        gen.assign((0, codegen_1._)`${data}[${ix}++]`, el);
      });
    }
    function parseValues(cxt) {
      const { gen, schema, data } = cxt;
      parseToken(cxt, "{");
      gen.assign(data, (0, codegen_1._)`{}`);
      parseItems(cxt, "}", () => parseKeyValue(cxt, schema.values));
    }
    function parseItems(cxt, endToken, block) {
      tryParseItems(cxt, endToken, block);
      parseToken(cxt, endToken);
    }
    function tryParseItems(cxt, endToken, block) {
      const { gen } = cxt;
      gen.for((0, codegen_1._)`;${names_1.default.jsonPos}<${names_1.default.jsonLen} && ${jsonSlice(1)}!==${endToken};`, () => {
        block();
        tryParseToken(cxt, ",", () => gen.break(), hasItem);
      });
      function hasItem() {
        tryParseToken(cxt, endToken, () => {
        }, jsonSyntaxError);
      }
    }
    function parseKeyValue(cxt, schema) {
      const { gen } = cxt;
      const key = gen.let("key");
      parseString({ ...cxt, data: key });
      parseToken(cxt, ":");
      parsePropertyValue(cxt, key, schema);
    }
    function parseDiscriminator(cxt) {
      const { gen, data, schema } = cxt;
      const { discriminator, mapping } = schema;
      parseToken(cxt, "{");
      gen.assign(data, (0, codegen_1._)`{}`);
      const startPos = gen.const("pos", names_1.default.jsonPos);
      const value = gen.let("value");
      const tag = gen.let("tag");
      tryParseItems(cxt, "}", () => {
        const key = gen.let("key");
        parseString({ ...cxt, data: key });
        parseToken(cxt, ":");
        gen.if(
          (0, codegen_1._)`${key} === ${discriminator}`,
          () => {
            parseString({ ...cxt, data: tag });
            gen.assign((0, codegen_1._)`${data}[${key}]`, tag);
            gen.break();
          },
          () => parseEmpty({ ...cxt, data: value })
          // can be discarded/skipped
        );
      });
      gen.assign(names_1.default.jsonPos, startPos);
      gen.if((0, codegen_1._)`${tag} === undefined`);
      parsingError(cxt, (0, codegen_1.str)`discriminator tag not found`);
      for (const tagValue in mapping) {
        gen.elseIf((0, codegen_1._)`${tag} === ${tagValue}`);
        parseSchemaProperties({ ...cxt, schema: mapping[tagValue] }, discriminator);
      }
      gen.else();
      parsingError(cxt, (0, codegen_1.str)`discriminator value not in schema`);
      gen.endIf();
    }
    function parseProperties(cxt) {
      const { gen, data } = cxt;
      parseToken(cxt, "{");
      gen.assign(data, (0, codegen_1._)`{}`);
      parseSchemaProperties(cxt);
    }
    function parseSchemaProperties(cxt, discriminator) {
      const { gen, schema, data } = cxt;
      const { properties, optionalProperties, additionalProperties } = schema;
      parseItems(cxt, "}", () => {
        const key = gen.let("key");
        parseString({ ...cxt, data: key });
        parseToken(cxt, ":");
        gen.if(false);
        parseDefinedProperty(cxt, key, properties);
        parseDefinedProperty(cxt, key, optionalProperties);
        if (discriminator) {
          gen.elseIf((0, codegen_1._)`${key} === ${discriminator}`);
          const tag = gen.let("tag");
          parseString({ ...cxt, data: tag });
        }
        gen.else();
        if (additionalProperties) {
          parseEmpty({ ...cxt, data: (0, codegen_1._)`${data}[${key}]` });
        } else {
          parsingError(cxt, (0, codegen_1.str)`property ${key} not allowed`);
        }
        gen.endIf();
      });
      if (properties) {
        const hasProp = (0, code_1.hasPropFunc)(gen);
        const allProps = (0, codegen_1.and)(...Object.keys(properties).map((p) => (0, codegen_1._)`${hasProp}.call(${data}, ${p})`));
        gen.if((0, codegen_1.not)(allProps), () => parsingError(cxt, (0, codegen_1.str)`missing required properties`));
      }
    }
    function parseDefinedProperty(cxt, key, schemas = {}) {
      const { gen } = cxt;
      for (const prop in schemas) {
        gen.elseIf((0, codegen_1._)`${key} === ${prop}`);
        parsePropertyValue(cxt, key, schemas[prop]);
      }
    }
    function parsePropertyValue(cxt, key, schema) {
      parseCode({ ...cxt, schema, data: (0, codegen_1._)`${cxt.data}[${key}]` });
    }
    function parseType(cxt) {
      const { gen, schema, data, self: self2 } = cxt;
      switch (schema.type) {
        case "boolean":
          parseBoolean(cxt);
          break;
        case "string":
          parseString(cxt);
          break;
        case "timestamp": {
          parseString(cxt);
          const vts = (0, util_1.useFunc)(gen, timestamp_1.default);
          const { allowDate, parseDate } = self2.opts;
          const notValid = allowDate ? (0, codegen_1._)`!${vts}(${data}, true)` : (0, codegen_1._)`!${vts}(${data})`;
          const fail = parseDate ? (0, codegen_1.or)(notValid, (0, codegen_1._)`(${data} = new Date(${data}), false)`, (0, codegen_1._)`isNaN(${data}.valueOf())`) : notValid;
          gen.if(fail, () => parsingError(cxt, (0, codegen_1.str)`invalid timestamp`));
          break;
        }
        case "float32":
        case "float64":
          parseNumber(cxt);
          break;
        default: {
          const t = schema.type;
          if (!self2.opts.int32range && (t === "int32" || t === "uint32")) {
            parseNumber(cxt, 16);
            if (t === "uint32") {
              gen.if((0, codegen_1._)`${data} < 0`, () => parsingError(cxt, (0, codegen_1.str)`integer out of range`));
            }
          } else {
            const [min, max, maxDigits] = type_1.intRange[t];
            parseNumber(cxt, maxDigits);
            gen.if((0, codegen_1._)`${data} < ${min} || ${data} > ${max}`, () => parsingError(cxt, (0, codegen_1.str)`integer out of range`));
          }
        }
      }
    }
    function parseString(cxt) {
      parseToken(cxt, '"');
      parseWith(cxt, parseJson_1.parseJsonString);
    }
    function parseEnum(cxt) {
      const { gen, data, schema } = cxt;
      const enumSch = schema.enum;
      parseToken(cxt, '"');
      gen.if(false);
      for (const value of enumSch) {
        const valueStr = JSON.stringify(value).slice(1);
        gen.elseIf((0, codegen_1._)`${jsonSlice(valueStr.length)} === ${valueStr}`);
        gen.assign(data, (0, codegen_1.str)`${value}`);
        gen.add(names_1.default.jsonPos, valueStr.length);
      }
      gen.else();
      jsonSyntaxError(cxt);
      gen.endIf();
    }
    function parseNumber(cxt, maxDigits) {
      const { gen } = cxt;
      skipWhitespace(cxt);
      gen.if((0, codegen_1._)`"-0123456789".indexOf(${jsonSlice(1)}) < 0`, () => jsonSyntaxError(cxt), () => parseWith(cxt, parseJson_1.parseJsonNumber, maxDigits));
    }
    function parseBooleanToken(bool, fail) {
      return (cxt) => {
        const { gen, data } = cxt;
        tryParseToken(cxt, `${bool}`, () => fail(cxt), () => gen.assign(data, bool));
      };
    }
    function parseRef(cxt) {
      const { gen, self: self2, definitions, schema, schemaEnv } = cxt;
      const { ref } = schema;
      const refSchema = definitions[ref];
      if (!refSchema)
        throw new ref_error_1.default(self2.opts.uriResolver, "", ref, `No definition ${ref}`);
      if (!(0, ref_1.hasRef)(refSchema))
        return parseCode({ ...cxt, schema: refSchema });
      const { root } = schemaEnv;
      const sch = compileParser.call(self2, new __1.SchemaEnv({ schema: refSchema, root }), definitions);
      partialParse(cxt, getParser(gen, sch), true);
    }
    function getParser(gen, sch) {
      return sch.parse ? gen.scopeValue("parse", { ref: sch.parse }) : (0, codegen_1._)`${gen.scopeValue("wrapper", { ref: sch })}.parse`;
    }
    function parseEmpty(cxt) {
      parseWith(cxt, parseJson_1.parseJson);
    }
    function parseWith(cxt, parseFunc, args) {
      partialParse(cxt, (0, util_1.useFunc)(cxt.gen, parseFunc), args);
    }
    function partialParse(cxt, parseFunc, args) {
      const { gen, data } = cxt;
      gen.assign(data, (0, codegen_1._)`${parseFunc}(${names_1.default.json}, ${names_1.default.jsonPos}${args ? (0, codegen_1._)`, ${args}` : codegen_1.nil})`);
      gen.assign(names_1.default.jsonPos, (0, codegen_1._)`${parseFunc}.position`);
      gen.if((0, codegen_1._)`${data} === undefined`, () => parsingError(cxt, (0, codegen_1._)`${parseFunc}.message`));
    }
    function parseToken(cxt, tok) {
      tryParseToken(cxt, tok, jsonSyntaxError);
    }
    function tryParseToken(cxt, tok, fail, success) {
      const { gen } = cxt;
      const n = tok.length;
      skipWhitespace(cxt);
      gen.if((0, codegen_1._)`${jsonSlice(n)} === ${tok}`, () => {
        gen.add(names_1.default.jsonPos, n);
        success === null || success === void 0 ? void 0 : success(cxt);
      }, () => fail(cxt));
    }
    function skipWhitespace({ gen, char: c }) {
      gen.code((0, codegen_1._)`while((${c}=${names_1.default.json}[${names_1.default.jsonPos}],${c}===" "||${c}==="\\n"||${c}==="\\r"||${c}==="\\t"))${names_1.default.jsonPos}++;`);
    }
    function jsonSlice(len) {
      return len === 1 ? (0, codegen_1._)`${names_1.default.json}[${names_1.default.jsonPos}]` : (0, codegen_1._)`${names_1.default.json}.slice(${names_1.default.jsonPos}, ${names_1.default.jsonPos}+${len})`;
    }
    function jsonSyntaxError(cxt) {
      parsingError(cxt, (0, codegen_1._)`"unexpected token " + ${names_1.default.json}[${names_1.default.jsonPos}]`);
    }
    function parsingError({ gen, parseName }, msg) {
      gen.assign((0, codegen_1._)`${parseName}.message`, msg);
      gen.assign((0, codegen_1._)`${parseName}.position`, names_1.default.jsonPos);
      gen.return(undef);
    }
  }
});

// node_modules/ajv/dist/jtd.js
var require_jtd2 = __commonJS({
  "node_modules/ajv/dist/jtd.js"(exports2, module2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.MissingRefError = exports2.ValidationError = exports2.CodeGen = exports2.Name = exports2.nil = exports2.stringify = exports2.str = exports2._ = exports2.KeywordCxt = exports2.Ajv = void 0;
    var core_1 = require_core();
    var jtd_1 = require_jtd();
    var jtd_schema_1 = require_jtd_schema();
    var serialize_1 = require_serialize();
    var parse_1 = require_parse3();
    var META_SCHEMA_ID = "JTD-meta-schema";
    var Ajv = class extends core_1.default {
      constructor(opts = {}) {
        super({
          ...opts,
          jtd: true
        });
      }
      _addVocabularies() {
        super._addVocabularies();
        this.addVocabulary(jtd_1.default);
      }
      _addDefaultMetaSchema() {
        super._addDefaultMetaSchema();
        if (!this.opts.meta)
          return;
        this.addMetaSchema(jtd_schema_1.default, META_SCHEMA_ID, false);
      }
      defaultMeta() {
        return this.opts.defaultMeta = super.defaultMeta() || (this.getSchema(META_SCHEMA_ID) ? META_SCHEMA_ID : void 0);
      }
      compileSerializer(schema) {
        const sch = this._addSchema(schema);
        return sch.serialize || this._compileSerializer(sch);
      }
      compileParser(schema) {
        const sch = this._addSchema(schema);
        return sch.parse || this._compileParser(sch);
      }
      _compileSerializer(sch) {
        serialize_1.default.call(this, sch, sch.schema.definitions || {});
        if (!sch.serialize)
          throw new Error("ajv implementation error");
        return sch.serialize;
      }
      _compileParser(sch) {
        parse_1.default.call(this, sch, sch.schema.definitions || {});
        if (!sch.parse)
          throw new Error("ajv implementation error");
        return sch.parse;
      }
    };
    exports2.Ajv = Ajv;
    module2.exports = exports2 = Ajv;
    module2.exports.Ajv = Ajv;
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.default = Ajv;
    var validate_1 = require_validate();
    Object.defineProperty(exports2, "KeywordCxt", { enumerable: true, get: function() {
      return validate_1.KeywordCxt;
    } });
    var codegen_1 = require_codegen();
    Object.defineProperty(exports2, "_", { enumerable: true, get: function() {
      return codegen_1._;
    } });
    Object.defineProperty(exports2, "str", { enumerable: true, get: function() {
      return codegen_1.str;
    } });
    Object.defineProperty(exports2, "stringify", { enumerable: true, get: function() {
      return codegen_1.stringify;
    } });
    Object.defineProperty(exports2, "nil", { enumerable: true, get: function() {
      return codegen_1.nil;
    } });
    Object.defineProperty(exports2, "Name", { enumerable: true, get: function() {
      return codegen_1.Name;
    } });
    Object.defineProperty(exports2, "CodeGen", { enumerable: true, get: function() {
      return codegen_1.CodeGen;
    } });
    var validation_error_1 = require_validation_error();
    Object.defineProperty(exports2, "ValidationError", { enumerable: true, get: function() {
      return validation_error_1.default;
    } });
    var ref_error_1 = require_ref_error();
    Object.defineProperty(exports2, "MissingRefError", { enumerable: true, get: function() {
      return ref_error_1.default;
    } });
  }
});

// node_modules/@fastify/ajv-compiler/lib/default-ajv-options.js
var require_default_ajv_options = __commonJS({
  "node_modules/@fastify/ajv-compiler/lib/default-ajv-options.js"(exports2, module2) {
    "use strict";
    var fastUri = require_fast_uri();
    module2.exports = Object.freeze({
      coerceTypes: "array",
      useDefaults: true,
      removeAdditional: true,
      uriResolver: fastUri,
      addUsedSchema: false,
      // Explicitly set allErrors to `false`.
      // When set to `true`, a DoS attack is possible.
      allErrors: false
    });
  }
});

// node_modules/@fastify/ajv-compiler/lib/validator-compiler.js
var require_validator_compiler = __commonJS({
  "node_modules/@fastify/ajv-compiler/lib/validator-compiler.js"(exports2, module2) {
    "use strict";
    var Ajv = require_ajv().default;
    var AjvJTD = require_jtd2();
    var defaultAjvOptions = require_default_ajv_options();
    var ValidatorCompiler = class {
      constructor(externalSchemas, options) {
        if (options.mode === "JTD") {
          this.ajv = new AjvJTD(Object.assign({}, defaultAjvOptions, options.customOptions));
        } else {
          this.ajv = new Ajv(Object.assign({}, defaultAjvOptions, options.customOptions));
        }
        let addFormatPlugin = true;
        if (options.plugins && options.plugins.length > 0) {
          for (const plugin of options.plugins) {
            if (Array.isArray(plugin)) {
              addFormatPlugin = addFormatPlugin && plugin[0].name !== "formatsPlugin";
              plugin[0](this.ajv, plugin[1]);
            } else {
              addFormatPlugin = addFormatPlugin && plugin.name !== "formatsPlugin";
              plugin(this.ajv);
            }
          }
        }
        if (addFormatPlugin) {
          require_dist2()(this.ajv);
        }
        options.onCreate?.(this.ajv);
        const sourceSchemas = Object.values(externalSchemas);
        for (const extSchema of sourceSchemas) {
          this.ajv.addSchema(extSchema);
        }
      }
      buildValidatorFunction({
        schema
        /*, method, url, httpPart */
      }) {
        if (schema.$id) {
          const stored = this.ajv.getSchema(schema.$id);
          if (stored) {
            return stored;
          }
        }
        return this.ajv.compile(schema);
      }
    };
    module2.exports = ValidatorCompiler;
  }
});

// node_modules/@fastify/ajv-compiler/lib/serializer-compiler.js
var require_serializer_compiler = __commonJS({
  "node_modules/@fastify/ajv-compiler/lib/serializer-compiler.js"(exports2, module2) {
    "use strict";
    var AjvJTD = require_jtd2();
    var defaultAjvOptions = require_default_ajv_options();
    var SerializerCompiler = class {
      constructor(_externalSchemas, options) {
        this.ajv = new AjvJTD(Object.assign({}, defaultAjvOptions, options));
      }
      buildSerializerFunction({
        schema
        /*, method, url, httpStatus */
      }) {
        return this.ajv.compileSerializer(schema);
      }
    };
    module2.exports = SerializerCompiler;
  }
});

// node_modules/ajv/dist/standalone/index.js
var require_standalone3 = __commonJS({
  "node_modules/ajv/dist/standalone/index.js"(exports2, module2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var scope_1 = require_scope();
    var code_1 = require_code();
    function standaloneCode(ajv, refsOrFunc) {
      if (!ajv.opts.code.source) {
        throw new Error("moduleCode: ajv instance must have code.source option");
      }
      const { _n } = ajv.scope.opts;
      return typeof refsOrFunc == "function" ? funcExportCode(refsOrFunc.source) : refsOrFunc !== void 0 ? multiExportsCode(refsOrFunc, getValidate) : multiExportsCode(ajv.schemas, (sch) => sch.meta ? void 0 : ajv.compile(sch.schema));
      function getValidate(id2) {
        const v = ajv.getSchema(id2);
        if (!v)
          throw new Error(`moduleCode: no schema with id ${id2}`);
        return v;
      }
      function funcExportCode(source) {
        const usedValues = {};
        const n = source === null || source === void 0 ? void 0 : source.validateName;
        const vCode = validateCode(usedValues, source);
        if (ajv.opts.code.esm) {
          return `"use strict";${_n}export const validate = ${n};${_n}export default ${n};${_n}${vCode}`;
        }
        return `"use strict";${_n}module.exports = ${n};${_n}module.exports.default = ${n};${_n}${vCode}`;
      }
      function multiExportsCode(schemas, getValidateFunc) {
        var _a;
        const usedValues = {};
        let code = (0, code_1._)`"use strict";`;
        for (const name in schemas) {
          const v = getValidateFunc(schemas[name]);
          if (v) {
            const vCode = validateCode(usedValues, v.source);
            const exportSyntax = ajv.opts.code.esm ? (0, code_1._)`export const ${(0, code_1.getEsmExportName)(name)}` : (0, code_1._)`exports${(0, code_1.getProperty)(name)}`;
            code = (0, code_1._)`${code}${_n}${exportSyntax} = ${(_a = v.source) === null || _a === void 0 ? void 0 : _a.validateName};${_n}${vCode}`;
          }
        }
        return `${code}`;
      }
      function validateCode(usedValues, s) {
        if (!s)
          throw new Error('moduleCode: function does not have "source" property');
        if (usedState(s.validateName) === scope_1.UsedValueState.Completed)
          return code_1.nil;
        setUsedState(s.validateName, scope_1.UsedValueState.Started);
        const scopeCode = ajv.scope.scopeCode(s.scopeValues, usedValues, refValidateCode);
        const code = new code_1._Code(`${scopeCode}${_n}${s.validateCode}`);
        return s.evaluated ? (0, code_1._)`${code}${s.validateName}.evaluated = ${s.evaluated};${_n}` : code;
        function refValidateCode(n) {
          var _a;
          const vRef = (_a = n.value) === null || _a === void 0 ? void 0 : _a.ref;
          if (n.prefix === "validate" && typeof vRef == "function") {
            const v = vRef;
            return validateCode(usedValues, v.source);
          } else if ((n.prefix === "root" || n.prefix === "wrapper") && typeof vRef == "object") {
            const { validate, validateName } = vRef;
            if (!validateName)
              throw new Error("ajv internal error");
            const def = ajv.opts.code.es5 ? scope_1.varKinds.var : scope_1.varKinds.const;
            const wrapper = (0, code_1._)`${def} ${n} = {validate: ${validateName}};`;
            if (usedState(validateName) === scope_1.UsedValueState.Started)
              return wrapper;
            const vCode = validateCode(usedValues, validate === null || validate === void 0 ? void 0 : validate.source);
            return (0, code_1._)`${wrapper}${_n}${vCode}`;
          }
          return void 0;
        }
        function usedState(name) {
          var _a;
          return (_a = usedValues[name.prefix]) === null || _a === void 0 ? void 0 : _a.get(name);
        }
        function setUsedState(name, state) {
          const { prefix } = name;
          const names = usedValues[prefix] = usedValues[prefix] || /* @__PURE__ */ new Map();
          names.set(name, state);
        }
      }
    }
    module2.exports = exports2 = standaloneCode;
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.default = standaloneCode;
  }
});

// node_modules/@fastify/ajv-compiler/standalone.js
var require_standalone4 = __commonJS({
  "node_modules/@fastify/ajv-compiler/standalone.js"(exports2, module2) {
    "use strict";
    var ValidatorSelector = require_ajv_compiler();
    var standaloneCode = require_standalone3().default;
    function StandaloneValidator(options = { readMode: true }) {
      if (options.readMode === true && !options.restoreFunction) {
        throw new Error("You must provide a restoreFunction options when readMode ON");
      }
      if (options.readMode !== true && !options.storeFunction) {
        throw new Error("You must provide a storeFunction options when readMode OFF");
      }
      if (options.readMode === true) {
        return function wrapper() {
          return function(opts) {
            return options.restoreFunction(opts);
          };
        };
      }
      const factory = ValidatorSelector();
      return function wrapper(externalSchemas, ajvOptions = {}) {
        if (!ajvOptions.customOptions || !ajvOptions.customOptions.code) {
          ajvOptions.customOptions = Object.assign({}, ajvOptions.customOptions, { code: { source: true } });
        }
        const compiler = factory(externalSchemas, ajvOptions);
        return function(opts) {
          const validationFunc = compiler(opts);
          const schemaValidationCode = standaloneCode(compiler[ValidatorSelector.AjvReference].ajv, validationFunc);
          options.storeFunction(opts, schemaValidationCode);
          return validationFunc;
        };
      };
    }
    module2.exports = StandaloneValidator;
  }
});

// node_modules/@fastify/ajv-compiler/index.js
var require_ajv_compiler = __commonJS({
  "node_modules/@fastify/ajv-compiler/index.js"(exports2, module2) {
    "use strict";
    var AjvReference = Symbol.for("fastify.ajv-compiler.reference");
    var ValidatorCompiler = require_validator_compiler();
    var SerializerCompiler = require_serializer_compiler();
    function AjvCompiler(opts) {
      const validatorPool = /* @__PURE__ */ new Map();
      const serializerPool = /* @__PURE__ */ new Map();
      if (opts && opts.jtdSerializer === true) {
        return function buildSerializerFromPool(externalSchemas, serializerOpts) {
          const uniqueAjvKey = getPoolKey({}, serializerOpts);
          if (serializerPool.has(uniqueAjvKey)) {
            return serializerPool.get(uniqueAjvKey);
          }
          const compiler = new SerializerCompiler(externalSchemas, serializerOpts);
          const ret = compiler.buildSerializerFunction.bind(compiler);
          serializerPool.set(uniqueAjvKey, ret);
          return ret;
        };
      }
      return function buildCompilerFromPool(externalSchemas, options) {
        const uniqueAjvKey = getPoolKey(externalSchemas, options.customOptions);
        if (validatorPool.has(uniqueAjvKey)) {
          return validatorPool.get(uniqueAjvKey);
        }
        const compiler = new ValidatorCompiler(externalSchemas, options);
        const ret = compiler.buildValidatorFunction.bind(compiler);
        validatorPool.set(uniqueAjvKey, ret);
        if (options.customOptions.code !== void 0) {
          ret[AjvReference] = compiler;
        }
        return ret;
      };
    }
    function getPoolKey(externalSchemas, options) {
      const externals = JSON.stringify(externalSchemas);
      const ajvConfig = JSON.stringify(options);
      return `${externals}${ajvConfig}`;
    }
    module2.exports = AjvCompiler;
    module2.exports.default = AjvCompiler;
    module2.exports.AjvCompiler = AjvCompiler;
    module2.exports.AjvReference = AjvReference;
    module2.exports.StandaloneValidator = require_standalone4();
  }
});

// node_modules/fastify/lib/schema-controller.js
var require_schema_controller = __commonJS({
  "node_modules/fastify/lib/schema-controller.js"(exports2, module2) {
    "use strict";
    var { buildSchemas } = require_schemas();
    var SerializerSelector = require_fast_json_stringify_compiler();
    var ValidatorSelector = require_ajv_compiler();
    function buildSchemaController(parentSchemaCtrl, opts) {
      if (parentSchemaCtrl) {
        return new SchemaController(parentSchemaCtrl, opts);
      }
      const compilersFactory = Object.assign({
        buildValidator: null,
        buildSerializer: null
      }, opts?.compilersFactory);
      if (!compilersFactory.buildValidator) {
        compilersFactory.buildValidator = ValidatorSelector();
      }
      if (!compilersFactory.buildSerializer) {
        compilersFactory.buildSerializer = SerializerSelector();
      }
      const option = {
        bucket: opts && opts.bucket || buildSchemas,
        compilersFactory,
        isCustomValidatorCompiler: typeof opts?.compilersFactory?.buildValidator === "function",
        isCustomSerializerCompiler: typeof opts?.compilersFactory?.buildValidator === "function"
      };
      return new SchemaController(void 0, option);
    }
    var SchemaController = class {
      constructor(parent, options) {
        this.opts = options || parent?.opts;
        this.addedSchemas = false;
        this.compilersFactory = this.opts.compilersFactory;
        if (parent) {
          this.schemaBucket = this.opts.bucket(parent.getSchemas());
          this.validatorCompiler = parent.getValidatorCompiler();
          this.serializerCompiler = parent.getSerializerCompiler();
          this.isCustomValidatorCompiler = parent.isCustomValidatorCompiler;
          this.isCustomSerializerCompiler = parent.isCustomSerializerCompiler;
          this.parent = parent;
        } else {
          this.schemaBucket = this.opts.bucket();
          this.isCustomValidatorCompiler = this.opts.isCustomValidatorCompiler || false;
          this.isCustomSerializerCompiler = this.opts.isCustomSerializerCompiler || false;
        }
      }
      // Bucket interface
      add(schema) {
        this.addedSchemas = true;
        return this.schemaBucket.add(schema);
      }
      getSchema(schemaId) {
        return this.schemaBucket.getSchema(schemaId);
      }
      getSchemas() {
        return this.schemaBucket.getSchemas();
      }
      setValidatorCompiler(validatorCompiler) {
        this.compilersFactory = Object.assign(
          {},
          this.compilersFactory,
          { buildValidator: () => validatorCompiler }
        );
        this.validatorCompiler = validatorCompiler;
        this.isCustomValidatorCompiler = true;
      }
      setSerializerCompiler(serializerCompiler) {
        this.compilersFactory = Object.assign(
          {},
          this.compilersFactory,
          { buildSerializer: () => serializerCompiler }
        );
        this.serializerCompiler = serializerCompiler;
        this.isCustomSerializerCompiler = true;
      }
      getValidatorCompiler() {
        return this.validatorCompiler || this.parent && this.parent.getValidatorCompiler();
      }
      getSerializerCompiler() {
        return this.serializerCompiler || this.parent && this.parent.getSerializerCompiler();
      }
      getSerializerBuilder() {
        return this.compilersFactory.buildSerializer || this.parent && this.parent.getSerializerBuilder();
      }
      getValidatorBuilder() {
        return this.compilersFactory.buildValidator || this.parent && this.parent.getValidatorBuilder();
      }
      /**
       * This method will be called when a validator must be setup.
       * Do not setup the compiler more than once
       * @param {object} serverOptions the fastify server options
       */
      setupValidator(serverOptions) {
        const isReady = this.validatorCompiler !== void 0 && !this.addedSchemas;
        if (isReady) {
          return;
        }
        this.validatorCompiler = this.getValidatorBuilder()(this.schemaBucket.getSchemas(), serverOptions.ajv);
      }
      /**
       * This method will be called when a serializer must be setup.
       * Do not setup the compiler more than once
       * @param {object} serverOptions the fastify server options
       */
      setupSerializer(serverOptions) {
        const isReady = this.serializerCompiler !== void 0 && !this.addedSchemas;
        if (isReady) {
          return;
        }
        this.serializerCompiler = this.getSerializerBuilder()(this.schemaBucket.getSchemas(), serverOptions.serializerOpts);
      }
    };
    SchemaController.buildSchemaController = buildSchemaController;
    module2.exports = SchemaController;
  }
});

// node_modules/semver/internal/constants.js
var require_constants2 = __commonJS({
  "node_modules/semver/internal/constants.js"(exports2, module2) {
    "use strict";
    var SEMVER_SPEC_VERSION = "2.0.0";
    var MAX_LENGTH = 256;
    var MAX_SAFE_INTEGER = Number.MAX_SAFE_INTEGER || /* istanbul ignore next */
    9007199254740991;
    var MAX_SAFE_COMPONENT_LENGTH = 16;
    var MAX_SAFE_BUILD_LENGTH = MAX_LENGTH - 6;
    var RELEASE_TYPES = [
      "major",
      "premajor",
      "minor",
      "preminor",
      "patch",
      "prepatch",
      "prerelease"
    ];
    module2.exports = {
      MAX_LENGTH,
      MAX_SAFE_COMPONENT_LENGTH,
      MAX_SAFE_BUILD_LENGTH,
      MAX_SAFE_INTEGER,
      RELEASE_TYPES,
      SEMVER_SPEC_VERSION,
      FLAG_INCLUDE_PRERELEASE: 1,
      FLAG_LOOSE: 2
    };
  }
});

// node_modules/semver/internal/debug.js
var require_debug2 = __commonJS({
  "node_modules/semver/internal/debug.js"(exports2, module2) {
    "use strict";
    var debug = typeof process === "object" && process.env && process.env.NODE_DEBUG && /\bsemver\b/i.test(process.env.NODE_DEBUG) ? (...args) => console.error("SEMVER", ...args) : () => {
    };
    module2.exports = debug;
  }
});

// node_modules/semver/internal/re.js
var require_re = __commonJS({
  "node_modules/semver/internal/re.js"(exports2, module2) {
    "use strict";
    var {
      MAX_SAFE_COMPONENT_LENGTH,
      MAX_SAFE_BUILD_LENGTH,
      MAX_LENGTH
    } = require_constants2();
    var debug = require_debug2();
    exports2 = module2.exports = {};
    var re = exports2.re = [];
    var safeRe = exports2.safeRe = [];
    var src = exports2.src = [];
    var safeSrc = exports2.safeSrc = [];
    var t = exports2.t = {};
    var R = 0;
    var LETTERDASHNUMBER = "[a-zA-Z0-9-]";
    var safeRegexReplacements = [
      ["\\s", 1],
      ["\\d", MAX_LENGTH],
      [LETTERDASHNUMBER, MAX_SAFE_BUILD_LENGTH]
    ];
    var makeSafeRegex = (value) => {
      for (const [token, max] of safeRegexReplacements) {
        value = value.split(`${token}*`).join(`${token}{0,${max}}`).split(`${token}+`).join(`${token}{1,${max}}`);
      }
      return value;
    };
    var createToken = (name, value, isGlobal) => {
      const safe = makeSafeRegex(value);
      const index = R++;
      debug(name, index, value);
      t[name] = index;
      src[index] = value;
      safeSrc[index] = safe;
      re[index] = new RegExp(value, isGlobal ? "g" : void 0);
      safeRe[index] = new RegExp(safe, isGlobal ? "g" : void 0);
    };
    createToken("NUMERICIDENTIFIER", "0|[1-9]\\d*");
    createToken("NUMERICIDENTIFIERLOOSE", "\\d+");
    createToken("NONNUMERICIDENTIFIER", `\\d*[a-zA-Z-]${LETTERDASHNUMBER}*`);
    createToken("MAINVERSION", `(${src[t.NUMERICIDENTIFIER]})\\.(${src[t.NUMERICIDENTIFIER]})\\.(${src[t.NUMERICIDENTIFIER]})`);
    createToken("MAINVERSIONLOOSE", `(${src[t.NUMERICIDENTIFIERLOOSE]})\\.(${src[t.NUMERICIDENTIFIERLOOSE]})\\.(${src[t.NUMERICIDENTIFIERLOOSE]})`);
    createToken("PRERELEASEIDENTIFIER", `(?:${src[t.NONNUMERICIDENTIFIER]}|${src[t.NUMERICIDENTIFIER]})`);
    createToken("PRERELEASEIDENTIFIERLOOSE", `(?:${src[t.NONNUMERICIDENTIFIER]}|${src[t.NUMERICIDENTIFIERLOOSE]})`);
    createToken("PRERELEASE", `(?:-(${src[t.PRERELEASEIDENTIFIER]}(?:\\.${src[t.PRERELEASEIDENTIFIER]})*))`);
    createToken("PRERELEASELOOSE", `(?:-?(${src[t.PRERELEASEIDENTIFIERLOOSE]}(?:\\.${src[t.PRERELEASEIDENTIFIERLOOSE]})*))`);
    createToken("BUILDIDENTIFIER", `${LETTERDASHNUMBER}+`);
    createToken("BUILD", `(?:\\+(${src[t.BUILDIDENTIFIER]}(?:\\.${src[t.BUILDIDENTIFIER]})*))`);
    createToken("FULLPLAIN", `v?${src[t.MAINVERSION]}${src[t.PRERELEASE]}?${src[t.BUILD]}?`);
    createToken("FULL", `^${src[t.FULLPLAIN]}$`);
    createToken("LOOSEPLAIN", `[v=\\s]*${src[t.MAINVERSIONLOOSE]}${src[t.PRERELEASELOOSE]}?${src[t.BUILD]}?`);
    createToken("LOOSE", `^${src[t.LOOSEPLAIN]}$`);
    createToken("GTLT", "((?:<|>)?=?)");
    createToken("XRANGEIDENTIFIERLOOSE", `${src[t.NUMERICIDENTIFIERLOOSE]}|x|X|\\*`);
    createToken("XRANGEIDENTIFIER", `${src[t.NUMERICIDENTIFIER]}|x|X|\\*`);
    createToken("XRANGEPLAIN", `[v=\\s]*(${src[t.XRANGEIDENTIFIER]})(?:\\.(${src[t.XRANGEIDENTIFIER]})(?:\\.(${src[t.XRANGEIDENTIFIER]})(?:${src[t.PRERELEASE]})?${src[t.BUILD]}?)?)?`);
    createToken("XRANGEPLAINLOOSE", `[v=\\s]*(${src[t.XRANGEIDENTIFIERLOOSE]})(?:\\.(${src[t.XRANGEIDENTIFIERLOOSE]})(?:\\.(${src[t.XRANGEIDENTIFIERLOOSE]})(?:${src[t.PRERELEASELOOSE]})?${src[t.BUILD]}?)?)?`);
    createToken("XRANGE", `^${src[t.GTLT]}\\s*${src[t.XRANGEPLAIN]}$`);
    createToken("XRANGELOOSE", `^${src[t.GTLT]}\\s*${src[t.XRANGEPLAINLOOSE]}$`);
    createToken("COERCEPLAIN", `${"(^|[^\\d])(\\d{1,"}${MAX_SAFE_COMPONENT_LENGTH}})(?:\\.(\\d{1,${MAX_SAFE_COMPONENT_LENGTH}}))?(?:\\.(\\d{1,${MAX_SAFE_COMPONENT_LENGTH}}))?`);
    createToken("COERCE", `${src[t.COERCEPLAIN]}(?:$|[^\\d])`);
    createToken("COERCEFULL", src[t.COERCEPLAIN] + `(?:${src[t.PRERELEASE]})?(?:${src[t.BUILD]})?(?:$|[^\\d])`);
    createToken("COERCERTL", src[t.COERCE], true);
    createToken("COERCERTLFULL", src[t.COERCEFULL], true);
    createToken("LONETILDE", "(?:~>?)");
    createToken("TILDETRIM", `(\\s*)${src[t.LONETILDE]}\\s+`, true);
    exports2.tildeTrimReplace = "$1~";
    createToken("TILDE", `^${src[t.LONETILDE]}${src[t.XRANGEPLAIN]}$`);
    createToken("TILDELOOSE", `^${src[t.LONETILDE]}${src[t.XRANGEPLAINLOOSE]}$`);
    createToken("LONECARET", "(?:\\^)");
    createToken("CARETTRIM", `(\\s*)${src[t.LONECARET]}\\s+`, true);
    exports2.caretTrimReplace = "$1^";
    createToken("CARET", `^${src[t.LONECARET]}${src[t.XRANGEPLAIN]}$`);
    createToken("CARETLOOSE", `^${src[t.LONECARET]}${src[t.XRANGEPLAINLOOSE]}$`);
    createToken("COMPARATORLOOSE", `^${src[t.GTLT]}\\s*(${src[t.LOOSEPLAIN]})$|^$`);
    createToken("COMPARATOR", `^${src[t.GTLT]}\\s*(${src[t.FULLPLAIN]})$|^$`);
    createToken("COMPARATORTRIM", `(\\s*)${src[t.GTLT]}\\s*(${src[t.LOOSEPLAIN]}|${src[t.XRANGEPLAIN]})`, true);
    exports2.comparatorTrimReplace = "$1$2$3";
    createToken("HYPHENRANGE", `^\\s*(${src[t.XRANGEPLAIN]})\\s+-\\s+(${src[t.XRANGEPLAIN]})\\s*$`);
    createToken("HYPHENRANGELOOSE", `^\\s*(${src[t.XRANGEPLAINLOOSE]})\\s+-\\s+(${src[t.XRANGEPLAINLOOSE]})\\s*$`);
    createToken("STAR", "(<|>)?=?\\s*\\*");
    createToken("GTE0", "^\\s*>=\\s*0\\.0\\.0\\s*$");
    createToken("GTE0PRE", "^\\s*>=\\s*0\\.0\\.0-0\\s*$");
  }
});

// node_modules/semver/internal/parse-options.js
var require_parse_options = __commonJS({
  "node_modules/semver/internal/parse-options.js"(exports2, module2) {
    "use strict";
    var looseOption = Object.freeze({ loose: true });
    var emptyOpts = Object.freeze({});
    var parseOptions = (options) => {
      if (!options) {
        return emptyOpts;
      }
      if (typeof options !== "object") {
        return looseOption;
      }
      return options;
    };
    module2.exports = parseOptions;
  }
});

// node_modules/semver/internal/identifiers.js
var require_identifiers = __commonJS({
  "node_modules/semver/internal/identifiers.js"(exports2, module2) {
    "use strict";
    var numeric = /^[0-9]+$/;
    var compareIdentifiers = (a, b) => {
      const anum = numeric.test(a);
      const bnum = numeric.test(b);
      if (anum && bnum) {
        a = +a;
        b = +b;
      }
      return a === b ? 0 : anum && !bnum ? -1 : bnum && !anum ? 1 : a < b ? -1 : 1;
    };
    var rcompareIdentifiers = (a, b) => compareIdentifiers(b, a);
    module2.exports = {
      compareIdentifiers,
      rcompareIdentifiers
    };
  }
});

// node_modules/semver/classes/semver.js
var require_semver = __commonJS({
  "node_modules/semver/classes/semver.js"(exports2, module2) {
    "use strict";
    var debug = require_debug2();
    var { MAX_LENGTH, MAX_SAFE_INTEGER } = require_constants2();
    var { safeRe: re, t } = require_re();
    var parseOptions = require_parse_options();
    var { compareIdentifiers } = require_identifiers();
    var SemVer = class _SemVer {
      constructor(version2, options) {
        options = parseOptions(options);
        if (version2 instanceof _SemVer) {
          if (version2.loose === !!options.loose && version2.includePrerelease === !!options.includePrerelease) {
            return version2;
          } else {
            version2 = version2.version;
          }
        } else if (typeof version2 !== "string") {
          throw new TypeError(`Invalid version. Must be a string. Got type "${typeof version2}".`);
        }
        if (version2.length > MAX_LENGTH) {
          throw new TypeError(
            `version is longer than ${MAX_LENGTH} characters`
          );
        }
        debug("SemVer", version2, options);
        this.options = options;
        this.loose = !!options.loose;
        this.includePrerelease = !!options.includePrerelease;
        const m = version2.trim().match(options.loose ? re[t.LOOSE] : re[t.FULL]);
        if (!m) {
          throw new TypeError(`Invalid Version: ${version2}`);
        }
        this.raw = version2;
        this.major = +m[1];
        this.minor = +m[2];
        this.patch = +m[3];
        if (this.major > MAX_SAFE_INTEGER || this.major < 0) {
          throw new TypeError("Invalid major version");
        }
        if (this.minor > MAX_SAFE_INTEGER || this.minor < 0) {
          throw new TypeError("Invalid minor version");
        }
        if (this.patch > MAX_SAFE_INTEGER || this.patch < 0) {
          throw new TypeError("Invalid patch version");
        }
        if (!m[4]) {
          this.prerelease = [];
        } else {
          this.prerelease = m[4].split(".").map((id2) => {
            if (/^[0-9]+$/.test(id2)) {
              const num = +id2;
              if (num >= 0 && num < MAX_SAFE_INTEGER) {
                return num;
              }
            }
            return id2;
          });
        }
        this.build = m[5] ? m[5].split(".") : [];
        this.format();
      }
      format() {
        this.version = `${this.major}.${this.minor}.${this.patch}`;
        if (this.prerelease.length) {
          this.version += `-${this.prerelease.join(".")}`;
        }
        return this.version;
      }
      toString() {
        return this.version;
      }
      compare(other) {
        debug("SemVer.compare", this.version, this.options, other);
        if (!(other instanceof _SemVer)) {
          if (typeof other === "string" && other === this.version) {
            return 0;
          }
          other = new _SemVer(other, this.options);
        }
        if (other.version === this.version) {
          return 0;
        }
        return this.compareMain(other) || this.comparePre(other);
      }
      compareMain(other) {
        if (!(other instanceof _SemVer)) {
          other = new _SemVer(other, this.options);
        }
        return compareIdentifiers(this.major, other.major) || compareIdentifiers(this.minor, other.minor) || compareIdentifiers(this.patch, other.patch);
      }
      comparePre(other) {
        if (!(other instanceof _SemVer)) {
          other = new _SemVer(other, this.options);
        }
        if (this.prerelease.length && !other.prerelease.length) {
          return -1;
        } else if (!this.prerelease.length && other.prerelease.length) {
          return 1;
        } else if (!this.prerelease.length && !other.prerelease.length) {
          return 0;
        }
        let i = 0;
        do {
          const a = this.prerelease[i];
          const b = other.prerelease[i];
          debug("prerelease compare", i, a, b);
          if (a === void 0 && b === void 0) {
            return 0;
          } else if (b === void 0) {
            return 1;
          } else if (a === void 0) {
            return -1;
          } else if (a === b) {
            continue;
          } else {
            return compareIdentifiers(a, b);
          }
        } while (++i);
      }
      compareBuild(other) {
        if (!(other instanceof _SemVer)) {
          other = new _SemVer(other, this.options);
        }
        let i = 0;
        do {
          const a = this.build[i];
          const b = other.build[i];
          debug("build compare", i, a, b);
          if (a === void 0 && b === void 0) {
            return 0;
          } else if (b === void 0) {
            return 1;
          } else if (a === void 0) {
            return -1;
          } else if (a === b) {
            continue;
          } else {
            return compareIdentifiers(a, b);
          }
        } while (++i);
      }
      // preminor will bump the version up to the next minor release, and immediately
      // down to pre-release. premajor and prepatch work the same way.
      inc(release, identifier, identifierBase) {
        if (release.startsWith("pre")) {
          if (!identifier && identifierBase === false) {
            throw new Error("invalid increment argument: identifier is empty");
          }
          if (identifier) {
            const match = `-${identifier}`.match(this.options.loose ? re[t.PRERELEASELOOSE] : re[t.PRERELEASE]);
            if (!match || match[1] !== identifier) {
              throw new Error(`invalid identifier: ${identifier}`);
            }
          }
        }
        switch (release) {
          case "premajor":
            this.prerelease.length = 0;
            this.patch = 0;
            this.minor = 0;
            this.major++;
            this.inc("pre", identifier, identifierBase);
            break;
          case "preminor":
            this.prerelease.length = 0;
            this.patch = 0;
            this.minor++;
            this.inc("pre", identifier, identifierBase);
            break;
          case "prepatch":
            this.prerelease.length = 0;
            this.inc("patch", identifier, identifierBase);
            this.inc("pre", identifier, identifierBase);
            break;
          // If the input is a non-prerelease version, this acts the same as
          // prepatch.
          case "prerelease":
            if (this.prerelease.length === 0) {
              this.inc("patch", identifier, identifierBase);
            }
            this.inc("pre", identifier, identifierBase);
            break;
          case "release":
            if (this.prerelease.length === 0) {
              throw new Error(`version ${this.raw} is not a prerelease`);
            }
            this.prerelease.length = 0;
            break;
          case "major":
            if (this.minor !== 0 || this.patch !== 0 || this.prerelease.length === 0) {
              this.major++;
            }
            this.minor = 0;
            this.patch = 0;
            this.prerelease = [];
            break;
          case "minor":
            if (this.patch !== 0 || this.prerelease.length === 0) {
              this.minor++;
            }
            this.patch = 0;
            this.prerelease = [];
            break;
          case "patch":
            if (this.prerelease.length === 0) {
              this.patch++;
            }
            this.prerelease = [];
            break;
          // This probably shouldn't be used publicly.
          // 1.0.0 'pre' would become 1.0.0-0 which is the wrong direction.
          case "pre": {
            const base = Number(identifierBase) ? 1 : 0;
            if (this.prerelease.length === 0) {
              this.prerelease = [base];
            } else {
              let i = this.prerelease.length;
              while (--i >= 0) {
                if (typeof this.prerelease[i] === "number") {
                  this.prerelease[i]++;
                  i = -2;
                }
              }
              if (i === -1) {
                if (identifier === this.prerelease.join(".") && identifierBase === false) {
                  throw new Error("invalid increment argument: identifier already exists");
                }
                this.prerelease.push(base);
              }
            }
            if (identifier) {
              let prerelease = [identifier, base];
              if (identifierBase === false) {
                prerelease = [identifier];
              }
              if (compareIdentifiers(this.prerelease[0], identifier) === 0) {
                if (isNaN(this.prerelease[1])) {
                  this.prerelease = prerelease;
                }
              } else {
                this.prerelease = prerelease;
              }
            }
            break;
          }
          default:
            throw new Error(`invalid increment argument: ${release}`);
        }
        this.raw = this.format();
        if (this.build.length) {
          this.raw += `+${this.build.join(".")}`;
        }
        return this;
      }
    };
    module2.exports = SemVer;
  }
});

// node_modules/semver/functions/parse.js
var require_parse4 = __commonJS({
  "node_modules/semver/functions/parse.js"(exports2, module2) {
    "use strict";
    var SemVer = require_semver();
    var parse = (version2, options, throwErrors = false) => {
      if (version2 instanceof SemVer) {
        return version2;
      }
      try {
        return new SemVer(version2, options);
      } catch (er) {
        if (!throwErrors) {
          return null;
        }
        throw er;
      }
    };
    module2.exports = parse;
  }
});

// node_modules/semver/functions/valid.js
var require_valid = __commonJS({
  "node_modules/semver/functions/valid.js"(exports2, module2) {
    "use strict";
    var parse = require_parse4();
    var valid = (version2, options) => {
      const v = parse(version2, options);
      return v ? v.version : null;
    };
    module2.exports = valid;
  }
});

// node_modules/semver/functions/clean.js
var require_clean = __commonJS({
  "node_modules/semver/functions/clean.js"(exports2, module2) {
    "use strict";
    var parse = require_parse4();
    var clean = (version2, options) => {
      const s = parse(version2.trim().replace(/^[=v]+/, ""), options);
      return s ? s.version : null;
    };
    module2.exports = clean;
  }
});

// node_modules/semver/functions/inc.js
var require_inc = __commonJS({
  "node_modules/semver/functions/inc.js"(exports2, module2) {
    "use strict";
    var SemVer = require_semver();
    var inc = (version2, release, options, identifier, identifierBase) => {
      if (typeof options === "string") {
        identifierBase = identifier;
        identifier = options;
        options = void 0;
      }
      try {
        return new SemVer(
          version2 instanceof SemVer ? version2.version : version2,
          options
        ).inc(release, identifier, identifierBase).version;
      } catch (er) {
        return null;
      }
    };
    module2.exports = inc;
  }
});

// node_modules/semver/functions/diff.js
var require_diff = __commonJS({
  "node_modules/semver/functions/diff.js"(exports2, module2) {
    "use strict";
    var parse = require_parse4();
    var diff = (version1, version2) => {
      const v1 = parse(version1, null, true);
      const v2 = parse(version2, null, true);
      const comparison = v1.compare(v2);
      if (comparison === 0) {
        return null;
      }
      const v1Higher = comparison > 0;
      const highVersion = v1Higher ? v1 : v2;
      const lowVersion = v1Higher ? v2 : v1;
      const highHasPre = !!highVersion.prerelease.length;
      const lowHasPre = !!lowVersion.prerelease.length;
      if (lowHasPre && !highHasPre) {
        if (!lowVersion.patch && !lowVersion.minor) {
          return "major";
        }
        if (lowVersion.compareMain(highVersion) === 0) {
          if (lowVersion.minor && !lowVersion.patch) {
            return "minor";
          }
          return "patch";
        }
      }
      const prefix = highHasPre ? "pre" : "";
      if (v1.major !== v2.major) {
        return prefix + "major";
      }
      if (v1.minor !== v2.minor) {
        return prefix + "minor";
      }
      if (v1.patch !== v2.patch) {
        return prefix + "patch";
      }
      return "prerelease";
    };
    module2.exports = diff;
  }
});

// node_modules/semver/functions/major.js
var require_major = __commonJS({
  "node_modules/semver/functions/major.js"(exports2, module2) {
    "use strict";
    var SemVer = require_semver();
    var major = (a, loose) => new SemVer(a, loose).major;
    module2.exports = major;
  }
});

// node_modules/semver/functions/minor.js
var require_minor = __commonJS({
  "node_modules/semver/functions/minor.js"(exports2, module2) {
    "use strict";
    var SemVer = require_semver();
    var minor = (a, loose) => new SemVer(a, loose).minor;
    module2.exports = minor;
  }
});

// node_modules/semver/functions/patch.js
var require_patch = __commonJS({
  "node_modules/semver/functions/patch.js"(exports2, module2) {
    "use strict";
    var SemVer = require_semver();
    var patch = (a, loose) => new SemVer(a, loose).patch;
    module2.exports = patch;
  }
});

// node_modules/semver/functions/prerelease.js
var require_prerelease = __commonJS({
  "node_modules/semver/functions/prerelease.js"(exports2, module2) {
    "use strict";
    var parse = require_parse4();
    var prerelease = (version2, options) => {
      const parsed = parse(version2, options);
      return parsed && parsed.prerelease.length ? parsed.prerelease : null;
    };
    module2.exports = prerelease;
  }
});

// node_modules/semver/functions/compare.js
var require_compare = __commonJS({
  "node_modules/semver/functions/compare.js"(exports2, module2) {
    "use strict";
    var SemVer = require_semver();
    var compare = (a, b, loose) => new SemVer(a, loose).compare(new SemVer(b, loose));
    module2.exports = compare;
  }
});

// node_modules/semver/functions/rcompare.js
var require_rcompare = __commonJS({
  "node_modules/semver/functions/rcompare.js"(exports2, module2) {
    "use strict";
    var compare = require_compare();
    var rcompare = (a, b, loose) => compare(b, a, loose);
    module2.exports = rcompare;
  }
});

// node_modules/semver/functions/compare-loose.js
var require_compare_loose = __commonJS({
  "node_modules/semver/functions/compare-loose.js"(exports2, module2) {
    "use strict";
    var compare = require_compare();
    var compareLoose = (a, b) => compare(a, b, true);
    module2.exports = compareLoose;
  }
});

// node_modules/semver/functions/compare-build.js
var require_compare_build = __commonJS({
  "node_modules/semver/functions/compare-build.js"(exports2, module2) {
    "use strict";
    var SemVer = require_semver();
    var compareBuild = (a, b, loose) => {
      const versionA = new SemVer(a, loose);
      const versionB = new SemVer(b, loose);
      return versionA.compare(versionB) || versionA.compareBuild(versionB);
    };
    module2.exports = compareBuild;
  }
});

// node_modules/semver/functions/sort.js
var require_sort = __commonJS({
  "node_modules/semver/functions/sort.js"(exports2, module2) {
    "use strict";
    var compareBuild = require_compare_build();
    var sort = (list, loose) => list.sort((a, b) => compareBuild(a, b, loose));
    module2.exports = sort;
  }
});

// node_modules/semver/functions/rsort.js
var require_rsort = __commonJS({
  "node_modules/semver/functions/rsort.js"(exports2, module2) {
    "use strict";
    var compareBuild = require_compare_build();
    var rsort = (list, loose) => list.sort((a, b) => compareBuild(b, a, loose));
    module2.exports = rsort;
  }
});

// node_modules/semver/functions/gt.js
var require_gt = __commonJS({
  "node_modules/semver/functions/gt.js"(exports2, module2) {
    "use strict";
    var compare = require_compare();
    var gt = (a, b, loose) => compare(a, b, loose) > 0;
    module2.exports = gt;
  }
});

// node_modules/semver/functions/lt.js
var require_lt = __commonJS({
  "node_modules/semver/functions/lt.js"(exports2, module2) {
    "use strict";
    var compare = require_compare();
    var lt = (a, b, loose) => compare(a, b, loose) < 0;
    module2.exports = lt;
  }
});

// node_modules/semver/functions/eq.js
var require_eq = __commonJS({
  "node_modules/semver/functions/eq.js"(exports2, module2) {
    "use strict";
    var compare = require_compare();
    var eq = (a, b, loose) => compare(a, b, loose) === 0;
    module2.exports = eq;
  }
});

// node_modules/semver/functions/neq.js
var require_neq = __commonJS({
  "node_modules/semver/functions/neq.js"(exports2, module2) {
    "use strict";
    var compare = require_compare();
    var neq = (a, b, loose) => compare(a, b, loose) !== 0;
    module2.exports = neq;
  }
});

// node_modules/semver/functions/gte.js
var require_gte = __commonJS({
  "node_modules/semver/functions/gte.js"(exports2, module2) {
    "use strict";
    var compare = require_compare();
    var gte = (a, b, loose) => compare(a, b, loose) >= 0;
    module2.exports = gte;
  }
});

// node_modules/semver/functions/lte.js
var require_lte = __commonJS({
  "node_modules/semver/functions/lte.js"(exports2, module2) {
    "use strict";
    var compare = require_compare();
    var lte = (a, b, loose) => compare(a, b, loose) <= 0;
    module2.exports = lte;
  }
});

// node_modules/semver/functions/cmp.js
var require_cmp = __commonJS({
  "node_modules/semver/functions/cmp.js"(exports2, module2) {
    "use strict";
    var eq = require_eq();
    var neq = require_neq();
    var gt = require_gt();
    var gte = require_gte();
    var lt = require_lt();
    var lte = require_lte();
    var cmp = (a, op2, b, loose) => {
      switch (op2) {
        case "===":
          if (typeof a === "object") {
            a = a.version;
          }
          if (typeof b === "object") {
            b = b.version;
          }
          return a === b;
        case "!==":
          if (typeof a === "object") {
            a = a.version;
          }
          if (typeof b === "object") {
            b = b.version;
          }
          return a !== b;
        case "":
        case "=":
        case "==":
          return eq(a, b, loose);
        case "!=":
          return neq(a, b, loose);
        case ">":
          return gt(a, b, loose);
        case ">=":
          return gte(a, b, loose);
        case "<":
          return lt(a, b, loose);
        case "<=":
          return lte(a, b, loose);
        default:
          throw new TypeError(`Invalid operator: ${op2}`);
      }
    };
    module2.exports = cmp;
  }
});

// node_modules/semver/functions/coerce.js
var require_coerce = __commonJS({
  "node_modules/semver/functions/coerce.js"(exports2, module2) {
    "use strict";
    var SemVer = require_semver();
    var parse = require_parse4();
    var { safeRe: re, t } = require_re();
    var coerce = (version2, options) => {
      if (version2 instanceof SemVer) {
        return version2;
      }
      if (typeof version2 === "number") {
        version2 = String(version2);
      }
      if (typeof version2 !== "string") {
        return null;
      }
      options = options || {};
      let match = null;
      if (!options.rtl) {
        match = version2.match(options.includePrerelease ? re[t.COERCEFULL] : re[t.COERCE]);
      } else {
        const coerceRtlRegex = options.includePrerelease ? re[t.COERCERTLFULL] : re[t.COERCERTL];
        let next;
        while ((next = coerceRtlRegex.exec(version2)) && (!match || match.index + match[0].length !== version2.length)) {
          if (!match || next.index + next[0].length !== match.index + match[0].length) {
            match = next;
          }
          coerceRtlRegex.lastIndex = next.index + next[1].length + next[2].length;
        }
        coerceRtlRegex.lastIndex = -1;
      }
      if (match === null) {
        return null;
      }
      const major = match[2];
      const minor = match[3] || "0";
      const patch = match[4] || "0";
      const prerelease = options.includePrerelease && match[5] ? `-${match[5]}` : "";
      const build = options.includePrerelease && match[6] ? `+${match[6]}` : "";
      return parse(`${major}.${minor}.${patch}${prerelease}${build}`, options);
    };
    module2.exports = coerce;
  }
});

// node_modules/semver/internal/lrucache.js
var require_lrucache = __commonJS({
  "node_modules/semver/internal/lrucache.js"(exports2, module2) {
    "use strict";
    var LRUCache = class {
      constructor() {
        this.max = 1e3;
        this.map = /* @__PURE__ */ new Map();
      }
      get(key) {
        const value = this.map.get(key);
        if (value === void 0) {
          return void 0;
        } else {
          this.map.delete(key);
          this.map.set(key, value);
          return value;
        }
      }
      delete(key) {
        return this.map.delete(key);
      }
      set(key, value) {
        const deleted = this.delete(key);
        if (!deleted && value !== void 0) {
          if (this.map.size >= this.max) {
            const firstKey = this.map.keys().next().value;
            this.delete(firstKey);
          }
          this.map.set(key, value);
        }
        return this;
      }
    };
    module2.exports = LRUCache;
  }
});

// node_modules/semver/classes/range.js
var require_range = __commonJS({
  "node_modules/semver/classes/range.js"(exports2, module2) {
    "use strict";
    var SPACE_CHARACTERS = /\s+/g;
    var Range = class _Range {
      constructor(range, options) {
        options = parseOptions(options);
        if (range instanceof _Range) {
          if (range.loose === !!options.loose && range.includePrerelease === !!options.includePrerelease) {
            return range;
          } else {
            return new _Range(range.raw, options);
          }
        }
        if (range instanceof Comparator) {
          this.raw = range.value;
          this.set = [[range]];
          this.formatted = void 0;
          return this;
        }
        this.options = options;
        this.loose = !!options.loose;
        this.includePrerelease = !!options.includePrerelease;
        this.raw = range.trim().replace(SPACE_CHARACTERS, " ");
        this.set = this.raw.split("||").map((r) => this.parseRange(r.trim())).filter((c) => c.length);
        if (!this.set.length) {
          throw new TypeError(`Invalid SemVer Range: ${this.raw}`);
        }
        if (this.set.length > 1) {
          const first = this.set[0];
          this.set = this.set.filter((c) => !isNullSet(c[0]));
          if (this.set.length === 0) {
            this.set = [first];
          } else if (this.set.length > 1) {
            for (const c of this.set) {
              if (c.length === 1 && isAny(c[0])) {
                this.set = [c];
                break;
              }
            }
          }
        }
        this.formatted = void 0;
      }
      get range() {
        if (this.formatted === void 0) {
          this.formatted = "";
          for (let i = 0; i < this.set.length; i++) {
            if (i > 0) {
              this.formatted += "||";
            }
            const comps = this.set[i];
            for (let k = 0; k < comps.length; k++) {
              if (k > 0) {
                this.formatted += " ";
              }
              this.formatted += comps[k].toString().trim();
            }
          }
        }
        return this.formatted;
      }
      format() {
        return this.range;
      }
      toString() {
        return this.range;
      }
      parseRange(range) {
        const memoOpts = (this.options.includePrerelease && FLAG_INCLUDE_PRERELEASE) | (this.options.loose && FLAG_LOOSE);
        const memoKey = memoOpts + ":" + range;
        const cached = cache.get(memoKey);
        if (cached) {
          return cached;
        }
        const loose = this.options.loose;
        const hr = loose ? re[t.HYPHENRANGELOOSE] : re[t.HYPHENRANGE];
        range = range.replace(hr, hyphenReplace(this.options.includePrerelease));
        debug("hyphen replace", range);
        range = range.replace(re[t.COMPARATORTRIM], comparatorTrimReplace);
        debug("comparator trim", range);
        range = range.replace(re[t.TILDETRIM], tildeTrimReplace);
        debug("tilde trim", range);
        range = range.replace(re[t.CARETTRIM], caretTrimReplace);
        debug("caret trim", range);
        let rangeList = range.split(" ").map((comp) => parseComparator(comp, this.options)).join(" ").split(/\s+/).map((comp) => replaceGTE0(comp, this.options));
        if (loose) {
          rangeList = rangeList.filter((comp) => {
            debug("loose invalid filter", comp, this.options);
            return !!comp.match(re[t.COMPARATORLOOSE]);
          });
        }
        debug("range list", rangeList);
        const rangeMap = /* @__PURE__ */ new Map();
        const comparators = rangeList.map((comp) => new Comparator(comp, this.options));
        for (const comp of comparators) {
          if (isNullSet(comp)) {
            return [comp];
          }
          rangeMap.set(comp.value, comp);
        }
        if (rangeMap.size > 1 && rangeMap.has("")) {
          rangeMap.delete("");
        }
        const result = [...rangeMap.values()];
        cache.set(memoKey, result);
        return result;
      }
      intersects(range, options) {
        if (!(range instanceof _Range)) {
          throw new TypeError("a Range is required");
        }
        return this.set.some((thisComparators) => {
          return isSatisfiable(thisComparators, options) && range.set.some((rangeComparators) => {
            return isSatisfiable(rangeComparators, options) && thisComparators.every((thisComparator) => {
              return rangeComparators.every((rangeComparator) => {
                return thisComparator.intersects(rangeComparator, options);
              });
            });
          });
        });
      }
      // if ANY of the sets match ALL of its comparators, then pass
      test(version2) {
        if (!version2) {
          return false;
        }
        if (typeof version2 === "string") {
          try {
            version2 = new SemVer(version2, this.options);
          } catch (er) {
            return false;
          }
        }
        for (let i = 0; i < this.set.length; i++) {
          if (testSet(this.set[i], version2, this.options)) {
            return true;
          }
        }
        return false;
      }
    };
    module2.exports = Range;
    var LRU = require_lrucache();
    var cache = new LRU();
    var parseOptions = require_parse_options();
    var Comparator = require_comparator();
    var debug = require_debug2();
    var SemVer = require_semver();
    var {
      safeRe: re,
      t,
      comparatorTrimReplace,
      tildeTrimReplace,
      caretTrimReplace
    } = require_re();
    var { FLAG_INCLUDE_PRERELEASE, FLAG_LOOSE } = require_constants2();
    var isNullSet = (c) => c.value === "<0.0.0-0";
    var isAny = (c) => c.value === "";
    var isSatisfiable = (comparators, options) => {
      let result = true;
      const remainingComparators = comparators.slice();
      let testComparator = remainingComparators.pop();
      while (result && remainingComparators.length) {
        result = remainingComparators.every((otherComparator) => {
          return testComparator.intersects(otherComparator, options);
        });
        testComparator = remainingComparators.pop();
      }
      return result;
    };
    var parseComparator = (comp, options) => {
      debug("comp", comp, options);
      comp = replaceCarets(comp, options);
      debug("caret", comp);
      comp = replaceTildes(comp, options);
      debug("tildes", comp);
      comp = replaceXRanges(comp, options);
      debug("xrange", comp);
      comp = replaceStars(comp, options);
      debug("stars", comp);
      return comp;
    };
    var isX = (id2) => !id2 || id2.toLowerCase() === "x" || id2 === "*";
    var replaceTildes = (comp, options) => {
      return comp.trim().split(/\s+/).map((c) => replaceTilde(c, options)).join(" ");
    };
    var replaceTilde = (comp, options) => {
      const r = options.loose ? re[t.TILDELOOSE] : re[t.TILDE];
      return comp.replace(r, (_, M, m, p, pr) => {
        debug("tilde", comp, _, M, m, p, pr);
        let ret;
        if (isX(M)) {
          ret = "";
        } else if (isX(m)) {
          ret = `>=${M}.0.0 <${+M + 1}.0.0-0`;
        } else if (isX(p)) {
          ret = `>=${M}.${m}.0 <${M}.${+m + 1}.0-0`;
        } else if (pr) {
          debug("replaceTilde pr", pr);
          ret = `>=${M}.${m}.${p}-${pr} <${M}.${+m + 1}.0-0`;
        } else {
          ret = `>=${M}.${m}.${p} <${M}.${+m + 1}.0-0`;
        }
        debug("tilde return", ret);
        return ret;
      });
    };
    var replaceCarets = (comp, options) => {
      return comp.trim().split(/\s+/).map((c) => replaceCaret(c, options)).join(" ");
    };
    var replaceCaret = (comp, options) => {
      debug("caret", comp, options);
      const r = options.loose ? re[t.CARETLOOSE] : re[t.CARET];
      const z2 = options.includePrerelease ? "-0" : "";
      return comp.replace(r, (_, M, m, p, pr) => {
        debug("caret", comp, _, M, m, p, pr);
        let ret;
        if (isX(M)) {
          ret = "";
        } else if (isX(m)) {
          ret = `>=${M}.0.0${z2} <${+M + 1}.0.0-0`;
        } else if (isX(p)) {
          if (M === "0") {
            ret = `>=${M}.${m}.0${z2} <${M}.${+m + 1}.0-0`;
          } else {
            ret = `>=${M}.${m}.0${z2} <${+M + 1}.0.0-0`;
          }
        } else if (pr) {
          debug("replaceCaret pr", pr);
          if (M === "0") {
            if (m === "0") {
              ret = `>=${M}.${m}.${p}-${pr} <${M}.${m}.${+p + 1}-0`;
            } else {
              ret = `>=${M}.${m}.${p}-${pr} <${M}.${+m + 1}.0-0`;
            }
          } else {
            ret = `>=${M}.${m}.${p}-${pr} <${+M + 1}.0.0-0`;
          }
        } else {
          debug("no pr");
          if (M === "0") {
            if (m === "0") {
              ret = `>=${M}.${m}.${p}${z2} <${M}.${m}.${+p + 1}-0`;
            } else {
              ret = `>=${M}.${m}.${p}${z2} <${M}.${+m + 1}.0-0`;
            }
          } else {
            ret = `>=${M}.${m}.${p} <${+M + 1}.0.0-0`;
          }
        }
        debug("caret return", ret);
        return ret;
      });
    };
    var replaceXRanges = (comp, options) => {
      debug("replaceXRanges", comp, options);
      return comp.split(/\s+/).map((c) => replaceXRange(c, options)).join(" ");
    };
    var replaceXRange = (comp, options) => {
      comp = comp.trim();
      const r = options.loose ? re[t.XRANGELOOSE] : re[t.XRANGE];
      return comp.replace(r, (ret, gtlt, M, m, p, pr) => {
        debug("xRange", comp, ret, gtlt, M, m, p, pr);
        const xM = isX(M);
        const xm = xM || isX(m);
        const xp = xm || isX(p);
        const anyX = xp;
        if (gtlt === "=" && anyX) {
          gtlt = "";
        }
        pr = options.includePrerelease ? "-0" : "";
        if (xM) {
          if (gtlt === ">" || gtlt === "<") {
            ret = "<0.0.0-0";
          } else {
            ret = "*";
          }
        } else if (gtlt && anyX) {
          if (xm) {
            m = 0;
          }
          p = 0;
          if (gtlt === ">") {
            gtlt = ">=";
            if (xm) {
              M = +M + 1;
              m = 0;
              p = 0;
            } else {
              m = +m + 1;
              p = 0;
            }
          } else if (gtlt === "<=") {
            gtlt = "<";
            if (xm) {
              M = +M + 1;
            } else {
              m = +m + 1;
            }
          }
          if (gtlt === "<") {
            pr = "-0";
          }
          ret = `${gtlt + M}.${m}.${p}${pr}`;
        } else if (xm) {
          ret = `>=${M}.0.0${pr} <${+M + 1}.0.0-0`;
        } else if (xp) {
          ret = `>=${M}.${m}.0${pr} <${M}.${+m + 1}.0-0`;
        }
        debug("xRange return", ret);
        return ret;
      });
    };
    var replaceStars = (comp, options) => {
      debug("replaceStars", comp, options);
      return comp.trim().replace(re[t.STAR], "");
    };
    var replaceGTE0 = (comp, options) => {
      debug("replaceGTE0", comp, options);
      return comp.trim().replace(re[options.includePrerelease ? t.GTE0PRE : t.GTE0], "");
    };
    var hyphenReplace = (incPr) => ($0, from, fM, fm, fp, fpr, fb, to, tM, tm, tp, tpr) => {
      if (isX(fM)) {
        from = "";
      } else if (isX(fm)) {
        from = `>=${fM}.0.0${incPr ? "-0" : ""}`;
      } else if (isX(fp)) {
        from = `>=${fM}.${fm}.0${incPr ? "-0" : ""}`;
      } else if (fpr) {
        from = `>=${from}`;
      } else {
        from = `>=${from}${incPr ? "-0" : ""}`;
      }
      if (isX(tM)) {
        to = "";
      } else if (isX(tm)) {
        to = `<${+tM + 1}.0.0-0`;
      } else if (isX(tp)) {
        to = `<${tM}.${+tm + 1}.0-0`;
      } else if (tpr) {
        to = `<=${tM}.${tm}.${tp}-${tpr}`;
      } else if (incPr) {
        to = `<${tM}.${tm}.${+tp + 1}-0`;
      } else {
        to = `<=${to}`;
      }
      return `${from} ${to}`.trim();
    };
    var testSet = (set, version2, options) => {
      for (let i = 0; i < set.length; i++) {
        if (!set[i].test(version2)) {
          return false;
        }
      }
      if (version2.prerelease.length && !options.includePrerelease) {
        for (let i = 0; i < set.length; i++) {
          debug(set[i].semver);
          if (set[i].semver === Comparator.ANY) {
            continue;
          }
          if (set[i].semver.prerelease.length > 0) {
            const allowed = set[i].semver;
            if (allowed.major === version2.major && allowed.minor === version2.minor && allowed.patch === version2.patch) {
              return true;
            }
          }
        }
        return false;
      }
      return true;
    };
  }
});

// node_modules/semver/classes/comparator.js
var require_comparator = __commonJS({
  "node_modules/semver/classes/comparator.js"(exports2, module2) {
    "use strict";
    var ANY = Symbol("SemVer ANY");
    var Comparator = class _Comparator {
      static get ANY() {
        return ANY;
      }
      constructor(comp, options) {
        options = parseOptions(options);
        if (comp instanceof _Comparator) {
          if (comp.loose === !!options.loose) {
            return comp;
          } else {
            comp = comp.value;
          }
        }
        comp = comp.trim().split(/\s+/).join(" ");
        debug("comparator", comp, options);
        this.options = options;
        this.loose = !!options.loose;
        this.parse(comp);
        if (this.semver === ANY) {
          this.value = "";
        } else {
          this.value = this.operator + this.semver.version;
        }
        debug("comp", this);
      }
      parse(comp) {
        const r = this.options.loose ? re[t.COMPARATORLOOSE] : re[t.COMPARATOR];
        const m = comp.match(r);
        if (!m) {
          throw new TypeError(`Invalid comparator: ${comp}`);
        }
        this.operator = m[1] !== void 0 ? m[1] : "";
        if (this.operator === "=") {
          this.operator = "";
        }
        if (!m[2]) {
          this.semver = ANY;
        } else {
          this.semver = new SemVer(m[2], this.options.loose);
        }
      }
      toString() {
        return this.value;
      }
      test(version2) {
        debug("Comparator.test", version2, this.options.loose);
        if (this.semver === ANY || version2 === ANY) {
          return true;
        }
        if (typeof version2 === "string") {
          try {
            version2 = new SemVer(version2, this.options);
          } catch (er) {
            return false;
          }
        }
        return cmp(version2, this.operator, this.semver, this.options);
      }
      intersects(comp, options) {
        if (!(comp instanceof _Comparator)) {
          throw new TypeError("a Comparator is required");
        }
        if (this.operator === "") {
          if (this.value === "") {
            return true;
          }
          return new Range(comp.value, options).test(this.value);
        } else if (comp.operator === "") {
          if (comp.value === "") {
            return true;
          }
          return new Range(this.value, options).test(comp.semver);
        }
        options = parseOptions(options);
        if (options.includePrerelease && (this.value === "<0.0.0-0" || comp.value === "<0.0.0-0")) {
          return false;
        }
        if (!options.includePrerelease && (this.value.startsWith("<0.0.0") || comp.value.startsWith("<0.0.0"))) {
          return false;
        }
        if (this.operator.startsWith(">") && comp.operator.startsWith(">")) {
          return true;
        }
        if (this.operator.startsWith("<") && comp.operator.startsWith("<")) {
          return true;
        }
        if (this.semver.version === comp.semver.version && this.operator.includes("=") && comp.operator.includes("=")) {
          return true;
        }
        if (cmp(this.semver, "<", comp.semver, options) && this.operator.startsWith(">") && comp.operator.startsWith("<")) {
          return true;
        }
        if (cmp(this.semver, ">", comp.semver, options) && this.operator.startsWith("<") && comp.operator.startsWith(">")) {
          return true;
        }
        return false;
      }
    };
    module2.exports = Comparator;
    var parseOptions = require_parse_options();
    var { safeRe: re, t } = require_re();
    var cmp = require_cmp();
    var debug = require_debug2();
    var SemVer = require_semver();
    var Range = require_range();
  }
});

// node_modules/semver/functions/satisfies.js
var require_satisfies = __commonJS({
  "node_modules/semver/functions/satisfies.js"(exports2, module2) {
    "use strict";
    var Range = require_range();
    var satisfies = (version2, range, options) => {
      try {
        range = new Range(range, options);
      } catch (er) {
        return false;
      }
      return range.test(version2);
    };
    module2.exports = satisfies;
  }
});

// node_modules/semver/ranges/to-comparators.js
var require_to_comparators = __commonJS({
  "node_modules/semver/ranges/to-comparators.js"(exports2, module2) {
    "use strict";
    var Range = require_range();
    var toComparators = (range, options) => new Range(range, options).set.map((comp) => comp.map((c) => c.value).join(" ").trim().split(" "));
    module2.exports = toComparators;
  }
});

// node_modules/semver/ranges/max-satisfying.js
var require_max_satisfying = __commonJS({
  "node_modules/semver/ranges/max-satisfying.js"(exports2, module2) {
    "use strict";
    var SemVer = require_semver();
    var Range = require_range();
    var maxSatisfying = (versions, range, options) => {
      let max = null;
      let maxSV = null;
      let rangeObj = null;
      try {
        rangeObj = new Range(range, options);
      } catch (er) {
        return null;
      }
      versions.forEach((v) => {
        if (rangeObj.test(v)) {
          if (!max || maxSV.compare(v) === -1) {
            max = v;
            maxSV = new SemVer(max, options);
          }
        }
      });
      return max;
    };
    module2.exports = maxSatisfying;
  }
});

// node_modules/semver/ranges/min-satisfying.js
var require_min_satisfying = __commonJS({
  "node_modules/semver/ranges/min-satisfying.js"(exports2, module2) {
    "use strict";
    var SemVer = require_semver();
    var Range = require_range();
    var minSatisfying = (versions, range, options) => {
      let min = null;
      let minSV = null;
      let rangeObj = null;
      try {
        rangeObj = new Range(range, options);
      } catch (er) {
        return null;
      }
      versions.forEach((v) => {
        if (rangeObj.test(v)) {
          if (!min || minSV.compare(v) === 1) {
            min = v;
            minSV = new SemVer(min, options);
          }
        }
      });
      return min;
    };
    module2.exports = minSatisfying;
  }
});

// node_modules/semver/ranges/min-version.js
var require_min_version = __commonJS({
  "node_modules/semver/ranges/min-version.js"(exports2, module2) {
    "use strict";
    var SemVer = require_semver();
    var Range = require_range();
    var gt = require_gt();
    var minVersion = (range, loose) => {
      range = new Range(range, loose);
      let minver = new SemVer("0.0.0");
      if (range.test(minver)) {
        return minver;
      }
      minver = new SemVer("0.0.0-0");
      if (range.test(minver)) {
        return minver;
      }
      minver = null;
      for (let i = 0; i < range.set.length; ++i) {
        const comparators = range.set[i];
        let setMin = null;
        comparators.forEach((comparator) => {
          const compver = new SemVer(comparator.semver.version);
          switch (comparator.operator) {
            case ">":
              if (compver.prerelease.length === 0) {
                compver.patch++;
              } else {
                compver.prerelease.push(0);
              }
              compver.raw = compver.format();
            /* fallthrough */
            case "":
            case ">=":
              if (!setMin || gt(compver, setMin)) {
                setMin = compver;
              }
              break;
            case "<":
            case "<=":
              break;
            /* istanbul ignore next */
            default:
              throw new Error(`Unexpected operation: ${comparator.operator}`);
          }
        });
        if (setMin && (!minver || gt(minver, setMin))) {
          minver = setMin;
        }
      }
      if (minver && range.test(minver)) {
        return minver;
      }
      return null;
    };
    module2.exports = minVersion;
  }
});

// node_modules/semver/ranges/valid.js
var require_valid2 = __commonJS({
  "node_modules/semver/ranges/valid.js"(exports2, module2) {
    "use strict";
    var Range = require_range();
    var validRange = (range, options) => {
      try {
        return new Range(range, options).range || "*";
      } catch (er) {
        return null;
      }
    };
    module2.exports = validRange;
  }
});

// node_modules/semver/ranges/outside.js
var require_outside = __commonJS({
  "node_modules/semver/ranges/outside.js"(exports2, module2) {
    "use strict";
    var SemVer = require_semver();
    var Comparator = require_comparator();
    var { ANY } = Comparator;
    var Range = require_range();
    var satisfies = require_satisfies();
    var gt = require_gt();
    var lt = require_lt();
    var lte = require_lte();
    var gte = require_gte();
    var outside = (version2, range, hilo, options) => {
      version2 = new SemVer(version2, options);
      range = new Range(range, options);
      let gtfn, ltefn, ltfn, comp, ecomp;
      switch (hilo) {
        case ">":
          gtfn = gt;
          ltefn = lte;
          ltfn = lt;
          comp = ">";
          ecomp = ">=";
          break;
        case "<":
          gtfn = lt;
          ltefn = gte;
          ltfn = gt;
          comp = "<";
          ecomp = "<=";
          break;
        default:
          throw new TypeError('Must provide a hilo val of "<" or ">"');
      }
      if (satisfies(version2, range, options)) {
        return false;
      }
      for (let i = 0; i < range.set.length; ++i) {
        const comparators = range.set[i];
        let high = null;
        let low = null;
        comparators.forEach((comparator) => {
          if (comparator.semver === ANY) {
            comparator = new Comparator(">=0.0.0");
          }
          high = high || comparator;
          low = low || comparator;
          if (gtfn(comparator.semver, high.semver, options)) {
            high = comparator;
          } else if (ltfn(comparator.semver, low.semver, options)) {
            low = comparator;
          }
        });
        if (high.operator === comp || high.operator === ecomp) {
          return false;
        }
        if ((!low.operator || low.operator === comp) && ltefn(version2, low.semver)) {
          return false;
        } else if (low.operator === ecomp && ltfn(version2, low.semver)) {
          return false;
        }
      }
      return true;
    };
    module2.exports = outside;
  }
});

// node_modules/semver/ranges/gtr.js
var require_gtr = __commonJS({
  "node_modules/semver/ranges/gtr.js"(exports2, module2) {
    "use strict";
    var outside = require_outside();
    var gtr = (version2, range, options) => outside(version2, range, ">", options);
    module2.exports = gtr;
  }
});

// node_modules/semver/ranges/ltr.js
var require_ltr = __commonJS({
  "node_modules/semver/ranges/ltr.js"(exports2, module2) {
    "use strict";
    var outside = require_outside();
    var ltr = (version2, range, options) => outside(version2, range, "<", options);
    module2.exports = ltr;
  }
});

// node_modules/semver/ranges/intersects.js
var require_intersects = __commonJS({
  "node_modules/semver/ranges/intersects.js"(exports2, module2) {
    "use strict";
    var Range = require_range();
    var intersects = (r1, r2, options) => {
      r1 = new Range(r1, options);
      r2 = new Range(r2, options);
      return r1.intersects(r2, options);
    };
    module2.exports = intersects;
  }
});

// node_modules/semver/ranges/simplify.js
var require_simplify = __commonJS({
  "node_modules/semver/ranges/simplify.js"(exports2, module2) {
    "use strict";
    var satisfies = require_satisfies();
    var compare = require_compare();
    module2.exports = (versions, range, options) => {
      const set = [];
      let first = null;
      let prev = null;
      const v = versions.sort((a, b) => compare(a, b, options));
      for (const version2 of v) {
        const included = satisfies(version2, range, options);
        if (included) {
          prev = version2;
          if (!first) {
            first = version2;
          }
        } else {
          if (prev) {
            set.push([first, prev]);
          }
          prev = null;
          first = null;
        }
      }
      if (first) {
        set.push([first, null]);
      }
      const ranges = [];
      for (const [min, max] of set) {
        if (min === max) {
          ranges.push(min);
        } else if (!max && min === v[0]) {
          ranges.push("*");
        } else if (!max) {
          ranges.push(`>=${min}`);
        } else if (min === v[0]) {
          ranges.push(`<=${max}`);
        } else {
          ranges.push(`${min} - ${max}`);
        }
      }
      const simplified = ranges.join(" || ");
      const original = typeof range.raw === "string" ? range.raw : String(range);
      return simplified.length < original.length ? simplified : range;
    };
  }
});

// node_modules/semver/ranges/subset.js
var require_subset = __commonJS({
  "node_modules/semver/ranges/subset.js"(exports2, module2) {
    "use strict";
    var Range = require_range();
    var Comparator = require_comparator();
    var { ANY } = Comparator;
    var satisfies = require_satisfies();
    var compare = require_compare();
    var subset = (sub, dom, options = {}) => {
      if (sub === dom) {
        return true;
      }
      sub = new Range(sub, options);
      dom = new Range(dom, options);
      let sawNonNull = false;
      OUTER: for (const simpleSub of sub.set) {
        for (const simpleDom of dom.set) {
          const isSub = simpleSubset(simpleSub, simpleDom, options);
          sawNonNull = sawNonNull || isSub !== null;
          if (isSub) {
            continue OUTER;
          }
        }
        if (sawNonNull) {
          return false;
        }
      }
      return true;
    };
    var minimumVersionWithPreRelease = [new Comparator(">=0.0.0-0")];
    var minimumVersion = [new Comparator(">=0.0.0")];
    var simpleSubset = (sub, dom, options) => {
      if (sub === dom) {
        return true;
      }
      if (sub.length === 1 && sub[0].semver === ANY) {
        if (dom.length === 1 && dom[0].semver === ANY) {
          return true;
        } else if (options.includePrerelease) {
          sub = minimumVersionWithPreRelease;
        } else {
          sub = minimumVersion;
        }
      }
      if (dom.length === 1 && dom[0].semver === ANY) {
        if (options.includePrerelease) {
          return true;
        } else {
          dom = minimumVersion;
        }
      }
      const eqSet = /* @__PURE__ */ new Set();
      let gt, lt;
      for (const c of sub) {
        if (c.operator === ">" || c.operator === ">=") {
          gt = higherGT(gt, c, options);
        } else if (c.operator === "<" || c.operator === "<=") {
          lt = lowerLT(lt, c, options);
        } else {
          eqSet.add(c.semver);
        }
      }
      if (eqSet.size > 1) {
        return null;
      }
      let gtltComp;
      if (gt && lt) {
        gtltComp = compare(gt.semver, lt.semver, options);
        if (gtltComp > 0) {
          return null;
        } else if (gtltComp === 0 && (gt.operator !== ">=" || lt.operator !== "<=")) {
          return null;
        }
      }
      for (const eq of eqSet) {
        if (gt && !satisfies(eq, String(gt), options)) {
          return null;
        }
        if (lt && !satisfies(eq, String(lt), options)) {
          return null;
        }
        for (const c of dom) {
          if (!satisfies(eq, String(c), options)) {
            return false;
          }
        }
        return true;
      }
      let higher, lower;
      let hasDomLT, hasDomGT;
      let needDomLTPre = lt && !options.includePrerelease && lt.semver.prerelease.length ? lt.semver : false;
      let needDomGTPre = gt && !options.includePrerelease && gt.semver.prerelease.length ? gt.semver : false;
      if (needDomLTPre && needDomLTPre.prerelease.length === 1 && lt.operator === "<" && needDomLTPre.prerelease[0] === 0) {
        needDomLTPre = false;
      }
      for (const c of dom) {
        hasDomGT = hasDomGT || c.operator === ">" || c.operator === ">=";
        hasDomLT = hasDomLT || c.operator === "<" || c.operator === "<=";
        if (gt) {
          if (needDomGTPre) {
            if (c.semver.prerelease && c.semver.prerelease.length && c.semver.major === needDomGTPre.major && c.semver.minor === needDomGTPre.minor && c.semver.patch === needDomGTPre.patch) {
              needDomGTPre = false;
            }
          }
          if (c.operator === ">" || c.operator === ">=") {
            higher = higherGT(gt, c, options);
            if (higher === c && higher !== gt) {
              return false;
            }
          } else if (gt.operator === ">=" && !satisfies(gt.semver, String(c), options)) {
            return false;
          }
        }
        if (lt) {
          if (needDomLTPre) {
            if (c.semver.prerelease && c.semver.prerelease.length && c.semver.major === needDomLTPre.major && c.semver.minor === needDomLTPre.minor && c.semver.patch === needDomLTPre.patch) {
              needDomLTPre = false;
            }
          }
          if (c.operator === "<" || c.operator === "<=") {
            lower = lowerLT(lt, c, options);
            if (lower === c && lower !== lt) {
              return false;
            }
          } else if (lt.operator === "<=" && !satisfies(lt.semver, String(c), options)) {
            return false;
          }
        }
        if (!c.operator && (lt || gt) && gtltComp !== 0) {
          return false;
        }
      }
      if (gt && hasDomLT && !lt && gtltComp !== 0) {
        return false;
      }
      if (lt && hasDomGT && !gt && gtltComp !== 0) {
        return false;
      }
      if (needDomGTPre || needDomLTPre) {
        return false;
      }
      return true;
    };
    var higherGT = (a, b, options) => {
      if (!a) {
        return b;
      }
      const comp = compare(a.semver, b.semver, options);
      return comp > 0 ? a : comp < 0 ? b : b.operator === ">" && a.operator === ">=" ? b : a;
    };
    var lowerLT = (a, b, options) => {
      if (!a) {
        return b;
      }
      const comp = compare(a.semver, b.semver, options);
      return comp < 0 ? a : comp > 0 ? b : b.operator === "<" && a.operator === "<=" ? b : a;
    };
    module2.exports = subset;
  }
});

// node_modules/semver/index.js
var require_semver2 = __commonJS({
  "node_modules/semver/index.js"(exports2, module2) {
    "use strict";
    var internalRe = require_re();
    var constants = require_constants2();
    var SemVer = require_semver();
    var identifiers = require_identifiers();
    var parse = require_parse4();
    var valid = require_valid();
    var clean = require_clean();
    var inc = require_inc();
    var diff = require_diff();
    var major = require_major();
    var minor = require_minor();
    var patch = require_patch();
    var prerelease = require_prerelease();
    var compare = require_compare();
    var rcompare = require_rcompare();
    var compareLoose = require_compare_loose();
    var compareBuild = require_compare_build();
    var sort = require_sort();
    var rsort = require_rsort();
    var gt = require_gt();
    var lt = require_lt();
    var eq = require_eq();
    var neq = require_neq();
    var gte = require_gte();
    var lte = require_lte();
    var cmp = require_cmp();
    var coerce = require_coerce();
    var Comparator = require_comparator();
    var Range = require_range();
    var satisfies = require_satisfies();
    var toComparators = require_to_comparators();
    var maxSatisfying = require_max_satisfying();
    var minSatisfying = require_min_satisfying();
    var minVersion = require_min_version();
    var validRange = require_valid2();
    var outside = require_outside();
    var gtr = require_gtr();
    var ltr = require_ltr();
    var intersects = require_intersects();
    var simplifyRange = require_simplify();
    var subset = require_subset();
    module2.exports = {
      parse,
      valid,
      clean,
      inc,
      diff,
      major,
      minor,
      patch,
      prerelease,
      compare,
      rcompare,
      compareLoose,
      compareBuild,
      sort,
      rsort,
      gt,
      lt,
      eq,
      neq,
      gte,
      lte,
      cmp,
      coerce,
      Comparator,
      Range,
      satisfies,
      toComparators,
      maxSatisfying,
      minSatisfying,
      minVersion,
      validRange,
      outside,
      gtr,
      ltr,
      intersects,
      simplifyRange,
      subset,
      SemVer,
      re: internalRe.re,
      src: internalRe.src,
      tokens: internalRe.t,
      SEMVER_SPEC_VERSION: constants.SEMVER_SPEC_VERSION,
      RELEASE_TYPES: constants.RELEASE_TYPES,
      compareIdentifiers: identifiers.compareIdentifiers,
      rcompareIdentifiers: identifiers.rcompareIdentifiers
    };
  }
});

// node_modules/fastify/lib/pluginUtils.js
var require_pluginUtils = __commonJS({
  "node_modules/fastify/lib/pluginUtils.js"(exports2, module2) {
    "use strict";
    var semver = require_semver2();
    var assert = require("node:assert");
    var kRegisteredPlugins = Symbol.for("registered-plugin");
    var {
      kTestInternals
    } = require_symbols2();
    var { exist, existReply, existRequest } = require_decorate();
    var {
      FST_ERR_PLUGIN_VERSION_MISMATCH,
      FST_ERR_PLUGIN_NOT_PRESENT_IN_INSTANCE,
      FST_ERR_PLUGIN_INVALID_ASYNC_HANDLER
    } = require_errors2();
    var rcRegex = /-(?:rc|pre|alpha).+$/u;
    function getMeta(fn) {
      return fn[Symbol.for("plugin-meta")];
    }
    function getPluginName(func) {
      const display = getDisplayName(func);
      if (display) {
        return display;
      }
      const cache = require.cache;
      if (cache) {
        const keys = Object.keys(cache);
        for (let i = 0; i < keys.length; i++) {
          const key = keys[i];
          if (cache[key].exports === func) {
            return key;
          }
        }
      }
      if (func.name) {
        return func.name;
      }
      return null;
    }
    function getFuncPreview(func) {
      return func.toString().split("\n", 2).map((s) => s.trim()).join(" -- ");
    }
    function getDisplayName(fn) {
      return fn[Symbol.for("fastify.display-name")];
    }
    function shouldSkipOverride(fn) {
      return !!fn[Symbol.for("skip-override")];
    }
    function checkDependencies(fn) {
      const meta = getMeta(fn);
      if (!meta) return;
      const dependencies = meta.dependencies;
      if (!dependencies) return;
      assert(Array.isArray(dependencies), "The dependencies should be an array of strings");
      dependencies.forEach((dependency) => {
        assert(
          this[kRegisteredPlugins].indexOf(dependency) > -1,
          `The dependency '${dependency}' of plugin '${meta.name}' is not registered`
        );
      });
    }
    function checkDecorators(fn) {
      const meta = getMeta(fn);
      if (!meta) return;
      const { decorators, name } = meta;
      if (!decorators) return;
      if (decorators.fastify) _checkDecorators(this, "Fastify", decorators.fastify, name);
      if (decorators.reply) _checkDecorators(this, "Reply", decorators.reply, name);
      if (decorators.request) _checkDecorators(this, "Request", decorators.request, name);
    }
    var checks = {
      Fastify: exist,
      Request: existRequest,
      Reply: existReply
    };
    function _checkDecorators(that, instance, decorators, name) {
      assert(Array.isArray(decorators), "The decorators should be an array of strings");
      decorators.forEach((decorator) => {
        const withPluginName = typeof name === "string" ? ` required by '${name}'` : "";
        if (!checks[instance].call(that, decorator)) {
          throw new FST_ERR_PLUGIN_NOT_PRESENT_IN_INSTANCE(decorator, withPluginName, instance);
        }
      });
    }
    function checkVersion(fn) {
      const meta = getMeta(fn);
      if (meta?.fastify == null) return;
      const requiredVersion = meta.fastify;
      const fastifyRc = rcRegex.test(this.version);
      if (fastifyRc === true && semver.gt(this.version, semver.coerce(requiredVersion)) === true) {
        return;
      }
      if (requiredVersion && semver.satisfies(this.version, requiredVersion, { includePrerelease: fastifyRc }) === false) {
        throw new FST_ERR_PLUGIN_VERSION_MISMATCH(meta.name, requiredVersion, this.version);
      }
    }
    function registerPluginName(fn) {
      const meta = getMeta(fn);
      if (!meta) return;
      const name = meta.name;
      if (!name) return;
      this[kRegisteredPlugins].push(name);
      return name;
    }
    function checkPluginHealthiness(fn, pluginName) {
      if (fn.constructor.name === "AsyncFunction" && fn.length === 3) {
        throw new FST_ERR_PLUGIN_INVALID_ASYNC_HANDLER(pluginName);
      }
    }
    function registerPlugin(fn) {
      const pluginName = registerPluginName.call(this, fn) || getPluginName(fn);
      checkPluginHealthiness.call(this, fn, pluginName);
      checkVersion.call(this, fn);
      checkDecorators.call(this, fn);
      checkDependencies.call(this, fn);
      return shouldSkipOverride(fn);
    }
    module2.exports = {
      getPluginName,
      getFuncPreview,
      kRegisteredPlugins,
      getDisplayName,
      registerPlugin
    };
    module2.exports[kTestInternals] = {
      shouldSkipOverride,
      getMeta,
      checkDecorators,
      checkDependencies
    };
  }
});

// node_modules/fastify/lib/reqIdGenFactory.js
var require_reqIdGenFactory = __commonJS({
  "node_modules/fastify/lib/reqIdGenFactory.js"(exports2, module2) {
    "use strict";
    function reqIdGenFactory(requestIdHeader, optGenReqId) {
      const genReqId = optGenReqId || buildDefaultGenReqId();
      if (requestIdHeader) {
        return buildOptionalHeaderReqId(requestIdHeader, genReqId);
      }
      return genReqId;
    }
    function getGenReqId(contextServer, req) {
      return contextServer.genReqId(req);
    }
    function buildDefaultGenReqId() {
      const maxInt = 2147483647;
      let nextReqId = 0;
      return function defaultGenReqId() {
        nextReqId = nextReqId + 1 & maxInt;
        return `req-${nextReqId.toString(36)}`;
      };
    }
    function buildOptionalHeaderReqId(requestIdHeader, genReqId) {
      return function(req) {
        return req.headers[requestIdHeader] || genReqId(req);
      };
    }
    module2.exports = {
      getGenReqId,
      reqIdGenFactory
    };
  }
});

// node_modules/fast-decode-uri-component/index.js
var require_fast_decode_uri_component = __commonJS({
  "node_modules/fast-decode-uri-component/index.js"(exports2, module2) {
    "use strict";
    var UTF8_ACCEPT = 12;
    var UTF8_REJECT = 0;
    var UTF8_DATA = [
      // The first part of the table maps bytes to character to a transition.
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      2,
      2,
      2,
      2,
      2,
      2,
      2,
      2,
      2,
      2,
      2,
      2,
      2,
      2,
      2,
      2,
      3,
      3,
      3,
      3,
      3,
      3,
      3,
      3,
      3,
      3,
      3,
      3,
      3,
      3,
      3,
      3,
      3,
      3,
      3,
      3,
      3,
      3,
      3,
      3,
      3,
      3,
      3,
      3,
      3,
      3,
      3,
      3,
      4,
      4,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      6,
      7,
      7,
      7,
      7,
      7,
      7,
      7,
      7,
      7,
      7,
      7,
      7,
      8,
      7,
      7,
      10,
      9,
      9,
      9,
      11,
      4,
      4,
      4,
      4,
      4,
      4,
      4,
      4,
      4,
      4,
      4,
      // The second part of the table maps a state to a new state when adding a
      // transition.
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      12,
      0,
      0,
      0,
      0,
      24,
      36,
      48,
      60,
      72,
      84,
      96,
      0,
      12,
      12,
      12,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      24,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      24,
      24,
      24,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      24,
      24,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      48,
      48,
      48,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      48,
      48,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      48,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      // The third part maps the current transition to a mask that needs to apply
      // to the byte.
      127,
      63,
      63,
      63,
      0,
      31,
      15,
      15,
      15,
      7,
      7,
      7
    ];
    function decodeURIComponent2(uri) {
      var percentPosition = uri.indexOf("%");
      if (percentPosition === -1) return uri;
      var length = uri.length;
      var decoded = "";
      var last = 0;
      var codepoint = 0;
      var startOfOctets = percentPosition;
      var state = UTF8_ACCEPT;
      while (percentPosition > -1 && percentPosition < length) {
        var high = hexCodeToInt(uri[percentPosition + 1], 4);
        var low = hexCodeToInt(uri[percentPosition + 2], 0);
        var byte = high | low;
        var type = UTF8_DATA[byte];
        state = UTF8_DATA[256 + state + type];
        codepoint = codepoint << 6 | byte & UTF8_DATA[364 + type];
        if (state === UTF8_ACCEPT) {
          decoded += uri.slice(last, startOfOctets);
          decoded += codepoint <= 65535 ? String.fromCharCode(codepoint) : String.fromCharCode(
            55232 + (codepoint >> 10),
            56320 + (codepoint & 1023)
          );
          codepoint = 0;
          last = percentPosition + 3;
          percentPosition = startOfOctets = uri.indexOf("%", last);
        } else if (state === UTF8_REJECT) {
          return null;
        } else {
          percentPosition += 3;
          if (percentPosition < length && uri.charCodeAt(percentPosition) === 37) continue;
          return null;
        }
      }
      return decoded + uri.slice(last);
    }
    var HEX = {
      "0": 0,
      "1": 1,
      "2": 2,
      "3": 3,
      "4": 4,
      "5": 5,
      "6": 6,
      "7": 7,
      "8": 8,
      "9": 9,
      "a": 10,
      "A": 10,
      "b": 11,
      "B": 11,
      "c": 12,
      "C": 12,
      "d": 13,
      "D": 13,
      "e": 14,
      "E": 14,
      "f": 15,
      "F": 15
    };
    function hexCodeToInt(c, shift) {
      var i = HEX[c];
      return i === void 0 ? 255 : i << shift;
    }
    module2.exports = decodeURIComponent2;
  }
});

// node_modules/fast-querystring/lib/parse.js
var require_parse5 = __commonJS({
  "node_modules/fast-querystring/lib/parse.js"(exports2, module2) {
    "use strict";
    var fastDecode = require_fast_decode_uri_component();
    var plusRegex = /\+/g;
    var Empty = function() {
    };
    Empty.prototype = /* @__PURE__ */ Object.create(null);
    function parse(input) {
      const result = new Empty();
      if (typeof input !== "string") {
        return result;
      }
      let inputLength = input.length;
      let key = "";
      let value = "";
      let startingIndex = -1;
      let equalityIndex = -1;
      let shouldDecodeKey = false;
      let shouldDecodeValue = false;
      let keyHasPlus = false;
      let valueHasPlus = false;
      let hasBothKeyValuePair = false;
      let c = 0;
      for (let i = 0; i < inputLength + 1; i++) {
        c = i !== inputLength ? input.charCodeAt(i) : 38;
        if (c === 38) {
          hasBothKeyValuePair = equalityIndex > startingIndex;
          if (!hasBothKeyValuePair) {
            equalityIndex = i;
          }
          key = input.slice(startingIndex + 1, equalityIndex);
          if (hasBothKeyValuePair || key.length > 0) {
            if (keyHasPlus) {
              key = key.replace(plusRegex, " ");
            }
            if (shouldDecodeKey) {
              key = fastDecode(key) || key;
            }
            if (hasBothKeyValuePair) {
              value = input.slice(equalityIndex + 1, i);
              if (valueHasPlus) {
                value = value.replace(plusRegex, " ");
              }
              if (shouldDecodeValue) {
                value = fastDecode(value) || value;
              }
            }
            const currentValue = result[key];
            if (currentValue === void 0) {
              result[key] = value;
            } else {
              if (currentValue.pop) {
                currentValue.push(value);
              } else {
                result[key] = [currentValue, value];
              }
            }
          }
          value = "";
          startingIndex = i;
          equalityIndex = i;
          shouldDecodeKey = false;
          shouldDecodeValue = false;
          keyHasPlus = false;
          valueHasPlus = false;
        } else if (c === 61) {
          if (equalityIndex <= startingIndex) {
            equalityIndex = i;
          } else {
            shouldDecodeValue = true;
          }
        } else if (c === 43) {
          if (equalityIndex > startingIndex) {
            valueHasPlus = true;
          } else {
            keyHasPlus = true;
          }
        } else if (c === 37) {
          if (equalityIndex > startingIndex) {
            shouldDecodeValue = true;
          } else {
            shouldDecodeKey = true;
          }
        }
      }
      return result;
    }
    module2.exports = parse;
  }
});

// node_modules/fast-querystring/lib/internals/querystring.js
var require_querystring = __commonJS({
  "node_modules/fast-querystring/lib/internals/querystring.js"(exports2, module2) {
    var hexTable = Array.from(
      { length: 256 },
      (_, i) => "%" + ((i < 16 ? "0" : "") + i.toString(16)).toUpperCase()
    );
    var noEscape = new Int8Array([
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      // 0 - 15
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      // 16 - 31
      0,
      1,
      0,
      0,
      0,
      0,
      0,
      1,
      1,
      1,
      1,
      0,
      0,
      1,
      1,
      0,
      // 32 - 47
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      0,
      0,
      0,
      0,
      0,
      0,
      // 48 - 63
      0,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      // 64 - 79
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      0,
      0,
      0,
      0,
      1,
      // 80 - 95
      0,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      // 96 - 111
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      0,
      0,
      0,
      1,
      0
      // 112 - 127
    ]);
    function encodeString(str) {
      const len = str.length;
      if (len === 0) return "";
      let out = "";
      let lastPos = 0;
      let i = 0;
      outer: for (; i < len; i++) {
        let c = str.charCodeAt(i);
        while (c < 128) {
          if (noEscape[c] !== 1) {
            if (lastPos < i) out += str.slice(lastPos, i);
            lastPos = i + 1;
            out += hexTable[c];
          }
          if (++i === len) break outer;
          c = str.charCodeAt(i);
        }
        if (lastPos < i) out += str.slice(lastPos, i);
        if (c < 2048) {
          lastPos = i + 1;
          out += hexTable[192 | c >> 6] + hexTable[128 | c & 63];
          continue;
        }
        if (c < 55296 || c >= 57344) {
          lastPos = i + 1;
          out += hexTable[224 | c >> 12] + hexTable[128 | c >> 6 & 63] + hexTable[128 | c & 63];
          continue;
        }
        ++i;
        if (i >= len) {
          throw new Error("URI malformed");
        }
        const c2 = str.charCodeAt(i) & 1023;
        lastPos = i + 1;
        c = 65536 + ((c & 1023) << 10 | c2);
        out += hexTable[240 | c >> 18] + hexTable[128 | c >> 12 & 63] + hexTable[128 | c >> 6 & 63] + hexTable[128 | c & 63];
      }
      if (lastPos === 0) return str;
      if (lastPos < len) return out + str.slice(lastPos);
      return out;
    }
    module2.exports = { encodeString };
  }
});

// node_modules/fast-querystring/lib/stringify.js
var require_stringify2 = __commonJS({
  "node_modules/fast-querystring/lib/stringify.js"(exports2, module2) {
    "use strict";
    var { encodeString } = require_querystring();
    function getAsPrimitive(value) {
      const type = typeof value;
      if (type === "string") {
        return encodeString(value);
      } else if (type === "bigint") {
        return value.toString();
      } else if (type === "boolean") {
        return value ? "true" : "false";
      } else if (type === "number" && Number.isFinite(value)) {
        return value < 1e21 ? "" + value : encodeString("" + value);
      }
      return "";
    }
    function stringify(input) {
      let result = "";
      if (input === null || typeof input !== "object") {
        return result;
      }
      const separator = "&";
      const keys = Object.keys(input);
      const keyLength = keys.length;
      let valueLength = 0;
      for (let i = 0; i < keyLength; i++) {
        const key = keys[i];
        const value = input[key];
        const encodedKey = encodeString(key) + "=";
        if (i) {
          result += separator;
        }
        if (Array.isArray(value)) {
          valueLength = value.length;
          for (let j = 0; j < valueLength; j++) {
            if (j) {
              result += separator;
            }
            result += encodedKey;
            result += getAsPrimitive(value[j]);
          }
        } else {
          result += encodedKey;
          result += getAsPrimitive(value);
        }
      }
      return result;
    }
    module2.exports = stringify;
  }
});

// node_modules/fast-querystring/lib/index.js
var require_lib2 = __commonJS({
  "node_modules/fast-querystring/lib/index.js"(exports2, module2) {
    "use strict";
    var parse = require_parse5();
    var stringify = require_stringify2();
    var fastQuerystring = {
      parse,
      stringify
    };
    module2.exports = fastQuerystring;
    module2.exports.default = fastQuerystring;
    module2.exports.parse = parse;
    module2.exports.stringify = stringify;
  }
});

// node_modules/ret/dist/types/tokens.js
var require_tokens = __commonJS({
  "node_modules/ret/dist/types/tokens.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
  }
});

// node_modules/ret/dist/types/types.js
var require_types3 = __commonJS({
  "node_modules/ret/dist/types/types.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.types = void 0;
    var types;
    (function(types2) {
      types2[types2["ROOT"] = 0] = "ROOT";
      types2[types2["GROUP"] = 1] = "GROUP";
      types2[types2["POSITION"] = 2] = "POSITION";
      types2[types2["SET"] = 3] = "SET";
      types2[types2["RANGE"] = 4] = "RANGE";
      types2[types2["REPETITION"] = 5] = "REPETITION";
      types2[types2["REFERENCE"] = 6] = "REFERENCE";
      types2[types2["CHAR"] = 7] = "CHAR";
    })(types = exports2.types || (exports2.types = {}));
  }
});

// node_modules/ret/dist/types/set-lookup.js
var require_set_lookup = __commonJS({
  "node_modules/ret/dist/types/set-lookup.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
  }
});

// node_modules/ret/dist/types/index.js
var require_types4 = __commonJS({
  "node_modules/ret/dist/types/index.js"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      Object.defineProperty(o, k2, { enumerable: true, get: function() {
        return m[k];
      } });
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports2 && exports2.__exportStar || function(m, exports3) {
      for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p)) __createBinding(exports3, m, p);
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    __exportStar(require_tokens(), exports2);
    __exportStar(require_types3(), exports2);
    __exportStar(require_set_lookup(), exports2);
  }
});

// node_modules/ret/dist/sets.js
var require_sets = __commonJS({
  "node_modules/ret/dist/sets.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.anyChar = exports2.notWhitespace = exports2.whitespace = exports2.notInts = exports2.ints = exports2.notWords = exports2.words = void 0;
    var types_1 = require_types4();
    var INTS = () => [{ type: types_1.types.RANGE, from: 48, to: 57 }];
    var WORDS = () => [
      { type: types_1.types.CHAR, value: 95 },
      { type: types_1.types.RANGE, from: 97, to: 122 },
      { type: types_1.types.RANGE, from: 65, to: 90 },
      { type: types_1.types.RANGE, from: 48, to: 57 }
    ];
    var WHITESPACE = () => [
      { type: types_1.types.CHAR, value: 9 },
      { type: types_1.types.CHAR, value: 10 },
      { type: types_1.types.CHAR, value: 11 },
      { type: types_1.types.CHAR, value: 12 },
      { type: types_1.types.CHAR, value: 13 },
      { type: types_1.types.CHAR, value: 32 },
      { type: types_1.types.CHAR, value: 160 },
      { type: types_1.types.CHAR, value: 5760 },
      { type: types_1.types.RANGE, from: 8192, to: 8202 },
      { type: types_1.types.CHAR, value: 8232 },
      { type: types_1.types.CHAR, value: 8233 },
      { type: types_1.types.CHAR, value: 8239 },
      { type: types_1.types.CHAR, value: 8287 },
      { type: types_1.types.CHAR, value: 12288 },
      { type: types_1.types.CHAR, value: 65279 }
    ];
    var NOTANYCHAR = () => [
      { type: types_1.types.CHAR, value: 10 },
      { type: types_1.types.CHAR, value: 13 },
      { type: types_1.types.CHAR, value: 8232 },
      { type: types_1.types.CHAR, value: 8233 }
    ];
    exports2.words = () => ({ type: types_1.types.SET, set: WORDS(), not: false });
    exports2.notWords = () => ({ type: types_1.types.SET, set: WORDS(), not: true });
    exports2.ints = () => ({ type: types_1.types.SET, set: INTS(), not: false });
    exports2.notInts = () => ({ type: types_1.types.SET, set: INTS(), not: true });
    exports2.whitespace = () => ({ type: types_1.types.SET, set: WHITESPACE(), not: false });
    exports2.notWhitespace = () => ({ type: types_1.types.SET, set: WHITESPACE(), not: true });
    exports2.anyChar = () => ({ type: types_1.types.SET, set: NOTANYCHAR(), not: true });
  }
});

// node_modules/ret/dist/util.js
var require_util3 = __commonJS({
  "node_modules/ret/dist/util.js"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      Object.defineProperty(o, k2, { enumerable: true, get: function() {
        return m[k];
      } });
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports2 && exports2.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports2 && exports2.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.tokenizeClass = exports2.strToChars = void 0;
    var types_1 = require_types4();
    var sets = __importStar(require_sets());
    var CTRL = "@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^ ?";
    exports2.strToChars = (str) => {
      const charsRegex = /(\[\\b\])|(\\)?\\(?:u([A-F0-9]{4})|x([A-F0-9]{2})|c([@A-Z[\\\]^?])|([0tnvfr]))/g;
      return str.replace(charsRegex, (s, b, lbs, a16, b16, dctrl, eslsh) => {
        if (lbs) {
          return s;
        }
        let code = b ? 8 : a16 ? parseInt(a16, 16) : b16 ? parseInt(b16, 16) : dctrl ? CTRL.indexOf(dctrl) : {
          0: 0,
          t: 9,
          n: 10,
          v: 11,
          f: 12,
          r: 13
        }[eslsh];
        let c = String.fromCharCode(code);
        return /[[\]{}^$.|?*+()]/.test(c) ? `\\${c}` : c;
      });
    };
    exports2.tokenizeClass = (str, regexpStr) => {
      var _a, _b, _c, _d, _e, _f, _g;
      let tokens = [], rs, c;
      const regexp = /\\(?:(w)|(d)|(s)|(W)|(D)|(S))|((?:(?:\\)(.)|([^\]\\]))-(((?:\\)])|(((?:\\)?([^\]])))))|(\])|(?:\\)?([^])/g;
      while ((rs = regexp.exec(str)) !== null) {
        const p = (_g = (_f = (_e = (_d = (_c = (_b = (_a = rs[1] && sets.words()) !== null && _a !== void 0 ? _a : rs[2] && sets.ints()) !== null && _b !== void 0 ? _b : rs[3] && sets.whitespace()) !== null && _c !== void 0 ? _c : rs[4] && sets.notWords()) !== null && _d !== void 0 ? _d : rs[5] && sets.notInts()) !== null && _e !== void 0 ? _e : rs[6] && sets.notWhitespace()) !== null && _f !== void 0 ? _f : rs[7] && {
          type: types_1.types.RANGE,
          from: (rs[8] || rs[9]).charCodeAt(0),
          to: (c = rs[10]).charCodeAt(c.length - 1)
        }) !== null && _g !== void 0 ? _g : (c = rs[16]) && { type: types_1.types.CHAR, value: c.charCodeAt(0) };
        if (p) {
          tokens.push(p);
        } else {
          return [tokens, regexp.lastIndex];
        }
      }
      throw new SyntaxError(`Invalid regular expression: /${regexpStr}/: Unterminated character class`);
    };
  }
});

// node_modules/ret/dist/tokenizer.js
var require_tokenizer = __commonJS({
  "node_modules/ret/dist/tokenizer.js"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      Object.defineProperty(o, k2, { enumerable: true, get: function() {
        return m[k];
      } });
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports2 && exports2.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports2 && exports2.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.tokenizer = void 0;
    var util = __importStar(require_util3());
    var types_1 = require_types4();
    var sets = __importStar(require_sets());
    var captureGroupFirstChar = /^[a-zA-Z_$]$/i;
    var captureGroupChars = /^[a-zA-Z0-9_$]$/i;
    var digit = /\d/;
    exports2.tokenizer = (regexpStr) => {
      let i = 0, c;
      let start = { type: types_1.types.ROOT, stack: [] };
      let lastGroup = start;
      let last = start.stack;
      let groupStack = [];
      let referenceQueue = [];
      let groupCount = 0;
      const repeatErr = (col) => {
        throw new SyntaxError(`Invalid regular expression: /${regexpStr}/: Nothing to repeat at column ${col - 1}`);
      };
      let str = util.strToChars(regexpStr);
      while (i < str.length) {
        switch (c = str[i++]) {
          // Handle escaped characters, inclues a few sets.
          case "\\":
            if (i === str.length) {
              throw new SyntaxError(`Invalid regular expression: /${regexpStr}/: \\ at end of pattern`);
            }
            switch (c = str[i++]) {
              case "b":
                last.push({ type: types_1.types.POSITION, value: "b" });
                break;
              case "B":
                last.push({ type: types_1.types.POSITION, value: "B" });
                break;
              case "w":
                last.push(sets.words());
                break;
              case "W":
                last.push(sets.notWords());
                break;
              case "d":
                last.push(sets.ints());
                break;
              case "D":
                last.push(sets.notInts());
                break;
              case "s":
                last.push(sets.whitespace());
                break;
              case "S":
                last.push(sets.notWhitespace());
                break;
              default:
                if (digit.test(c)) {
                  let digits = c;
                  while (i < str.length && digit.test(str[i])) {
                    digits += str[i++];
                  }
                  let value = parseInt(digits, 10);
                  const reference = { type: types_1.types.REFERENCE, value };
                  last.push(reference);
                  referenceQueue.push({ reference, stack: last, index: last.length - 1 });
                } else {
                  last.push({ type: types_1.types.CHAR, value: c.charCodeAt(0) });
                }
            }
            break;
          // Positionals.
          case "^":
            last.push({ type: types_1.types.POSITION, value: "^" });
            break;
          case "$":
            last.push({ type: types_1.types.POSITION, value: "$" });
            break;
          // Handle custom sets.
          case "[": {
            let not;
            if (str[i] === "^") {
              not = true;
              i++;
            } else {
              not = false;
            }
            let classTokens = util.tokenizeClass(str.slice(i), regexpStr);
            i += classTokens[1];
            last.push({
              type: types_1.types.SET,
              set: classTokens[0],
              not
            });
            break;
          }
          // Class of any character except \n.
          case ".":
            last.push(sets.anyChar());
            break;
          // Push group onto stack.
          case "(": {
            let group = {
              type: types_1.types.GROUP,
              stack: [],
              remember: true
            };
            if (str[i] === "?") {
              c = str[i + 1];
              i += 2;
              if (c === "=") {
                group.followedBy = true;
                group.remember = false;
              } else if (c === "!") {
                group.notFollowedBy = true;
                group.remember = false;
              } else if (c === "<") {
                let name = "";
                if (captureGroupFirstChar.test(str[i])) {
                  name += str[i];
                  i++;
                } else {
                  throw new SyntaxError(`Invalid regular expression: /${regexpStr}/: Invalid capture group name, character '${str[i]}' after '<' at column ${i + 1}`);
                }
                while (i < str.length && captureGroupChars.test(str[i])) {
                  name += str[i];
                  i++;
                }
                if (!name) {
                  throw new SyntaxError(`Invalid regular expression: /${regexpStr}/: Invalid capture group name, character '${str[i]}' after '<' at column ${i + 1}`);
                }
                if (str[i] !== ">") {
                  throw new SyntaxError(`Invalid regular expression: /${regexpStr}/: Unclosed capture group name, expected '>', found '${str[i]}' at column ${i + 1}`);
                }
                group.name = name;
                i++;
              } else if (c === ":") {
                group.remember = false;
              } else {
                throw new SyntaxError(`Invalid regular expression: /${regexpStr}/: Invalid group, character '${c}' after '?' at column ${i - 1}`);
              }
            } else {
              groupCount += 1;
            }
            last.push(group);
            groupStack.push(lastGroup);
            lastGroup = group;
            last = group.stack;
            break;
          }
          // Pop group out of stack.
          case ")":
            if (groupStack.length === 0) {
              throw new SyntaxError(`Invalid regular expression: /${regexpStr}/: Unmatched ) at column ${i - 1}`);
            }
            lastGroup = groupStack.pop();
            last = lastGroup.options ? lastGroup.options[lastGroup.options.length - 1] : lastGroup.stack;
            break;
          // Use pipe character to give more choices.
          case "|": {
            if (!lastGroup.options) {
              lastGroup.options = [lastGroup.stack];
              delete lastGroup.stack;
            }
            let stack = [];
            lastGroup.options.push(stack);
            last = stack;
            break;
          }
          // Repetition.
          // For every repetition, remove last element from last stack
          // then insert back a RANGE object.
          // This design is chosen because there could be more than
          // one repetition symbols in a regex i.e. `a?+{2,3}`.
          case "{": {
            let rs = /^(\d+)(,(\d+)?)?\}/.exec(str.slice(i)), min, max;
            if (rs !== null) {
              if (last.length === 0) {
                repeatErr(i);
              }
              min = parseInt(rs[1], 10);
              max = rs[2] ? rs[3] ? parseInt(rs[3], 10) : Infinity : min;
              i += rs[0].length;
              last.push({
                type: types_1.types.REPETITION,
                min,
                max,
                value: last.pop()
              });
            } else {
              last.push({
                type: types_1.types.CHAR,
                value: 123
              });
            }
            break;
          }
          case "?":
            if (last.length === 0) {
              repeatErr(i);
            }
            last.push({
              type: types_1.types.REPETITION,
              min: 0,
              max: 1,
              value: last.pop()
            });
            break;
          case "+":
            if (last.length === 0) {
              repeatErr(i);
            }
            last.push({
              type: types_1.types.REPETITION,
              min: 1,
              max: Infinity,
              value: last.pop()
            });
            break;
          case "*":
            if (last.length === 0) {
              repeatErr(i);
            }
            last.push({
              type: types_1.types.REPETITION,
              min: 0,
              max: Infinity,
              value: last.pop()
            });
            break;
          // Default is a character that is not `\[](){}?+*^$`.
          default:
            last.push({
              type: types_1.types.CHAR,
              value: c.charCodeAt(0)
            });
        }
      }
      if (groupStack.length !== 0) {
        throw new SyntaxError(`Invalid regular expression: /${regexpStr}/: Unterminated group`);
      }
      updateReferences(referenceQueue, groupCount);
      return start;
    };
    function updateReferences(referenceQueue, groupCount) {
      for (const elem of referenceQueue.reverse()) {
        if (groupCount < elem.reference.value) {
          elem.reference.type = types_1.types.CHAR;
          const valueString = elem.reference.value.toString();
          elem.reference.value = parseInt(valueString, 8);
          if (!/^[0-7]+$/.test(valueString)) {
            let i = 0;
            while (valueString[i] !== "8" && valueString[i] !== "9") {
              i += 1;
            }
            if (i === 0) {
              elem.reference.value = valueString.charCodeAt(0);
              i += 1;
            } else {
              elem.reference.value = parseInt(valueString.slice(0, i), 8);
            }
            if (valueString.length > i) {
              const tail = elem.stack.splice(elem.index + 1);
              for (const char of valueString.slice(i)) {
                elem.stack.push({
                  type: types_1.types.CHAR,
                  value: char.charCodeAt(0)
                });
              }
              elem.stack.push(...tail);
            }
          }
        }
      }
    }
  }
});

// node_modules/ret/dist/sets-lookup.js
var require_sets_lookup = __commonJS({
  "node_modules/ret/dist/sets-lookup.js"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      Object.defineProperty(o, k2, { enumerable: true, get: function() {
        return m[k];
      } });
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports2 && exports2.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports2 && exports2.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.NOTANYCHAR = exports2.WHITESPACE = exports2.WORDS = exports2.INTS = void 0;
    var Sets = __importStar(require_sets());
    var types_1 = require_types4();
    function setToLookup(tokens) {
      let lookup = {};
      let len = 0;
      for (const token of tokens) {
        if (token.type === types_1.types.CHAR) {
          lookup[token.value] = true;
        }
        if (token.type === types_1.types.RANGE) {
          lookup[`${token.from}-${token.to}`] = true;
        }
        len += 1;
      }
      return {
        lookup: () => Object.assign({}, lookup),
        len
      };
    }
    exports2.INTS = setToLookup(Sets.ints().set);
    exports2.WORDS = setToLookup(Sets.words().set);
    exports2.WHITESPACE = setToLookup(Sets.whitespace().set);
    exports2.NOTANYCHAR = setToLookup(Sets.anyChar().set);
  }
});

// node_modules/ret/dist/write-set-tokens.js
var require_write_set_tokens = __commonJS({
  "node_modules/ret/dist/write-set-tokens.js"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      Object.defineProperty(o, k2, { enumerable: true, get: function() {
        return m[k];
      } });
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports2 && exports2.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports2 && exports2.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.writeSetTokens = exports2.setChar = void 0;
    var types_1 = require_types4();
    var sets = __importStar(require_sets_lookup());
    function setChar(charCode) {
      return charCode === 94 ? "\\^" : charCode === 92 ? "\\\\" : charCode === 93 ? "\\]" : charCode === 45 ? "\\-" : String.fromCharCode(charCode);
    }
    exports2.setChar = setChar;
    function isSameSet(set, { lookup, len }) {
      if (len !== set.length) {
        return false;
      }
      const map = lookup();
      for (const elem of set) {
        if (elem.type === types_1.types.SET) {
          return false;
        }
        const key = elem.type === types_1.types.CHAR ? elem.value : `${elem.from}-${elem.to}`;
        if (map[key]) {
          map[key] = false;
        } else {
          return false;
        }
      }
      return true;
    }
    function writeSetTokens(set, isNested = false) {
      if (isSameSet(set.set, sets.INTS)) {
        return set.not ? "\\D" : "\\d";
      }
      if (isSameSet(set.set, sets.WORDS)) {
        return set.not ? "\\W" : "\\w";
      }
      if (set.not && isSameSet(set.set, sets.NOTANYCHAR)) {
        return ".";
      }
      if (isSameSet(set.set, sets.WHITESPACE)) {
        return set.not ? "\\S" : "\\s";
      }
      let tokenString = "";
      for (let i = 0; i < set.set.length; i++) {
        const subset = set.set[i];
        tokenString += writeSetToken(subset);
      }
      const contents = `${set.not ? "^" : ""}${tokenString}`;
      return isNested ? contents : `[${contents}]`;
    }
    exports2.writeSetTokens = writeSetTokens;
    function writeSetToken(set) {
      if (set.type === types_1.types.CHAR) {
        return setChar(set.value);
      } else if (set.type === types_1.types.RANGE) {
        return `${setChar(set.from)}-${setChar(set.to)}`;
      }
      return writeSetTokens(set, true);
    }
  }
});

// node_modules/ret/dist/reconstruct.js
var require_reconstruct = __commonJS({
  "node_modules/ret/dist/reconstruct.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.reconstruct = void 0;
    var types_1 = require_types4();
    var write_set_tokens_1 = require_write_set_tokens();
    var reduceStack = (stack) => stack.map(exports2.reconstruct).join("");
    var createAlternate = (token) => {
      if ("options" in token) {
        return token.options.map(reduceStack).join("|");
      } else if ("stack" in token) {
        return reduceStack(token.stack);
      } else {
        throw new Error(`options or stack must be Root or Group token`);
      }
    };
    exports2.reconstruct = (token) => {
      switch (token.type) {
        case types_1.types.ROOT:
          return createAlternate(token);
        case types_1.types.CHAR: {
          const c = String.fromCharCode(token.value);
          return (/[[\\{}$^.|?*+()]/.test(c) ? "\\" : "") + c;
        }
        case types_1.types.POSITION:
          if (token.value === "^" || token.value === "$") {
            return token.value;
          } else {
            return `\\${token.value}`;
          }
        case types_1.types.REFERENCE:
          return `\\${token.value}`;
        case types_1.types.SET:
          return write_set_tokens_1.writeSetTokens(token);
        case types_1.types.GROUP: {
          const prefix = token.name ? `?<${token.name}>` : token.remember ? "" : token.followedBy ? "?=" : token.notFollowedBy ? "?!" : "?:";
          return `(${prefix}${createAlternate(token)})`;
        }
        case types_1.types.REPETITION: {
          const { min, max } = token;
          let endWith;
          if (min === 0 && max === 1) {
            endWith = "?";
          } else if (min === 1 && max === Infinity) {
            endWith = "+";
          } else if (min === 0 && max === Infinity) {
            endWith = "*";
          } else if (max === Infinity) {
            endWith = `{${min},}`;
          } else if (min === max) {
            endWith = `{${min}}`;
          } else {
            endWith = `{${min},${max}}`;
          }
          return `${exports2.reconstruct(token.value)}${endWith}`;
        }
        case types_1.types.RANGE:
          return `${write_set_tokens_1.setChar(token.from)}-${write_set_tokens_1.setChar(token.to)}`;
        default:
          throw new Error(`Invalid token type ${token}`);
      }
    };
  }
});

// node_modules/ret/dist/index.js
var require_dist3 = __commonJS({
  "node_modules/ret/dist/index.js"(exports2, module2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      Object.defineProperty(o, k2, { enumerable: true, get: function() {
        return m[k];
      } });
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports2 && exports2.__exportStar || function(m, exports3) {
      for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p)) __createBinding(exports3, m, p);
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.types = void 0;
    var types_1 = require_types4();
    Object.defineProperty(exports2, "types", { enumerable: true, get: function() {
      return types_1.types;
    } });
    __exportStar(require_tokenizer(), exports2);
    __exportStar(require_reconstruct(), exports2);
    var tokenizer_1 = require_tokenizer();
    var reconstruct_1 = require_reconstruct();
    __exportStar(require_types4(), exports2);
    exports2.default = tokenizer_1.tokenizer;
    module2.exports = tokenizer_1.tokenizer;
    module2.exports.types = types_1.types;
    module2.exports.reconstruct = reconstruct_1.reconstruct;
  }
});

// node_modules/safe-regex2/index.js
var require_safe_regex2 = __commonJS({
  "node_modules/safe-regex2/index.js"(exports2, module2) {
    "use strict";
    var parse = require_dist3();
    var types = parse.types;
    function safeRegex(re, opts) {
      if (!opts) opts = {};
      const replimit = opts.limit === void 0 ? 25 : opts.limit;
      if (isRegExp(re)) re = re.source;
      else if (typeof re !== "string") re = String(re);
      try {
        re = parse(re);
      } catch {
        return false;
      }
      let reps = 0;
      return function walk(node, starHeight) {
        let i;
        let ok;
        let len;
        if (node.type === types.REPETITION) {
          starHeight++;
          reps++;
          if (starHeight > 1) return false;
          if (reps > replimit) return false;
        }
        if (node.options) {
          for (i = 0, len = node.options.length; i < len; i++) {
            ok = walk({ stack: node.options[i] }, starHeight);
            if (!ok) return false;
          }
        }
        const stack = node.stack || node.value?.stack;
        if (!stack) return true;
        for (i = 0; i < stack.length; i++) {
          ok = walk(stack[i], starHeight);
          if (!ok) return false;
        }
        return true;
      }(re, 0);
    }
    function isRegExp(x) {
      return {}.toString.call(x) === "[object RegExp]";
    }
    module2.exports = safeRegex;
    module2.exports.default = safeRegex;
    module2.exports.safeRegex = safeRegex;
  }
});

// node_modules/find-my-way/lib/strategies/http-method.js
var require_http_method = __commonJS({
  "node_modules/find-my-way/lib/strategies/http-method.js"(exports2, module2) {
    "use strict";
    module2.exports = {
      name: "__fmw_internal_strategy_merged_tree_http_method__",
      storage: function() {
        const handlers = /* @__PURE__ */ new Map();
        return {
          get: (type) => {
            return handlers.get(type) || null;
          },
          set: (type, store) => {
            handlers.set(type, store);
          }
        };
      },
      /* c8 ignore next 1 */
      deriveConstraint: (req) => req.method,
      mustMatchWhenDerived: true
    };
  }
});

// node_modules/find-my-way/lib/pretty-print.js
var require_pretty_print = __commonJS({
  "node_modules/find-my-way/lib/pretty-print.js"(exports2, module2) {
    "use strict";
    var deepEqual = require_fast_deep_equal();
    var httpMethodStrategy = require_http_method();
    var treeDataSymbol = Symbol("treeData");
    function printObjectTree(obj, parentPrefix = "") {
      let tree = "";
      const keys = Object.keys(obj);
      for (let i = 0; i < keys.length; i++) {
        const key = keys[i];
        const value = obj[key];
        const isLast = i === keys.length - 1;
        const nodePrefix = isLast ? "\u2514\u2500\u2500 " : "\u251C\u2500\u2500 ";
        const childPrefix = isLast ? "    " : "\u2502   ";
        const nodeData = value[treeDataSymbol] || "";
        const prefixedNodeData = nodeData.replaceAll("\n", "\n" + parentPrefix + childPrefix);
        tree += parentPrefix + nodePrefix + key + prefixedNodeData + "\n";
        tree += printObjectTree(value, parentPrefix + childPrefix);
      }
      return tree;
    }
    function parseFunctionName(fn) {
      let fName = fn.name || "";
      fName = fName.replace("bound", "").trim();
      fName = (fName || "anonymous") + "()";
      return fName;
    }
    function parseMeta(meta) {
      if (Array.isArray(meta)) return meta.map((m) => parseMeta(m));
      if (typeof meta === "symbol") return meta.toString();
      if (typeof meta === "function") return parseFunctionName(meta);
      return meta;
    }
    function getRouteMetaData(route, options) {
      if (!options.includeMeta) return {};
      const metaDataObject = options.buildPrettyMeta(route);
      const filteredMetaData = {};
      let includeMetaKeys = options.includeMeta;
      if (!Array.isArray(includeMetaKeys)) {
        includeMetaKeys = Reflect.ownKeys(metaDataObject);
      }
      for (const metaKey of includeMetaKeys) {
        if (!Object.prototype.hasOwnProperty.call(metaDataObject, metaKey)) continue;
        const serializedKey = metaKey.toString();
        const metaValue = metaDataObject[metaKey];
        if (metaValue !== void 0 && metaValue !== null) {
          const serializedValue = JSON.stringify(parseMeta(metaValue));
          filteredMetaData[serializedKey] = serializedValue;
        }
      }
      return filteredMetaData;
    }
    function serializeMetaData(metaData) {
      let serializedMetaData = "";
      for (const [key, value] of Object.entries(metaData)) {
        serializedMetaData += `
\u2022 (${key}) ${value}`;
      }
      return serializedMetaData;
    }
    function normalizeRoute(route) {
      const constraints = { ...route.opts.constraints };
      const method = constraints[httpMethodStrategy.name];
      delete constraints[httpMethodStrategy.name];
      return { ...route, method, opts: { constraints } };
    }
    function serializeRoute(route) {
      let serializedRoute = ` (${route.method})`;
      const constraints = route.opts.constraints || {};
      if (Object.keys(constraints).length !== 0) {
        serializedRoute += " " + JSON.stringify(constraints);
      }
      serializedRoute += serializeMetaData(route.metaData);
      return serializedRoute;
    }
    function mergeSimilarRoutes(routes) {
      return routes.reduce((mergedRoutes, route) => {
        for (const nodeRoute of mergedRoutes) {
          if (deepEqual(route.opts.constraints, nodeRoute.opts.constraints) && deepEqual(route.metaData, nodeRoute.metaData)) {
            nodeRoute.method += ", " + route.method;
            return mergedRoutes;
          }
        }
        mergedRoutes.push(route);
        return mergedRoutes;
      }, []);
    }
    function serializeNode(node, prefix, options) {
      let routes = node.routes;
      if (options.method === void 0) {
        routes = routes.map(normalizeRoute);
      }
      routes = routes.map((route) => {
        route.metaData = getRouteMetaData(route, options);
        return route;
      });
      if (options.method === void 0) {
        routes = mergeSimilarRoutes(routes);
      }
      return routes.map(serializeRoute).join(`
${prefix}`);
    }
    function buildObjectTree(node, tree, prefix, options) {
      if (node.isLeafNode || options.commonPrefix !== false) {
        prefix = prefix || "(empty root node)";
        tree = tree[prefix] = {};
        if (node.isLeafNode) {
          tree[treeDataSymbol] = serializeNode(node, prefix, options);
        }
        prefix = "";
      }
      if (node.staticChildren) {
        for (const child of Object.values(node.staticChildren)) {
          buildObjectTree(child, tree, prefix + child.prefix, options);
        }
      }
      if (node.parametricChildren) {
        for (const child of Object.values(node.parametricChildren)) {
          const childPrefix = Array.from(child.nodePaths).join("|");
          buildObjectTree(child, tree, prefix + childPrefix, options);
        }
      }
      if (node.wildcardChild) {
        buildObjectTree(node.wildcardChild, tree, "*", options);
      }
    }
    function prettyPrintTree(root, options) {
      const objectTree = {};
      buildObjectTree(root, objectTree, root.prefix, options);
      return printObjectTree(objectTree);
    }
    module2.exports = { prettyPrintTree };
  }
});

// node_modules/find-my-way/lib/null-object.js
var require_null_object = __commonJS({
  "node_modules/find-my-way/lib/null-object.js"(exports2, module2) {
    "use strict";
    var NullObject = function() {
    };
    NullObject.prototype = /* @__PURE__ */ Object.create(null);
    module2.exports = {
      NullObject
    };
  }
});

// node_modules/find-my-way/lib/handler-storage.js
var require_handler_storage = __commonJS({
  "node_modules/find-my-way/lib/handler-storage.js"(exports2, module2) {
    "use strict";
    var { NullObject } = require_null_object();
    var httpMethodStrategy = require_http_method();
    var HandlerStorage = class {
      constructor() {
        this.unconstrainedHandler = null;
        this.constraints = [];
        this.handlers = [];
        this.constrainedHandlerStores = null;
      }
      // This is the hot path for node handler finding -- change with care!
      getMatchingHandler(derivedConstraints) {
        if (derivedConstraints === void 0) {
          return this.unconstrainedHandler;
        }
        return this._getHandlerMatchingConstraints(derivedConstraints);
      }
      addHandler(constrainer, route) {
        const params = route.params;
        const constraints = route.opts.constraints || {};
        const handlerObject = {
          params,
          constraints,
          handler: route.handler,
          store: route.store || null,
          _createParamsObject: this._compileCreateParamsObject(params)
        };
        const constraintsNames = Object.keys(constraints);
        if (constraintsNames.length === 0) {
          this.unconstrainedHandler = handlerObject;
        }
        for (const constraint of constraintsNames) {
          if (!this.constraints.includes(constraint)) {
            if (constraint === "version") {
              this.constraints.unshift(constraint);
            } else {
              this.constraints.push(constraint);
            }
          }
        }
        const isMergedTree = constraintsNames.includes(httpMethodStrategy.name);
        if (!isMergedTree && this.handlers.length >= 31) {
          throw new Error("find-my-way supports a maximum of 31 route handlers per node when there are constraints, limit reached");
        }
        this.handlers.push(handlerObject);
        this.handlers.sort((a, b) => Object.keys(a.constraints).length - Object.keys(b.constraints).length);
        if (!isMergedTree) {
          this._compileGetHandlerMatchingConstraints(constrainer, constraints);
        }
      }
      _compileCreateParamsObject(params) {
        const fnBody = [];
        fnBody.push("const fn = function _createParamsObject (paramsArray) {");
        fnBody.push("const params = new NullObject()");
        for (let i = 0; i < params.length; i++) {
          fnBody.push(`params['${params[i]}'] = paramsArray[${i}]`);
        }
        fnBody.push("return params");
        fnBody.push("}");
        fnBody.push("return fn");
        return new Function("NullObject", fnBody.join("\n"))(NullObject);
      }
      _getHandlerMatchingConstraints() {
        return null;
      }
      // Builds a store object that maps from constraint values to a bitmap of handler indexes which pass the constraint for a value
      // So for a host constraint, this might look like { "fastify.io": 0b0010, "google.ca": 0b0101 }, meaning the 3rd handler is constrainted to fastify.io, and the 2nd and 4th handlers are constrained to google.ca.
      // The store's implementation comes from the strategies provided to the Router.
      _buildConstraintStore(store, constraint) {
        for (let i = 0; i < this.handlers.length; i++) {
          const handler = this.handlers[i];
          const constraintValue = handler.constraints[constraint];
          if (constraintValue !== void 0) {
            let indexes = store.get(constraintValue) || 0;
            indexes |= 1 << i;
            store.set(constraintValue, indexes);
          }
        }
      }
      // Builds a bitmask for a given constraint that has a bit for each handler index that is 0 when that handler *is* constrained and 1 when the handler *isnt* constrainted. This is opposite to what might be obvious, but is just for convienience when doing the bitwise operations.
      _constrainedIndexBitmask(constraint) {
        let mask = 0;
        for (let i = 0; i < this.handlers.length; i++) {
          const handler = this.handlers[i];
          const constraintValue = handler.constraints[constraint];
          if (constraintValue !== void 0) {
            mask |= 1 << i;
          }
        }
        return ~mask;
      }
      // Compile a fast function to match the handlers for this node
      // The function implements a general case multi-constraint matching algorithm.
      // The general idea is this: we have a bunch of handlers, each with a potentially different set of constraints, and sometimes none at all. We're given a list of constraint values and we have to use the constraint-value-comparison strategies to see which handlers match the constraint values passed in.
      // We do this by asking each constraint store which handler indexes match the given constraint value for each store. Trickily, the handlers that a store says match are the handlers constrained by that store, but handlers that aren't constrained at all by that store could still match just fine. So, each constraint store can only describe matches for it, and it won't have any bearing on the handlers it doesn't care about. For this reason, we have to ask each stores which handlers match and track which have been matched (or not cared about) by all of them.
      // We use bitmaps to represent these lists of matches so we can use bitwise operations to implement this efficiently. Bitmaps are cheap to allocate, let us implement this masking behaviour in one CPU instruction, and are quite compact in memory. We start with a bitmap set to all 1s representing every handler that is a match candidate, and then for each constraint, see which handlers match using the store, and then mask the result by the mask of handlers that that store applies to, and bitwise AND with the candidate list. Phew.
      // We consider all this compiling function complexity to be worth it, because the naive implementation that just loops over the handlers asking which stores match is quite a bit slower.
      _compileGetHandlerMatchingConstraints(constrainer) {
        this.constrainedHandlerStores = {};
        for (const constraint of this.constraints) {
          const store = constrainer.newStoreForConstraint(constraint);
          this.constrainedHandlerStores[constraint] = store;
          this._buildConstraintStore(store, constraint);
        }
        const lines = [];
        lines.push(`
    let candidates = ${(1 << this.handlers.length) - 1}
    let mask, matches
    `);
        for (const constraint of this.constraints) {
          lines.push(`
      mask = ${this._constrainedIndexBitmask(constraint)}
      value = derivedConstraints.${constraint}
      `);
          const strategy = constrainer.strategies[constraint];
          const matchMask = strategy.mustMatchWhenDerived ? "matches" : "(matches | mask)";
          lines.push(`
      if (value === undefined) {
        candidates &= mask
      } else {
        matches = this.constrainedHandlerStores.${constraint}.get(value) || 0
        candidates &= ${matchMask}
      }
      if (candidates === 0) return null;
      `);
        }
        for (const constraint in constrainer.strategies) {
          const strategy = constrainer.strategies[constraint];
          if (strategy.mustMatchWhenDerived && !this.constraints.includes(constraint)) {
            lines.push(`if (derivedConstraints.${constraint} !== undefined) return null`);
          }
        }
        lines.push("return this.handlers[Math.floor(Math.log2(candidates))]");
        this._getHandlerMatchingConstraints = new Function("derivedConstraints", lines.join("\n"));
      }
    };
    module2.exports = HandlerStorage;
  }
});

// node_modules/find-my-way/lib/node.js
var require_node = __commonJS({
  "node_modules/find-my-way/lib/node.js"(exports2, module2) {
    "use strict";
    var HandlerStorage = require_handler_storage();
    var NODE_TYPES = {
      STATIC: 0,
      PARAMETRIC: 1,
      WILDCARD: 2
    };
    var Node = class {
      constructor() {
        this.isLeafNode = false;
        this.routes = null;
        this.handlerStorage = null;
      }
      addRoute(route, constrainer) {
        if (this.routes === null) {
          this.routes = [];
        }
        if (this.handlerStorage === null) {
          this.handlerStorage = new HandlerStorage();
        }
        this.isLeafNode = true;
        this.routes.push(route);
        this.handlerStorage.addHandler(constrainer, route);
      }
    };
    var ParentNode = class extends Node {
      constructor() {
        super();
        this.staticChildren = {};
      }
      findStaticMatchingChild(path4, pathIndex) {
        const staticChild = this.staticChildren[path4.charAt(pathIndex)];
        if (staticChild === void 0 || !staticChild.matchPrefix(path4, pathIndex)) {
          return null;
        }
        return staticChild;
      }
      getStaticChild(path4, pathIndex = 0) {
        if (path4.length === pathIndex) {
          return this;
        }
        const staticChild = this.findStaticMatchingChild(path4, pathIndex);
        if (staticChild) {
          return staticChild.getStaticChild(path4, pathIndex + staticChild.prefix.length);
        }
        return null;
      }
      createStaticChild(path4) {
        if (path4.length === 0) {
          return this;
        }
        let staticChild = this.staticChildren[path4.charAt(0)];
        if (staticChild) {
          let i = 1;
          for (; i < staticChild.prefix.length; i++) {
            if (path4.charCodeAt(i) !== staticChild.prefix.charCodeAt(i)) {
              staticChild = staticChild.split(this, i);
              break;
            }
          }
          return staticChild.createStaticChild(path4.slice(i));
        }
        const label = path4.charAt(0);
        this.staticChildren[label] = new StaticNode(path4);
        return this.staticChildren[label];
      }
    };
    var StaticNode = class _StaticNode extends ParentNode {
      constructor(prefix) {
        super();
        this.prefix = prefix;
        this.wildcardChild = null;
        this.parametricChildren = [];
        this.kind = NODE_TYPES.STATIC;
        this._compilePrefixMatch();
      }
      getParametricChild(regex) {
        const regexpSource = regex && regex.source;
        const parametricChild = this.parametricChildren.find((child) => {
          const childRegexSource = child.regex && child.regex.source;
          return childRegexSource === regexpSource;
        });
        if (parametricChild) {
          return parametricChild;
        }
        return null;
      }
      createParametricChild(regex, staticSuffix, nodePath) {
        let parametricChild = this.getParametricChild(regex);
        if (parametricChild) {
          parametricChild.nodePaths.add(nodePath);
          return parametricChild;
        }
        parametricChild = new ParametricNode(regex, staticSuffix, nodePath);
        this.parametricChildren.push(parametricChild);
        this.parametricChildren.sort((child1, child2) => {
          if (!child1.isRegex) return 1;
          if (!child2.isRegex) return -1;
          if (child1.staticSuffix === null) return 1;
          if (child2.staticSuffix === null) return -1;
          if (child2.staticSuffix.endsWith(child1.staticSuffix)) return 1;
          if (child1.staticSuffix.endsWith(child2.staticSuffix)) return -1;
          return 0;
        });
        return parametricChild;
      }
      getWildcardChild() {
        return this.wildcardChild;
      }
      createWildcardChild() {
        this.wildcardChild = this.getWildcardChild() || new WildcardNode();
        return this.wildcardChild;
      }
      split(parentNode, length) {
        const parentPrefix = this.prefix.slice(0, length);
        const childPrefix = this.prefix.slice(length);
        this.prefix = childPrefix;
        this._compilePrefixMatch();
        const staticNode = new _StaticNode(parentPrefix);
        staticNode.staticChildren[childPrefix.charAt(0)] = this;
        parentNode.staticChildren[parentPrefix.charAt(0)] = staticNode;
        return staticNode;
      }
      getNextNode(path4, pathIndex, nodeStack, paramsCount) {
        let node = this.findStaticMatchingChild(path4, pathIndex);
        let parametricBrotherNodeIndex = 0;
        if (node === null) {
          if (this.parametricChildren.length === 0) {
            return this.wildcardChild;
          }
          node = this.parametricChildren[0];
          parametricBrotherNodeIndex = 1;
        }
        if (this.wildcardChild !== null) {
          nodeStack.push({
            paramsCount,
            brotherPathIndex: pathIndex,
            brotherNode: this.wildcardChild
          });
        }
        for (let i = this.parametricChildren.length - 1; i >= parametricBrotherNodeIndex; i--) {
          nodeStack.push({
            paramsCount,
            brotherPathIndex: pathIndex,
            brotherNode: this.parametricChildren[i]
          });
        }
        return node;
      }
      _compilePrefixMatch() {
        if (this.prefix.length === 1) {
          this.matchPrefix = () => true;
          return;
        }
        const lines = [];
        for (let i = 1; i < this.prefix.length; i++) {
          const charCode = this.prefix.charCodeAt(i);
          lines.push(`path.charCodeAt(i + ${i}) === ${charCode}`);
        }
        this.matchPrefix = new Function("path", "i", `return ${lines.join(" && ")}`);
      }
    };
    var ParametricNode = class extends ParentNode {
      constructor(regex, staticSuffix, nodePath) {
        super();
        this.isRegex = !!regex;
        this.regex = regex || null;
        this.staticSuffix = staticSuffix || null;
        this.kind = NODE_TYPES.PARAMETRIC;
        this.nodePaths = /* @__PURE__ */ new Set([nodePath]);
      }
      getNextNode(path4, pathIndex) {
        return this.findStaticMatchingChild(path4, pathIndex);
      }
    };
    var WildcardNode = class extends Node {
      constructor() {
        super();
        this.kind = NODE_TYPES.WILDCARD;
      }
      getNextNode() {
        return null;
      }
    };
    module2.exports = { StaticNode, ParametricNode, WildcardNode, NODE_TYPES };
  }
});

// node_modules/find-my-way/lib/strategies/accept-version.js
var require_accept_version = __commonJS({
  "node_modules/find-my-way/lib/strategies/accept-version.js"(exports2, module2) {
    "use strict";
    var assert = require("node:assert");
    function SemVerStore() {
      if (!(this instanceof SemVerStore)) {
        return new SemVerStore();
      }
      this.store = /* @__PURE__ */ new Map();
      this.maxMajor = 0;
      this.maxMinors = {};
      this.maxPatches = {};
    }
    SemVerStore.prototype.set = function(version2, store) {
      if (typeof version2 !== "string") {
        throw new TypeError("Version should be a string");
      }
      let [major, minor, patch] = version2.split(".", 3);
      if (isNaN(major)) {
        throw new TypeError("Major version must be a numeric value");
      }
      major = Number(major);
      minor = Number(minor) || 0;
      patch = Number(patch) || 0;
      if (major >= this.maxMajor) {
        this.maxMajor = major;
        this.store.set("x", store);
        this.store.set("*", store);
        this.store.set("x.x", store);
        this.store.set("x.x.x", store);
      }
      if (minor >= (this.maxMinors[major] || 0)) {
        this.maxMinors[major] = minor;
        this.store.set(`${major}.x`, store);
        this.store.set(`${major}.x.x`, store);
      }
      if (patch >= (this.maxPatches[`${major}.${minor}`] || 0)) {
        this.maxPatches[`${major}.${minor}`] = patch;
        this.store.set(`${major}.${minor}.x`, store);
      }
      this.store.set(`${major}.${minor}.${patch}`, store);
      return this;
    };
    SemVerStore.prototype.get = function(version2) {
      return this.store.get(version2);
    };
    module2.exports = {
      name: "version",
      mustMatchWhenDerived: true,
      storage: SemVerStore,
      validate(value) {
        assert(typeof value === "string", "Version should be a string");
      }
    };
  }
});

// node_modules/find-my-way/lib/strategies/accept-host.js
var require_accept_host = __commonJS({
  "node_modules/find-my-way/lib/strategies/accept-host.js"(exports2, module2) {
    "use strict";
    var assert = require("node:assert");
    function HostStorage() {
      const hosts = /* @__PURE__ */ new Map();
      const regexHosts = [];
      return {
        get: (host) => {
          const exact = hosts.get(host);
          if (exact) {
            return exact;
          }
          for (const regex of regexHosts) {
            if (regex.host.test(host)) {
              return regex.value;
            }
          }
        },
        set: (host, value) => {
          if (host instanceof RegExp) {
            regexHosts.push({ host, value });
          } else {
            hosts.set(host, value);
          }
        }
      };
    }
    module2.exports = {
      name: "host",
      mustMatchWhenDerived: false,
      storage: HostStorage,
      validate(value) {
        assert(typeof value === "string" || Object.prototype.toString.call(value) === "[object RegExp]", "Host should be a string or a RegExp");
      }
    };
  }
});

// node_modules/find-my-way/lib/constrainer.js
var require_constrainer = __commonJS({
  "node_modules/find-my-way/lib/constrainer.js"(exports2, module2) {
    "use strict";
    var acceptVersionStrategy = require_accept_version();
    var acceptHostStrategy = require_accept_host();
    var assert = require("node:assert");
    var Constrainer = class {
      constructor(customStrategies) {
        this.strategies = {
          version: acceptVersionStrategy,
          host: acceptHostStrategy
        };
        this.strategiesInUse = /* @__PURE__ */ new Set();
        this.asyncStrategiesInUse = /* @__PURE__ */ new Set();
        if (customStrategies) {
          for (const strategy of Object.values(customStrategies)) {
            this.addConstraintStrategy(strategy);
          }
        }
      }
      isStrategyUsed(strategyName) {
        return this.strategiesInUse.has(strategyName) || this.asyncStrategiesInUse.has(strategyName);
      }
      hasConstraintStrategy(strategyName) {
        const customConstraintStrategy = this.strategies[strategyName];
        if (customConstraintStrategy !== void 0) {
          return customConstraintStrategy.isCustom || this.isStrategyUsed(strategyName);
        }
        return false;
      }
      addConstraintStrategy(strategy) {
        assert(typeof strategy.name === "string" && strategy.name !== "", "strategy.name is required.");
        assert(strategy.storage && typeof strategy.storage === "function", "strategy.storage function is required.");
        assert(strategy.deriveConstraint && typeof strategy.deriveConstraint === "function", "strategy.deriveConstraint function is required.");
        if (this.strategies[strategy.name] && this.strategies[strategy.name].isCustom) {
          throw new Error(`There already exists a custom constraint with the name ${strategy.name}.`);
        }
        if (this.isStrategyUsed(strategy.name)) {
          throw new Error(`There already exists a route with ${strategy.name} constraint.`);
        }
        strategy.isCustom = true;
        strategy.isAsync = strategy.deriveConstraint.length === 3;
        this.strategies[strategy.name] = strategy;
        if (strategy.mustMatchWhenDerived) {
          this.noteUsage({ [strategy.name]: strategy });
        }
      }
      deriveConstraints(req, ctx, done) {
        const constraints = this.deriveSyncConstraints(req, ctx);
        if (done === void 0) {
          return constraints;
        }
        this.deriveAsyncConstraints(constraints, req, ctx, done);
      }
      deriveSyncConstraints(req, ctx) {
        return void 0;
      }
      // When new constraints start getting used, we need to rebuild the deriver to derive them. Do so if we see novel constraints used.
      noteUsage(constraints) {
        if (constraints) {
          const beforeSize = this.strategiesInUse.size;
          for (const key in constraints) {
            const strategy = this.strategies[key];
            if (strategy.isAsync) {
              this.asyncStrategiesInUse.add(key);
            } else {
              this.strategiesInUse.add(key);
            }
          }
          if (beforeSize !== this.strategiesInUse.size) {
            this._buildDeriveConstraints();
          }
        }
      }
      newStoreForConstraint(constraint) {
        if (!this.strategies[constraint]) {
          throw new Error(`No strategy registered for constraint key ${constraint}`);
        }
        return this.strategies[constraint].storage();
      }
      validateConstraints(constraints) {
        for (const key in constraints) {
          const value = constraints[key];
          if (typeof value === "undefined") {
            throw new Error("Can't pass an undefined constraint value, must pass null or no key at all");
          }
          const strategy = this.strategies[key];
          if (!strategy) {
            throw new Error(`No strategy registered for constraint key ${key}`);
          }
          if (strategy.validate) {
            strategy.validate(value);
          }
        }
      }
      deriveAsyncConstraints(constraints, req, ctx, done) {
        let asyncConstraintsCount = this.asyncStrategiesInUse.size;
        if (asyncConstraintsCount === 0) {
          done(null, constraints);
          return;
        }
        constraints = constraints || {};
        for (const key of this.asyncStrategiesInUse) {
          const strategy = this.strategies[key];
          strategy.deriveConstraint(req, ctx, (err, constraintValue) => {
            if (err !== null) {
              done(err);
              return;
            }
            constraints[key] = constraintValue;
            if (--asyncConstraintsCount === 0) {
              done(null, constraints);
            }
          });
        }
      }
      // Optimization: build a fast function for deriving the constraints for all the strategies at once. We inline the definitions of the version constraint and the host constraint for performance.
      // If no constraining strategies are in use (no routes constrain on host, or version, or any custom strategies) then we don't need to derive constraints for each route match, so don't do anything special, and just return undefined
      // This allows us to not allocate an object to hold constraint values if no constraints are defined.
      _buildDeriveConstraints() {
        if (this.strategiesInUse.size === 0) return;
        const lines = ["return {"];
        for (const key of this.strategiesInUse) {
          const strategy = this.strategies[key];
          if (!strategy.isCustom) {
            if (key === "version") {
              lines.push("   version: req.headers['accept-version'],");
            } else {
              lines.push("   host: req.headers.host || req.headers[':authority'],");
            }
          } else {
            lines.push(`  ${strategy.name}: this.strategies.${key}.deriveConstraint(req, ctx),`);
          }
        }
        lines.push("}");
        this.deriveSyncConstraints = new Function("req", "ctx", lines.join("\n")).bind(this);
      }
    };
    module2.exports = Constrainer;
  }
});

// node_modules/find-my-way/lib/http-methods.js
var require_http_methods = __commonJS({
  "node_modules/find-my-way/lib/http-methods.js"(exports2, module2) {
    "use strict";
    var httpMethods = [
      "ACL",
      "BIND",
      "CHECKOUT",
      "CONNECT",
      "COPY",
      "DELETE",
      "GET",
      "HEAD",
      "LINK",
      "LOCK",
      "M-SEARCH",
      "MERGE",
      "MKACTIVITY",
      "MKCALENDAR",
      "MKCOL",
      "MOVE",
      "NOTIFY",
      "OPTIONS",
      "PATCH",
      "POST",
      "PROPFIND",
      "PROPPATCH",
      "PURGE",
      "PUT",
      "QUERY",
      "REBIND",
      "REPORT",
      "SEARCH",
      "SOURCE",
      "SUBSCRIBE",
      "TRACE",
      "UNBIND",
      "UNLINK",
      "UNLOCK",
      "UNSUBSCRIBE"
    ];
    module2.exports = httpMethods;
  }
});

// node_modules/find-my-way/lib/url-sanitizer.js
var require_url_sanitizer = __commonJS({
  "node_modules/find-my-way/lib/url-sanitizer.js"(exports2, module2) {
    "use strict";
    function decodeComponentChar(highCharCode, lowCharCode) {
      if (highCharCode === 50) {
        if (lowCharCode === 53) return "%";
        if (lowCharCode === 51) return "#";
        if (lowCharCode === 52) return "$";
        if (lowCharCode === 54) return "&";
        if (lowCharCode === 66) return "+";
        if (lowCharCode === 98) return "+";
        if (lowCharCode === 67) return ",";
        if (lowCharCode === 99) return ",";
        if (lowCharCode === 70) return "/";
        if (lowCharCode === 102) return "/";
        return null;
      }
      if (highCharCode === 51) {
        if (lowCharCode === 65) return ":";
        if (lowCharCode === 97) return ":";
        if (lowCharCode === 66) return ";";
        if (lowCharCode === 98) return ";";
        if (lowCharCode === 68) return "=";
        if (lowCharCode === 100) return "=";
        if (lowCharCode === 70) return "?";
        if (lowCharCode === 102) return "?";
        return null;
      }
      if (highCharCode === 52 && lowCharCode === 48) {
        return "@";
      }
      return null;
    }
    function safeDecodeURI(path4, useSemicolonDelimiter) {
      let shouldDecode = false;
      let shouldDecodeParam = false;
      let querystring = "";
      for (let i = 1; i < path4.length; i++) {
        const charCode = path4.charCodeAt(i);
        if (charCode === 37) {
          const highCharCode = path4.charCodeAt(i + 1);
          const lowCharCode = path4.charCodeAt(i + 2);
          if (decodeComponentChar(highCharCode, lowCharCode) === null) {
            shouldDecode = true;
          } else {
            shouldDecodeParam = true;
            if (highCharCode === 50 && lowCharCode === 53) {
              shouldDecode = true;
              path4 = path4.slice(0, i + 1) + "25" + path4.slice(i + 1);
              i += 2;
            }
            i += 2;
          }
        } else if (charCode === 63 || charCode === 35 || charCode === 59 && useSemicolonDelimiter) {
          querystring = path4.slice(i + 1);
          path4 = path4.slice(0, i);
          break;
        }
      }
      const decodedPath = shouldDecode ? decodeURI(path4) : path4;
      return { path: decodedPath, querystring, shouldDecodeParam };
    }
    function safeDecodeURIComponent(uriComponent) {
      const startIndex = uriComponent.indexOf("%");
      if (startIndex === -1) return uriComponent;
      let decoded = "";
      let lastIndex = startIndex;
      for (let i = startIndex; i < uriComponent.length; i++) {
        if (uriComponent.charCodeAt(i) === 37) {
          const highCharCode = uriComponent.charCodeAt(i + 1);
          const lowCharCode = uriComponent.charCodeAt(i + 2);
          const decodedChar = decodeComponentChar(highCharCode, lowCharCode);
          decoded += uriComponent.slice(lastIndex, i) + decodedChar;
          lastIndex = i + 3;
        }
      }
      return uriComponent.slice(0, startIndex) + decoded + uriComponent.slice(lastIndex);
    }
    module2.exports = { safeDecodeURI, safeDecodeURIComponent };
  }
});

// node_modules/find-my-way/index.js
var require_find_my_way = __commonJS({
  "node_modules/find-my-way/index.js"(exports2, module2) {
    "use strict";
    var assert = require("node:assert");
    var querystring = require_lib2();
    var isRegexSafe = require_safe_regex2();
    var deepEqual = require_fast_deep_equal();
    var { prettyPrintTree } = require_pretty_print();
    var { StaticNode, NODE_TYPES } = require_node();
    var Constrainer = require_constrainer();
    var httpMethods = require_http_methods();
    var httpMethodStrategy = require_http_method();
    var { safeDecodeURI, safeDecodeURIComponent } = require_url_sanitizer();
    var FULL_PATH_REGEXP = /^https?:\/\/.*?\//;
    var OPTIONAL_PARAM_REGEXP = /(\/:[^/()]*?)\?(\/?)/;
    var ESCAPE_REGEXP = /[.*+?^${}()|[\]\\]/g;
    var REMOVE_DUPLICATE_SLASHES_REGEXP = /\/\/+/g;
    if (!isRegexSafe(FULL_PATH_REGEXP)) {
      throw new Error("the FULL_PATH_REGEXP is not safe, update this module");
    }
    if (!isRegexSafe(OPTIONAL_PARAM_REGEXP)) {
      throw new Error("the OPTIONAL_PARAM_REGEXP is not safe, update this module");
    }
    if (!isRegexSafe(ESCAPE_REGEXP)) {
      throw new Error("the ESCAPE_REGEXP is not safe, update this module");
    }
    if (!isRegexSafe(REMOVE_DUPLICATE_SLASHES_REGEXP)) {
      throw new Error("the REMOVE_DUPLICATE_SLASHES_REGEXP is not safe, update this module");
    }
    function Router(opts) {
      if (!(this instanceof Router)) {
        return new Router(opts);
      }
      opts = opts || {};
      this._opts = opts;
      if (opts.defaultRoute) {
        assert(typeof opts.defaultRoute === "function", "The default route must be a function");
        this.defaultRoute = opts.defaultRoute;
      } else {
        this.defaultRoute = null;
      }
      if (opts.onBadUrl) {
        assert(typeof opts.onBadUrl === "function", "The bad url handler must be a function");
        this.onBadUrl = opts.onBadUrl;
      } else {
        this.onBadUrl = null;
      }
      if (opts.buildPrettyMeta) {
        assert(typeof opts.buildPrettyMeta === "function", "buildPrettyMeta must be a function");
        this.buildPrettyMeta = opts.buildPrettyMeta;
      } else {
        this.buildPrettyMeta = defaultBuildPrettyMeta;
      }
      if (opts.querystringParser) {
        assert(typeof opts.querystringParser === "function", "querystringParser must be a function");
        this.querystringParser = opts.querystringParser;
      } else {
        this.querystringParser = (query) => query.length === 0 ? {} : querystring.parse(query);
      }
      this.caseSensitive = opts.caseSensitive === void 0 ? true : opts.caseSensitive;
      this.ignoreTrailingSlash = opts.ignoreTrailingSlash || false;
      this.ignoreDuplicateSlashes = opts.ignoreDuplicateSlashes || false;
      this.maxParamLength = opts.maxParamLength || 100;
      this.allowUnsafeRegex = opts.allowUnsafeRegex || false;
      this.constrainer = new Constrainer(opts.constraints);
      this.useSemicolonDelimiter = opts.useSemicolonDelimiter || false;
      this.routes = [];
      this.trees = {};
    }
    Router.prototype.on = function on(method, path4, opts, handler, store) {
      if (typeof opts === "function") {
        if (handler !== void 0) {
          store = handler;
        }
        handler = opts;
        opts = {};
      }
      assert(typeof path4 === "string", "Path should be a string");
      assert(path4.length > 0, "The path could not be empty");
      assert(path4[0] === "/" || path4[0] === "*", "The first character of a path should be `/` or `*`");
      assert(typeof handler === "function", "Handler should be a function");
      const optionalParamMatch = path4.match(OPTIONAL_PARAM_REGEXP);
      if (optionalParamMatch) {
        assert(path4.length === optionalParamMatch.index + optionalParamMatch[0].length, "Optional Parameter needs to be the last parameter of the path");
        const pathFull = path4.replace(OPTIONAL_PARAM_REGEXP, "$1$2");
        const pathOptional = path4.replace(OPTIONAL_PARAM_REGEXP, "$2") || "/";
        this.on(method, pathFull, opts, handler, store);
        this.on(method, pathOptional, opts, handler, store);
        return;
      }
      const route = path4;
      if (this.ignoreDuplicateSlashes) {
        path4 = removeDuplicateSlashes(path4);
      }
      if (this.ignoreTrailingSlash) {
        path4 = trimLastSlash(path4);
      }
      const methods = Array.isArray(method) ? method : [method];
      for (const method2 of methods) {
        assert(typeof method2 === "string", "Method should be a string");
        assert(httpMethods.includes(method2), `Method '${method2}' is not an http method.`);
        this._on(method2, path4, opts, handler, store, route);
      }
    };
    Router.prototype._on = function _on(method, path4, opts, handler, store) {
      let constraints = {};
      if (opts.constraints !== void 0) {
        assert(typeof opts.constraints === "object" && opts.constraints !== null, "Constraints should be an object");
        if (Object.keys(opts.constraints).length !== 0) {
          constraints = opts.constraints;
        }
      }
      this.constrainer.validateConstraints(constraints);
      this.constrainer.noteUsage(constraints);
      if (this.trees[method] === void 0) {
        this.trees[method] = new StaticNode("/");
      }
      let pattern = path4;
      if (pattern === "*" && this.trees[method].prefix.length !== 0) {
        const currentRoot = this.trees[method];
        this.trees[method] = new StaticNode("");
        this.trees[method].staticChildren["/"] = currentRoot;
      }
      let currentNode = this.trees[method];
      let parentNodePathIndex = currentNode.prefix.length;
      const params = [];
      for (let i = 0; i <= pattern.length; i++) {
        if (pattern.charCodeAt(i) === 58 && pattern.charCodeAt(i + 1) === 58) {
          i++;
          continue;
        }
        const isParametricNode = pattern.charCodeAt(i) === 58 && pattern.charCodeAt(i + 1) !== 58;
        const isWildcardNode = pattern.charCodeAt(i) === 42;
        if (isParametricNode || isWildcardNode || i === pattern.length && i !== parentNodePathIndex) {
          let staticNodePath = pattern.slice(parentNodePathIndex, i);
          if (!this.caseSensitive) {
            staticNodePath = staticNodePath.toLowerCase();
          }
          staticNodePath = staticNodePath.replaceAll("::", ":");
          staticNodePath = staticNodePath.replaceAll("%", "%25");
          currentNode = currentNode.createStaticChild(staticNodePath);
        }
        if (isParametricNode) {
          let isRegexNode = false;
          let isParamSafe = true;
          let backtrack = "";
          const regexps = [];
          let lastParamStartIndex = i + 1;
          for (let j = lastParamStartIndex; ; j++) {
            const charCode = pattern.charCodeAt(j);
            const isRegexParam = charCode === 40;
            const isStaticPart = charCode === 45 || charCode === 46;
            const isEndOfNode = charCode === 47 || j === pattern.length;
            if (isRegexParam || isStaticPart || isEndOfNode) {
              const paramName = pattern.slice(lastParamStartIndex, j);
              params.push(paramName);
              isRegexNode = isRegexNode || isRegexParam || isStaticPart;
              if (isRegexParam) {
                const endOfRegexIndex = getClosingParenthensePosition(pattern, j);
                const regexString = pattern.slice(j, endOfRegexIndex + 1);
                if (!this.allowUnsafeRegex) {
                  assert(isRegexSafe(new RegExp(regexString)), `The regex '${regexString}' is not safe!`);
                }
                regexps.push(trimRegExpStartAndEnd(regexString));
                j = endOfRegexIndex + 1;
                isParamSafe = true;
              } else {
                regexps.push(isParamSafe ? "(.*?)" : `(${backtrack}|(?:(?!${backtrack}).)*)`);
                isParamSafe = false;
              }
              const staticPartStartIndex = j;
              for (; j < pattern.length; j++) {
                const charCode2 = pattern.charCodeAt(j);
                if (charCode2 === 47) break;
                if (charCode2 === 58) {
                  const nextCharCode = pattern.charCodeAt(j + 1);
                  if (nextCharCode === 58) j++;
                  else break;
                }
              }
              let staticPart = pattern.slice(staticPartStartIndex, j);
              if (staticPart) {
                staticPart = staticPart.replaceAll("::", ":");
                staticPart = staticPart.replaceAll("%", "%25");
                regexps.push(backtrack = escapeRegExp(staticPart));
              }
              lastParamStartIndex = j + 1;
              if (isEndOfNode || pattern.charCodeAt(j) === 47 || j === pattern.length) {
                const nodePattern = isRegexNode ? "()" + staticPart : staticPart;
                const nodePath = pattern.slice(i, j);
                pattern = pattern.slice(0, i + 1) + nodePattern + pattern.slice(j);
                i += nodePattern.length;
                const regex = isRegexNode ? new RegExp("^" + regexps.join("") + "$") : null;
                currentNode = currentNode.createParametricChild(regex, staticPart || null, nodePath);
                parentNodePathIndex = i + 1;
                break;
              }
            }
          }
        } else if (isWildcardNode) {
          params.push("*");
          currentNode = currentNode.createWildcardChild();
          parentNodePathIndex = i + 1;
          if (i !== pattern.length - 1) {
            throw new Error("Wildcard must be the last character in the route");
          }
        }
      }
      if (!this.caseSensitive) {
        pattern = pattern.toLowerCase();
      }
      if (pattern === "*") {
        pattern = "/*";
      }
      for (const existRoute of this.routes) {
        const routeConstraints = existRoute.opts.constraints || {};
        if (existRoute.method === method && existRoute.pattern === pattern && deepEqual(routeConstraints, constraints)) {
          throw new Error(`Method '${method}' already declared for route '${pattern}' with constraints '${JSON.stringify(constraints)}'`);
        }
      }
      const route = { method, path: path4, pattern, params, opts, handler, store };
      this.routes.push(route);
      currentNode.addRoute(route, this.constrainer);
    };
    Router.prototype.hasRoute = function hasRoute(method, path4, constraints) {
      const route = this.findRoute(method, path4, constraints);
      return route !== null;
    };
    Router.prototype.findRoute = function findNode(method, path4, constraints = {}) {
      if (this.trees[method] === void 0) {
        return null;
      }
      let pattern = path4;
      let currentNode = this.trees[method];
      let parentNodePathIndex = currentNode.prefix.length;
      const params = [];
      for (let i = 0; i <= pattern.length; i++) {
        if (pattern.charCodeAt(i) === 58 && pattern.charCodeAt(i + 1) === 58) {
          i++;
          continue;
        }
        const isParametricNode = pattern.charCodeAt(i) === 58 && pattern.charCodeAt(i + 1) !== 58;
        const isWildcardNode = pattern.charCodeAt(i) === 42;
        if (isParametricNode || isWildcardNode || i === pattern.length && i !== parentNodePathIndex) {
          let staticNodePath = pattern.slice(parentNodePathIndex, i);
          if (!this.caseSensitive) {
            staticNodePath = staticNodePath.toLowerCase();
          }
          staticNodePath = staticNodePath.replaceAll("::", ":");
          staticNodePath = staticNodePath.replaceAll("%", "%25");
          currentNode = currentNode.getStaticChild(staticNodePath);
          if (currentNode === null) {
            return null;
          }
        }
        if (isParametricNode) {
          let isRegexNode = false;
          let isParamSafe = true;
          let backtrack = "";
          const regexps = [];
          let lastParamStartIndex = i + 1;
          for (let j = lastParamStartIndex; ; j++) {
            const charCode = pattern.charCodeAt(j);
            const isRegexParam = charCode === 40;
            const isStaticPart = charCode === 45 || charCode === 46;
            const isEndOfNode = charCode === 47 || j === pattern.length;
            if (isRegexParam || isStaticPart || isEndOfNode) {
              const paramName = pattern.slice(lastParamStartIndex, j);
              params.push(paramName);
              isRegexNode = isRegexNode || isRegexParam || isStaticPart;
              if (isRegexParam) {
                const endOfRegexIndex = getClosingParenthensePosition(pattern, j);
                const regexString = pattern.slice(j, endOfRegexIndex + 1);
                if (!this.allowUnsafeRegex) {
                  assert(isRegexSafe(new RegExp(regexString)), `The regex '${regexString}' is not safe!`);
                }
                regexps.push(trimRegExpStartAndEnd(regexString));
                j = endOfRegexIndex + 1;
                isParamSafe = false;
              } else {
                regexps.push(isParamSafe ? "(.*?)" : `(${backtrack}|(?:(?!${backtrack}).)*)`);
                isParamSafe = false;
              }
              const staticPartStartIndex = j;
              for (; j < pattern.length; j++) {
                const charCode2 = pattern.charCodeAt(j);
                if (charCode2 === 47) break;
                if (charCode2 === 58) {
                  const nextCharCode = pattern.charCodeAt(j + 1);
                  if (nextCharCode === 58) j++;
                  else break;
                }
              }
              let staticPart = pattern.slice(staticPartStartIndex, j);
              if (staticPart) {
                staticPart = staticPart.replaceAll("::", ":");
                staticPart = staticPart.replaceAll("%", "%25");
                regexps.push(backtrack = escapeRegExp(staticPart));
              }
              lastParamStartIndex = j + 1;
              if (isEndOfNode || pattern.charCodeAt(j) === 47 || j === pattern.length) {
                const nodePattern = isRegexNode ? "()" + staticPart : staticPart;
                const nodePath = pattern.slice(i, j);
                pattern = pattern.slice(0, i + 1) + nodePattern + pattern.slice(j);
                i += nodePattern.length;
                const regex = isRegexNode ? new RegExp("^" + regexps.join("") + "$") : null;
                currentNode = currentNode.getParametricChild(regex, staticPart || null, nodePath);
                if (currentNode === null) {
                  return null;
                }
                parentNodePathIndex = i + 1;
                break;
              }
            }
          }
        } else if (isWildcardNode) {
          params.push("*");
          currentNode = currentNode.getWildcardChild();
          parentNodePathIndex = i + 1;
          if (i !== pattern.length - 1) {
            throw new Error("Wildcard must be the last character in the route");
          }
        }
      }
      if (!this.caseSensitive) {
        pattern = pattern.toLowerCase();
      }
      for (const existRoute of this.routes) {
        const routeConstraints = existRoute.opts.constraints || {};
        if (existRoute.method === method && existRoute.pattern === pattern && deepEqual(routeConstraints, constraints)) {
          return {
            handler: existRoute.handler,
            store: existRoute.store,
            params: existRoute.params
          };
        }
      }
      return null;
    };
    Router.prototype.hasConstraintStrategy = function(strategyName) {
      return this.constrainer.hasConstraintStrategy(strategyName);
    };
    Router.prototype.addConstraintStrategy = function(constraints) {
      this.constrainer.addConstraintStrategy(constraints);
      this._rebuild(this.routes);
    };
    Router.prototype.reset = function reset() {
      this.trees = {};
      this.routes = [];
    };
    Router.prototype.off = function off(method, path4, constraints) {
      assert(typeof path4 === "string", "Path should be a string");
      assert(path4.length > 0, "The path could not be empty");
      assert(path4[0] === "/" || path4[0] === "*", "The first character of a path should be `/` or `*`");
      assert(
        typeof constraints === "undefined" || typeof constraints === "object" && !Array.isArray(constraints) && constraints !== null,
        "Constraints should be an object or undefined."
      );
      const optionalParamMatch = path4.match(OPTIONAL_PARAM_REGEXP);
      if (optionalParamMatch) {
        assert(path4.length === optionalParamMatch.index + optionalParamMatch[0].length, "Optional Parameter needs to be the last parameter of the path");
        const pathFull = path4.replace(OPTIONAL_PARAM_REGEXP, "$1$2");
        const pathOptional = path4.replace(OPTIONAL_PARAM_REGEXP, "$2");
        this.off(method, pathFull, constraints);
        this.off(method, pathOptional, constraints);
        return;
      }
      if (this.ignoreDuplicateSlashes) {
        path4 = removeDuplicateSlashes(path4);
      }
      if (this.ignoreTrailingSlash) {
        path4 = trimLastSlash(path4);
      }
      const methods = Array.isArray(method) ? method : [method];
      for (const method2 of methods) {
        this._off(method2, path4, constraints);
      }
    };
    Router.prototype._off = function _off(method, path4, constraints) {
      assert(typeof method === "string", "Method should be a string");
      assert(httpMethods.includes(method), `Method '${method}' is not an http method.`);
      function matcherWithoutConstraints(route) {
        return method !== route.method || path4 !== route.path;
      }
      function matcherWithConstraints(route) {
        return matcherWithoutConstraints(route) || !deepEqual(constraints, route.opts.constraints || {});
      }
      const predicate = constraints ? matcherWithConstraints : matcherWithoutConstraints;
      const newRoutes = this.routes.filter(predicate);
      this._rebuild(newRoutes);
    };
    Router.prototype.lookup = function lookup(req, res, ctx, done) {
      if (typeof ctx === "function") {
        done = ctx;
        ctx = void 0;
      }
      if (done === void 0) {
        const constraints = this.constrainer.deriveConstraints(req, ctx);
        const handle = this.find(req.method, req.url, constraints);
        return this.callHandler(handle, req, res, ctx);
      }
      this.constrainer.deriveConstraints(req, ctx, (err, constraints) => {
        if (err !== null) {
          done(err);
          return;
        }
        try {
          const handle = this.find(req.method, req.url, constraints);
          const result = this.callHandler(handle, req, res, ctx);
          done(null, result);
        } catch (err2) {
          done(err2);
        }
      });
    };
    Router.prototype.callHandler = function callHandler(handle, req, res, ctx) {
      if (handle === null) return this._defaultRoute(req, res, ctx);
      return ctx === void 0 ? handle.handler(req, res, handle.params, handle.store, handle.searchParams) : handle.handler.call(ctx, req, res, handle.params, handle.store, handle.searchParams);
    };
    Router.prototype.find = function find(method, path4, derivedConstraints) {
      let currentNode = this.trees[method];
      if (currentNode === void 0) return null;
      if (path4.charCodeAt(0) !== 47) {
        path4 = path4.replace(FULL_PATH_REGEXP, "/");
      }
      if (this.ignoreDuplicateSlashes) {
        path4 = removeDuplicateSlashes(path4);
      }
      let sanitizedUrl;
      let querystring2;
      let shouldDecodeParam;
      try {
        sanitizedUrl = safeDecodeURI(path4, this.useSemicolonDelimiter);
        path4 = sanitizedUrl.path;
        querystring2 = sanitizedUrl.querystring;
        shouldDecodeParam = sanitizedUrl.shouldDecodeParam;
      } catch (error) {
        return this._onBadUrl(path4);
      }
      if (this.ignoreTrailingSlash) {
        path4 = trimLastSlash(path4);
      }
      const originPath = path4;
      if (this.caseSensitive === false) {
        path4 = path4.toLowerCase();
      }
      const maxParamLength = this.maxParamLength;
      let pathIndex = currentNode.prefix.length;
      const params = [];
      const pathLen = path4.length;
      const brothersNodesStack = [];
      while (true) {
        if (pathIndex === pathLen && currentNode.isLeafNode) {
          const handle = currentNode.handlerStorage.getMatchingHandler(derivedConstraints);
          if (handle !== null) {
            return {
              handler: handle.handler,
              store: handle.store,
              params: handle._createParamsObject(params),
              searchParams: this.querystringParser(querystring2)
            };
          }
        }
        let node = currentNode.getNextNode(path4, pathIndex, brothersNodesStack, params.length);
        if (node === null) {
          if (brothersNodesStack.length === 0) {
            return null;
          }
          const brotherNodeState = brothersNodesStack.pop();
          pathIndex = brotherNodeState.brotherPathIndex;
          params.splice(brotherNodeState.paramsCount);
          node = brotherNodeState.brotherNode;
        }
        currentNode = node;
        if (currentNode.kind === NODE_TYPES.STATIC) {
          pathIndex += currentNode.prefix.length;
          continue;
        }
        if (currentNode.kind === NODE_TYPES.WILDCARD) {
          let param2 = originPath.slice(pathIndex);
          if (shouldDecodeParam) {
            param2 = safeDecodeURIComponent(param2);
          }
          params.push(param2);
          pathIndex = pathLen;
          continue;
        }
        let paramEndIndex = originPath.indexOf("/", pathIndex);
        if (paramEndIndex === -1) {
          paramEndIndex = pathLen;
        }
        let param = originPath.slice(pathIndex, paramEndIndex);
        if (shouldDecodeParam) {
          param = safeDecodeURIComponent(param);
        }
        if (currentNode.isRegex) {
          const matchedParameters = currentNode.regex.exec(param);
          if (matchedParameters === null) continue;
          for (let i = 1; i < matchedParameters.length; i++) {
            const matchedParam = matchedParameters[i];
            if (matchedParam.length > maxParamLength) {
              return null;
            }
            params.push(matchedParam);
          }
        } else {
          if (param.length > maxParamLength) {
            return null;
          }
          params.push(param);
        }
        pathIndex = paramEndIndex;
      }
    };
    Router.prototype._rebuild = function(routes) {
      this.reset();
      for (const route of routes) {
        const { method, path: path4, opts, handler, store } = route;
        this._on(method, path4, opts, handler, store);
      }
    };
    Router.prototype._defaultRoute = function(req, res, ctx) {
      if (this.defaultRoute !== null) {
        return ctx === void 0 ? this.defaultRoute(req, res) : this.defaultRoute.call(ctx, req, res);
      } else {
        res.statusCode = 404;
        res.end();
      }
    };
    Router.prototype._onBadUrl = function(path4) {
      if (this.onBadUrl === null) {
        return null;
      }
      const onBadUrl = this.onBadUrl;
      return {
        handler: (req, res, ctx) => onBadUrl(path4, req, res),
        params: {},
        store: null
      };
    };
    Router.prototype.prettyPrint = function(options = {}) {
      const method = options.method;
      options.buildPrettyMeta = this.buildPrettyMeta.bind(this);
      let tree = null;
      if (method === void 0) {
        const { version: version2, host, ...constraints } = this.constrainer.strategies;
        constraints[httpMethodStrategy.name] = httpMethodStrategy;
        const mergedRouter = new Router({ ...this._opts, constraints });
        const mergedRoutes = this.routes.map((route) => {
          const constraints2 = {
            ...route.opts.constraints,
            [httpMethodStrategy.name]: route.method
          };
          return { ...route, method: "MERGED", opts: { constraints: constraints2 } };
        });
        mergedRouter._rebuild(mergedRoutes);
        tree = mergedRouter.trees.MERGED;
      } else {
        tree = this.trees[method];
      }
      if (tree == null) return "(empty tree)";
      return prettyPrintTree(tree, options);
    };
    for (const i in httpMethods) {
      if (!httpMethods.hasOwnProperty(i)) continue;
      const m = httpMethods[i];
      const methodName = m.toLowerCase();
      Router.prototype[methodName] = function(path4, handler, store) {
        return this.on(m, path4, handler, store);
      };
    }
    Router.prototype.all = function(path4, handler, store) {
      this.on(httpMethods, path4, handler, store);
    };
    module2.exports = Router;
    function escapeRegExp(string) {
      return string.replace(ESCAPE_REGEXP, "\\$&");
    }
    function removeDuplicateSlashes(path4) {
      return path4.indexOf("//") !== -1 ? path4.replace(REMOVE_DUPLICATE_SLASHES_REGEXP, "/") : path4;
    }
    function trimLastSlash(path4) {
      if (path4.length > 1 && path4.charCodeAt(path4.length - 1) === 47) {
        return path4.slice(0, -1);
      }
      return path4;
    }
    function trimRegExpStartAndEnd(regexString) {
      if (regexString.charCodeAt(1) === 94) {
        regexString = regexString.slice(0, 1) + regexString.slice(2);
      }
      if (regexString.charCodeAt(regexString.length - 2) === 36) {
        regexString = regexString.slice(0, regexString.length - 2) + regexString.slice(regexString.length - 1);
      }
      return regexString;
    }
    function getClosingParenthensePosition(path4, idx) {
      let parentheses = 1;
      while (idx < path4.length) {
        idx++;
        if (path4.charCodeAt(idx) === 92) {
          idx++;
          continue;
        }
        if (path4.charCodeAt(idx) === 41) {
          parentheses--;
        } else if (path4.charCodeAt(idx) === 40) {
          parentheses++;
        }
        if (!parentheses) return idx;
      }
      throw new TypeError('Invalid regexp expression in "' + path4 + '"');
    }
    function defaultBuildPrettyMeta(route) {
      if (!route) return {};
      if (!route.store) return {};
      return Object.assign({}, route.store);
    }
  }
});

// node_modules/fastify/lib/headRoute.js
var require_headRoute = __commonJS({
  "node_modules/fastify/lib/headRoute.js"(exports2, module2) {
    "use strict";
    function headRouteOnSendHandler(req, reply, payload, done) {
      if (payload === void 0) {
        reply.header("content-length", "0");
        done(null, null);
        return;
      }
      if (typeof payload.resume === "function") {
        payload.on("error", (err) => {
          reply.log.error({ err }, "Error on Stream found for HEAD route");
        });
        payload.resume();
        done(null, null);
        return;
      }
      const size = "" + Buffer.byteLength(payload);
      reply.header("content-length", size);
      done(null, null);
    }
    function parseHeadOnSendHandlers(onSendHandlers) {
      if (onSendHandlers == null) return headRouteOnSendHandler;
      return Array.isArray(onSendHandlers) ? [...onSendHandlers, headRouteOnSendHandler] : [onSendHandlers, headRouteOnSendHandler];
    }
    module2.exports = {
      parseHeadOnSendHandlers
    };
  }
});

// node_modules/fastify/lib/route.js
var require_route = __commonJS({
  "node_modules/fastify/lib/route.js"(exports2, module2) {
    "use strict";
    var FindMyWay = require_find_my_way();
    var Context = require_context();
    var handleRequest = require_handleRequest();
    var { onRequestAbortHookRunner, lifecycleHooks, preParsingHookRunner, onTimeoutHookRunner, onRequestHookRunner } = require_hooks();
    var { normalizeSchema } = require_schemas();
    var { parseHeadOnSendHandlers } = require_headRoute();
    var {
      compileSchemasForValidation,
      compileSchemasForSerialization
    } = require_validation();
    var {
      FST_ERR_SCH_VALIDATION_BUILD,
      FST_ERR_SCH_SERIALIZATION_BUILD,
      FST_ERR_DUPLICATED_ROUTE,
      FST_ERR_INVALID_URL,
      FST_ERR_HOOK_INVALID_HANDLER,
      FST_ERR_ROUTE_OPTIONS_NOT_OBJ,
      FST_ERR_ROUTE_DUPLICATED_HANDLER,
      FST_ERR_ROUTE_HANDLER_NOT_FN,
      FST_ERR_ROUTE_MISSING_HANDLER,
      FST_ERR_ROUTE_METHOD_NOT_SUPPORTED,
      FST_ERR_ROUTE_METHOD_INVALID,
      FST_ERR_ROUTE_BODY_VALIDATION_SCHEMA_NOT_SUPPORTED,
      FST_ERR_ROUTE_BODY_LIMIT_OPTION_NOT_INT,
      FST_ERR_HOOK_INVALID_ASYNC_HANDLER
    } = require_errors2();
    var {
      kRoutePrefix,
      kSupportedHTTPMethods,
      kLogLevel,
      kLogSerializers,
      kHooks,
      kSchemaController,
      kOptions,
      kReplySerializerDefault,
      kReplyIsError,
      kRequestPayloadStream,
      kDisableRequestLogging,
      kSchemaErrorFormatter,
      kErrorHandler,
      kHasBeenDecorated,
      kRequestAcceptVersion,
      kRouteByFastify,
      kRouteContext
    } = require_symbols2();
    var { buildErrorHandler } = require_error_handler();
    var { createChildLogger } = require_logger_factory();
    var { getGenReqId } = require_reqIdGenFactory();
    function buildRouting(options) {
      const router2 = FindMyWay(options.config);
      let avvio;
      let fourOhFour;
      let logger;
      let hasLogger;
      let setupResponseListeners;
      let throwIfAlreadyStarted;
      let disableRequestLogging;
      let ignoreTrailingSlash;
      let ignoreDuplicateSlashes;
      let return503OnClosing;
      let globalExposeHeadRoutes;
      let keepAliveConnections;
      let closing = false;
      return {
        /**
         * @param {import('../fastify').FastifyServerOptions} options
         * @param {*} fastifyArgs
         */
        setup(options2, fastifyArgs) {
          avvio = fastifyArgs.avvio;
          fourOhFour = fastifyArgs.fourOhFour;
          logger = fastifyArgs.logger;
          hasLogger = fastifyArgs.hasLogger;
          setupResponseListeners = fastifyArgs.setupResponseListeners;
          throwIfAlreadyStarted = fastifyArgs.throwIfAlreadyStarted;
          globalExposeHeadRoutes = options2.exposeHeadRoutes;
          disableRequestLogging = options2.disableRequestLogging;
          ignoreTrailingSlash = options2.ignoreTrailingSlash;
          ignoreDuplicateSlashes = options2.ignoreDuplicateSlashes;
          return503OnClosing = Object.hasOwn(options2, "return503OnClosing") ? options2.return503OnClosing : true;
          keepAliveConnections = fastifyArgs.keepAliveConnections;
        },
        routing: router2.lookup.bind(router2),
        // router func to find the right handler to call
        route,
        // configure a route in the fastify instance
        hasRoute,
        prepareRoute,
        routeHandler,
        closeRoutes: () => {
          closing = true;
        },
        printRoutes: router2.prettyPrint.bind(router2),
        addConstraintStrategy,
        hasConstraintStrategy,
        isAsyncConstraint,
        findRoute
      };
      function addConstraintStrategy(strategy) {
        throwIfAlreadyStarted("Cannot add constraint strategy!");
        return router2.addConstraintStrategy(strategy);
      }
      function hasConstraintStrategy(strategyName) {
        return router2.hasConstraintStrategy(strategyName);
      }
      function isAsyncConstraint() {
        return router2.constrainer.asyncStrategiesInUse.size > 0;
      }
      function prepareRoute({ method, url, options: options2, handler, isFastify }) {
        if (typeof url !== "string") {
          throw new FST_ERR_INVALID_URL(typeof url);
        }
        if (!handler && typeof options2 === "function") {
          handler = options2;
          options2 = {};
        } else if (handler && typeof handler === "function") {
          if (Object.prototype.toString.call(options2) !== "[object Object]") {
            throw new FST_ERR_ROUTE_OPTIONS_NOT_OBJ(method, url);
          } else if (options2.handler) {
            if (typeof options2.handler === "function") {
              throw new FST_ERR_ROUTE_DUPLICATED_HANDLER(method, url);
            } else {
              throw new FST_ERR_ROUTE_HANDLER_NOT_FN(method, url);
            }
          }
        }
        options2 = Object.assign({}, options2, {
          method,
          url,
          path: url,
          handler: handler || options2 && options2.handler
        });
        return route.call(this, { options: options2, isFastify });
      }
      function hasRoute({ options: options2 }) {
        const normalizedMethod = options2.method?.toUpperCase() ?? "";
        return router2.hasRoute(
          normalizedMethod,
          options2.url || "",
          options2.constraints
        );
      }
      function findRoute(options2) {
        const route2 = router2.find(
          options2.method,
          options2.url || "",
          options2.constraints
        );
        if (route2) {
          return {
            handler: route2.handler,
            params: route2.params,
            searchParams: route2.searchParams
          };
        } else {
          return null;
        }
      }
      function route({ options: options2, isFastify }) {
        throwIfAlreadyStarted("Cannot add route!");
        const opts = { ...options2 };
        const path4 = opts.url || opts.path || "";
        if (!opts.handler) {
          throw new FST_ERR_ROUTE_MISSING_HANDLER(opts.method, path4);
        }
        if (opts.errorHandler !== void 0 && typeof opts.errorHandler !== "function") {
          throw new FST_ERR_ROUTE_HANDLER_NOT_FN(opts.method, path4);
        }
        validateBodyLimitOption(opts.bodyLimit);
        const shouldExposeHead = opts.exposeHeadRoute ?? globalExposeHeadRoutes;
        let isGetRoute = false;
        let isHeadRoute = false;
        if (Array.isArray(opts.method)) {
          for (let i = 0; i < opts.method.length; ++i) {
            opts.method[i] = normalizeAndValidateMethod.call(this, opts.method[i]);
            validateSchemaBodyOption.call(this, opts.method[i], path4, opts.schema);
            isGetRoute = opts.method.includes("GET");
            isHeadRoute = opts.method.includes("HEAD");
          }
        } else {
          opts.method = normalizeAndValidateMethod.call(this, opts.method);
          validateSchemaBodyOption.call(this, opts.method, path4, opts.schema);
          isGetRoute = opts.method === "GET";
          isHeadRoute = opts.method === "HEAD";
        }
        const headOpts = shouldExposeHead && isGetRoute ? { ...options2 } : null;
        const prefix = this[kRoutePrefix];
        if (path4 === "/" && prefix.length > 0 && opts.method !== "HEAD") {
          switch (opts.prefixTrailingSlash) {
            case "slash":
              addNewRoute.call(this, { path: path4, isFastify });
              break;
            case "no-slash":
              addNewRoute.call(this, { path: "", isFastify });
              break;
            case "both":
            default:
              addNewRoute.call(this, { path: "", isFastify });
              if (ignoreTrailingSlash !== true && (ignoreDuplicateSlashes !== true || !prefix.endsWith("/"))) {
                addNewRoute.call(this, { path: path4, prefixing: true, isFastify });
              }
          }
        } else if (path4[0] === "/" && prefix.endsWith("/")) {
          addNewRoute.call(this, { path: path4.slice(1), isFastify });
        } else {
          addNewRoute.call(this, { path: path4, isFastify });
        }
        return this;
        function addNewRoute({ path: path5, prefixing = false, isFastify: isFastify2 = false }) {
          const url = prefix + path5;
          opts.url = url;
          opts.path = url;
          opts.routePath = path5;
          opts.prefix = prefix;
          opts.logLevel = opts.logLevel || this[kLogLevel];
          if (this[kLogSerializers] || opts.logSerializers) {
            opts.logSerializers = Object.assign(Object.create(this[kLogSerializers]), opts.logSerializers);
          }
          if (opts.attachValidation == null) {
            opts.attachValidation = false;
          }
          if (prefixing === false) {
            for (const hook of this[kHooks].onRoute) {
              hook.call(this, opts);
            }
          }
          for (const hook of lifecycleHooks) {
            if (opts && hook in opts) {
              if (Array.isArray(opts[hook])) {
                for (const func of opts[hook]) {
                  if (typeof func !== "function") {
                    throw new FST_ERR_HOOK_INVALID_HANDLER(hook, Object.prototype.toString.call(func));
                  }
                  if (hook === "onSend" || hook === "preSerialization" || hook === "onError" || hook === "preParsing") {
                    if (func.constructor.name === "AsyncFunction" && func.length === 4) {
                      throw new FST_ERR_HOOK_INVALID_ASYNC_HANDLER();
                    }
                  } else if (hook === "onRequestAbort") {
                    if (func.constructor.name === "AsyncFunction" && func.length !== 1) {
                      throw new FST_ERR_HOOK_INVALID_ASYNC_HANDLER();
                    }
                  } else {
                    if (func.constructor.name === "AsyncFunction" && func.length === 3) {
                      throw new FST_ERR_HOOK_INVALID_ASYNC_HANDLER();
                    }
                  }
                }
              } else if (opts[hook] !== void 0 && typeof opts[hook] !== "function") {
                throw new FST_ERR_HOOK_INVALID_HANDLER(hook, Object.prototype.toString.call(opts[hook]));
              }
            }
          }
          const constraints = opts.constraints || {};
          const config = {
            ...opts.config,
            url,
            method: opts.method
          };
          const context = new Context({
            schema: opts.schema,
            handler: opts.handler.bind(this),
            config,
            errorHandler: opts.errorHandler,
            childLoggerFactory: opts.childLoggerFactory,
            bodyLimit: opts.bodyLimit,
            logLevel: opts.logLevel,
            logSerializers: opts.logSerializers,
            attachValidation: opts.attachValidation,
            schemaErrorFormatter: opts.schemaErrorFormatter,
            replySerializer: this[kReplySerializerDefault],
            validatorCompiler: opts.validatorCompiler,
            serializerCompiler: opts.serializerCompiler,
            exposeHeadRoute: shouldExposeHead,
            prefixTrailingSlash: opts.prefixTrailingSlash || "both",
            server: this,
            isFastify: isFastify2
          });
          const headHandler = router2.findRoute("HEAD", opts.url, constraints);
          const hasHEADHandler = headHandler !== null;
          try {
            router2.on(opts.method, opts.url, { constraints }, routeHandler, context);
          } catch (error) {
            if (!context[kRouteByFastify]) {
              const isDuplicatedRoute = error.message.includes(`Method '${opts.method}' already declared for route`);
              if (isDuplicatedRoute) {
                throw new FST_ERR_DUPLICATED_ROUTE(opts.method, opts.url);
              }
              throw error;
            }
          }
          this.after((notHandledErr, done) => {
            context.errorHandler = opts.errorHandler ? buildErrorHandler(this[kErrorHandler], opts.errorHandler) : this[kErrorHandler];
            context._parserOptions.limit = opts.bodyLimit || null;
            context.logLevel = opts.logLevel;
            context.logSerializers = opts.logSerializers;
            context.attachValidation = opts.attachValidation;
            context[kReplySerializerDefault] = this[kReplySerializerDefault];
            context.schemaErrorFormatter = opts.schemaErrorFormatter || this[kSchemaErrorFormatter] || context.schemaErrorFormatter;
            avvio.once("preReady", () => {
              for (const hook of lifecycleHooks) {
                const toSet = this[kHooks][hook].concat(opts[hook] || []).map((h) => h.bind(this));
                context[hook] = toSet.length ? toSet : null;
              }
              while (!context.Request[kHasBeenDecorated] && context.Request.parent) {
                context.Request = context.Request.parent;
              }
              while (!context.Reply[kHasBeenDecorated] && context.Reply.parent) {
                context.Reply = context.Reply.parent;
              }
              fourOhFour.setContext(this, context);
              if (opts.schema) {
                context.schema = normalizeSchema(context.schema, this.initialConfig);
                const schemaController = this[kSchemaController];
                if (!opts.validatorCompiler && (opts.schema.body || opts.schema.headers || opts.schema.querystring || opts.schema.params)) {
                  schemaController.setupValidator(this[kOptions]);
                }
                try {
                  const isCustom = typeof opts?.validatorCompiler === "function" || schemaController.isCustomValidatorCompiler;
                  compileSchemasForValidation(context, opts.validatorCompiler || schemaController.validatorCompiler, isCustom);
                } catch (error) {
                  throw new FST_ERR_SCH_VALIDATION_BUILD(opts.method, url, error.message);
                }
                if (opts.schema.response && !opts.serializerCompiler) {
                  schemaController.setupSerializer(this[kOptions]);
                }
                try {
                  compileSchemasForSerialization(context, opts.serializerCompiler || schemaController.serializerCompiler);
                } catch (error) {
                  throw new FST_ERR_SCH_SERIALIZATION_BUILD(opts.method, url, error.message);
                }
              }
            });
            done(notHandledErr);
          });
          if (shouldExposeHead && isGetRoute && !isHeadRoute && !hasHEADHandler) {
            const onSendHandlers = parseHeadOnSendHandlers(headOpts.onSend);
            prepareRoute.call(this, { method: "HEAD", url: path5, options: { ...headOpts, onSend: onSendHandlers }, isFastify: true });
          }
        }
      }
      function routeHandler(req, res, params, context, query) {
        const id2 = getGenReqId(context.server, req);
        const loggerOpts = {
          level: context.logLevel
        };
        if (context.logSerializers) {
          loggerOpts.serializers = context.logSerializers;
        }
        const childLogger = createChildLogger(context, logger, req, id2, loggerOpts);
        childLogger[kDisableRequestLogging] = disableRequestLogging;
        if (closing === true) {
          if (req.httpVersionMajor !== 2) {
            res.setHeader("Connection", "close");
          }
          if (return503OnClosing) {
            const headers = {
              "Content-Type": "application/json",
              "Content-Length": "80"
            };
            res.writeHead(503, headers);
            res.end('{"error":"Service Unavailable","message":"Service Unavailable","statusCode":503}');
            childLogger.info({ res: { statusCode: 503 } }, "request aborted - refusing to accept new requests as server is closing");
            return;
          }
        }
        const connHeader = String.prototype.toLowerCase.call(req.headers.connection || "");
        if (connHeader === "keep-alive") {
          if (keepAliveConnections.has(req.socket) === false) {
            keepAliveConnections.add(req.socket);
            req.socket.on("close", removeTrackedSocket.bind({ keepAliveConnections, socket: req.socket }));
          }
        }
        if (req.headers[kRequestAcceptVersion] !== void 0) {
          req.headers["accept-version"] = req.headers[kRequestAcceptVersion];
          req.headers[kRequestAcceptVersion] = void 0;
        }
        const request = new context.Request(id2, params, req, query, childLogger, context);
        const reply = new context.Reply(res, request, childLogger);
        if (disableRequestLogging === false) {
          childLogger.info({ req: request }, "incoming request");
        }
        if (hasLogger === true || context.onResponse !== null) {
          setupResponseListeners(reply);
        }
        if (context.onRequest !== null) {
          onRequestHookRunner(
            context.onRequest,
            request,
            reply,
            runPreParsing
          );
        } else {
          runPreParsing(null, request, reply);
        }
        if (context.onRequestAbort !== null) {
          req.on("close", () => {
            if (req.aborted) {
              onRequestAbortHookRunner(
                context.onRequestAbort,
                request,
                handleOnRequestAbortHooksErrors.bind(null, reply)
              );
            }
          });
        }
        if (context.onTimeout !== null) {
          if (!request.raw.socket._meta) {
            request.raw.socket.on("timeout", handleTimeout);
          }
          request.raw.socket._meta = { context, request, reply };
        }
      }
    }
    function handleOnRequestAbortHooksErrors(reply, err) {
      if (err) {
        reply.log.error({ err }, "onRequestAborted hook failed");
      }
    }
    function handleTimeout() {
      const { context, request, reply } = this._meta;
      onTimeoutHookRunner(
        context.onTimeout,
        request,
        reply,
        noop
      );
    }
    function normalizeAndValidateMethod(method) {
      if (typeof method !== "string") {
        throw new FST_ERR_ROUTE_METHOD_INVALID();
      }
      method = method.toUpperCase();
      if (!this[kSupportedHTTPMethods].bodyless.has(method) && !this[kSupportedHTTPMethods].bodywith.has(method)) {
        throw new FST_ERR_ROUTE_METHOD_NOT_SUPPORTED(method);
      }
      return method;
    }
    function validateSchemaBodyOption(method, path4, schema) {
      if (this[kSupportedHTTPMethods].bodyless.has(method) && schema?.body) {
        throw new FST_ERR_ROUTE_BODY_VALIDATION_SCHEMA_NOT_SUPPORTED(method, path4);
      }
    }
    function validateBodyLimitOption(bodyLimit) {
      if (bodyLimit === void 0) return;
      if (!Number.isInteger(bodyLimit) || bodyLimit <= 0) {
        throw new FST_ERR_ROUTE_BODY_LIMIT_OPTION_NOT_INT(bodyLimit);
      }
    }
    function runPreParsing(err, request, reply) {
      if (reply.sent === true) return;
      if (err != null) {
        reply[kReplyIsError] = true;
        reply.send(err);
        return;
      }
      request[kRequestPayloadStream] = request.raw;
      if (request[kRouteContext].preParsing !== null) {
        preParsingHookRunner(request[kRouteContext].preParsing, request, reply, handleRequest.bind(request.server));
      } else {
        handleRequest.call(request.server, null, request, reply);
      }
    }
    function removeTrackedSocket() {
      this.keepAliveConnections.delete(this.socket);
    }
    function noop() {
    }
    module2.exports = { buildRouting, validateBodyLimitOption };
  }
});

// node_modules/fastify/lib/fourOhFour.js
var require_fourOhFour = __commonJS({
  "node_modules/fastify/lib/fourOhFour.js"(exports2, module2) {
    "use strict";
    var FindMyWay = require_find_my_way();
    var Reply = require_reply();
    var Request = require_request();
    var Context = require_context();
    var {
      kRoutePrefix,
      kCanSetNotFoundHandler,
      kFourOhFourLevelInstance,
      kFourOhFourContext,
      kHooks,
      kErrorHandler
    } = require_symbols2();
    var { lifecycleHooks } = require_hooks();
    var { buildErrorHandler } = require_error_handler();
    var {
      FST_ERR_NOT_FOUND
    } = require_errors2();
    var { createChildLogger } = require_logger_factory();
    var { getGenReqId } = require_reqIdGenFactory();
    function fourOhFour(options) {
      const { logger, disableRequestLogging } = options;
      const router2 = FindMyWay({ onBadUrl: createOnBadUrl(), defaultRoute: fourOhFourFallBack });
      let _onBadUrlHandler = null;
      return { router: router2, setNotFoundHandler, setContext, arrange404 };
      function arrange404(instance) {
        instance[kFourOhFourLevelInstance] = instance;
        instance[kCanSetNotFoundHandler] = true;
        router2.onBadUrl = router2.onBadUrl.bind(instance);
        router2.defaultRoute = router2.defaultRoute.bind(instance);
      }
      function basic404(request, reply) {
        const { url, method } = request.raw;
        const message = `Route ${method}:${url} not found`;
        if (!disableRequestLogging) {
          request.log.info(message);
        }
        reply.code(404).send({
          message,
          error: "Not Found",
          statusCode: 404
        });
      }
      function createOnBadUrl() {
        return function onBadUrl(path4, req, res) {
          const fourOhFourContext = this[kFourOhFourLevelInstance][kFourOhFourContext];
          const id2 = getGenReqId(fourOhFourContext.server, req);
          const childLogger = createChildLogger(fourOhFourContext, logger, req, id2);
          const request = new Request(id2, null, req, null, childLogger, fourOhFourContext);
          const reply = new Reply(res, request, childLogger);
          _onBadUrlHandler(request, reply);
        };
      }
      function setContext(instance, context) {
        const _404Context = Object.assign({}, instance[kFourOhFourContext]);
        _404Context.onSend = context.onSend;
        context[kFourOhFourContext] = _404Context;
      }
      function setNotFoundHandler(opts, handler, avvio, routeHandler) {
        if (this[kCanSetNotFoundHandler] === void 0) {
          this[kCanSetNotFoundHandler] = true;
        }
        if (this[kFourOhFourContext] === void 0) {
          this[kFourOhFourContext] = null;
        }
        const _fastify = this;
        const prefix = this[kRoutePrefix] || "/";
        if (this[kCanSetNotFoundHandler] === false) {
          throw new Error(`Not found handler already set for Fastify instance with prefix: '${prefix}'`);
        }
        if (typeof opts === "object") {
          if (opts.preHandler) {
            if (Array.isArray(opts.preHandler)) {
              opts.preHandler = opts.preHandler.map((hook) => hook.bind(_fastify));
            } else {
              opts.preHandler = opts.preHandler.bind(_fastify);
            }
          }
          if (opts.preValidation) {
            if (Array.isArray(opts.preValidation)) {
              opts.preValidation = opts.preValidation.map((hook) => hook.bind(_fastify));
            } else {
              opts.preValidation = opts.preValidation.bind(_fastify);
            }
          }
        }
        if (typeof opts === "function") {
          handler = opts;
          opts = void 0;
        }
        opts = opts || {};
        if (handler) {
          this[kFourOhFourLevelInstance][kCanSetNotFoundHandler] = false;
          handler = handler.bind(this);
          _onBadUrlHandler = handler;
        } else {
          handler = basic404;
          _onBadUrlHandler = basic404;
        }
        this.after((notHandledErr, done) => {
          _setNotFoundHandler.call(this, prefix, opts, handler, avvio, routeHandler);
          done(notHandledErr);
        });
      }
      function _setNotFoundHandler(prefix, opts, handler, avvio, routeHandler) {
        const context = new Context({
          schema: opts.schema,
          handler,
          config: opts.config || {},
          server: this
        });
        avvio.once("preReady", () => {
          const context2 = this[kFourOhFourContext];
          for (const hook of lifecycleHooks) {
            const toSet = this[kHooks][hook].concat(opts[hook] || []).map((h) => h.bind(this));
            context2[hook] = toSet.length ? toSet : null;
          }
          context2.errorHandler = opts.errorHandler ? buildErrorHandler(this[kErrorHandler], opts.errorHandler) : this[kErrorHandler];
        });
        if (this[kFourOhFourContext] !== null && prefix === "/") {
          Object.assign(this[kFourOhFourContext], context);
          return;
        }
        this[kFourOhFourLevelInstance][kFourOhFourContext] = context;
        router2.all(prefix + (prefix.endsWith("/") ? "*" : "/*"), routeHandler, context);
        router2.all(prefix, routeHandler, context);
      }
      function fourOhFourFallBack(req, res) {
        const fourOhFourContext = this[kFourOhFourLevelInstance][kFourOhFourContext];
        const id2 = getGenReqId(fourOhFourContext.server, req);
        const childLogger = createChildLogger(fourOhFourContext, logger, req, id2);
        childLogger.info({ req }, "incoming request");
        const request = new Request(id2, null, req, null, childLogger, fourOhFourContext);
        const reply = new Reply(res, request, childLogger);
        request.log.warn("the default handler for 404 did not catch this, this is likely a fastify bug, please report it");
        request.log.warn(router2.prettyPrint());
        reply.code(404).send(new FST_ERR_NOT_FOUND());
      }
    }
    module2.exports = fourOhFour;
  }
});

// node_modules/fastify/lib/configValidator.js
var require_configValidator = __commonJS({
  "node_modules/fastify/lib/configValidator.js"(exports2, module2) {
    "use strict";
    module2.exports = validate10;
    module2.exports.default = validate10;
    var schema11 = { "type": "object", "additionalProperties": false, "properties": { "connectionTimeout": { "type": "integer", "default": 0 }, "keepAliveTimeout": { "type": "integer", "default": 72e3 }, "forceCloseConnections": { "oneOf": [{ "type": "string", "pattern": "idle" }, { "type": "boolean" }] }, "maxRequestsPerSocket": { "type": "integer", "default": 0, "nullable": true }, "requestTimeout": { "type": "integer", "default": 0 }, "bodyLimit": { "type": "integer", "default": 1048576 }, "caseSensitive": { "type": "boolean", "default": true }, "allowUnsafeRegex": { "type": "boolean", "default": false }, "http2": { "type": "boolean" }, "https": { "if": { "not": { "oneOf": [{ "type": "boolean" }, { "type": "null" }, { "type": "object", "additionalProperties": false, "required": ["allowHTTP1"], "properties": { "allowHTTP1": { "type": "boolean" } } }] } }, "then": { "setDefaultValue": true } }, "ignoreTrailingSlash": { "type": "boolean", "default": false }, "ignoreDuplicateSlashes": { "type": "boolean", "default": false }, "disableRequestLogging": { "type": "boolean", "default": false }, "maxParamLength": { "type": "integer", "default": 100 }, "onProtoPoisoning": { "type": "string", "default": "error" }, "onConstructorPoisoning": { "type": "string", "default": "error" }, "pluginTimeout": { "type": "integer", "default": 1e4 }, "requestIdHeader": { "anyOf": [{ "type": "boolean" }, { "type": "string" }], "default": false }, "requestIdLogLabel": { "type": "string", "default": "reqId" }, "http2SessionTimeout": { "type": "integer", "default": 72e3 }, "exposeHeadRoutes": { "type": "boolean", "default": true }, "useSemicolonDelimiter": { "type": "boolean", "default": false }, "constraints": { "type": "object", "additionalProperties": { "type": "object", "required": ["name", "storage", "validate", "deriveConstraint"], "additionalProperties": true, "properties": { "name": { "type": "string" }, "storage": {}, "validate": {}, "deriveConstraint": {} } } } } };
    var func2 = Object.prototype.hasOwnProperty;
    var pattern0 = new RegExp("idle", "u");
    function validate10(data, { instancePath = "", parentData, parentDataProperty, rootData = data } = {}) {
      let vErrors = null;
      let errors = 0;
      if (errors === 0) {
        if (data && typeof data == "object" && !Array.isArray(data)) {
          if (data.connectionTimeout === void 0) {
            data.connectionTimeout = 0;
          }
          if (data.keepAliveTimeout === void 0) {
            data.keepAliveTimeout = 72e3;
          }
          if (data.maxRequestsPerSocket === void 0) {
            data.maxRequestsPerSocket = 0;
          }
          if (data.requestTimeout === void 0) {
            data.requestTimeout = 0;
          }
          if (data.bodyLimit === void 0) {
            data.bodyLimit = 1048576;
          }
          if (data.caseSensitive === void 0) {
            data.caseSensitive = true;
          }
          if (data.allowUnsafeRegex === void 0) {
            data.allowUnsafeRegex = false;
          }
          if (data.ignoreTrailingSlash === void 0) {
            data.ignoreTrailingSlash = false;
          }
          if (data.ignoreDuplicateSlashes === void 0) {
            data.ignoreDuplicateSlashes = false;
          }
          if (data.disableRequestLogging === void 0) {
            data.disableRequestLogging = false;
          }
          if (data.maxParamLength === void 0) {
            data.maxParamLength = 100;
          }
          if (data.onProtoPoisoning === void 0) {
            data.onProtoPoisoning = "error";
          }
          if (data.onConstructorPoisoning === void 0) {
            data.onConstructorPoisoning = "error";
          }
          if (data.pluginTimeout === void 0) {
            data.pluginTimeout = 1e4;
          }
          if (data.requestIdHeader === void 0) {
            data.requestIdHeader = false;
          }
          if (data.requestIdLogLabel === void 0) {
            data.requestIdLogLabel = "reqId";
          }
          if (data.http2SessionTimeout === void 0) {
            data.http2SessionTimeout = 72e3;
          }
          if (data.exposeHeadRoutes === void 0) {
            data.exposeHeadRoutes = true;
          }
          if (data.useSemicolonDelimiter === void 0) {
            data.useSemicolonDelimiter = false;
          }
          const _errs1 = errors;
          for (const key0 in data) {
            if (!func2.call(schema11.properties, key0)) {
              delete data[key0];
            }
          }
          if (_errs1 === errors) {
            let data0 = data.connectionTimeout;
            const _errs2 = errors;
            if (!(typeof data0 == "number" && (!(data0 % 1) && !isNaN(data0)) && isFinite(data0))) {
              let dataType0 = typeof data0;
              let coerced0 = void 0;
              if (!(coerced0 !== void 0)) {
                if (dataType0 === "boolean" || data0 === null || dataType0 === "string" && data0 && data0 == +data0 && !(data0 % 1)) {
                  coerced0 = +data0;
                } else {
                  validate10.errors = [{ instancePath: instancePath + "/connectionTimeout", schemaPath: "#/properties/connectionTimeout/type", keyword: "type", params: { type: "integer" }, message: "must be integer" }];
                  return false;
                }
              }
              if (coerced0 !== void 0) {
                data0 = coerced0;
                if (data !== void 0) {
                  data["connectionTimeout"] = coerced0;
                }
              }
            }
            var valid0 = _errs2 === errors;
            if (valid0) {
              let data1 = data.keepAliveTimeout;
              const _errs4 = errors;
              if (!(typeof data1 == "number" && (!(data1 % 1) && !isNaN(data1)) && isFinite(data1))) {
                let dataType1 = typeof data1;
                let coerced1 = void 0;
                if (!(coerced1 !== void 0)) {
                  if (dataType1 === "boolean" || data1 === null || dataType1 === "string" && data1 && data1 == +data1 && !(data1 % 1)) {
                    coerced1 = +data1;
                  } else {
                    validate10.errors = [{ instancePath: instancePath + "/keepAliveTimeout", schemaPath: "#/properties/keepAliveTimeout/type", keyword: "type", params: { type: "integer" }, message: "must be integer" }];
                    return false;
                  }
                }
                if (coerced1 !== void 0) {
                  data1 = coerced1;
                  if (data !== void 0) {
                    data["keepAliveTimeout"] = coerced1;
                  }
                }
              }
              var valid0 = _errs4 === errors;
              if (valid0) {
                if (data.forceCloseConnections !== void 0) {
                  let data2 = data.forceCloseConnections;
                  const _errs6 = errors;
                  const _errs7 = errors;
                  let valid1 = false;
                  let passing0 = null;
                  const _errs8 = errors;
                  if (typeof data2 !== "string") {
                    let dataType2 = typeof data2;
                    let coerced2 = void 0;
                    if (!(coerced2 !== void 0)) {
                      if (dataType2 == "number" || dataType2 == "boolean") {
                        coerced2 = "" + data2;
                      } else if (data2 === null) {
                        coerced2 = "";
                      } else {
                        const err0 = { instancePath: instancePath + "/forceCloseConnections", schemaPath: "#/properties/forceCloseConnections/oneOf/0/type", keyword: "type", params: { type: "string" }, message: "must be string" };
                        if (vErrors === null) {
                          vErrors = [err0];
                        } else {
                          vErrors.push(err0);
                        }
                        errors++;
                      }
                    }
                    if (coerced2 !== void 0) {
                      data2 = coerced2;
                      if (data !== void 0) {
                        data["forceCloseConnections"] = coerced2;
                      }
                    }
                  }
                  if (errors === _errs8) {
                    if (typeof data2 === "string") {
                      if (!pattern0.test(data2)) {
                        const err1 = { instancePath: instancePath + "/forceCloseConnections", schemaPath: "#/properties/forceCloseConnections/oneOf/0/pattern", keyword: "pattern", params: { pattern: "idle" }, message: 'must match pattern "idle"' };
                        if (vErrors === null) {
                          vErrors = [err1];
                        } else {
                          vErrors.push(err1);
                        }
                        errors++;
                      }
                    }
                  }
                  var _valid0 = _errs8 === errors;
                  if (_valid0) {
                    valid1 = true;
                    passing0 = 0;
                  }
                  const _errs10 = errors;
                  if (typeof data2 !== "boolean") {
                    let coerced3 = void 0;
                    if (!(coerced3 !== void 0)) {
                      if (data2 === "false" || data2 === 0 || data2 === null) {
                        coerced3 = false;
                      } else if (data2 === "true" || data2 === 1) {
                        coerced3 = true;
                      } else {
                        const err2 = { instancePath: instancePath + "/forceCloseConnections", schemaPath: "#/properties/forceCloseConnections/oneOf/1/type", keyword: "type", params: { type: "boolean" }, message: "must be boolean" };
                        if (vErrors === null) {
                          vErrors = [err2];
                        } else {
                          vErrors.push(err2);
                        }
                        errors++;
                      }
                    }
                    if (coerced3 !== void 0) {
                      data2 = coerced3;
                      if (data !== void 0) {
                        data["forceCloseConnections"] = coerced3;
                      }
                    }
                  }
                  var _valid0 = _errs10 === errors;
                  if (_valid0 && valid1) {
                    valid1 = false;
                    passing0 = [passing0, 1];
                  } else {
                    if (_valid0) {
                      valid1 = true;
                      passing0 = 1;
                    }
                  }
                  if (!valid1) {
                    const err3 = { instancePath: instancePath + "/forceCloseConnections", schemaPath: "#/properties/forceCloseConnections/oneOf", keyword: "oneOf", params: { passingSchemas: passing0 }, message: "must match exactly one schema in oneOf" };
                    if (vErrors === null) {
                      vErrors = [err3];
                    } else {
                      vErrors.push(err3);
                    }
                    errors++;
                    validate10.errors = vErrors;
                    return false;
                  } else {
                    errors = _errs7;
                    if (vErrors !== null) {
                      if (_errs7) {
                        vErrors.length = _errs7;
                      } else {
                        vErrors = null;
                      }
                    }
                  }
                  var valid0 = _errs6 === errors;
                } else {
                  var valid0 = true;
                }
                if (valid0) {
                  let data3 = data.maxRequestsPerSocket;
                  const _errs12 = errors;
                  if (!(typeof data3 == "number" && (!(data3 % 1) && !isNaN(data3)) && isFinite(data3)) && data3 !== null) {
                    let dataType4 = typeof data3;
                    let coerced4 = void 0;
                    if (!(coerced4 !== void 0)) {
                      if (dataType4 === "boolean" || data3 === null || dataType4 === "string" && data3 && data3 == +data3 && !(data3 % 1)) {
                        coerced4 = +data3;
                      } else if (data3 === "" || data3 === 0 || data3 === false) {
                        coerced4 = null;
                      } else {
                        validate10.errors = [{ instancePath: instancePath + "/maxRequestsPerSocket", schemaPath: "#/properties/maxRequestsPerSocket/type", keyword: "type", params: { type: "integer" }, message: "must be integer" }];
                        return false;
                      }
                    }
                    if (coerced4 !== void 0) {
                      data3 = coerced4;
                      if (data !== void 0) {
                        data["maxRequestsPerSocket"] = coerced4;
                      }
                    }
                  }
                  var valid0 = _errs12 === errors;
                  if (valid0) {
                    let data4 = data.requestTimeout;
                    const _errs15 = errors;
                    if (!(typeof data4 == "number" && (!(data4 % 1) && !isNaN(data4)) && isFinite(data4))) {
                      let dataType5 = typeof data4;
                      let coerced5 = void 0;
                      if (!(coerced5 !== void 0)) {
                        if (dataType5 === "boolean" || data4 === null || dataType5 === "string" && data4 && data4 == +data4 && !(data4 % 1)) {
                          coerced5 = +data4;
                        } else {
                          validate10.errors = [{ instancePath: instancePath + "/requestTimeout", schemaPath: "#/properties/requestTimeout/type", keyword: "type", params: { type: "integer" }, message: "must be integer" }];
                          return false;
                        }
                      }
                      if (coerced5 !== void 0) {
                        data4 = coerced5;
                        if (data !== void 0) {
                          data["requestTimeout"] = coerced5;
                        }
                      }
                    }
                    var valid0 = _errs15 === errors;
                    if (valid0) {
                      let data5 = data.bodyLimit;
                      const _errs17 = errors;
                      if (!(typeof data5 == "number" && (!(data5 % 1) && !isNaN(data5)) && isFinite(data5))) {
                        let dataType6 = typeof data5;
                        let coerced6 = void 0;
                        if (!(coerced6 !== void 0)) {
                          if (dataType6 === "boolean" || data5 === null || dataType6 === "string" && data5 && data5 == +data5 && !(data5 % 1)) {
                            coerced6 = +data5;
                          } else {
                            validate10.errors = [{ instancePath: instancePath + "/bodyLimit", schemaPath: "#/properties/bodyLimit/type", keyword: "type", params: { type: "integer" }, message: "must be integer" }];
                            return false;
                          }
                        }
                        if (coerced6 !== void 0) {
                          data5 = coerced6;
                          if (data !== void 0) {
                            data["bodyLimit"] = coerced6;
                          }
                        }
                      }
                      var valid0 = _errs17 === errors;
                      if (valid0) {
                        let data6 = data.caseSensitive;
                        const _errs19 = errors;
                        if (typeof data6 !== "boolean") {
                          let coerced7 = void 0;
                          if (!(coerced7 !== void 0)) {
                            if (data6 === "false" || data6 === 0 || data6 === null) {
                              coerced7 = false;
                            } else if (data6 === "true" || data6 === 1) {
                              coerced7 = true;
                            } else {
                              validate10.errors = [{ instancePath: instancePath + "/caseSensitive", schemaPath: "#/properties/caseSensitive/type", keyword: "type", params: { type: "boolean" }, message: "must be boolean" }];
                              return false;
                            }
                          }
                          if (coerced7 !== void 0) {
                            data6 = coerced7;
                            if (data !== void 0) {
                              data["caseSensitive"] = coerced7;
                            }
                          }
                        }
                        var valid0 = _errs19 === errors;
                        if (valid0) {
                          let data7 = data.allowUnsafeRegex;
                          const _errs21 = errors;
                          if (typeof data7 !== "boolean") {
                            let coerced8 = void 0;
                            if (!(coerced8 !== void 0)) {
                              if (data7 === "false" || data7 === 0 || data7 === null) {
                                coerced8 = false;
                              } else if (data7 === "true" || data7 === 1) {
                                coerced8 = true;
                              } else {
                                validate10.errors = [{ instancePath: instancePath + "/allowUnsafeRegex", schemaPath: "#/properties/allowUnsafeRegex/type", keyword: "type", params: { type: "boolean" }, message: "must be boolean" }];
                                return false;
                              }
                            }
                            if (coerced8 !== void 0) {
                              data7 = coerced8;
                              if (data !== void 0) {
                                data["allowUnsafeRegex"] = coerced8;
                              }
                            }
                          }
                          var valid0 = _errs21 === errors;
                          if (valid0) {
                            if (data.http2 !== void 0) {
                              let data8 = data.http2;
                              const _errs23 = errors;
                              if (typeof data8 !== "boolean") {
                                let coerced9 = void 0;
                                if (!(coerced9 !== void 0)) {
                                  if (data8 === "false" || data8 === 0 || data8 === null) {
                                    coerced9 = false;
                                  } else if (data8 === "true" || data8 === 1) {
                                    coerced9 = true;
                                  } else {
                                    validate10.errors = [{ instancePath: instancePath + "/http2", schemaPath: "#/properties/http2/type", keyword: "type", params: { type: "boolean" }, message: "must be boolean" }];
                                    return false;
                                  }
                                }
                                if (coerced9 !== void 0) {
                                  data8 = coerced9;
                                  if (data !== void 0) {
                                    data["http2"] = coerced9;
                                  }
                                }
                              }
                              var valid0 = _errs23 === errors;
                            } else {
                              var valid0 = true;
                            }
                            if (valid0) {
                              if (data.https !== void 0) {
                                let data9 = data.https;
                                const _errs25 = errors;
                                const _errs26 = errors;
                                let valid2 = true;
                                const _errs27 = errors;
                                const _errs28 = errors;
                                const _errs29 = errors;
                                const _errs30 = errors;
                                let valid4 = false;
                                let passing1 = null;
                                const _errs31 = errors;
                                if (typeof data9 !== "boolean") {
                                  let coerced10 = void 0;
                                  if (!(coerced10 !== void 0)) {
                                    if (data9 === "false" || data9 === 0 || data9 === null) {
                                      coerced10 = false;
                                    } else if (data9 === "true" || data9 === 1) {
                                      coerced10 = true;
                                    } else {
                                      const err4 = {};
                                      if (vErrors === null) {
                                        vErrors = [err4];
                                      } else {
                                        vErrors.push(err4);
                                      }
                                      errors++;
                                    }
                                  }
                                  if (coerced10 !== void 0) {
                                    data9 = coerced10;
                                    if (data !== void 0) {
                                      data["https"] = coerced10;
                                    }
                                  }
                                }
                                var _valid2 = _errs31 === errors;
                                if (_valid2) {
                                  valid4 = true;
                                  passing1 = 0;
                                }
                                const _errs33 = errors;
                                if (data9 !== null) {
                                  let coerced11 = void 0;
                                  if (!(coerced11 !== void 0)) {
                                    if (data9 === "" || data9 === 0 || data9 === false) {
                                      coerced11 = null;
                                    } else {
                                      const err5 = {};
                                      if (vErrors === null) {
                                        vErrors = [err5];
                                      } else {
                                        vErrors.push(err5);
                                      }
                                      errors++;
                                    }
                                  }
                                  if (coerced11 !== void 0) {
                                    data9 = coerced11;
                                    if (data !== void 0) {
                                      data["https"] = coerced11;
                                    }
                                  }
                                }
                                var _valid2 = _errs33 === errors;
                                if (_valid2 && valid4) {
                                  valid4 = false;
                                  passing1 = [passing1, 1];
                                } else {
                                  if (_valid2) {
                                    valid4 = true;
                                    passing1 = 1;
                                  }
                                  const _errs35 = errors;
                                  if (errors === _errs35) {
                                    if (data9 && typeof data9 == "object" && !Array.isArray(data9)) {
                                      let missing0;
                                      if (data9.allowHTTP1 === void 0 && (missing0 = "allowHTTP1")) {
                                        const err6 = {};
                                        if (vErrors === null) {
                                          vErrors = [err6];
                                        } else {
                                          vErrors.push(err6);
                                        }
                                        errors++;
                                      } else {
                                        const _errs37 = errors;
                                        for (const key1 in data9) {
                                          if (!(key1 === "allowHTTP1")) {
                                            delete data9[key1];
                                          }
                                        }
                                        if (_errs37 === errors) {
                                          if (data9.allowHTTP1 !== void 0) {
                                            let data10 = data9.allowHTTP1;
                                            if (typeof data10 !== "boolean") {
                                              let coerced12 = void 0;
                                              if (!(coerced12 !== void 0)) {
                                                if (data10 === "false" || data10 === 0 || data10 === null) {
                                                  coerced12 = false;
                                                } else if (data10 === "true" || data10 === 1) {
                                                  coerced12 = true;
                                                } else {
                                                  const err7 = {};
                                                  if (vErrors === null) {
                                                    vErrors = [err7];
                                                  } else {
                                                    vErrors.push(err7);
                                                  }
                                                  errors++;
                                                }
                                              }
                                              if (coerced12 !== void 0) {
                                                data10 = coerced12;
                                                if (data9 !== void 0) {
                                                  data9["allowHTTP1"] = coerced12;
                                                }
                                              }
                                            }
                                          }
                                        }
                                      }
                                    } else {
                                      const err8 = {};
                                      if (vErrors === null) {
                                        vErrors = [err8];
                                      } else {
                                        vErrors.push(err8);
                                      }
                                      errors++;
                                    }
                                  }
                                  var _valid2 = _errs35 === errors;
                                  if (_valid2 && valid4) {
                                    valid4 = false;
                                    passing1 = [passing1, 2];
                                  } else {
                                    if (_valid2) {
                                      valid4 = true;
                                      passing1 = 2;
                                    }
                                  }
                                }
                                if (!valid4) {
                                  const err9 = {};
                                  if (vErrors === null) {
                                    vErrors = [err9];
                                  } else {
                                    vErrors.push(err9);
                                  }
                                  errors++;
                                } else {
                                  errors = _errs30;
                                  if (vErrors !== null) {
                                    if (_errs30) {
                                      vErrors.length = _errs30;
                                    } else {
                                      vErrors = null;
                                    }
                                  }
                                }
                                var valid3 = _errs29 === errors;
                                if (valid3) {
                                  const err10 = {};
                                  if (vErrors === null) {
                                    vErrors = [err10];
                                  } else {
                                    vErrors.push(err10);
                                  }
                                  errors++;
                                } else {
                                  errors = _errs28;
                                  if (vErrors !== null) {
                                    if (_errs28) {
                                      vErrors.length = _errs28;
                                    } else {
                                      vErrors = null;
                                    }
                                  }
                                }
                                var _valid1 = _errs27 === errors;
                                errors = _errs26;
                                if (vErrors !== null) {
                                  if (_errs26) {
                                    vErrors.length = _errs26;
                                  } else {
                                    vErrors = null;
                                  }
                                }
                                if (_valid1) {
                                  const _errs40 = errors;
                                  data["https"] = true;
                                  var _valid1 = _errs40 === errors;
                                  valid2 = _valid1;
                                }
                                if (!valid2) {
                                  const err11 = { instancePath: instancePath + "/https", schemaPath: "#/properties/https/if", keyword: "if", params: { failingKeyword: "then" }, message: 'must match "then" schema' };
                                  if (vErrors === null) {
                                    vErrors = [err11];
                                  } else {
                                    vErrors.push(err11);
                                  }
                                  errors++;
                                  validate10.errors = vErrors;
                                  return false;
                                }
                                var valid0 = _errs25 === errors;
                              } else {
                                var valid0 = true;
                              }
                              if (valid0) {
                                let data11 = data.ignoreTrailingSlash;
                                const _errs41 = errors;
                                if (typeof data11 !== "boolean") {
                                  let coerced13 = void 0;
                                  if (!(coerced13 !== void 0)) {
                                    if (data11 === "false" || data11 === 0 || data11 === null) {
                                      coerced13 = false;
                                    } else if (data11 === "true" || data11 === 1) {
                                      coerced13 = true;
                                    } else {
                                      validate10.errors = [{ instancePath: instancePath + "/ignoreTrailingSlash", schemaPath: "#/properties/ignoreTrailingSlash/type", keyword: "type", params: { type: "boolean" }, message: "must be boolean" }];
                                      return false;
                                    }
                                  }
                                  if (coerced13 !== void 0) {
                                    data11 = coerced13;
                                    if (data !== void 0) {
                                      data["ignoreTrailingSlash"] = coerced13;
                                    }
                                  }
                                }
                                var valid0 = _errs41 === errors;
                                if (valid0) {
                                  let data12 = data.ignoreDuplicateSlashes;
                                  const _errs43 = errors;
                                  if (typeof data12 !== "boolean") {
                                    let coerced14 = void 0;
                                    if (!(coerced14 !== void 0)) {
                                      if (data12 === "false" || data12 === 0 || data12 === null) {
                                        coerced14 = false;
                                      } else if (data12 === "true" || data12 === 1) {
                                        coerced14 = true;
                                      } else {
                                        validate10.errors = [{ instancePath: instancePath + "/ignoreDuplicateSlashes", schemaPath: "#/properties/ignoreDuplicateSlashes/type", keyword: "type", params: { type: "boolean" }, message: "must be boolean" }];
                                        return false;
                                      }
                                    }
                                    if (coerced14 !== void 0) {
                                      data12 = coerced14;
                                      if (data !== void 0) {
                                        data["ignoreDuplicateSlashes"] = coerced14;
                                      }
                                    }
                                  }
                                  var valid0 = _errs43 === errors;
                                  if (valid0) {
                                    let data13 = data.disableRequestLogging;
                                    const _errs45 = errors;
                                    if (typeof data13 !== "boolean") {
                                      let coerced15 = void 0;
                                      if (!(coerced15 !== void 0)) {
                                        if (data13 === "false" || data13 === 0 || data13 === null) {
                                          coerced15 = false;
                                        } else if (data13 === "true" || data13 === 1) {
                                          coerced15 = true;
                                        } else {
                                          validate10.errors = [{ instancePath: instancePath + "/disableRequestLogging", schemaPath: "#/properties/disableRequestLogging/type", keyword: "type", params: { type: "boolean" }, message: "must be boolean" }];
                                          return false;
                                        }
                                      }
                                      if (coerced15 !== void 0) {
                                        data13 = coerced15;
                                        if (data !== void 0) {
                                          data["disableRequestLogging"] = coerced15;
                                        }
                                      }
                                    }
                                    var valid0 = _errs45 === errors;
                                    if (valid0) {
                                      let data14 = data.maxParamLength;
                                      const _errs47 = errors;
                                      if (!(typeof data14 == "number" && (!(data14 % 1) && !isNaN(data14)) && isFinite(data14))) {
                                        let dataType16 = typeof data14;
                                        let coerced16 = void 0;
                                        if (!(coerced16 !== void 0)) {
                                          if (dataType16 === "boolean" || data14 === null || dataType16 === "string" && data14 && data14 == +data14 && !(data14 % 1)) {
                                            coerced16 = +data14;
                                          } else {
                                            validate10.errors = [{ instancePath: instancePath + "/maxParamLength", schemaPath: "#/properties/maxParamLength/type", keyword: "type", params: { type: "integer" }, message: "must be integer" }];
                                            return false;
                                          }
                                        }
                                        if (coerced16 !== void 0) {
                                          data14 = coerced16;
                                          if (data !== void 0) {
                                            data["maxParamLength"] = coerced16;
                                          }
                                        }
                                      }
                                      var valid0 = _errs47 === errors;
                                      if (valid0) {
                                        let data15 = data.onProtoPoisoning;
                                        const _errs49 = errors;
                                        if (typeof data15 !== "string") {
                                          let dataType17 = typeof data15;
                                          let coerced17 = void 0;
                                          if (!(coerced17 !== void 0)) {
                                            if (dataType17 == "number" || dataType17 == "boolean") {
                                              coerced17 = "" + data15;
                                            } else if (data15 === null) {
                                              coerced17 = "";
                                            } else {
                                              validate10.errors = [{ instancePath: instancePath + "/onProtoPoisoning", schemaPath: "#/properties/onProtoPoisoning/type", keyword: "type", params: { type: "string" }, message: "must be string" }];
                                              return false;
                                            }
                                          }
                                          if (coerced17 !== void 0) {
                                            data15 = coerced17;
                                            if (data !== void 0) {
                                              data["onProtoPoisoning"] = coerced17;
                                            }
                                          }
                                        }
                                        var valid0 = _errs49 === errors;
                                        if (valid0) {
                                          let data16 = data.onConstructorPoisoning;
                                          const _errs51 = errors;
                                          if (typeof data16 !== "string") {
                                            let dataType18 = typeof data16;
                                            let coerced18 = void 0;
                                            if (!(coerced18 !== void 0)) {
                                              if (dataType18 == "number" || dataType18 == "boolean") {
                                                coerced18 = "" + data16;
                                              } else if (data16 === null) {
                                                coerced18 = "";
                                              } else {
                                                validate10.errors = [{ instancePath: instancePath + "/onConstructorPoisoning", schemaPath: "#/properties/onConstructorPoisoning/type", keyword: "type", params: { type: "string" }, message: "must be string" }];
                                                return false;
                                              }
                                            }
                                            if (coerced18 !== void 0) {
                                              data16 = coerced18;
                                              if (data !== void 0) {
                                                data["onConstructorPoisoning"] = coerced18;
                                              }
                                            }
                                          }
                                          var valid0 = _errs51 === errors;
                                          if (valid0) {
                                            let data17 = data.pluginTimeout;
                                            const _errs53 = errors;
                                            if (!(typeof data17 == "number" && (!(data17 % 1) && !isNaN(data17)) && isFinite(data17))) {
                                              let dataType19 = typeof data17;
                                              let coerced19 = void 0;
                                              if (!(coerced19 !== void 0)) {
                                                if (dataType19 === "boolean" || data17 === null || dataType19 === "string" && data17 && data17 == +data17 && !(data17 % 1)) {
                                                  coerced19 = +data17;
                                                } else {
                                                  validate10.errors = [{ instancePath: instancePath + "/pluginTimeout", schemaPath: "#/properties/pluginTimeout/type", keyword: "type", params: { type: "integer" }, message: "must be integer" }];
                                                  return false;
                                                }
                                              }
                                              if (coerced19 !== void 0) {
                                                data17 = coerced19;
                                                if (data !== void 0) {
                                                  data["pluginTimeout"] = coerced19;
                                                }
                                              }
                                            }
                                            var valid0 = _errs53 === errors;
                                            if (valid0) {
                                              let data18 = data.requestIdHeader;
                                              const _errs55 = errors;
                                              const _errs56 = errors;
                                              let valid6 = false;
                                              const _errs57 = errors;
                                              if (typeof data18 !== "boolean") {
                                                let coerced20 = void 0;
                                                if (!(coerced20 !== void 0)) {
                                                  if (data18 === "false" || data18 === 0 || data18 === null) {
                                                    coerced20 = false;
                                                  } else if (data18 === "true" || data18 === 1) {
                                                    coerced20 = true;
                                                  } else {
                                                    const err12 = { instancePath: instancePath + "/requestIdHeader", schemaPath: "#/properties/requestIdHeader/anyOf/0/type", keyword: "type", params: { type: "boolean" }, message: "must be boolean" };
                                                    if (vErrors === null) {
                                                      vErrors = [err12];
                                                    } else {
                                                      vErrors.push(err12);
                                                    }
                                                    errors++;
                                                  }
                                                }
                                                if (coerced20 !== void 0) {
                                                  data18 = coerced20;
                                                  if (data !== void 0) {
                                                    data["requestIdHeader"] = coerced20;
                                                  }
                                                }
                                              }
                                              var _valid3 = _errs57 === errors;
                                              valid6 = valid6 || _valid3;
                                              if (!valid6) {
                                                const _errs59 = errors;
                                                if (typeof data18 !== "string") {
                                                  let dataType21 = typeof data18;
                                                  let coerced21 = void 0;
                                                  if (!(coerced21 !== void 0)) {
                                                    if (dataType21 == "number" || dataType21 == "boolean") {
                                                      coerced21 = "" + data18;
                                                    } else if (data18 === null) {
                                                      coerced21 = "";
                                                    } else {
                                                      const err13 = { instancePath: instancePath + "/requestIdHeader", schemaPath: "#/properties/requestIdHeader/anyOf/1/type", keyword: "type", params: { type: "string" }, message: "must be string" };
                                                      if (vErrors === null) {
                                                        vErrors = [err13];
                                                      } else {
                                                        vErrors.push(err13);
                                                      }
                                                      errors++;
                                                    }
                                                  }
                                                  if (coerced21 !== void 0) {
                                                    data18 = coerced21;
                                                    if (data !== void 0) {
                                                      data["requestIdHeader"] = coerced21;
                                                    }
                                                  }
                                                }
                                                var _valid3 = _errs59 === errors;
                                                valid6 = valid6 || _valid3;
                                              }
                                              if (!valid6) {
                                                const err14 = { instancePath: instancePath + "/requestIdHeader", schemaPath: "#/properties/requestIdHeader/anyOf", keyword: "anyOf", params: {}, message: "must match a schema in anyOf" };
                                                if (vErrors === null) {
                                                  vErrors = [err14];
                                                } else {
                                                  vErrors.push(err14);
                                                }
                                                errors++;
                                                validate10.errors = vErrors;
                                                return false;
                                              } else {
                                                errors = _errs56;
                                                if (vErrors !== null) {
                                                  if (_errs56) {
                                                    vErrors.length = _errs56;
                                                  } else {
                                                    vErrors = null;
                                                  }
                                                }
                                              }
                                              var valid0 = _errs55 === errors;
                                              if (valid0) {
                                                let data19 = data.requestIdLogLabel;
                                                const _errs61 = errors;
                                                if (typeof data19 !== "string") {
                                                  let dataType22 = typeof data19;
                                                  let coerced22 = void 0;
                                                  if (!(coerced22 !== void 0)) {
                                                    if (dataType22 == "number" || dataType22 == "boolean") {
                                                      coerced22 = "" + data19;
                                                    } else if (data19 === null) {
                                                      coerced22 = "";
                                                    } else {
                                                      validate10.errors = [{ instancePath: instancePath + "/requestIdLogLabel", schemaPath: "#/properties/requestIdLogLabel/type", keyword: "type", params: { type: "string" }, message: "must be string" }];
                                                      return false;
                                                    }
                                                  }
                                                  if (coerced22 !== void 0) {
                                                    data19 = coerced22;
                                                    if (data !== void 0) {
                                                      data["requestIdLogLabel"] = coerced22;
                                                    }
                                                  }
                                                }
                                                var valid0 = _errs61 === errors;
                                                if (valid0) {
                                                  let data20 = data.http2SessionTimeout;
                                                  const _errs63 = errors;
                                                  if (!(typeof data20 == "number" && (!(data20 % 1) && !isNaN(data20)) && isFinite(data20))) {
                                                    let dataType23 = typeof data20;
                                                    let coerced23 = void 0;
                                                    if (!(coerced23 !== void 0)) {
                                                      if (dataType23 === "boolean" || data20 === null || dataType23 === "string" && data20 && data20 == +data20 && !(data20 % 1)) {
                                                        coerced23 = +data20;
                                                      } else {
                                                        validate10.errors = [{ instancePath: instancePath + "/http2SessionTimeout", schemaPath: "#/properties/http2SessionTimeout/type", keyword: "type", params: { type: "integer" }, message: "must be integer" }];
                                                        return false;
                                                      }
                                                    }
                                                    if (coerced23 !== void 0) {
                                                      data20 = coerced23;
                                                      if (data !== void 0) {
                                                        data["http2SessionTimeout"] = coerced23;
                                                      }
                                                    }
                                                  }
                                                  var valid0 = _errs63 === errors;
                                                  if (valid0) {
                                                    let data21 = data.exposeHeadRoutes;
                                                    const _errs65 = errors;
                                                    if (typeof data21 !== "boolean") {
                                                      let coerced24 = void 0;
                                                      if (!(coerced24 !== void 0)) {
                                                        if (data21 === "false" || data21 === 0 || data21 === null) {
                                                          coerced24 = false;
                                                        } else if (data21 === "true" || data21 === 1) {
                                                          coerced24 = true;
                                                        } else {
                                                          validate10.errors = [{ instancePath: instancePath + "/exposeHeadRoutes", schemaPath: "#/properties/exposeHeadRoutes/type", keyword: "type", params: { type: "boolean" }, message: "must be boolean" }];
                                                          return false;
                                                        }
                                                      }
                                                      if (coerced24 !== void 0) {
                                                        data21 = coerced24;
                                                        if (data !== void 0) {
                                                          data["exposeHeadRoutes"] = coerced24;
                                                        }
                                                      }
                                                    }
                                                    var valid0 = _errs65 === errors;
                                                    if (valid0) {
                                                      let data22 = data.useSemicolonDelimiter;
                                                      const _errs67 = errors;
                                                      if (typeof data22 !== "boolean") {
                                                        let coerced25 = void 0;
                                                        if (!(coerced25 !== void 0)) {
                                                          if (data22 === "false" || data22 === 0 || data22 === null) {
                                                            coerced25 = false;
                                                          } else if (data22 === "true" || data22 === 1) {
                                                            coerced25 = true;
                                                          } else {
                                                            validate10.errors = [{ instancePath: instancePath + "/useSemicolonDelimiter", schemaPath: "#/properties/useSemicolonDelimiter/type", keyword: "type", params: { type: "boolean" }, message: "must be boolean" }];
                                                            return false;
                                                          }
                                                        }
                                                        if (coerced25 !== void 0) {
                                                          data22 = coerced25;
                                                          if (data !== void 0) {
                                                            data["useSemicolonDelimiter"] = coerced25;
                                                          }
                                                        }
                                                      }
                                                      var valid0 = _errs67 === errors;
                                                      if (valid0) {
                                                        if (data.constraints !== void 0) {
                                                          let data23 = data.constraints;
                                                          const _errs69 = errors;
                                                          if (errors === _errs69) {
                                                            if (data23 && typeof data23 == "object" && !Array.isArray(data23)) {
                                                              for (const key2 in data23) {
                                                                let data24 = data23[key2];
                                                                const _errs72 = errors;
                                                                if (errors === _errs72) {
                                                                  if (data24 && typeof data24 == "object" && !Array.isArray(data24)) {
                                                                    let missing1;
                                                                    if (data24.name === void 0 && (missing1 = "name") || data24.storage === void 0 && (missing1 = "storage") || data24.validate === void 0 && (missing1 = "validate") || data24.deriveConstraint === void 0 && (missing1 = "deriveConstraint")) {
                                                                      validate10.errors = [{ instancePath: instancePath + "/constraints/" + key2.replace(/~/g, "~0").replace(/\//g, "~1"), schemaPath: "#/properties/constraints/additionalProperties/required", keyword: "required", params: { missingProperty: missing1 }, message: "must have required property '" + missing1 + "'" }];
                                                                      return false;
                                                                    } else {
                                                                      if (data24.name !== void 0) {
                                                                        let data25 = data24.name;
                                                                        if (typeof data25 !== "string") {
                                                                          let dataType26 = typeof data25;
                                                                          let coerced26 = void 0;
                                                                          if (!(coerced26 !== void 0)) {
                                                                            if (dataType26 == "number" || dataType26 == "boolean") {
                                                                              coerced26 = "" + data25;
                                                                            } else if (data25 === null) {
                                                                              coerced26 = "";
                                                                            } else {
                                                                              validate10.errors = [{ instancePath: instancePath + "/constraints/" + key2.replace(/~/g, "~0").replace(/\//g, "~1") + "/name", schemaPath: "#/properties/constraints/additionalProperties/properties/name/type", keyword: "type", params: { type: "string" }, message: "must be string" }];
                                                                              return false;
                                                                            }
                                                                          }
                                                                          if (coerced26 !== void 0) {
                                                                            data25 = coerced26;
                                                                            if (data24 !== void 0) {
                                                                              data24["name"] = coerced26;
                                                                            }
                                                                          }
                                                                        }
                                                                      }
                                                                    }
                                                                  } else {
                                                                    validate10.errors = [{ instancePath: instancePath + "/constraints/" + key2.replace(/~/g, "~0").replace(/\//g, "~1"), schemaPath: "#/properties/constraints/additionalProperties/type", keyword: "type", params: { type: "object" }, message: "must be object" }];
                                                                    return false;
                                                                  }
                                                                }
                                                                var valid7 = _errs72 === errors;
                                                                if (!valid7) {
                                                                  break;
                                                                }
                                                              }
                                                            } else {
                                                              validate10.errors = [{ instancePath: instancePath + "/constraints", schemaPath: "#/properties/constraints/type", keyword: "type", params: { type: "object" }, message: "must be object" }];
                                                              return false;
                                                            }
                                                          }
                                                          var valid0 = _errs69 === errors;
                                                        } else {
                                                          var valid0 = true;
                                                        }
                                                      }
                                                    }
                                                  }
                                                }
                                              }
                                            }
                                          }
                                        }
                                      }
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        } else {
          validate10.errors = [{ instancePath, schemaPath: "#/type", keyword: "type", params: { type: "object" }, message: "must be object" }];
          return false;
        }
      }
      validate10.errors = vErrors;
      return errors === 0;
    }
    module2.exports.defaultInitOptions = { "connectionTimeout": 0, "keepAliveTimeout": 72e3, "maxRequestsPerSocket": 0, "requestTimeout": 0, "bodyLimit": 1048576, "caseSensitive": true, "allowUnsafeRegex": false, "disableRequestLogging": false, "ignoreTrailingSlash": false, "ignoreDuplicateSlashes": false, "maxParamLength": 100, "onProtoPoisoning": "error", "onConstructorPoisoning": "error", "pluginTimeout": 1e4, "requestIdHeader": false, "requestIdLogLabel": "reqId", "http2SessionTimeout": 72e3, "exposeHeadRoutes": true, "useSemicolonDelimiter": false, "allowErrorHandlerOverride": true };
  }
});

// node_modules/fastify/lib/initialConfigValidation.js
var require_initialConfigValidation = __commonJS({
  "node_modules/fastify/lib/initialConfigValidation.js"(exports2, module2) {
    "use strict";
    var validate = require_configValidator();
    var deepClone = require_rfdc()({ circles: true, proto: false });
    var { FST_ERR_INIT_OPTS_INVALID } = require_errors2();
    function validateInitialConfig(options) {
      const opts = deepClone(options);
      if (!validate(opts)) {
        const error = new FST_ERR_INIT_OPTS_INVALID(JSON.stringify(validate.errors.map((e) => e.message)));
        error.errors = validate.errors;
        throw error;
      }
      return deepFreezeObject(opts);
    }
    function deepFreezeObject(object) {
      const properties = Object.getOwnPropertyNames(object);
      for (const name of properties) {
        const value = object[name];
        if (ArrayBuffer.isView(value) && !(value instanceof DataView)) {
          continue;
        }
        object[name] = value && typeof value === "object" ? deepFreezeObject(value) : value;
      }
      return Object.freeze(object);
    }
    module2.exports = validateInitialConfig;
    module2.exports.defaultInitOptions = validate.defaultInitOptions;
    module2.exports.utils = { deepFreezeObject };
  }
});

// node_modules/fastify/lib/pluginOverride.js
var require_pluginOverride = __commonJS({
  "node_modules/fastify/lib/pluginOverride.js"(exports2, module2) {
    "use strict";
    var {
      kAvvioBoot,
      kChildren,
      kRoutePrefix,
      kLogLevel,
      kLogSerializers,
      kHooks,
      kSchemaController,
      kContentTypeParser,
      kReply,
      kRequest,
      kFourOhFour,
      kPluginNameChain,
      kErrorHandlerAlreadySet
    } = require_symbols2();
    var Reply = require_reply();
    var Request = require_request();
    var SchemaController = require_schema_controller();
    var ContentTypeParser = require_contentTypeParser();
    var { buildHooks } = require_hooks();
    var pluginUtils = require_pluginUtils();
    module2.exports = function override(old, fn, opts) {
      const shouldSkipOverride = pluginUtils.registerPlugin.call(old, fn);
      const fnName = pluginUtils.getPluginName(fn) || pluginUtils.getFuncPreview(fn);
      if (shouldSkipOverride) {
        old[kPluginNameChain].push(fnName);
        return old;
      }
      const instance = Object.create(old);
      old[kChildren].push(instance);
      instance.ready = old[kAvvioBoot].bind(instance);
      instance[kChildren] = [];
      instance[kReply] = Reply.buildReply(instance[kReply]);
      instance[kRequest] = Request.buildRequest(instance[kRequest]);
      instance[kContentTypeParser] = ContentTypeParser.helpers.buildContentTypeParser(instance[kContentTypeParser]);
      instance[kHooks] = buildHooks(instance[kHooks]);
      instance[kRoutePrefix] = buildRoutePrefix(instance[kRoutePrefix], opts.prefix);
      instance[kLogLevel] = opts.logLevel || instance[kLogLevel];
      instance[kSchemaController] = SchemaController.buildSchemaController(old[kSchemaController]);
      instance.getSchema = instance[kSchemaController].getSchema.bind(instance[kSchemaController]);
      instance.getSchemas = instance[kSchemaController].getSchemas.bind(instance[kSchemaController]);
      instance[pluginUtils.kRegisteredPlugins] = Object.create(instance[pluginUtils.kRegisteredPlugins]);
      instance[kPluginNameChain] = [fnName];
      instance[kErrorHandlerAlreadySet] = false;
      if (instance[kLogSerializers] || opts.logSerializers) {
        instance[kLogSerializers] = Object.assign(Object.create(instance[kLogSerializers]), opts.logSerializers);
      }
      if (opts.prefix) {
        instance[kFourOhFour].arrange404(instance);
      }
      for (const hook of instance[kHooks].onRegister) hook.call(old, instance, opts);
      return instance;
    };
    function buildRoutePrefix(instancePrefix, pluginPrefix) {
      if (!pluginPrefix) {
        return instancePrefix;
      }
      if (instancePrefix.endsWith("/") && pluginPrefix[0] === "/") {
        pluginPrefix = pluginPrefix.slice(1);
      } else if (pluginPrefix[0] !== "/") {
        pluginPrefix = "/" + pluginPrefix;
      }
      return instancePrefix + pluginPrefix;
    }
  }
});

// node_modules/fastify/lib/noop-set.js
var require_noop_set = __commonJS({
  "node_modules/fastify/lib/noop-set.js"(exports2, module2) {
    "use strict";
    module2.exports = function noopSet() {
      return {
        [Symbol.iterator]: function* () {
        },
        add() {
        },
        delete() {
        },
        has() {
          return true;
        }
      };
    };
  }
});

// node_modules/cookie/dist/index.js
var require_dist4 = __commonJS({
  "node_modules/cookie/dist/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.parse = parse;
    exports2.serialize = serialize;
    var cookieNameRegExp = /^[\u0021-\u003A\u003C\u003E-\u007E]+$/;
    var cookieValueRegExp = /^[\u0021-\u003A\u003C-\u007E]*$/;
    var domainValueRegExp = /^([.]?[a-z0-9]([a-z0-9-]{0,61}[a-z0-9])?)([.][a-z0-9]([a-z0-9-]{0,61}[a-z0-9])?)*$/i;
    var pathValueRegExp = /^[\u0020-\u003A\u003D-\u007E]*$/;
    var __toString = Object.prototype.toString;
    var NullObject = /* @__PURE__ */ (() => {
      const C = function() {
      };
      C.prototype = /* @__PURE__ */ Object.create(null);
      return C;
    })();
    function parse(str, options) {
      const obj = new NullObject();
      const len = str.length;
      if (len < 2)
        return obj;
      const dec = options?.decode || decode;
      let index = 0;
      do {
        const eqIdx = str.indexOf("=", index);
        if (eqIdx === -1)
          break;
        const colonIdx = str.indexOf(";", index);
        const endIdx = colonIdx === -1 ? len : colonIdx;
        if (eqIdx > endIdx) {
          index = str.lastIndexOf(";", eqIdx - 1) + 1;
          continue;
        }
        const keyStartIdx = startIndex(str, index, eqIdx);
        const keyEndIdx = endIndex(str, eqIdx, keyStartIdx);
        const key = str.slice(keyStartIdx, keyEndIdx);
        if (obj[key] === void 0) {
          let valStartIdx = startIndex(str, eqIdx + 1, endIdx);
          let valEndIdx = endIndex(str, endIdx, valStartIdx);
          const value = dec(str.slice(valStartIdx, valEndIdx));
          obj[key] = value;
        }
        index = endIdx + 1;
      } while (index < len);
      return obj;
    }
    function startIndex(str, index, max) {
      do {
        const code = str.charCodeAt(index);
        if (code !== 32 && code !== 9)
          return index;
      } while (++index < max);
      return max;
    }
    function endIndex(str, index, min) {
      while (index > min) {
        const code = str.charCodeAt(--index);
        if (code !== 32 && code !== 9)
          return index + 1;
      }
      return min;
    }
    function serialize(name, val, options) {
      const enc2 = options?.encode || encodeURIComponent;
      if (!cookieNameRegExp.test(name)) {
        throw new TypeError(`argument name is invalid: ${name}`);
      }
      const value = enc2(val);
      if (!cookieValueRegExp.test(value)) {
        throw new TypeError(`argument val is invalid: ${val}`);
      }
      let str = name + "=" + value;
      if (!options)
        return str;
      if (options.maxAge !== void 0) {
        if (!Number.isInteger(options.maxAge)) {
          throw new TypeError(`option maxAge is invalid: ${options.maxAge}`);
        }
        str += "; Max-Age=" + options.maxAge;
      }
      if (options.domain) {
        if (!domainValueRegExp.test(options.domain)) {
          throw new TypeError(`option domain is invalid: ${options.domain}`);
        }
        str += "; Domain=" + options.domain;
      }
      if (options.path) {
        if (!pathValueRegExp.test(options.path)) {
          throw new TypeError(`option path is invalid: ${options.path}`);
        }
        str += "; Path=" + options.path;
      }
      if (options.expires) {
        if (!isDate(options.expires) || !Number.isFinite(options.expires.valueOf())) {
          throw new TypeError(`option expires is invalid: ${options.expires}`);
        }
        str += "; Expires=" + options.expires.toUTCString();
      }
      if (options.httpOnly) {
        str += "; HttpOnly";
      }
      if (options.secure) {
        str += "; Secure";
      }
      if (options.partitioned) {
        str += "; Partitioned";
      }
      if (options.priority) {
        const priority = typeof options.priority === "string" ? options.priority.toLowerCase() : void 0;
        switch (priority) {
          case "low":
            str += "; Priority=Low";
            break;
          case "medium":
            str += "; Priority=Medium";
            break;
          case "high":
            str += "; Priority=High";
            break;
          default:
            throw new TypeError(`option priority is invalid: ${options.priority}`);
        }
      }
      if (options.sameSite) {
        const sameSite = typeof options.sameSite === "string" ? options.sameSite.toLowerCase() : options.sameSite;
        switch (sameSite) {
          case true:
          case "strict":
            str += "; SameSite=Strict";
            break;
          case "lax":
            str += "; SameSite=Lax";
            break;
          case "none":
            str += "; SameSite=None";
            break;
          default:
            throw new TypeError(`option sameSite is invalid: ${options.sameSite}`);
        }
      }
      return str;
    }
    function decode(str) {
      if (str.indexOf("%") === -1)
        return str;
      try {
        return decodeURIComponent(str);
      } catch (e) {
        return str;
      }
    }
    function isDate(val) {
      return __toString.call(val) === "[object Date]";
    }
  }
});

// node_modules/light-my-request/node_modules/process-warning/index.js
var require_process_warning2 = __commonJS({
  "node_modules/light-my-request/node_modules/process-warning/index.js"(exports2, module2) {
    "use strict";
    var { format } = require("node:util");
    function createDeprecation(params) {
      return createWarning({ ...params, name: "DeprecationWarning" });
    }
    function createWarning({ name, code, message, unlimited = false } = {}) {
      if (!name) throw new Error("Warning name must not be empty");
      if (!code) throw new Error("Warning code must not be empty");
      if (!message) throw new Error("Warning message must not be empty");
      if (typeof unlimited !== "boolean") throw new Error("Warning opts.unlimited must be a boolean");
      code = code.toUpperCase();
      let warningContainer = {
        [name]: function(a, b, c) {
          if (warning.emitted === true && warning.unlimited !== true) {
            return;
          }
          warning.emitted = true;
          process.emitWarning(warning.format(a, b, c), warning.name, warning.code);
        }
      };
      if (unlimited) {
        warningContainer = {
          [name]: function(a, b, c) {
            warning.emitted = true;
            process.emitWarning(warning.format(a, b, c), warning.name, warning.code);
          }
        };
      }
      const warning = warningContainer[name];
      warning.emitted = false;
      warning.message = message;
      warning.unlimited = unlimited;
      warning.code = code;
      warning.format = function(a, b, c) {
        let formatted;
        if (a && b && c) {
          formatted = format(message, a, b, c);
        } else if (a && b) {
          formatted = format(message, a, b);
        } else if (a) {
          formatted = format(message, a);
        } else {
          formatted = message;
        }
        return formatted;
      };
      return warning;
    }
    var out = { createWarning, createDeprecation };
    module2.exports = out;
    module2.exports.default = out;
    module2.exports.processWarning = out;
  }
});

// node_modules/light-my-request/lib/parse-url.js
var require_parse_url = __commonJS({
  "node_modules/light-my-request/lib/parse-url.js"(exports2, module2) {
    "use strict";
    var { URL: URL2 } = require("node:url");
    var BASE_URL = "http://localhost";
    module2.exports = function parseURL(url, query) {
      if ((typeof url === "string" || Object.prototype.toString.call(url) === "[object String]") && url.startsWith("//")) {
        url = BASE_URL + url;
      }
      const result = typeof url === "object" ? Object.assign(new URL2(BASE_URL), url) : new URL2(url, BASE_URL);
      if (typeof query === "string") {
        query = new URLSearchParams(query);
        for (const key of query.keys()) {
          result.searchParams.delete(key);
          for (const value of query.getAll(key)) {
            result.searchParams.append(key, value);
          }
        }
      } else {
        const merged = Object.assign({}, url.query, query);
        for (const key in merged) {
          const value = merged[key];
          if (Array.isArray(value)) {
            result.searchParams.delete(key);
            for (const param of value) {
              result.searchParams.append(key, param);
            }
          } else {
            result.searchParams.set(key, value);
          }
        }
      }
      return result;
    };
  }
});

// node_modules/light-my-request/lib/form-data.js
var require_form_data = __commonJS({
  "node_modules/light-my-request/lib/form-data.js"(exports2, module2) {
    "use strict";
    var { randomUUID } = require("node:crypto");
    var { Readable } = require("node:stream");
    var textEncoder;
    function isFormDataLike(payload) {
      return payload && typeof payload === "object" && typeof payload.append === "function" && typeof payload.delete === "function" && typeof payload.get === "function" && typeof payload.getAll === "function" && typeof payload.has === "function" && typeof payload.set === "function" && payload[Symbol.toStringTag] === "FormData";
    }
    function formDataToStream(formdata) {
      textEncoder = textEncoder ?? new TextEncoder();
      const boundary = `----formdata-${randomUUID()}`;
      const prefix = `--${boundary}\r
Content-Disposition: form-data`;
      const escape2 = (str) => str.replace(/\n/g, "%0A").replace(/\r/g, "%0D").replace(/"/g, "%22");
      const normalizeLinefeeds = (value) => value.replace(/\r?\n|\r/g, "\r\n");
      const linebreak = new Uint8Array([13, 10]);
      async function* asyncIterator() {
        for (const [name, value] of formdata) {
          if (typeof value === "string") {
            yield textEncoder.encode(`${prefix}; name="${escape2(normalizeLinefeeds(name))}"\r
\r
`);
            yield textEncoder.encode(`${normalizeLinefeeds(value)}\r
`);
          } else {
            let header = `${prefix}; name="${escape2(normalizeLinefeeds(name))}"`;
            value.name && (header += `; filename="${escape2(value.name)}"`);
            header += `\r
Content-Type: ${value.type || "application/octet-stream"}\r
\r
`;
            yield textEncoder.encode(header);
            if (value.stream) {
              yield* value.stream();
            } else {
              yield value;
            }
            yield linebreak;
          }
        }
        yield textEncoder.encode(`--${boundary}--`);
      }
      const stream = Readable.from(asyncIterator());
      return {
        stream,
        contentType: `multipart/form-data; boundary=${boundary}`
      };
    }
    module2.exports.isFormDataLike = isFormDataLike;
    module2.exports.formDataToStream = formDataToStream;
  }
});

// node_modules/light-my-request/lib/request.js
var require_request2 = __commonJS({
  "node_modules/light-my-request/lib/request.js"(exports2, module2) {
    "use strict";
    var { Readable, addAbortSignal } = require("node:stream");
    var util = require("node:util");
    var cookie = require_dist4();
    var assert = require("node:assert");
    var { createDeprecation } = require_process_warning2();
    var parseURL = require_parse_url();
    var { isFormDataLike, formDataToStream } = require_form_data();
    var { EventEmitter } = require("node:events");
    var FST_LIGHTMYREQUEST_DEP01 = createDeprecation({
      name: "FastifyDeprecationLightMyRequest",
      code: "FST_LIGHTMYREQUEST_DEP01",
      message: 'You are accessing "request.connection", use "request.socket" instead.'
    });
    function hostHeaderFromURL(parsedURL) {
      return parsedURL.port ? parsedURL.host : parsedURL.hostname + (parsedURL.protocol === "https:" ? ":443" : ":80");
    }
    var MockSocket = class extends EventEmitter {
      constructor(remoteAddress) {
        super();
        this.remoteAddress = remoteAddress;
      }
    };
    function CustomRequest(options) {
      return new _CustomLMRRequest(this);
      function _CustomLMRRequest(obj) {
        Request.call(obj, {
          ...options,
          Request: void 0
        });
        Object.assign(this, obj);
        for (const fn of Object.keys(Request.prototype)) {
          this.constructor.prototype[fn] = Request.prototype[fn];
        }
        util.inherits(this.constructor, options.Request);
        return this;
      }
    }
    function Request(options) {
      Readable.call(this, {
        autoDestroy: false
      });
      const parsedURL = parseURL(options.url || options.path, options.query);
      this.url = parsedURL.pathname + parsedURL.search;
      this.aborted = false;
      this.httpVersionMajor = 1;
      this.httpVersionMinor = 1;
      this.httpVersion = "1.1";
      this.method = options.method ? options.method.toUpperCase() : "GET";
      this.headers = {};
      this.rawHeaders = [];
      const headers = options.headers || {};
      for (const field in headers) {
        const fieldLowerCase = field.toLowerCase();
        if ((fieldLowerCase === "user-agent" || fieldLowerCase === "content-type") && headers[field] === void 0) {
          this.headers[fieldLowerCase] = void 0;
          continue;
        }
        const value = headers[field];
        assert(value !== void 0, 'invalid value "undefined" for header ' + field);
        this.headers[fieldLowerCase] = "" + value;
      }
      if ("user-agent" in this.headers === false) {
        this.headers["user-agent"] = "lightMyRequest";
      }
      this.headers.host = this.headers.host || options.authority || hostHeaderFromURL(parsedURL);
      if (options.cookies) {
        const { cookies } = options;
        const cookieValues = Object.keys(cookies).map((key) => cookie.serialize(key, cookies[key]));
        if (this.headers.cookie) {
          cookieValues.unshift(this.headers.cookie);
        }
        this.headers.cookie = cookieValues.join("; ");
      }
      this.socket = new MockSocket(options.remoteAddress || "127.0.0.1");
      Object.defineProperty(this, "connection", {
        get() {
          FST_LIGHTMYREQUEST_DEP01();
          return this.socket;
        },
        configurable: true
      });
      let payload = options.payload || options.body || null;
      let payloadResume = payload && typeof payload.resume === "function";
      if (isFormDataLike(payload)) {
        const stream = formDataToStream(payload);
        payload = stream.stream;
        payloadResume = true;
        this.headers["content-type"] = stream.contentType;
        this.headers["transfer-encoding"] = "chunked";
      }
      if (payload && typeof payload !== "string" && !payloadResume && !Buffer.isBuffer(payload)) {
        payload = JSON.stringify(payload);
        if ("content-type" in this.headers === false) {
          this.headers["content-type"] = "application/json";
        }
      }
      if (payload && !payloadResume && !Object.hasOwn(this.headers, "content-length")) {
        this.headers["content-length"] = (Buffer.isBuffer(payload) ? payload.length : Buffer.byteLength(payload)).toString();
      }
      for (const header of Object.keys(this.headers)) {
        this.rawHeaders.push(header, this.headers[header]);
      }
      this._lightMyRequest = {
        payload,
        isDone: false,
        simulate: options.simulate || {},
        payloadAsStream: options.payloadAsStream,
        signal: options.signal
      };
      const signal = options.signal;
      if (signal) {
        addAbortSignal(signal, this);
      }
      {
        const payload2 = this._lightMyRequest.payload;
        if (payload2?._readableState) {
          this._read = readStream;
          payload2.on("error", (err) => {
            this.destroy(err);
          });
          payload2.on("end", () => {
            this.push(null);
          });
        } else {
          this._read = readEverythingElse;
        }
      }
      return this;
    }
    function readStream() {
      const payload = this._lightMyRequest.payload;
      let more = true;
      let pushed = false;
      let chunk;
      while (more && (chunk = payload.read())) {
        pushed = true;
        more = this.push(chunk);
      }
      if (more && !pushed) {
        this._lightMyRequest.payload.once("readable", this._read.bind(this));
      }
    }
    function readEverythingElse() {
      setImmediate(() => {
        if (this._lightMyRequest.isDone) {
          if (this._lightMyRequest.simulate.end !== false) {
            this.push(null);
          }
          return;
        }
        this._lightMyRequest.isDone = true;
        if (this._lightMyRequest.payload) {
          if (this._lightMyRequest.simulate.split) {
            this.push(this._lightMyRequest.payload.slice(0, 1));
            this.push(this._lightMyRequest.payload.slice(1));
          } else {
            this.push(this._lightMyRequest.payload);
          }
        }
        if (this._lightMyRequest.simulate.error) {
          this.emit("error", new Error("Simulated"));
        }
        if (this._lightMyRequest.simulate.close) {
          this.emit("close");
        }
        if (this._lightMyRequest.simulate.end !== false) {
          this.push(null);
        }
      });
    }
    util.inherits(Request, Readable);
    util.inherits(CustomRequest, Request);
    Request.prototype.destroy = function(error) {
      if (this.destroyed || this._lightMyRequest.isDone) return;
      this.destroyed = true;
      if (error) {
        this._error = true;
        process.nextTick(() => this.emit("error", error));
      }
      process.nextTick(() => this.emit("close"));
    };
    module2.exports = Request;
    module2.exports.Request = Request;
    module2.exports.CustomRequest = CustomRequest;
  }
});

// node_modules/set-cookie-parser/lib/set-cookie.js
var require_set_cookie = __commonJS({
  "node_modules/set-cookie-parser/lib/set-cookie.js"(exports2, module2) {
    "use strict";
    var defaultParseOptions = {
      decodeValues: true,
      map: false,
      silent: false
    };
    function isNonEmptyString(str) {
      return typeof str === "string" && !!str.trim();
    }
    function parseString(setCookieValue, options) {
      var parts = setCookieValue.split(";").filter(isNonEmptyString);
      var nameValuePairStr = parts.shift();
      var parsed = parseNameValuePair(nameValuePairStr);
      var name = parsed.name;
      var value = parsed.value;
      options = options ? Object.assign({}, defaultParseOptions, options) : defaultParseOptions;
      try {
        value = options.decodeValues ? decodeURIComponent(value) : value;
      } catch (e) {
        console.error(
          "set-cookie-parser encountered an error while decoding a cookie with value '" + value + "'. Set options.decodeValues to false to disable this feature.",
          e
        );
      }
      var cookie = {
        name,
        value
      };
      parts.forEach(function(part) {
        var sides = part.split("=");
        var key = sides.shift().trimLeft().toLowerCase();
        var value2 = sides.join("=");
        if (key === "expires") {
          cookie.expires = new Date(value2);
        } else if (key === "max-age") {
          cookie.maxAge = parseInt(value2, 10);
        } else if (key === "secure") {
          cookie.secure = true;
        } else if (key === "httponly") {
          cookie.httpOnly = true;
        } else if (key === "samesite") {
          cookie.sameSite = value2;
        } else if (key === "partitioned") {
          cookie.partitioned = true;
        } else {
          cookie[key] = value2;
        }
      });
      return cookie;
    }
    function parseNameValuePair(nameValuePairStr) {
      var name = "";
      var value = "";
      var nameValueArr = nameValuePairStr.split("=");
      if (nameValueArr.length > 1) {
        name = nameValueArr.shift();
        value = nameValueArr.join("=");
      } else {
        value = nameValuePairStr;
      }
      return { name, value };
    }
    function parse(input, options) {
      options = options ? Object.assign({}, defaultParseOptions, options) : defaultParseOptions;
      if (!input) {
        if (!options.map) {
          return [];
        } else {
          return {};
        }
      }
      if (input.headers) {
        if (typeof input.headers.getSetCookie === "function") {
          input = input.headers.getSetCookie();
        } else if (input.headers["set-cookie"]) {
          input = input.headers["set-cookie"];
        } else {
          var sch = input.headers[Object.keys(input.headers).find(function(key) {
            return key.toLowerCase() === "set-cookie";
          })];
          if (!sch && input.headers.cookie && !options.silent) {
            console.warn(
              "Warning: set-cookie-parser appears to have been called on a request object. It is designed to parse Set-Cookie headers from responses, not Cookie headers from requests. Set the option {silent: true} to suppress this warning."
            );
          }
          input = sch;
        }
      }
      if (!Array.isArray(input)) {
        input = [input];
      }
      if (!options.map) {
        return input.filter(isNonEmptyString).map(function(str) {
          return parseString(str, options);
        });
      } else {
        var cookies = {};
        return input.filter(isNonEmptyString).reduce(function(cookies2, str) {
          var cookie = parseString(str, options);
          cookies2[cookie.name] = cookie;
          return cookies2;
        }, cookies);
      }
    }
    function splitCookiesString(cookiesString) {
      if (Array.isArray(cookiesString)) {
        return cookiesString;
      }
      if (typeof cookiesString !== "string") {
        return [];
      }
      var cookiesStrings = [];
      var pos = 0;
      var start;
      var ch2;
      var lastComma;
      var nextStart;
      var cookiesSeparatorFound;
      function skipWhitespace() {
        while (pos < cookiesString.length && /\s/.test(cookiesString.charAt(pos))) {
          pos += 1;
        }
        return pos < cookiesString.length;
      }
      function notSpecialChar() {
        ch2 = cookiesString.charAt(pos);
        return ch2 !== "=" && ch2 !== ";" && ch2 !== ",";
      }
      while (pos < cookiesString.length) {
        start = pos;
        cookiesSeparatorFound = false;
        while (skipWhitespace()) {
          ch2 = cookiesString.charAt(pos);
          if (ch2 === ",") {
            lastComma = pos;
            pos += 1;
            skipWhitespace();
            nextStart = pos;
            while (pos < cookiesString.length && notSpecialChar()) {
              pos += 1;
            }
            if (pos < cookiesString.length && cookiesString.charAt(pos) === "=") {
              cookiesSeparatorFound = true;
              pos = nextStart;
              cookiesStrings.push(cookiesString.substring(start, lastComma));
              start = pos;
            } else {
              pos = lastComma + 1;
            }
          } else {
            pos += 1;
          }
        }
        if (!cookiesSeparatorFound || pos >= cookiesString.length) {
          cookiesStrings.push(cookiesString.substring(start, cookiesString.length));
        }
      }
      return cookiesStrings;
    }
    module2.exports = parse;
    module2.exports.parse = parse;
    module2.exports.parseString = parseString;
    module2.exports.splitCookiesString = splitCookiesString;
  }
});

// node_modules/light-my-request/lib/response.js
var require_response = __commonJS({
  "node_modules/light-my-request/lib/response.js"(exports2, module2) {
    "use strict";
    var http = require("node:http");
    var { Writable, Readable, addAbortSignal } = require("node:stream");
    var util = require("node:util");
    var setCookie = require_set_cookie();
    function Response2(req, onEnd, reject) {
      http.ServerResponse.call(this, req);
      if (req._lightMyRequest?.payloadAsStream) {
        const read = this.emit.bind(this, "drain");
        this._lightMyRequest = { headers: null, trailers: {}, stream: new Readable({ read }) };
        const signal = req._lightMyRequest.signal;
        if (signal) {
          addAbortSignal(signal, this._lightMyRequest.stream);
        }
      } else {
        this._lightMyRequest = { headers: null, trailers: {}, payloadChunks: [] };
      }
      this.setHeader("foo", "bar");
      this.removeHeader("foo");
      this.assignSocket(getNullSocket());
      this._promiseCallback = typeof reject === "function";
      let called = false;
      const onEndSuccess = (payload) => {
        if (called) return;
        called = true;
        if (this._promiseCallback) {
          return process.nextTick(() => onEnd(payload));
        }
        process.nextTick(() => onEnd(null, payload));
      };
      this._lightMyRequest.onEndSuccess = onEndSuccess;
      let finished = false;
      const onEndFailure = (err) => {
        if (called) {
          if (this._lightMyRequest.stream && !finished) {
            if (!err) {
              err = new Error("response destroyed before completion");
              err.code = "LIGHT_ECONNRESET";
            }
            this._lightMyRequest.stream.destroy(err);
            this._lightMyRequest.stream.on("error", () => {
            });
          }
          return;
        }
        called = true;
        if (!err) {
          err = new Error("response destroyed before completion");
          err.code = "LIGHT_ECONNRESET";
        }
        if (this._promiseCallback) {
          return process.nextTick(() => reject(err));
        }
        process.nextTick(() => onEnd(err, null));
      };
      if (this._lightMyRequest.stream) {
        this.once("finish", () => {
          finished = true;
          this._lightMyRequest.stream.push(null);
        });
      } else {
        this.once("finish", () => {
          const res = generatePayload(this);
          res.raw.req = req;
          onEndSuccess(res);
        });
      }
      this.connection.once("error", onEndFailure);
      this.once("error", onEndFailure);
      this.once("close", onEndFailure);
    }
    util.inherits(Response2, http.ServerResponse);
    Response2.prototype.setTimeout = function(msecs, callback) {
      this.timeoutHandle = setTimeout(() => {
        this.emit("timeout");
      }, msecs);
      this.on("timeout", callback);
      return this;
    };
    Response2.prototype.writeHead = function() {
      const result = http.ServerResponse.prototype.writeHead.apply(this, arguments);
      copyHeaders(this);
      if (this._lightMyRequest.stream) {
        this._lightMyRequest.onEndSuccess(generatePayload(this));
      }
      return result;
    };
    Response2.prototype.write = function(data, encoding, callback) {
      if (this.timeoutHandle) {
        clearTimeout(this.timeoutHandle);
      }
      http.ServerResponse.prototype.write.call(this, data, encoding, callback);
      if (this._lightMyRequest.stream) {
        return this._lightMyRequest.stream.push(Buffer.from(data, encoding));
      } else {
        this._lightMyRequest.payloadChunks.push(Buffer.from(data, encoding));
        return true;
      }
    };
    Response2.prototype.end = function(data, encoding, callback) {
      if (data) {
        this.write(data, encoding);
      }
      http.ServerResponse.prototype.end.call(this, callback);
      this.emit("finish");
      this.destroy();
    };
    Response2.prototype.destroy = function(error) {
      if (this.destroyed) return;
      this.destroyed = true;
      if (error) {
        process.nextTick(() => this.emit("error", error));
      }
      process.nextTick(() => this.emit("close"));
    };
    Response2.prototype.addTrailers = function(trailers) {
      for (const key in trailers) {
        this._lightMyRequest.trailers[key.toLowerCase().trim()] = trailers[key].toString().trim();
      }
    };
    function generatePayload(response) {
      if (response._lightMyRequest.headers === null) {
        copyHeaders(response);
      }
      serializeHeaders(response);
      const res = {
        raw: {
          res: response
        },
        headers: response._lightMyRequest.headers,
        statusCode: response.statusCode,
        statusMessage: response.statusMessage,
        trailers: {},
        get cookies() {
          return setCookie.parse(this);
        }
      };
      res.trailers = response._lightMyRequest.trailers;
      if (response._lightMyRequest.payloadChunks) {
        const rawBuffer = Buffer.concat(response._lightMyRequest.payloadChunks);
        res.rawPayload = rawBuffer;
        res.payload = rawBuffer.toString();
        res.body = res.payload;
        res.json = function parseJsonPayload() {
          return JSON.parse(res.payload);
        };
      } else {
        res.json = function() {
          throw new Error("Response payload is not available with payloadAsStream: true");
        };
      }
      res.stream = function streamPayload() {
        if (response._lightMyRequest.stream) {
          return response._lightMyRequest.stream;
        }
        return Readable.from(response._lightMyRequest.payloadChunks);
      };
      return res;
    }
    function getNullSocket() {
      return new Writable({
        write(_chunk, _encoding, callback) {
          setImmediate(callback);
        }
      });
    }
    function serializeHeaders(response) {
      const headers = response._lightMyRequest.headers;
      for (const headerName of Object.keys(headers)) {
        const headerValue = headers[headerName];
        if (Array.isArray(headerValue)) {
          headers[headerName] = headerValue.map((value) => "" + value);
        } else {
          headers[headerName] = "" + headerValue;
        }
      }
    }
    function copyHeaders(response) {
      response._lightMyRequest.headers = Object.assign({}, response.getHeaders());
      ["Date", "Connection", "Transfer-Encoding"].forEach((name) => {
        const regex = new RegExp("\\r\\n" + name + ": ([^\\r]*)\\r\\n");
        const field = response._header?.match(regex);
        if (field) {
          response._lightMyRequest.headers[name.toLowerCase()] = field[1];
        }
      });
    }
    module2.exports = Response2;
  }
});

// node_modules/light-my-request/lib/config-validator.js
var require_config_validator = __commonJS({
  "node_modules/light-my-request/lib/config-validator.js"(exports2, module2) {
    "use strict";
    module2.exports = validate10;
    module2.exports.default = validate10;
    var schema11 = { "type": "object", "properties": { "url": { "oneOf": [{ "type": "string" }, { "type": "object", "properties": { "protocol": { "type": "string" }, "hostname": { "type": "string" }, "pathname": { "type": "string" } }, "additionalProperties": true, "required": ["pathname"] }] }, "path": { "oneOf": [{ "type": "string" }, { "type": "object", "properties": { "protocol": { "type": "string" }, "hostname": { "type": "string" }, "pathname": { "type": "string" } }, "additionalProperties": true, "required": ["pathname"] }] }, "cookies": { "type": "object", "additionalProperties": true }, "headers": { "type": "object", "additionalProperties": true }, "query": { "anyOf": [{ "type": "object", "additionalProperties": true }, { "type": "string" }] }, "simulate": { "type": "object", "properties": { "end": { "type": "boolean" }, "split": { "type": "boolean" }, "error": { "type": "boolean" }, "close": { "type": "boolean" } } }, "authority": { "type": "string" }, "remoteAddress": { "type": "string" }, "method": { "type": "string", "enum": ["ACL", "BIND", "CHECKOUT", "CONNECT", "COPY", "DELETE", "GET", "HEAD", "LINK", "LOCK", "M-SEARCH", "MERGE", "MKACTIVITY", "MKCALENDAR", "MKCOL", "MOVE", "NOTIFY", "OPTIONS", "PATCH", "POST", "PROPFIND", "PROPPATCH", "PURGE", "PUT", "QUERY", "REBIND", "REPORT", "SEARCH", "SOURCE", "SUBSCRIBE", "TRACE", "UNBIND", "UNLINK", "UNLOCK", "UNSUBSCRIBE", "acl", "bind", "checkout", "connect", "copy", "delete", "get", "head", "link", "lock", "m-search", "merge", "mkactivity", "mkcalendar", "mkcol", "move", "notify", "options", "patch", "post", "propfind", "proppatch", "purge", "put", "query", "rebind", "report", "search", "source", "subscribe", "trace", "unbind", "unlink", "unlock", "unsubscribe"] }, "validate": { "type": "boolean" } }, "additionalProperties": true, "oneOf": [{ "required": ["url"] }, { "required": ["path"] }] };
    function validate10(data, { instancePath = "", parentData, parentDataProperty, rootData = data } = {}) {
      let vErrors = null;
      let errors = 0;
      const _errs1 = errors;
      let valid0 = false;
      let passing0 = null;
      const _errs2 = errors;
      if (data && typeof data == "object" && !Array.isArray(data)) {
        let missing0;
        if (data.url === void 0 && (missing0 = "url")) {
          const err0 = { instancePath, schemaPath: "#/oneOf/0/required", keyword: "required", params: { missingProperty: missing0 }, message: "must have required property '" + missing0 + "'" };
          if (vErrors === null) {
            vErrors = [err0];
          } else {
            vErrors.push(err0);
          }
          errors++;
        }
      }
      var _valid0 = _errs2 === errors;
      if (_valid0) {
        valid0 = true;
        passing0 = 0;
      }
      const _errs3 = errors;
      if (data && typeof data == "object" && !Array.isArray(data)) {
        let missing1;
        if (data.path === void 0 && (missing1 = "path")) {
          const err1 = { instancePath, schemaPath: "#/oneOf/1/required", keyword: "required", params: { missingProperty: missing1 }, message: "must have required property '" + missing1 + "'" };
          if (vErrors === null) {
            vErrors = [err1];
          } else {
            vErrors.push(err1);
          }
          errors++;
        }
      }
      var _valid0 = _errs3 === errors;
      if (_valid0 && valid0) {
        valid0 = false;
        passing0 = [passing0, 1];
      } else {
        if (_valid0) {
          valid0 = true;
          passing0 = 1;
        }
      }
      if (!valid0) {
        const err2 = { instancePath, schemaPath: "#/oneOf", keyword: "oneOf", params: { passingSchemas: passing0 }, message: "must match exactly one schema in oneOf" };
        if (vErrors === null) {
          vErrors = [err2];
        } else {
          vErrors.push(err2);
        }
        errors++;
        validate10.errors = vErrors;
        return false;
      } else {
        errors = _errs1;
        if (vErrors !== null) {
          if (_errs1) {
            vErrors.length = _errs1;
          } else {
            vErrors = null;
          }
        }
      }
      if (errors === 0) {
        if (data && typeof data == "object" && !Array.isArray(data)) {
          if (data.url !== void 0) {
            let data0 = data.url;
            const _errs5 = errors;
            const _errs6 = errors;
            let valid2 = false;
            let passing1 = null;
            const _errs7 = errors;
            if (typeof data0 !== "string") {
              let dataType0 = typeof data0;
              let coerced0 = void 0;
              if (!(coerced0 !== void 0)) {
                if (dataType0 == "number" || dataType0 == "boolean") {
                  coerced0 = "" + data0;
                } else if (data0 === null) {
                  coerced0 = "";
                } else {
                  const err3 = { instancePath: instancePath + "/url", schemaPath: "#/properties/url/oneOf/0/type", keyword: "type", params: { type: "string" }, message: "must be string" };
                  if (vErrors === null) {
                    vErrors = [err3];
                  } else {
                    vErrors.push(err3);
                  }
                  errors++;
                }
              }
              if (coerced0 !== void 0) {
                data0 = coerced0;
                if (data !== void 0) {
                  data["url"] = coerced0;
                }
              }
            }
            var _valid1 = _errs7 === errors;
            if (_valid1) {
              valid2 = true;
              passing1 = 0;
            }
            const _errs9 = errors;
            if (errors === _errs9) {
              if (data0 && typeof data0 == "object" && !Array.isArray(data0)) {
                let missing2;
                if (data0.pathname === void 0 && (missing2 = "pathname")) {
                  const err4 = { instancePath: instancePath + "/url", schemaPath: "#/properties/url/oneOf/1/required", keyword: "required", params: { missingProperty: missing2 }, message: "must have required property '" + missing2 + "'" };
                  if (vErrors === null) {
                    vErrors = [err4];
                  } else {
                    vErrors.push(err4);
                  }
                  errors++;
                } else {
                  if (data0.protocol !== void 0) {
                    let data1 = data0.protocol;
                    const _errs12 = errors;
                    if (typeof data1 !== "string") {
                      let dataType1 = typeof data1;
                      let coerced1 = void 0;
                      if (!(coerced1 !== void 0)) {
                        if (dataType1 == "number" || dataType1 == "boolean") {
                          coerced1 = "" + data1;
                        } else if (data1 === null) {
                          coerced1 = "";
                        } else {
                          const err5 = { instancePath: instancePath + "/url/protocol", schemaPath: "#/properties/url/oneOf/1/properties/protocol/type", keyword: "type", params: { type: "string" }, message: "must be string" };
                          if (vErrors === null) {
                            vErrors = [err5];
                          } else {
                            vErrors.push(err5);
                          }
                          errors++;
                        }
                      }
                      if (coerced1 !== void 0) {
                        data1 = coerced1;
                        if (data0 !== void 0) {
                          data0["protocol"] = coerced1;
                        }
                      }
                    }
                    var valid3 = _errs12 === errors;
                  } else {
                    var valid3 = true;
                  }
                  if (valid3) {
                    if (data0.hostname !== void 0) {
                      let data2 = data0.hostname;
                      const _errs14 = errors;
                      if (typeof data2 !== "string") {
                        let dataType2 = typeof data2;
                        let coerced2 = void 0;
                        if (!(coerced2 !== void 0)) {
                          if (dataType2 == "number" || dataType2 == "boolean") {
                            coerced2 = "" + data2;
                          } else if (data2 === null) {
                            coerced2 = "";
                          } else {
                            const err6 = { instancePath: instancePath + "/url/hostname", schemaPath: "#/properties/url/oneOf/1/properties/hostname/type", keyword: "type", params: { type: "string" }, message: "must be string" };
                            if (vErrors === null) {
                              vErrors = [err6];
                            } else {
                              vErrors.push(err6);
                            }
                            errors++;
                          }
                        }
                        if (coerced2 !== void 0) {
                          data2 = coerced2;
                          if (data0 !== void 0) {
                            data0["hostname"] = coerced2;
                          }
                        }
                      }
                      var valid3 = _errs14 === errors;
                    } else {
                      var valid3 = true;
                    }
                    if (valid3) {
                      if (data0.pathname !== void 0) {
                        let data3 = data0.pathname;
                        const _errs16 = errors;
                        if (typeof data3 !== "string") {
                          let dataType3 = typeof data3;
                          let coerced3 = void 0;
                          if (!(coerced3 !== void 0)) {
                            if (dataType3 == "number" || dataType3 == "boolean") {
                              coerced3 = "" + data3;
                            } else if (data3 === null) {
                              coerced3 = "";
                            } else {
                              const err7 = { instancePath: instancePath + "/url/pathname", schemaPath: "#/properties/url/oneOf/1/properties/pathname/type", keyword: "type", params: { type: "string" }, message: "must be string" };
                              if (vErrors === null) {
                                vErrors = [err7];
                              } else {
                                vErrors.push(err7);
                              }
                              errors++;
                            }
                          }
                          if (coerced3 !== void 0) {
                            data3 = coerced3;
                            if (data0 !== void 0) {
                              data0["pathname"] = coerced3;
                            }
                          }
                        }
                        var valid3 = _errs16 === errors;
                      } else {
                        var valid3 = true;
                      }
                    }
                  }
                }
              } else {
                const err8 = { instancePath: instancePath + "/url", schemaPath: "#/properties/url/oneOf/1/type", keyword: "type", params: { type: "object" }, message: "must be object" };
                if (vErrors === null) {
                  vErrors = [err8];
                } else {
                  vErrors.push(err8);
                }
                errors++;
              }
            }
            var _valid1 = _errs9 === errors;
            if (_valid1 && valid2) {
              valid2 = false;
              passing1 = [passing1, 1];
            } else {
              if (_valid1) {
                valid2 = true;
                passing1 = 1;
              }
            }
            if (!valid2) {
              const err9 = { instancePath: instancePath + "/url", schemaPath: "#/properties/url/oneOf", keyword: "oneOf", params: { passingSchemas: passing1 }, message: "must match exactly one schema in oneOf" };
              if (vErrors === null) {
                vErrors = [err9];
              } else {
                vErrors.push(err9);
              }
              errors++;
              validate10.errors = vErrors;
              return false;
            } else {
              errors = _errs6;
              if (vErrors !== null) {
                if (_errs6) {
                  vErrors.length = _errs6;
                } else {
                  vErrors = null;
                }
              }
            }
            var valid1 = _errs5 === errors;
          } else {
            var valid1 = true;
          }
          if (valid1) {
            if (data.path !== void 0) {
              let data4 = data.path;
              const _errs18 = errors;
              const _errs19 = errors;
              let valid4 = false;
              let passing2 = null;
              const _errs20 = errors;
              if (typeof data4 !== "string") {
                let dataType4 = typeof data4;
                let coerced4 = void 0;
                if (!(coerced4 !== void 0)) {
                  if (dataType4 == "number" || dataType4 == "boolean") {
                    coerced4 = "" + data4;
                  } else if (data4 === null) {
                    coerced4 = "";
                  } else {
                    const err10 = { instancePath: instancePath + "/path", schemaPath: "#/properties/path/oneOf/0/type", keyword: "type", params: { type: "string" }, message: "must be string" };
                    if (vErrors === null) {
                      vErrors = [err10];
                    } else {
                      vErrors.push(err10);
                    }
                    errors++;
                  }
                }
                if (coerced4 !== void 0) {
                  data4 = coerced4;
                  if (data !== void 0) {
                    data["path"] = coerced4;
                  }
                }
              }
              var _valid2 = _errs20 === errors;
              if (_valid2) {
                valid4 = true;
                passing2 = 0;
              }
              const _errs22 = errors;
              if (errors === _errs22) {
                if (data4 && typeof data4 == "object" && !Array.isArray(data4)) {
                  let missing3;
                  if (data4.pathname === void 0 && (missing3 = "pathname")) {
                    const err11 = { instancePath: instancePath + "/path", schemaPath: "#/properties/path/oneOf/1/required", keyword: "required", params: { missingProperty: missing3 }, message: "must have required property '" + missing3 + "'" };
                    if (vErrors === null) {
                      vErrors = [err11];
                    } else {
                      vErrors.push(err11);
                    }
                    errors++;
                  } else {
                    if (data4.protocol !== void 0) {
                      let data5 = data4.protocol;
                      const _errs25 = errors;
                      if (typeof data5 !== "string") {
                        let dataType5 = typeof data5;
                        let coerced5 = void 0;
                        if (!(coerced5 !== void 0)) {
                          if (dataType5 == "number" || dataType5 == "boolean") {
                            coerced5 = "" + data5;
                          } else if (data5 === null) {
                            coerced5 = "";
                          } else {
                            const err12 = { instancePath: instancePath + "/path/protocol", schemaPath: "#/properties/path/oneOf/1/properties/protocol/type", keyword: "type", params: { type: "string" }, message: "must be string" };
                            if (vErrors === null) {
                              vErrors = [err12];
                            } else {
                              vErrors.push(err12);
                            }
                            errors++;
                          }
                        }
                        if (coerced5 !== void 0) {
                          data5 = coerced5;
                          if (data4 !== void 0) {
                            data4["protocol"] = coerced5;
                          }
                        }
                      }
                      var valid5 = _errs25 === errors;
                    } else {
                      var valid5 = true;
                    }
                    if (valid5) {
                      if (data4.hostname !== void 0) {
                        let data6 = data4.hostname;
                        const _errs27 = errors;
                        if (typeof data6 !== "string") {
                          let dataType6 = typeof data6;
                          let coerced6 = void 0;
                          if (!(coerced6 !== void 0)) {
                            if (dataType6 == "number" || dataType6 == "boolean") {
                              coerced6 = "" + data6;
                            } else if (data6 === null) {
                              coerced6 = "";
                            } else {
                              const err13 = { instancePath: instancePath + "/path/hostname", schemaPath: "#/properties/path/oneOf/1/properties/hostname/type", keyword: "type", params: { type: "string" }, message: "must be string" };
                              if (vErrors === null) {
                                vErrors = [err13];
                              } else {
                                vErrors.push(err13);
                              }
                              errors++;
                            }
                          }
                          if (coerced6 !== void 0) {
                            data6 = coerced6;
                            if (data4 !== void 0) {
                              data4["hostname"] = coerced6;
                            }
                          }
                        }
                        var valid5 = _errs27 === errors;
                      } else {
                        var valid5 = true;
                      }
                      if (valid5) {
                        if (data4.pathname !== void 0) {
                          let data7 = data4.pathname;
                          const _errs29 = errors;
                          if (typeof data7 !== "string") {
                            let dataType7 = typeof data7;
                            let coerced7 = void 0;
                            if (!(coerced7 !== void 0)) {
                              if (dataType7 == "number" || dataType7 == "boolean") {
                                coerced7 = "" + data7;
                              } else if (data7 === null) {
                                coerced7 = "";
                              } else {
                                const err14 = { instancePath: instancePath + "/path/pathname", schemaPath: "#/properties/path/oneOf/1/properties/pathname/type", keyword: "type", params: { type: "string" }, message: "must be string" };
                                if (vErrors === null) {
                                  vErrors = [err14];
                                } else {
                                  vErrors.push(err14);
                                }
                                errors++;
                              }
                            }
                            if (coerced7 !== void 0) {
                              data7 = coerced7;
                              if (data4 !== void 0) {
                                data4["pathname"] = coerced7;
                              }
                            }
                          }
                          var valid5 = _errs29 === errors;
                        } else {
                          var valid5 = true;
                        }
                      }
                    }
                  }
                } else {
                  const err15 = { instancePath: instancePath + "/path", schemaPath: "#/properties/path/oneOf/1/type", keyword: "type", params: { type: "object" }, message: "must be object" };
                  if (vErrors === null) {
                    vErrors = [err15];
                  } else {
                    vErrors.push(err15);
                  }
                  errors++;
                }
              }
              var _valid2 = _errs22 === errors;
              if (_valid2 && valid4) {
                valid4 = false;
                passing2 = [passing2, 1];
              } else {
                if (_valid2) {
                  valid4 = true;
                  passing2 = 1;
                }
              }
              if (!valid4) {
                const err16 = { instancePath: instancePath + "/path", schemaPath: "#/properties/path/oneOf", keyword: "oneOf", params: { passingSchemas: passing2 }, message: "must match exactly one schema in oneOf" };
                if (vErrors === null) {
                  vErrors = [err16];
                } else {
                  vErrors.push(err16);
                }
                errors++;
                validate10.errors = vErrors;
                return false;
              } else {
                errors = _errs19;
                if (vErrors !== null) {
                  if (_errs19) {
                    vErrors.length = _errs19;
                  } else {
                    vErrors = null;
                  }
                }
              }
              var valid1 = _errs18 === errors;
            } else {
              var valid1 = true;
            }
            if (valid1) {
              if (data.cookies !== void 0) {
                let data8 = data.cookies;
                const _errs31 = errors;
                if (errors === _errs31) {
                  if (!(data8 && typeof data8 == "object" && !Array.isArray(data8))) {
                    validate10.errors = [{ instancePath: instancePath + "/cookies", schemaPath: "#/properties/cookies/type", keyword: "type", params: { type: "object" }, message: "must be object" }];
                    return false;
                  }
                }
                var valid1 = _errs31 === errors;
              } else {
                var valid1 = true;
              }
              if (valid1) {
                if (data.headers !== void 0) {
                  let data9 = data.headers;
                  const _errs34 = errors;
                  if (errors === _errs34) {
                    if (!(data9 && typeof data9 == "object" && !Array.isArray(data9))) {
                      validate10.errors = [{ instancePath: instancePath + "/headers", schemaPath: "#/properties/headers/type", keyword: "type", params: { type: "object" }, message: "must be object" }];
                      return false;
                    }
                  }
                  var valid1 = _errs34 === errors;
                } else {
                  var valid1 = true;
                }
                if (valid1) {
                  if (data.query !== void 0) {
                    let data10 = data.query;
                    const _errs37 = errors;
                    const _errs38 = errors;
                    let valid6 = false;
                    const _errs39 = errors;
                    if (errors === _errs39) {
                      if (!(data10 && typeof data10 == "object" && !Array.isArray(data10))) {
                        const err17 = { instancePath: instancePath + "/query", schemaPath: "#/properties/query/anyOf/0/type", keyword: "type", params: { type: "object" }, message: "must be object" };
                        if (vErrors === null) {
                          vErrors = [err17];
                        } else {
                          vErrors.push(err17);
                        }
                        errors++;
                      }
                    }
                    var _valid3 = _errs39 === errors;
                    valid6 = valid6 || _valid3;
                    if (!valid6) {
                      const _errs42 = errors;
                      if (typeof data10 !== "string") {
                        let dataType8 = typeof data10;
                        let coerced8 = void 0;
                        if (!(coerced8 !== void 0)) {
                          if (dataType8 == "number" || dataType8 == "boolean") {
                            coerced8 = "" + data10;
                          } else if (data10 === null) {
                            coerced8 = "";
                          } else {
                            const err18 = { instancePath: instancePath + "/query", schemaPath: "#/properties/query/anyOf/1/type", keyword: "type", params: { type: "string" }, message: "must be string" };
                            if (vErrors === null) {
                              vErrors = [err18];
                            } else {
                              vErrors.push(err18);
                            }
                            errors++;
                          }
                        }
                        if (coerced8 !== void 0) {
                          data10 = coerced8;
                          if (data !== void 0) {
                            data["query"] = coerced8;
                          }
                        }
                      }
                      var _valid3 = _errs42 === errors;
                      valid6 = valid6 || _valid3;
                    }
                    if (!valid6) {
                      const err19 = { instancePath: instancePath + "/query", schemaPath: "#/properties/query/anyOf", keyword: "anyOf", params: {}, message: "must match a schema in anyOf" };
                      if (vErrors === null) {
                        vErrors = [err19];
                      } else {
                        vErrors.push(err19);
                      }
                      errors++;
                      validate10.errors = vErrors;
                      return false;
                    } else {
                      errors = _errs38;
                      if (vErrors !== null) {
                        if (_errs38) {
                          vErrors.length = _errs38;
                        } else {
                          vErrors = null;
                        }
                      }
                    }
                    var valid1 = _errs37 === errors;
                  } else {
                    var valid1 = true;
                  }
                  if (valid1) {
                    if (data.simulate !== void 0) {
                      let data11 = data.simulate;
                      const _errs44 = errors;
                      if (errors === _errs44) {
                        if (data11 && typeof data11 == "object" && !Array.isArray(data11)) {
                          if (data11.end !== void 0) {
                            let data12 = data11.end;
                            const _errs46 = errors;
                            if (typeof data12 !== "boolean") {
                              let coerced9 = void 0;
                              if (!(coerced9 !== void 0)) {
                                if (data12 === "false" || data12 === 0 || data12 === null) {
                                  coerced9 = false;
                                } else if (data12 === "true" || data12 === 1) {
                                  coerced9 = true;
                                } else {
                                  validate10.errors = [{ instancePath: instancePath + "/simulate/end", schemaPath: "#/properties/simulate/properties/end/type", keyword: "type", params: { type: "boolean" }, message: "must be boolean" }];
                                  return false;
                                }
                              }
                              if (coerced9 !== void 0) {
                                data12 = coerced9;
                                if (data11 !== void 0) {
                                  data11["end"] = coerced9;
                                }
                              }
                            }
                            var valid7 = _errs46 === errors;
                          } else {
                            var valid7 = true;
                          }
                          if (valid7) {
                            if (data11.split !== void 0) {
                              let data13 = data11.split;
                              const _errs48 = errors;
                              if (typeof data13 !== "boolean") {
                                let coerced10 = void 0;
                                if (!(coerced10 !== void 0)) {
                                  if (data13 === "false" || data13 === 0 || data13 === null) {
                                    coerced10 = false;
                                  } else if (data13 === "true" || data13 === 1) {
                                    coerced10 = true;
                                  } else {
                                    validate10.errors = [{ instancePath: instancePath + "/simulate/split", schemaPath: "#/properties/simulate/properties/split/type", keyword: "type", params: { type: "boolean" }, message: "must be boolean" }];
                                    return false;
                                  }
                                }
                                if (coerced10 !== void 0) {
                                  data13 = coerced10;
                                  if (data11 !== void 0) {
                                    data11["split"] = coerced10;
                                  }
                                }
                              }
                              var valid7 = _errs48 === errors;
                            } else {
                              var valid7 = true;
                            }
                            if (valid7) {
                              if (data11.error !== void 0) {
                                let data14 = data11.error;
                                const _errs50 = errors;
                                if (typeof data14 !== "boolean") {
                                  let coerced11 = void 0;
                                  if (!(coerced11 !== void 0)) {
                                    if (data14 === "false" || data14 === 0 || data14 === null) {
                                      coerced11 = false;
                                    } else if (data14 === "true" || data14 === 1) {
                                      coerced11 = true;
                                    } else {
                                      validate10.errors = [{ instancePath: instancePath + "/simulate/error", schemaPath: "#/properties/simulate/properties/error/type", keyword: "type", params: { type: "boolean" }, message: "must be boolean" }];
                                      return false;
                                    }
                                  }
                                  if (coerced11 !== void 0) {
                                    data14 = coerced11;
                                    if (data11 !== void 0) {
                                      data11["error"] = coerced11;
                                    }
                                  }
                                }
                                var valid7 = _errs50 === errors;
                              } else {
                                var valid7 = true;
                              }
                              if (valid7) {
                                if (data11.close !== void 0) {
                                  let data15 = data11.close;
                                  const _errs52 = errors;
                                  if (typeof data15 !== "boolean") {
                                    let coerced12 = void 0;
                                    if (!(coerced12 !== void 0)) {
                                      if (data15 === "false" || data15 === 0 || data15 === null) {
                                        coerced12 = false;
                                      } else if (data15 === "true" || data15 === 1) {
                                        coerced12 = true;
                                      } else {
                                        validate10.errors = [{ instancePath: instancePath + "/simulate/close", schemaPath: "#/properties/simulate/properties/close/type", keyword: "type", params: { type: "boolean" }, message: "must be boolean" }];
                                        return false;
                                      }
                                    }
                                    if (coerced12 !== void 0) {
                                      data15 = coerced12;
                                      if (data11 !== void 0) {
                                        data11["close"] = coerced12;
                                      }
                                    }
                                  }
                                  var valid7 = _errs52 === errors;
                                } else {
                                  var valid7 = true;
                                }
                              }
                            }
                          }
                        } else {
                          validate10.errors = [{ instancePath: instancePath + "/simulate", schemaPath: "#/properties/simulate/type", keyword: "type", params: { type: "object" }, message: "must be object" }];
                          return false;
                        }
                      }
                      var valid1 = _errs44 === errors;
                    } else {
                      var valid1 = true;
                    }
                    if (valid1) {
                      if (data.authority !== void 0) {
                        let data16 = data.authority;
                        const _errs54 = errors;
                        if (typeof data16 !== "string") {
                          let dataType13 = typeof data16;
                          let coerced13 = void 0;
                          if (!(coerced13 !== void 0)) {
                            if (dataType13 == "number" || dataType13 == "boolean") {
                              coerced13 = "" + data16;
                            } else if (data16 === null) {
                              coerced13 = "";
                            } else {
                              validate10.errors = [{ instancePath: instancePath + "/authority", schemaPath: "#/properties/authority/type", keyword: "type", params: { type: "string" }, message: "must be string" }];
                              return false;
                            }
                          }
                          if (coerced13 !== void 0) {
                            data16 = coerced13;
                            if (data !== void 0) {
                              data["authority"] = coerced13;
                            }
                          }
                        }
                        var valid1 = _errs54 === errors;
                      } else {
                        var valid1 = true;
                      }
                      if (valid1) {
                        if (data.remoteAddress !== void 0) {
                          let data17 = data.remoteAddress;
                          const _errs56 = errors;
                          if (typeof data17 !== "string") {
                            let dataType14 = typeof data17;
                            let coerced14 = void 0;
                            if (!(coerced14 !== void 0)) {
                              if (dataType14 == "number" || dataType14 == "boolean") {
                                coerced14 = "" + data17;
                              } else if (data17 === null) {
                                coerced14 = "";
                              } else {
                                validate10.errors = [{ instancePath: instancePath + "/remoteAddress", schemaPath: "#/properties/remoteAddress/type", keyword: "type", params: { type: "string" }, message: "must be string" }];
                                return false;
                              }
                            }
                            if (coerced14 !== void 0) {
                              data17 = coerced14;
                              if (data !== void 0) {
                                data["remoteAddress"] = coerced14;
                              }
                            }
                          }
                          var valid1 = _errs56 === errors;
                        } else {
                          var valid1 = true;
                        }
                        if (valid1) {
                          if (data.method !== void 0) {
                            let data18 = data.method;
                            const _errs58 = errors;
                            if (typeof data18 !== "string") {
                              let dataType15 = typeof data18;
                              let coerced15 = void 0;
                              if (!(coerced15 !== void 0)) {
                                if (dataType15 == "number" || dataType15 == "boolean") {
                                  coerced15 = "" + data18;
                                } else if (data18 === null) {
                                  coerced15 = "";
                                } else {
                                  validate10.errors = [{ instancePath: instancePath + "/method", schemaPath: "#/properties/method/type", keyword: "type", params: { type: "string" }, message: "must be string" }];
                                  return false;
                                }
                              }
                              if (coerced15 !== void 0) {
                                data18 = coerced15;
                                if (data !== void 0) {
                                  data["method"] = coerced15;
                                }
                              }
                            }
                            if (!(data18 === "ACL" || data18 === "BIND" || data18 === "CHECKOUT" || data18 === "CONNECT" || data18 === "COPY" || data18 === "DELETE" || data18 === "GET" || data18 === "HEAD" || data18 === "LINK" || data18 === "LOCK" || data18 === "M-SEARCH" || data18 === "MERGE" || data18 === "MKACTIVITY" || data18 === "MKCALENDAR" || data18 === "MKCOL" || data18 === "MOVE" || data18 === "NOTIFY" || data18 === "OPTIONS" || data18 === "PATCH" || data18 === "POST" || data18 === "PROPFIND" || data18 === "PROPPATCH" || data18 === "PURGE" || data18 === "PUT" || data18 === "QUERY" || data18 === "REBIND" || data18 === "REPORT" || data18 === "SEARCH" || data18 === "SOURCE" || data18 === "SUBSCRIBE" || data18 === "TRACE" || data18 === "UNBIND" || data18 === "UNLINK" || data18 === "UNLOCK" || data18 === "UNSUBSCRIBE" || data18 === "acl" || data18 === "bind" || data18 === "checkout" || data18 === "connect" || data18 === "copy" || data18 === "delete" || data18 === "get" || data18 === "head" || data18 === "link" || data18 === "lock" || data18 === "m-search" || data18 === "merge" || data18 === "mkactivity" || data18 === "mkcalendar" || data18 === "mkcol" || data18 === "move" || data18 === "notify" || data18 === "options" || data18 === "patch" || data18 === "post" || data18 === "propfind" || data18 === "proppatch" || data18 === "purge" || data18 === "put" || data18 === "query" || data18 === "rebind" || data18 === "report" || data18 === "search" || data18 === "source" || data18 === "subscribe" || data18 === "trace" || data18 === "unbind" || data18 === "unlink" || data18 === "unlock" || data18 === "unsubscribe")) {
                              validate10.errors = [{ instancePath: instancePath + "/method", schemaPath: "#/properties/method/enum", keyword: "enum", params: { allowedValues: schema11.properties.method.enum }, message: "must be equal to one of the allowed values" }];
                              return false;
                            }
                            var valid1 = _errs58 === errors;
                          } else {
                            var valid1 = true;
                          }
                          if (valid1) {
                            if (data.validate !== void 0) {
                              let data19 = data.validate;
                              const _errs60 = errors;
                              if (typeof data19 !== "boolean") {
                                let coerced16 = void 0;
                                if (!(coerced16 !== void 0)) {
                                  if (data19 === "false" || data19 === 0 || data19 === null) {
                                    coerced16 = false;
                                  } else if (data19 === "true" || data19 === 1) {
                                    coerced16 = true;
                                  } else {
                                    validate10.errors = [{ instancePath: instancePath + "/validate", schemaPath: "#/properties/validate/type", keyword: "type", params: { type: "boolean" }, message: "must be boolean" }];
                                    return false;
                                  }
                                }
                                if (coerced16 !== void 0) {
                                  data19 = coerced16;
                                  if (data !== void 0) {
                                    data["validate"] = coerced16;
                                  }
                                }
                              }
                              var valid1 = _errs60 === errors;
                            } else {
                              var valid1 = true;
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        } else {
          validate10.errors = [{ instancePath, schemaPath: "#/type", keyword: "type", params: { type: "object" }, message: "must be object" }];
          return false;
        }
      }
      validate10.errors = vErrors;
      return errors === 0;
    }
  }
});

// node_modules/light-my-request/index.js
var require_light_my_request = __commonJS({
  "node_modules/light-my-request/index.js"(exports2, module2) {
    "use strict";
    var assert = require("node:assert");
    var Request = require_request2();
    var Response2 = require_response();
    var errorMessage = "The dispatch function has already been invoked";
    var optsValidator = require_config_validator();
    function inject(dispatchFunc, options, callback) {
      if (callback === void 0) {
        return new Chain(dispatchFunc, options);
      } else {
        return doInject(dispatchFunc, options, callback);
      }
    }
    function supportStream1(req, next) {
      const payload = req._lightMyRequest.payload;
      if (!payload || payload._readableState || typeof payload.resume !== "function") {
        return next();
      }
      const chunks = [];
      payload.on("data", (chunk) => chunks.push(Buffer.from(chunk)));
      payload.on("end", () => {
        const payload2 = Buffer.concat(chunks);
        req.headers["content-length"] = req.headers["content-length"] || "" + payload2.length;
        delete req.headers["transfer-encoding"];
        req._lightMyRequest.payload = payload2;
        return next();
      });
      payload.resume();
    }
    function makeRequest(dispatchFunc, server, req, res) {
      req.once("error", function(err) {
        if (this.destroyed) res.destroy(err);
      });
      req.once("close", function() {
        if (this.destroyed && !this._error) {
          res.destroy();
        }
      });
      return supportStream1(req, () => dispatchFunc.call(server, req, res));
    }
    function doInject(dispatchFunc, options, callback) {
      options = typeof options === "string" ? { url: options } : options;
      if (options.validate !== false) {
        assert(typeof dispatchFunc === "function", "dispatchFunc should be a function");
        const isOptionValid = optsValidator(options);
        if (!isOptionValid) {
          throw new Error(optsValidator.errors.map((e) => e.message));
        }
      }
      const server = options.server || {};
      const RequestConstructor = options.Request ? Request.CustomRequest : Request;
      if (dispatchFunc.request && dispatchFunc.request.app === dispatchFunc) {
        Object.setPrototypeOf(Object.getPrototypeOf(dispatchFunc.request), RequestConstructor.prototype);
        Object.setPrototypeOf(Object.getPrototypeOf(dispatchFunc.response), Response2.prototype);
      }
      if (typeof callback === "function") {
        const req = new RequestConstructor(options);
        const res = new Response2(req, callback);
        return makeRequest(dispatchFunc, server, req, res);
      } else {
        return new Promise((resolve, reject) => {
          const req = new RequestConstructor(options);
          const res = new Response2(req, resolve, reject);
          makeRequest(dispatchFunc, server, req, res);
        });
      }
    }
    function Chain(dispatch, option) {
      if (typeof option === "string") {
        this.option = { url: option };
      } else {
        this.option = Object.assign({}, option);
      }
      this.dispatch = dispatch;
      this._hasInvoked = false;
      this._promise = null;
      if (this.option.autoStart !== false) {
        process.nextTick(() => {
          if (!this._hasInvoked) {
            this.end();
          }
        });
      }
    }
    var httpMethods = [
      "delete",
      "get",
      "head",
      "options",
      "patch",
      "post",
      "put",
      "trace"
    ];
    httpMethods.forEach((method) => {
      Chain.prototype[method] = function(url) {
        if (this._hasInvoked === true || this._promise) {
          throw new Error(errorMessage);
        }
        this.option.url = url;
        this.option.method = method.toUpperCase();
        return this;
      };
    });
    var chainMethods = [
      "body",
      "cookies",
      "headers",
      "payload",
      "query"
    ];
    chainMethods.forEach((method) => {
      Chain.prototype[method] = function(value) {
        if (this._hasInvoked === true || this._promise) {
          throw new Error(errorMessage);
        }
        this.option[method] = value;
        return this;
      };
    });
    Chain.prototype.end = function(callback) {
      if (this._hasInvoked === true || this._promise) {
        throw new Error(errorMessage);
      }
      this._hasInvoked = true;
      if (typeof callback === "function") {
        doInject(this.dispatch, this.option, callback);
      } else {
        this._promise = doInject(this.dispatch, this.option);
        return this._promise;
      }
    };
    Object.getOwnPropertyNames(Promise.prototype).forEach((method) => {
      if (method === "constructor") return;
      Chain.prototype[method] = function(...args) {
        if (!this._promise) {
          if (this._hasInvoked === true) {
            throw new Error(errorMessage);
          }
          this._hasInvoked = true;
          this._promise = doInject(this.dispatch, this.option);
        }
        return this._promise[method](...args);
      };
    });
    function isInjection(obj) {
      return obj instanceof Request || obj instanceof Response2 || obj?.constructor?.name === "_CustomLMRRequest";
    }
    module2.exports = inject;
    module2.exports.default = inject;
    module2.exports.inject = inject;
    module2.exports.isInjection = isInjection;
  }
});

// node_modules/fastify/fastify.js
var require_fastify = __commonJS({
  "node_modules/fastify/fastify.js"(exports2, module2) {
    "use strict";
    var VERSION = "5.4.0";
    var Avvio = require_boot();
    var http = require("node:http");
    var diagnostics = require("node:diagnostics_channel");
    var lightMyRequest;
    var {
      kAvvioBoot,
      kChildren,
      kServerBindings,
      kBodyLimit,
      kSupportedHTTPMethods,
      kRoutePrefix,
      kLogLevel,
      kLogSerializers,
      kHooks,
      kSchemaController,
      kRequestAcceptVersion,
      kReplySerializerDefault,
      kContentTypeParser,
      kReply,
      kRequest,
      kFourOhFour,
      kState,
      kOptions,
      kPluginNameChain,
      kSchemaErrorFormatter,
      kErrorHandler,
      kKeepAliveConnections,
      kChildLoggerFactory,
      kGenReqId,
      kErrorHandlerAlreadySet
    } = require_symbols2();
    var { createServer: createServer2 } = require_server();
    var Reply = require_reply();
    var Request = require_request();
    var Context = require_context();
    var decorator = require_decorate();
    var ContentTypeParser = require_contentTypeParser();
    var SchemaController = require_schema_controller();
    var { Hooks, hookRunnerApplication, supportedHooks } = require_hooks();
    var { createChildLogger, defaultChildLoggerFactory, createLogger } = require_logger_factory();
    var pluginUtils = require_pluginUtils();
    var { getGenReqId, reqIdGenFactory } = require_reqIdGenFactory();
    var { buildRouting, validateBodyLimitOption } = require_route();
    var build404 = require_fourOhFour();
    var getSecuredInitialConfig = require_initialConfigValidation();
    var override = require_pluginOverride();
    var noopSet = require_noop_set();
    var {
      appendStackTrace,
      AVVIO_ERRORS_MAP,
      ...errorCodes
    } = require_errors2();
    var { defaultInitOptions } = getSecuredInitialConfig;
    var {
      FST_ERR_ASYNC_CONSTRAINT,
      FST_ERR_BAD_URL,
      FST_ERR_FORCE_CLOSE_CONNECTIONS_IDLE_NOT_AVAILABLE,
      FST_ERR_OPTIONS_NOT_OBJ,
      FST_ERR_QSP_NOT_FN,
      FST_ERR_SCHEMA_CONTROLLER_BUCKET_OPT_NOT_FN,
      FST_ERR_AJV_CUSTOM_OPTIONS_OPT_NOT_OBJ,
      FST_ERR_AJV_CUSTOM_OPTIONS_OPT_NOT_ARR,
      FST_ERR_INSTANCE_ALREADY_LISTENING,
      FST_ERR_REOPENED_CLOSE_SERVER,
      FST_ERR_ROUTE_REWRITE_NOT_STR,
      FST_ERR_SCHEMA_ERROR_FORMATTER_NOT_FN,
      FST_ERR_ERROR_HANDLER_NOT_FN,
      FST_ERR_ERROR_HANDLER_ALREADY_SET,
      FST_ERR_ROUTE_METHOD_INVALID
    } = errorCodes;
    var { buildErrorHandler } = require_error_handler();
    var { FSTWRN004 } = require_warnings();
    var initChannel = diagnostics.channel("fastify.initialization");
    function defaultBuildPrettyMeta(route) {
      const cleanKeys = {};
      const allowedProps = ["errorHandler", "logLevel", "logSerializers"];
      allowedProps.concat(supportedHooks).forEach((k) => {
        cleanKeys[k] = route.store[k];
      });
      return Object.assign({}, cleanKeys);
    }
    function fastify(options) {
      if (options && typeof options !== "object") {
        throw new FST_ERR_OPTIONS_NOT_OBJ();
      } else {
        options = Object.assign({}, options);
      }
      if (options.querystringParser && typeof options.querystringParser !== "function") {
        throw new FST_ERR_QSP_NOT_FN(typeof options.querystringParser);
      }
      if (options.schemaController && options.schemaController.bucket && typeof options.schemaController.bucket !== "function") {
        throw new FST_ERR_SCHEMA_CONTROLLER_BUCKET_OPT_NOT_FN(typeof options.schemaController.bucket);
      }
      validateBodyLimitOption(options.bodyLimit);
      const requestIdHeader = typeof options.requestIdHeader === "string" && options.requestIdHeader.length !== 0 ? options.requestIdHeader.toLowerCase() : options.requestIdHeader === true && "request-id";
      const genReqId = reqIdGenFactory(requestIdHeader, options.genReqId);
      const requestIdLogLabel = options.requestIdLogLabel || "reqId";
      const bodyLimit = options.bodyLimit || defaultInitOptions.bodyLimit;
      const disableRequestLogging = options.disableRequestLogging || false;
      const ajvOptions = Object.assign({
        customOptions: {},
        plugins: []
      }, options.ajv);
      const frameworkErrors = options.frameworkErrors;
      if (!ajvOptions.customOptions || Object.prototype.toString.call(ajvOptions.customOptions) !== "[object Object]") {
        throw new FST_ERR_AJV_CUSTOM_OPTIONS_OPT_NOT_OBJ(typeof ajvOptions.customOptions);
      }
      if (!ajvOptions.plugins || !Array.isArray(ajvOptions.plugins)) {
        throw new FST_ERR_AJV_CUSTOM_OPTIONS_OPT_NOT_ARR(typeof ajvOptions.plugins);
      }
      const { logger, hasLogger } = createLogger(options);
      options.connectionTimeout = options.connectionTimeout || defaultInitOptions.connectionTimeout;
      options.keepAliveTimeout = options.keepAliveTimeout || defaultInitOptions.keepAliveTimeout;
      options.maxRequestsPerSocket = options.maxRequestsPerSocket || defaultInitOptions.maxRequestsPerSocket;
      options.requestTimeout = options.requestTimeout || defaultInitOptions.requestTimeout;
      options.logger = logger;
      options.requestIdHeader = requestIdHeader;
      options.requestIdLogLabel = requestIdLogLabel;
      options.disableRequestLogging = disableRequestLogging;
      options.ajv = ajvOptions;
      options.clientErrorHandler = options.clientErrorHandler || defaultClientErrorHandler;
      options.allowErrorHandlerOverride = options.allowErrorHandlerOverride ?? defaultInitOptions.allowErrorHandlerOverride;
      const initialConfig = getSecuredInitialConfig(options);
      options.exposeHeadRoutes = initialConfig.exposeHeadRoutes;
      const router2 = buildRouting({
        config: {
          defaultRoute,
          onBadUrl,
          constraints: options.constraints,
          ignoreTrailingSlash: options.ignoreTrailingSlash || defaultInitOptions.ignoreTrailingSlash,
          ignoreDuplicateSlashes: options.ignoreDuplicateSlashes || defaultInitOptions.ignoreDuplicateSlashes,
          maxParamLength: options.maxParamLength || defaultInitOptions.maxParamLength,
          caseSensitive: options.caseSensitive,
          allowUnsafeRegex: options.allowUnsafeRegex || defaultInitOptions.allowUnsafeRegex,
          buildPrettyMeta: defaultBuildPrettyMeta,
          querystringParser: options.querystringParser,
          useSemicolonDelimiter: options.useSemicolonDelimiter ?? defaultInitOptions.useSemicolonDelimiter
        }
      });
      const fourOhFour = build404(options);
      const httpHandler = wrapRouting(router2, options);
      options.http2SessionTimeout = initialConfig.http2SessionTimeout;
      const { server, listen } = createServer2(options, httpHandler);
      const serverHasCloseAllConnections = typeof server.closeAllConnections === "function";
      const serverHasCloseIdleConnections = typeof server.closeIdleConnections === "function";
      let forceCloseConnections = options.forceCloseConnections;
      if (forceCloseConnections === "idle" && !serverHasCloseIdleConnections) {
        throw new FST_ERR_FORCE_CLOSE_CONNECTIONS_IDLE_NOT_AVAILABLE();
      } else if (typeof forceCloseConnections !== "boolean") {
        forceCloseConnections = serverHasCloseIdleConnections ? "idle" : false;
      }
      const keepAliveConnections = !serverHasCloseAllConnections && forceCloseConnections === true ? /* @__PURE__ */ new Set() : noopSet();
      const setupResponseListeners = Reply.setupResponseListeners;
      const schemaController = SchemaController.buildSchemaController(null, options.schemaController);
      const fastify2 = {
        // Fastify internals
        [kState]: {
          listening: false,
          closing: false,
          started: false,
          ready: false,
          booting: false,
          readyPromise: null
        },
        [kKeepAliveConnections]: keepAliveConnections,
        [kSupportedHTTPMethods]: {
          bodyless: /* @__PURE__ */ new Set([
            // Standard
            "GET",
            "HEAD",
            "TRACE"
          ]),
          bodywith: /* @__PURE__ */ new Set([
            // Standard
            "DELETE",
            "OPTIONS",
            "PATCH",
            "PUT",
            "POST"
          ])
        },
        [kOptions]: options,
        [kChildren]: [],
        [kServerBindings]: [],
        [kBodyLimit]: bodyLimit,
        [kRoutePrefix]: "",
        [kLogLevel]: "",
        [kLogSerializers]: null,
        [kHooks]: new Hooks(),
        [kSchemaController]: schemaController,
        [kSchemaErrorFormatter]: null,
        [kErrorHandler]: buildErrorHandler(),
        [kErrorHandlerAlreadySet]: false,
        [kChildLoggerFactory]: defaultChildLoggerFactory,
        [kReplySerializerDefault]: null,
        [kContentTypeParser]: new ContentTypeParser(
          bodyLimit,
          options.onProtoPoisoning || defaultInitOptions.onProtoPoisoning,
          options.onConstructorPoisoning || defaultInitOptions.onConstructorPoisoning
        ),
        [kReply]: Reply.buildReply(Reply),
        [kRequest]: Request.buildRequest(Request, options.trustProxy),
        [kFourOhFour]: fourOhFour,
        [pluginUtils.kRegisteredPlugins]: [],
        [kPluginNameChain]: ["fastify"],
        [kAvvioBoot]: null,
        [kGenReqId]: genReqId,
        // routing method
        routing: httpHandler,
        // routes shorthand methods
        delete: function _delete(url, options2, handler) {
          return router2.prepareRoute.call(this, { method: "DELETE", url, options: options2, handler });
        },
        get: function _get(url, options2, handler) {
          return router2.prepareRoute.call(this, { method: "GET", url, options: options2, handler });
        },
        head: function _head(url, options2, handler) {
          return router2.prepareRoute.call(this, { method: "HEAD", url, options: options2, handler });
        },
        trace: function _trace(url, options2, handler) {
          return router2.prepareRoute.call(this, { method: "TRACE", url, options: options2, handler });
        },
        patch: function _patch(url, options2, handler) {
          return router2.prepareRoute.call(this, { method: "PATCH", url, options: options2, handler });
        },
        post: function _post(url, options2, handler) {
          return router2.prepareRoute.call(this, { method: "POST", url, options: options2, handler });
        },
        put: function _put(url, options2, handler) {
          return router2.prepareRoute.call(this, { method: "PUT", url, options: options2, handler });
        },
        options: function _options(url, options2, handler) {
          return router2.prepareRoute.call(this, { method: "OPTIONS", url, options: options2, handler });
        },
        all: function _all(url, options2, handler) {
          return router2.prepareRoute.call(this, { method: this.supportedMethods, url, options: options2, handler });
        },
        // extended route
        route: function _route(options2) {
          return router2.route.call(this, { options: options2 });
        },
        hasRoute: function _route(options2) {
          return router2.hasRoute.call(this, { options: options2 });
        },
        findRoute: function _findRoute(options2) {
          return router2.findRoute(options2);
        },
        // expose logger instance
        log: logger,
        // type provider
        withTypeProvider,
        // hooks
        addHook,
        // schemas
        addSchema,
        getSchema: schemaController.getSchema.bind(schemaController),
        getSchemas: schemaController.getSchemas.bind(schemaController),
        setValidatorCompiler,
        setSerializerCompiler,
        setSchemaController,
        setReplySerializer,
        setSchemaErrorFormatter,
        // set generated request id
        setGenReqId,
        // custom parsers
        addContentTypeParser: ContentTypeParser.helpers.addContentTypeParser,
        hasContentTypeParser: ContentTypeParser.helpers.hasContentTypeParser,
        getDefaultJsonParser: ContentTypeParser.defaultParsers.getDefaultJsonParser,
        defaultTextParser: ContentTypeParser.defaultParsers.defaultTextParser,
        removeContentTypeParser: ContentTypeParser.helpers.removeContentTypeParser,
        removeAllContentTypeParsers: ContentTypeParser.helpers.removeAllContentTypeParsers,
        // Fastify architecture methods (initialized by Avvio)
        register: null,
        after: null,
        ready: null,
        onClose: null,
        close: null,
        printPlugins: null,
        hasPlugin: function(name) {
          return this[pluginUtils.kRegisteredPlugins].includes(name) || this[kPluginNameChain].includes(name);
        },
        // http server
        listen,
        server,
        addresses: function() {
          const binded = this[kServerBindings].map((b) => b.address());
          binded.push(this.server.address());
          return binded.filter((adr) => adr);
        },
        // extend fastify objects
        decorate: decorator.add,
        hasDecorator: decorator.exist,
        decorateReply: decorator.decorateReply,
        decorateRequest: decorator.decorateRequest,
        hasRequestDecorator: decorator.existRequest,
        hasReplyDecorator: decorator.existReply,
        getDecorator: decorator.getInstanceDecorator,
        addHttpMethod,
        // fake http injection
        inject,
        // pretty print of the registered routes
        printRoutes,
        // custom error handling
        setNotFoundHandler,
        setErrorHandler,
        // child logger
        setChildLoggerFactory,
        // Set fastify initial configuration options read-only object
        initialConfig,
        // constraint strategies
        addConstraintStrategy: router2.addConstraintStrategy.bind(router2),
        hasConstraintStrategy: router2.hasConstraintStrategy.bind(router2)
      };
      Object.defineProperties(fastify2, {
        listeningOrigin: {
          get() {
            const address = this.addresses().slice(-1).pop();
            if (typeof address === "string") {
              return address;
            }
            const host = address.family === "IPv6" ? `[${address.address}]` : address.address;
            return `${this[kOptions].https ? "https" : "http"}://${host}:${address.port}`;
          }
        },
        pluginName: {
          configurable: true,
          get() {
            if (this[kPluginNameChain].length > 1) {
              return this[kPluginNameChain].join(" -> ");
            }
            return this[kPluginNameChain][0];
          }
        },
        prefix: {
          configurable: true,
          get() {
            return this[kRoutePrefix];
          }
        },
        validatorCompiler: {
          configurable: true,
          get() {
            return this[kSchemaController].getValidatorCompiler();
          }
        },
        serializerCompiler: {
          configurable: true,
          get() {
            return this[kSchemaController].getSerializerCompiler();
          }
        },
        childLoggerFactory: {
          configurable: true,
          get() {
            return this[kChildLoggerFactory];
          }
        },
        version: {
          configurable: true,
          get() {
            return VERSION;
          }
        },
        errorHandler: {
          configurable: true,
          get() {
            return this[kErrorHandler].func;
          }
        },
        genReqId: {
          configurable: true,
          get() {
            return this[kGenReqId];
          }
        },
        supportedMethods: {
          configurable: false,
          get() {
            return [
              ...this[kSupportedHTTPMethods].bodyless,
              ...this[kSupportedHTTPMethods].bodywith
            ];
          }
        }
      });
      if (options.schemaErrorFormatter) {
        validateSchemaErrorFormatter(options.schemaErrorFormatter);
        fastify2[kSchemaErrorFormatter] = options.schemaErrorFormatter.bind(fastify2);
      }
      const avvioPluginTimeout = Number(options.pluginTimeout);
      const avvio = Avvio(fastify2, {
        autostart: false,
        timeout: isNaN(avvioPluginTimeout) === false ? avvioPluginTimeout : defaultInitOptions.pluginTimeout,
        expose: {
          use: "register"
        }
      });
      avvio.override = override;
      avvio.on("start", () => fastify2[kState].started = true);
      fastify2[kAvvioBoot] = fastify2.ready;
      fastify2.ready = ready;
      fastify2.printPlugins = avvio.prettyPrint.bind(avvio);
      avvio.once("preReady", () => {
        fastify2.onClose((instance, done) => {
          fastify2[kState].closing = true;
          router2.closeRoutes();
          hookRunnerApplication("preClose", fastify2[kAvvioBoot], fastify2, function() {
            if (fastify2[kState].listening) {
              if (forceCloseConnections === "idle") {
                instance.server.closeIdleConnections();
              } else if (serverHasCloseAllConnections && forceCloseConnections) {
                instance.server.closeAllConnections();
              } else if (forceCloseConnections === true) {
                for (const conn of fastify2[kKeepAliveConnections]) {
                  conn.destroy();
                  fastify2[kKeepAliveConnections].delete(conn);
                }
              }
            }
            if (!options.serverFactory || fastify2[kState].listening) {
              instance.server.close(function(err) {
                if (err && err.code !== "ERR_SERVER_NOT_RUNNING") {
                  done(null);
                } else {
                  done();
                }
              });
            } else {
              process.nextTick(done, null);
            }
          });
        });
      });
      const onBadUrlContext = new Context({
        server: fastify2,
        config: {}
      });
      fastify2.setNotFoundHandler();
      fourOhFour.arrange404(fastify2);
      router2.setup(options, {
        avvio,
        fourOhFour,
        logger,
        hasLogger,
        setupResponseListeners,
        throwIfAlreadyStarted,
        keepAliveConnections
      });
      server.on("clientError", options.clientErrorHandler.bind(fastify2));
      if (initChannel.hasSubscribers) {
        initChannel.publish({ fastify: fastify2 });
      }
      if ("asyncDispose" in Symbol) {
        fastify2[Symbol.asyncDispose] = function dispose() {
          return fastify2.close();
        };
      }
      return fastify2;
      function throwIfAlreadyStarted(msg) {
        if (fastify2[kState].started) throw new FST_ERR_INSTANCE_ALREADY_LISTENING(msg);
      }
      function inject(opts, cb) {
        if (lightMyRequest === void 0) {
          lightMyRequest = require_light_my_request();
        }
        if (fastify2[kState].started) {
          if (fastify2[kState].closing) {
            const error = new FST_ERR_REOPENED_CLOSE_SERVER();
            if (cb) {
              cb(error);
              return;
            } else {
              return Promise.reject(error);
            }
          }
          return lightMyRequest(httpHandler, opts, cb);
        }
        if (cb) {
          this.ready((err) => {
            if (err) cb(err, null);
            else lightMyRequest(httpHandler, opts, cb);
          });
        } else {
          return lightMyRequest((req, res) => {
            this.ready(function(err) {
              if (err) {
                res.emit("error", err);
                return;
              }
              httpHandler(req, res);
            });
          }, opts);
        }
      }
      function ready(cb) {
        if (this[kState].readyPromise !== null) {
          if (cb != null) {
            this[kState].readyPromise.then(() => cb(null, fastify2), cb);
            return;
          }
          return this[kState].readyPromise;
        }
        let resolveReady;
        let rejectReady;
        process.nextTick(runHooks);
        this[kState].readyPromise = new Promise(function(resolve, reject) {
          resolveReady = resolve;
          rejectReady = reject;
        });
        if (!cb) {
          return this[kState].readyPromise;
        } else {
          this[kState].readyPromise.then(() => cb(null, fastify2), cb);
        }
        function runHooks() {
          fastify2[kAvvioBoot]((err, done) => {
            if (err || fastify2[kState].started || fastify2[kState].ready || fastify2[kState].booting) {
              manageErr(err);
            } else {
              fastify2[kState].booting = true;
              hookRunnerApplication("onReady", fastify2[kAvvioBoot], fastify2, manageErr);
            }
            done();
          });
        }
        function manageErr(err) {
          err = err != null && AVVIO_ERRORS_MAP[err.code] != null ? appendStackTrace(err, new AVVIO_ERRORS_MAP[err.code](err.message)) : err;
          if (err) {
            return rejectReady(err);
          }
          resolveReady(fastify2);
          fastify2[kState].booting = false;
          fastify2[kState].ready = true;
          fastify2[kState].readyPromise = null;
        }
      }
      function withTypeProvider() {
        return this;
      }
      function addHook(name, fn) {
        throwIfAlreadyStarted('Cannot call "addHook"!');
        if (fn == null) {
          throw new errorCodes.FST_ERR_HOOK_INVALID_HANDLER(name, fn);
        }
        if (name === "onSend" || name === "preSerialization" || name === "onError" || name === "preParsing") {
          if (fn.constructor.name === "AsyncFunction" && fn.length === 4) {
            throw new errorCodes.FST_ERR_HOOK_INVALID_ASYNC_HANDLER();
          }
        } else if (name === "onReady" || name === "onListen") {
          if (fn.constructor.name === "AsyncFunction" && fn.length !== 0) {
            throw new errorCodes.FST_ERR_HOOK_INVALID_ASYNC_HANDLER();
          }
        } else if (name === "onRequestAbort") {
          if (fn.constructor.name === "AsyncFunction" && fn.length !== 1) {
            throw new errorCodes.FST_ERR_HOOK_INVALID_ASYNC_HANDLER();
          }
        } else {
          if (fn.constructor.name === "AsyncFunction" && fn.length === 3) {
            throw new errorCodes.FST_ERR_HOOK_INVALID_ASYNC_HANDLER();
          }
        }
        if (name === "onClose") {
          this.onClose(fn.bind(this));
        } else if (name === "onReady" || name === "onListen" || name === "onRoute") {
          this[kHooks].add(name, fn);
        } else {
          this.after((err, done) => {
            try {
              _addHook.call(this, name, fn);
              done(err);
            } catch (err2) {
              done(err2);
            }
          });
        }
        return this;
        function _addHook(name2, fn2) {
          this[kHooks].add(name2, fn2);
          this[kChildren].forEach((child) => _addHook.call(child, name2, fn2));
        }
      }
      function addSchema(schema) {
        throwIfAlreadyStarted('Cannot call "addSchema"!');
        this[kSchemaController].add(schema);
        this[kChildren].forEach((child) => child.addSchema(schema));
        return this;
      }
      function defaultClientErrorHandler(err, socket) {
        if (err.code === "ECONNRESET" || socket.destroyed) {
          return;
        }
        let body, errorCode, errorStatus, errorLabel;
        if (err.code === "ERR_HTTP_REQUEST_TIMEOUT") {
          errorCode = "408";
          errorStatus = http.STATUS_CODES[errorCode];
          body = `{"error":"${errorStatus}","message":"Client Timeout","statusCode":408}`;
          errorLabel = "timeout";
        } else if (err.code === "HPE_HEADER_OVERFLOW") {
          errorCode = "431";
          errorStatus = http.STATUS_CODES[errorCode];
          body = `{"error":"${errorStatus}","message":"Exceeded maximum allowed HTTP header size","statusCode":431}`;
          errorLabel = "header_overflow";
        } else {
          errorCode = "400";
          errorStatus = http.STATUS_CODES[errorCode];
          body = `{"error":"${errorStatus}","message":"Client Error","statusCode":400}`;
          errorLabel = "error";
        }
        this.log.trace({ err }, `client ${errorLabel}`);
        if (socket.writable) {
          socket.write(`HTTP/1.1 ${errorCode} ${errorStatus}\r
Content-Length: ${body.length}\r
Content-Type: application/json\r
\r
${body}`);
        }
        socket.destroy(err);
      }
      function defaultRoute(req, res) {
        if (req.headers["accept-version"] !== void 0) {
          req.headers[kRequestAcceptVersion] = req.headers["accept-version"];
          req.headers["accept-version"] = void 0;
        }
        fourOhFour.router.lookup(req, res);
      }
      function onBadUrl(path4, req, res) {
        if (frameworkErrors) {
          const id2 = getGenReqId(onBadUrlContext.server, req);
          const childLogger = createChildLogger(onBadUrlContext, logger, req, id2);
          const request = new Request(id2, null, req, null, childLogger, onBadUrlContext);
          const reply = new Reply(res, request, childLogger);
          if (disableRequestLogging === false) {
            childLogger.info({ req: request }, "incoming request");
          }
          return frameworkErrors(new FST_ERR_BAD_URL(path4), request, reply);
        }
        const body = `{"error":"Bad Request","code":"FST_ERR_BAD_URL","message":"'${path4}' is not a valid url component","statusCode":400}`;
        res.writeHead(400, {
          "Content-Type": "application/json",
          "Content-Length": body.length
        });
        res.end(body);
      }
      function buildAsyncConstraintCallback(isAsync, req, res) {
        if (isAsync === false) return void 0;
        return function onAsyncConstraintError(err) {
          if (err) {
            if (frameworkErrors) {
              const id2 = getGenReqId(onBadUrlContext.server, req);
              const childLogger = createChildLogger(onBadUrlContext, logger, req, id2);
              const request = new Request(id2, null, req, null, childLogger, onBadUrlContext);
              const reply = new Reply(res, request, childLogger);
              if (disableRequestLogging === false) {
                childLogger.info({ req: request }, "incoming request");
              }
              return frameworkErrors(new FST_ERR_ASYNC_CONSTRAINT(), request, reply);
            }
            const body = '{"error":"Internal Server Error","message":"Unexpected error from async constraint","statusCode":500}';
            res.writeHead(500, {
              "Content-Type": "application/json",
              "Content-Length": body.length
            });
            res.end(body);
          }
        };
      }
      function setNotFoundHandler(opts, handler) {
        throwIfAlreadyStarted('Cannot call "setNotFoundHandler"!');
        fourOhFour.setNotFoundHandler.call(this, opts, handler, avvio, router2.routeHandler);
        return this;
      }
      function setValidatorCompiler(validatorCompiler) {
        throwIfAlreadyStarted('Cannot call "setValidatorCompiler"!');
        this[kSchemaController].setValidatorCompiler(validatorCompiler);
        return this;
      }
      function setSchemaErrorFormatter(errorFormatter) {
        throwIfAlreadyStarted('Cannot call "setSchemaErrorFormatter"!');
        validateSchemaErrorFormatter(errorFormatter);
        this[kSchemaErrorFormatter] = errorFormatter.bind(this);
        return this;
      }
      function setSerializerCompiler(serializerCompiler) {
        throwIfAlreadyStarted('Cannot call "setSerializerCompiler"!');
        this[kSchemaController].setSerializerCompiler(serializerCompiler);
        return this;
      }
      function setSchemaController(schemaControllerOpts) {
        throwIfAlreadyStarted('Cannot call "setSchemaController"!');
        const old = this[kSchemaController];
        const schemaController2 = SchemaController.buildSchemaController(old, Object.assign({}, old.opts, schemaControllerOpts));
        this[kSchemaController] = schemaController2;
        this.getSchema = schemaController2.getSchema.bind(schemaController2);
        this.getSchemas = schemaController2.getSchemas.bind(schemaController2);
        return this;
      }
      function setReplySerializer(replySerializer) {
        throwIfAlreadyStarted('Cannot call "setReplySerializer"!');
        this[kReplySerializerDefault] = replySerializer;
        return this;
      }
      function setErrorHandler(func) {
        throwIfAlreadyStarted('Cannot call "setErrorHandler"!');
        if (typeof func !== "function") {
          throw new FST_ERR_ERROR_HANDLER_NOT_FN();
        }
        if (!options.allowErrorHandlerOverride && this[kErrorHandlerAlreadySet]) {
          throw new FST_ERR_ERROR_HANDLER_ALREADY_SET();
        } else if (this[kErrorHandlerAlreadySet]) {
          FSTWRN004("To disable this behavior, set 'allowErrorHandlerOverride' to false or ignore this message. For more information, visit: https://fastify.dev/docs/latest/Reference/Server/#allowerrorhandleroverride");
        }
        this[kErrorHandlerAlreadySet] = true;
        this[kErrorHandler] = buildErrorHandler(this[kErrorHandler], func.bind(this));
        return this;
      }
      function setChildLoggerFactory(factory) {
        throwIfAlreadyStarted('Cannot call "setChildLoggerFactory"!');
        this[kChildLoggerFactory] = factory;
        return this;
      }
      function printRoutes(opts = {}) {
        opts.includeMeta = opts.includeHooks ? opts.includeMeta ? supportedHooks.concat(opts.includeMeta) : supportedHooks : opts.includeMeta;
        return router2.printRoutes(opts);
      }
      function wrapRouting(router3, { rewriteUrl, logger: logger2 }) {
        let isAsync;
        return function preRouting(req, res) {
          if (isAsync === void 0) isAsync = router3.isAsyncConstraint();
          if (rewriteUrl) {
            req.originalUrl = req.url;
            const url = rewriteUrl.call(fastify2, req);
            if (typeof url === "string") {
              req.url = url;
            } else {
              const err = new FST_ERR_ROUTE_REWRITE_NOT_STR(req.url, typeof url);
              req.destroy(err);
            }
          }
          router3.routing(req, res, buildAsyncConstraintCallback(isAsync, req, res));
        };
      }
      function setGenReqId(func) {
        throwIfAlreadyStarted('Cannot call "setGenReqId"!');
        this[kGenReqId] = reqIdGenFactory(this[kOptions].requestIdHeader, func);
        return this;
      }
      function addHttpMethod(method, { hasBody = false } = {}) {
        if (typeof method !== "string" || http.METHODS.indexOf(method) === -1) {
          throw new FST_ERR_ROUTE_METHOD_INVALID();
        }
        if (hasBody === true) {
          this[kSupportedHTTPMethods].bodywith.add(method);
          this[kSupportedHTTPMethods].bodyless.delete(method);
        } else {
          this[kSupportedHTTPMethods].bodywith.delete(method);
          this[kSupportedHTTPMethods].bodyless.add(method);
        }
        const _method = method.toLowerCase();
        if (!this.hasDecorator(_method)) {
          this.decorate(_method, function(url, options2, handler) {
            return router2.prepareRoute.call(this, { method, url, options: options2, handler });
          });
        }
        return this;
      }
    }
    function validateSchemaErrorFormatter(schemaErrorFormatter) {
      if (typeof schemaErrorFormatter !== "function") {
        throw new FST_ERR_SCHEMA_ERROR_FORMATTER_NOT_FN(typeof schemaErrorFormatter);
      } else if (schemaErrorFormatter.constructor.name === "AsyncFunction") {
        throw new FST_ERR_SCHEMA_ERROR_FORMATTER_NOT_FN("AsyncFunction");
      }
    }
    module2.exports = fastify;
    module2.exports.errorCodes = errorCodes;
    module2.exports.fastify = fastify;
    module2.exports.default = fastify;
  }
});

// node_modules/fastify-plugin/lib/getPluginName.js
var require_getPluginName = __commonJS({
  "node_modules/fastify-plugin/lib/getPluginName.js"(exports2, module2) {
    "use strict";
    var fpStackTracePattern = /at\s{1}(?:.*\.)?plugin\s{1}.*\n\s*(.*)/;
    var fileNamePattern = /(\w*(\.\w*)*)\..*/;
    module2.exports = function getPluginName(fn) {
      if (fn.name.length > 0) return fn.name;
      const stackTraceLimit = Error.stackTraceLimit;
      Error.stackTraceLimit = 10;
      try {
        throw new Error("anonymous function");
      } catch (e) {
        Error.stackTraceLimit = stackTraceLimit;
        return extractPluginName(e.stack);
      }
    };
    function extractPluginName(stack) {
      const m = stack.match(fpStackTracePattern);
      return m ? m[1].split(/[/\\]/).slice(-1)[0].match(fileNamePattern)[1] : "anonymous";
    }
    module2.exports.extractPluginName = extractPluginName;
  }
});

// node_modules/fastify-plugin/lib/toCamelCase.js
var require_toCamelCase = __commonJS({
  "node_modules/fastify-plugin/lib/toCamelCase.js"(exports2, module2) {
    "use strict";
    module2.exports = function toCamelCase(name) {
      if (name[0] === "@") {
        name = name.slice(1).replace("/", "-");
      }
      return name.replace(/-(.)/g, function(match, g1) {
        return g1.toUpperCase();
      });
    };
  }
});

// node_modules/fastify-plugin/plugin.js
var require_plugin2 = __commonJS({
  "node_modules/fastify-plugin/plugin.js"(exports2, module2) {
    "use strict";
    var getPluginName = require_getPluginName();
    var toCamelCase = require_toCamelCase();
    var count = 0;
    function plugin(fn, options = {}) {
      let autoName = false;
      if (fn.default !== void 0) {
        fn = fn.default;
      }
      if (typeof fn !== "function") {
        throw new TypeError(
          `fastify-plugin expects a function, instead got a '${typeof fn}'`
        );
      }
      if (typeof options === "string") {
        options = {
          fastify: options
        };
      }
      if (typeof options !== "object" || Array.isArray(options) || options === null) {
        throw new TypeError("The options object should be an object");
      }
      if (options.fastify !== void 0 && typeof options.fastify !== "string") {
        throw new TypeError(`fastify-plugin expects a version string, instead got '${typeof options.fastify}'`);
      }
      if (!options.name) {
        autoName = true;
        options.name = getPluginName(fn) + "-auto-" + count++;
      }
      fn[Symbol.for("skip-override")] = options.encapsulate !== true;
      fn[Symbol.for("fastify.display-name")] = options.name;
      fn[Symbol.for("plugin-meta")] = options;
      if (!fn.default) {
        fn.default = fn;
      }
      const camelCase = toCamelCase(options.name);
      if (!autoName && !fn[camelCase]) {
        fn[camelCase] = fn;
      }
      return fn;
    }
    module2.exports = plugin;
    module2.exports.default = plugin;
    module2.exports.fastifyPlugin = plugin;
  }
});

// node_modules/@fastify/cors/vary.js
var require_vary = __commonJS({
  "node_modules/@fastify/cors/vary.js"(exports2, module2) {
    "use strict";
    var { FifoMap: FifoCache } = require_toad_cache();
    var validFieldnameRE = /^[!#$%&'*+\-.^\w`|~]+$/u;
    function validateFieldname(fieldname) {
      if (validFieldnameRE.test(fieldname) === false) {
        throw new TypeError("Fieldname contains invalid characters.");
      }
    }
    function parse(header) {
      header = header.trim().toLowerCase();
      const result = [];
      if (header.length === 0) {
      } else if (header.indexOf(",") === -1) {
        result.push(header);
      } else {
        const il2 = header.length;
        let i = 0;
        let pos = 0;
        let char;
        for (i; i < il2; ++i) {
          char = header[i];
          if (char === " ") {
            pos = i + 1;
          } else if (char === ",") {
            if (pos !== i) {
              result.push(header.slice(pos, i));
            }
            pos = i + 1;
          }
        }
        if (pos !== i) {
          result.push(header.slice(pos, i));
        }
      }
      return result;
    }
    function createAddFieldnameToVary(fieldname) {
      const headerCache = new FifoCache(1e3);
      validateFieldname(fieldname);
      return function(reply) {
        let header = reply.getHeader("Vary");
        if (!header) {
          reply.header("Vary", fieldname);
          return;
        }
        if (header === "*") {
          return;
        }
        if (fieldname === "*") {
          reply.header("Vary", "*");
          return;
        }
        if (Array.isArray(header)) {
          header = header.join(", ");
        }
        if (headerCache.get(header) === void 0) {
          const vals = parse(header);
          if (vals.indexOf("*") !== -1) {
            headerCache.set(header, "*");
          } else if (vals.indexOf(fieldname.toLowerCase()) === -1) {
            headerCache.set(header, header + ", " + fieldname);
          } else {
            headerCache.set(header, null);
          }
        }
        const cached = headerCache.get(header);
        if (cached !== null) {
          reply.header("Vary", cached);
        }
      };
    }
    module2.exports.createAddFieldnameToVary = createAddFieldnameToVary;
    module2.exports.addOriginToVaryHeader = createAddFieldnameToVary("Origin");
    module2.exports.addAccessControlRequestHeadersToVaryHeader = createAddFieldnameToVary("Access-Control-Request-Headers");
    module2.exports.parse = parse;
  }
});

// node_modules/@fastify/cors/index.js
var require_cors = __commonJS({
  "node_modules/@fastify/cors/index.js"(exports2, module2) {
    "use strict";
    var fp = require_plugin2();
    var {
      addAccessControlRequestHeadersToVaryHeader,
      addOriginToVaryHeader
    } = require_vary();
    var defaultOptions = {
      origin: "*",
      methods: "GET,HEAD,POST",
      hook: "onRequest",
      preflightContinue: false,
      optionsSuccessStatus: 204,
      credentials: false,
      exposedHeaders: null,
      allowedHeaders: null,
      maxAge: null,
      preflight: true,
      strictPreflight: true
    };
    var validHooks = [
      "onRequest",
      "preParsing",
      "preValidation",
      "preHandler",
      "preSerialization",
      "onSend"
    ];
    var hookWithPayload = [
      "preSerialization",
      "preParsing",
      "onSend"
    ];
    function validateHook(value, next) {
      if (validHooks.indexOf(value) !== -1) {
        return;
      }
      next(new TypeError("@fastify/cors: Invalid hook option provided."));
    }
    function fastifyCors(fastify, opts, next) {
      fastify.decorateRequest("corsPreflightEnabled", false);
      let hideOptionsRoute = true;
      let logLevel;
      if (typeof opts === "function") {
        handleCorsOptionsDelegator(opts, fastify, { hook: defaultOptions.hook }, next);
      } else if (opts.delegator) {
        const { delegator, ...options } = opts;
        handleCorsOptionsDelegator(delegator, fastify, options, next);
      } else {
        const corsOptions = normalizeCorsOptions(opts);
        validateHook(corsOptions.hook, next);
        if (hookWithPayload.indexOf(corsOptions.hook) !== -1) {
          fastify.addHook(corsOptions.hook, function handleCors(req, reply, _payload, next2) {
            addCorsHeadersHandler(fastify, corsOptions, req, reply, next2);
          });
        } else {
          fastify.addHook(corsOptions.hook, function handleCors(req, reply, next2) {
            addCorsHeadersHandler(fastify, corsOptions, req, reply, next2);
          });
        }
      }
      if (opts.logLevel !== void 0) logLevel = opts.logLevel;
      if (opts.hideOptionsRoute !== void 0) hideOptionsRoute = opts.hideOptionsRoute;
      fastify.options("*", { schema: { hide: hideOptionsRoute }, logLevel }, (req, reply) => {
        if (!req.corsPreflightEnabled) {
          reply.callNotFound();
          return;
        }
        reply.send();
      });
      next();
    }
    function handleCorsOptionsDelegator(optionsResolver, fastify, opts, next) {
      const hook = opts?.hook || defaultOptions.hook;
      validateHook(hook, next);
      if (optionsResolver.length === 2) {
        if (hookWithPayload.indexOf(hook) !== -1) {
          fastify.addHook(hook, function handleCors(req, reply, _payload, next2) {
            handleCorsOptionsCallbackDelegator(optionsResolver, fastify, req, reply, next2);
          });
        } else {
          fastify.addHook(hook, function handleCors(req, reply, next2) {
            handleCorsOptionsCallbackDelegator(optionsResolver, fastify, req, reply, next2);
          });
        }
      } else {
        if (hookWithPayload.indexOf(hook) !== -1) {
          fastify.addHook(hook, function handleCors(req, reply, _payload, next2) {
            const ret = optionsResolver(req);
            if (ret && typeof ret.then === "function") {
              ret.then((options) => addCorsHeadersHandler(fastify, normalizeCorsOptions(options, true), req, reply, next2)).catch(next2);
              return;
            }
            next2(new Error("Invalid CORS origin option"));
          });
        } else {
          fastify.addHook(hook, function handleCors(req, reply, next2) {
            const ret = optionsResolver(req);
            if (ret && typeof ret.then === "function") {
              ret.then((options) => addCorsHeadersHandler(fastify, normalizeCorsOptions(options, true), req, reply, next2)).catch(next2);
              return;
            }
            next2(new Error("Invalid CORS origin option"));
          });
        }
      }
    }
    function handleCorsOptionsCallbackDelegator(optionsResolver, fastify, req, reply, next) {
      optionsResolver(req, (err, options) => {
        if (err) {
          next(err);
        } else {
          addCorsHeadersHandler(fastify, normalizeCorsOptions(options, true), req, reply, next);
        }
      });
    }
    function normalizeCorsOptions(opts, dynamic) {
      const corsOptions = { ...defaultOptions, ...opts };
      if (Array.isArray(opts.origin) && opts.origin.indexOf("*") !== -1) {
        corsOptions.origin = "*";
      }
      if (Number.isInteger(corsOptions.cacheControl)) {
        corsOptions.cacheControl = `max-age=${corsOptions.cacheControl}`;
      } else if (typeof corsOptions.cacheControl !== "string") {
        corsOptions.cacheControl = null;
      }
      corsOptions.dynamic = dynamic || false;
      return corsOptions;
    }
    function addCorsHeadersHandler(fastify, options, req, reply, next) {
      if (typeof options.origin !== "string" && options.origin !== false || options.dynamic) {
        addOriginToVaryHeader(reply);
      }
      const resolveOriginOption = typeof options.origin === "function" ? resolveOriginWrapper(fastify, options.origin) : (_, cb) => cb(null, options.origin);
      resolveOriginOption(req, (error, resolvedOriginOption) => {
        if (error !== null) {
          return next(error);
        }
        if (resolvedOriginOption === false) {
          return next();
        }
        if (req.routeOptions.config?.cors === false) {
          return next();
        }
        if (!resolvedOriginOption) {
          return next(new Error("Invalid CORS origin option"));
        }
        addCorsHeaders(req, reply, resolvedOriginOption, options);
        if (req.raw.method === "OPTIONS" && options.preflight === true) {
          if (options.strictPreflight === true && (!req.headers.origin || !req.headers["access-control-request-method"])) {
            reply.status(400).type("text/plain").send("Invalid Preflight Request");
            return;
          }
          req.corsPreflightEnabled = true;
          addPreflightHeaders(req, reply, options);
          if (!options.preflightContinue) {
            reply.code(options.optionsSuccessStatus).header("Content-Length", "0").send();
            return;
          }
        }
        return next();
      });
    }
    function addCorsHeaders(req, reply, originOption, corsOptions) {
      const origin = getAccessControlAllowOriginHeader(req.headers.origin, originOption);
      if (origin) {
        reply.header("Access-Control-Allow-Origin", origin);
      }
      if (corsOptions.credentials) {
        reply.header("Access-Control-Allow-Credentials", "true");
      }
      if (corsOptions.exposedHeaders !== null) {
        reply.header(
          "Access-Control-Expose-Headers",
          Array.isArray(corsOptions.exposedHeaders) ? corsOptions.exposedHeaders.join(", ") : corsOptions.exposedHeaders
        );
      }
    }
    function addPreflightHeaders(req, reply, corsOptions) {
      reply.header(
        "Access-Control-Allow-Methods",
        Array.isArray(corsOptions.methods) ? corsOptions.methods.join(", ") : corsOptions.methods
      );
      if (corsOptions.allowedHeaders === null) {
        addAccessControlRequestHeadersToVaryHeader(reply);
        const reqAllowedHeaders = req.headers["access-control-request-headers"];
        if (reqAllowedHeaders !== void 0) {
          reply.header("Access-Control-Allow-Headers", reqAllowedHeaders);
        }
      } else {
        reply.header(
          "Access-Control-Allow-Headers",
          Array.isArray(corsOptions.allowedHeaders) ? corsOptions.allowedHeaders.join(", ") : corsOptions.allowedHeaders
        );
      }
      if (corsOptions.maxAge !== null) {
        reply.header("Access-Control-Max-Age", String(corsOptions.maxAge));
      }
      if (corsOptions.cacheControl) {
        reply.header("Cache-Control", corsOptions.cacheControl);
      }
    }
    function resolveOriginWrapper(fastify, origin) {
      return function(req, cb) {
        const result = origin.call(fastify, req.headers.origin, cb);
        if (result && typeof result.then === "function") {
          result.then((res) => cb(null, res), cb);
        }
      };
    }
    function getAccessControlAllowOriginHeader(reqOrigin, originOption) {
      if (typeof originOption === "string") {
        return originOption;
      }
      return isRequestOriginAllowed(reqOrigin, originOption) ? reqOrigin : false;
    }
    function isRequestOriginAllowed(reqOrigin, allowedOrigin) {
      if (Array.isArray(allowedOrigin)) {
        for (let i = 0; i < allowedOrigin.length; ++i) {
          if (isRequestOriginAllowed(reqOrigin, allowedOrigin[i])) {
            return true;
          }
        }
        return false;
      } else if (typeof allowedOrigin === "string") {
        return reqOrigin === allowedOrigin;
      } else if (allowedOrigin instanceof RegExp) {
        allowedOrigin.lastIndex = 0;
        return allowedOrigin.test(reqOrigin);
      } else {
        return !!allowedOrigin;
      }
    }
    var _fastifyCors = fp(fastifyCors, {
      fastify: "5.x",
      name: "@fastify/cors"
    });
    module2.exports = _fastifyCors;
    module2.exports.fastifyCors = _fastifyCors;
    module2.exports.default = _fastifyCors;
  }
});

// node_modules/dotenv/package.json
var require_package2 = __commonJS({
  "node_modules/dotenv/package.json"(exports2, module2) {
    module2.exports = {
      name: "dotenv",
      version: "16.6.1",
      description: "Loads environment variables from .env file",
      main: "lib/main.js",
      types: "lib/main.d.ts",
      exports: {
        ".": {
          types: "./lib/main.d.ts",
          require: "./lib/main.js",
          default: "./lib/main.js"
        },
        "./config": "./config.js",
        "./config.js": "./config.js",
        "./lib/env-options": "./lib/env-options.js",
        "./lib/env-options.js": "./lib/env-options.js",
        "./lib/cli-options": "./lib/cli-options.js",
        "./lib/cli-options.js": "./lib/cli-options.js",
        "./package.json": "./package.json"
      },
      scripts: {
        "dts-check": "tsc --project tests/types/tsconfig.json",
        lint: "standard",
        pretest: "npm run lint && npm run dts-check",
        test: "tap run --allow-empty-coverage --disable-coverage --timeout=60000",
        "test:coverage": "tap run --show-full-coverage --timeout=60000 --coverage-report=text --coverage-report=lcov",
        prerelease: "npm test",
        release: "standard-version"
      },
      repository: {
        type: "git",
        url: "git://github.com/motdotla/dotenv.git"
      },
      homepage: "https://github.com/motdotla/dotenv#readme",
      funding: "https://dotenvx.com",
      keywords: [
        "dotenv",
        "env",
        ".env",
        "environment",
        "variables",
        "config",
        "settings"
      ],
      readmeFilename: "README.md",
      license: "BSD-2-Clause",
      devDependencies: {
        "@types/node": "^18.11.3",
        decache: "^4.6.2",
        sinon: "^14.0.1",
        standard: "^17.0.0",
        "standard-version": "^9.5.0",
        tap: "^19.2.0",
        typescript: "^4.8.4"
      },
      engines: {
        node: ">=12"
      },
      browser: {
        fs: false
      }
    };
  }
});

// node_modules/dotenv/lib/main.js
var require_main = __commonJS({
  "node_modules/dotenv/lib/main.js"(exports2, module2) {
    var fs5 = require("fs");
    var path4 = require("path");
    var os2 = require("os");
    var crypto2 = require("crypto");
    var packageJson = require_package2();
    var version2 = packageJson.version;
    var LINE = /(?:^|^)\s*(?:export\s+)?([\w.-]+)(?:\s*=\s*?|:\s+?)(\s*'(?:\\'|[^'])*'|\s*"(?:\\"|[^"])*"|\s*`(?:\\`|[^`])*`|[^#\r\n]+)?\s*(?:#.*)?(?:$|$)/mg;
    function parse(src) {
      const obj = {};
      let lines = src.toString();
      lines = lines.replace(/\r\n?/mg, "\n");
      let match;
      while ((match = LINE.exec(lines)) != null) {
        const key = match[1];
        let value = match[2] || "";
        value = value.trim();
        const maybeQuote = value[0];
        value = value.replace(/^(['"`])([\s\S]*)\1$/mg, "$2");
        if (maybeQuote === '"') {
          value = value.replace(/\\n/g, "\n");
          value = value.replace(/\\r/g, "\r");
        }
        obj[key] = value;
      }
      return obj;
    }
    function _parseVault(options) {
      options = options || {};
      const vaultPath = _vaultPath(options);
      options.path = vaultPath;
      const result = DotenvModule.configDotenv(options);
      if (!result.parsed) {
        const err = new Error(`MISSING_DATA: Cannot parse ${vaultPath} for an unknown reason`);
        err.code = "MISSING_DATA";
        throw err;
      }
      const keys = _dotenvKey(options).split(",");
      const length = keys.length;
      let decrypted;
      for (let i = 0; i < length; i++) {
        try {
          const key = keys[i].trim();
          const attrs = _instructions(result, key);
          decrypted = DotenvModule.decrypt(attrs.ciphertext, attrs.key);
          break;
        } catch (error) {
          if (i + 1 >= length) {
            throw error;
          }
        }
      }
      return DotenvModule.parse(decrypted);
    }
    function _warn(message) {
      console.log(`[dotenv@${version2}][WARN] ${message}`);
    }
    function _debug(message) {
      console.log(`[dotenv@${version2}][DEBUG] ${message}`);
    }
    function _log(message) {
      console.log(`[dotenv@${version2}] ${message}`);
    }
    function _dotenvKey(options) {
      if (options && options.DOTENV_KEY && options.DOTENV_KEY.length > 0) {
        return options.DOTENV_KEY;
      }
      if (process.env.DOTENV_KEY && process.env.DOTENV_KEY.length > 0) {
        return process.env.DOTENV_KEY;
      }
      return "";
    }
    function _instructions(result, dotenvKey) {
      let uri;
      try {
        uri = new URL(dotenvKey);
      } catch (error) {
        if (error.code === "ERR_INVALID_URL") {
          const err = new Error("INVALID_DOTENV_KEY: Wrong format. Must be in valid uri format like dotenv://:key_1234@dotenvx.com/vault/.env.vault?environment=development");
          err.code = "INVALID_DOTENV_KEY";
          throw err;
        }
        throw error;
      }
      const key = uri.password;
      if (!key) {
        const err = new Error("INVALID_DOTENV_KEY: Missing key part");
        err.code = "INVALID_DOTENV_KEY";
        throw err;
      }
      const environment = uri.searchParams.get("environment");
      if (!environment) {
        const err = new Error("INVALID_DOTENV_KEY: Missing environment part");
        err.code = "INVALID_DOTENV_KEY";
        throw err;
      }
      const environmentKey = `DOTENV_VAULT_${environment.toUpperCase()}`;
      const ciphertext = result.parsed[environmentKey];
      if (!ciphertext) {
        const err = new Error(`NOT_FOUND_DOTENV_ENVIRONMENT: Cannot locate environment ${environmentKey} in your .env.vault file.`);
        err.code = "NOT_FOUND_DOTENV_ENVIRONMENT";
        throw err;
      }
      return { ciphertext, key };
    }
    function _vaultPath(options) {
      let possibleVaultPath = null;
      if (options && options.path && options.path.length > 0) {
        if (Array.isArray(options.path)) {
          for (const filepath of options.path) {
            if (fs5.existsSync(filepath)) {
              possibleVaultPath = filepath.endsWith(".vault") ? filepath : `${filepath}.vault`;
            }
          }
        } else {
          possibleVaultPath = options.path.endsWith(".vault") ? options.path : `${options.path}.vault`;
        }
      } else {
        possibleVaultPath = path4.resolve(process.cwd(), ".env.vault");
      }
      if (fs5.existsSync(possibleVaultPath)) {
        return possibleVaultPath;
      }
      return null;
    }
    function _resolveHome(envPath) {
      return envPath[0] === "~" ? path4.join(os2.homedir(), envPath.slice(1)) : envPath;
    }
    function _configVault(options) {
      const debug = Boolean(options && options.debug);
      const quiet = options && "quiet" in options ? options.quiet : true;
      if (debug || !quiet) {
        _log("Loading env from encrypted .env.vault");
      }
      const parsed = DotenvModule._parseVault(options);
      let processEnv = process.env;
      if (options && options.processEnv != null) {
        processEnv = options.processEnv;
      }
      DotenvModule.populate(processEnv, parsed, options);
      return { parsed };
    }
    function configDotenv(options) {
      const dotenvPath = path4.resolve(process.cwd(), ".env");
      let encoding = "utf8";
      const debug = Boolean(options && options.debug);
      const quiet = options && "quiet" in options ? options.quiet : true;
      if (options && options.encoding) {
        encoding = options.encoding;
      } else {
        if (debug) {
          _debug("No encoding is specified. UTF-8 is used by default");
        }
      }
      let optionPaths = [dotenvPath];
      if (options && options.path) {
        if (!Array.isArray(options.path)) {
          optionPaths = [_resolveHome(options.path)];
        } else {
          optionPaths = [];
          for (const filepath of options.path) {
            optionPaths.push(_resolveHome(filepath));
          }
        }
      }
      let lastError;
      const parsedAll = {};
      for (const path5 of optionPaths) {
        try {
          const parsed = DotenvModule.parse(fs5.readFileSync(path5, { encoding }));
          DotenvModule.populate(parsedAll, parsed, options);
        } catch (e) {
          if (debug) {
            _debug(`Failed to load ${path5} ${e.message}`);
          }
          lastError = e;
        }
      }
      let processEnv = process.env;
      if (options && options.processEnv != null) {
        processEnv = options.processEnv;
      }
      DotenvModule.populate(processEnv, parsedAll, options);
      if (debug || !quiet) {
        const keysCount = Object.keys(parsedAll).length;
        const shortPaths = [];
        for (const filePath of optionPaths) {
          try {
            const relative = path4.relative(process.cwd(), filePath);
            shortPaths.push(relative);
          } catch (e) {
            if (debug) {
              _debug(`Failed to load ${filePath} ${e.message}`);
            }
            lastError = e;
          }
        }
        _log(`injecting env (${keysCount}) from ${shortPaths.join(",")}`);
      }
      if (lastError) {
        return { parsed: parsedAll, error: lastError };
      } else {
        return { parsed: parsedAll };
      }
    }
    function config(options) {
      if (_dotenvKey(options).length === 0) {
        return DotenvModule.configDotenv(options);
      }
      const vaultPath = _vaultPath(options);
      if (!vaultPath) {
        _warn(`You set DOTENV_KEY but you are missing a .env.vault file at ${vaultPath}. Did you forget to build it?`);
        return DotenvModule.configDotenv(options);
      }
      return DotenvModule._configVault(options);
    }
    function decrypt(encrypted, keyStr) {
      const key = Buffer.from(keyStr.slice(-64), "hex");
      let ciphertext = Buffer.from(encrypted, "base64");
      const nonce = ciphertext.subarray(0, 12);
      const authTag = ciphertext.subarray(-16);
      ciphertext = ciphertext.subarray(12, -16);
      try {
        const aesgcm = crypto2.createDecipheriv("aes-256-gcm", key, nonce);
        aesgcm.setAuthTag(authTag);
        return `${aesgcm.update(ciphertext)}${aesgcm.final()}`;
      } catch (error) {
        const isRange = error instanceof RangeError;
        const invalidKeyLength = error.message === "Invalid key length";
        const decryptionFailed = error.message === "Unsupported state or unable to authenticate data";
        if (isRange || invalidKeyLength) {
          const err = new Error("INVALID_DOTENV_KEY: It must be 64 characters long (or more)");
          err.code = "INVALID_DOTENV_KEY";
          throw err;
        } else if (decryptionFailed) {
          const err = new Error("DECRYPTION_FAILED: Please check your DOTENV_KEY");
          err.code = "DECRYPTION_FAILED";
          throw err;
        } else {
          throw error;
        }
      }
    }
    function populate(processEnv, parsed, options = {}) {
      const debug = Boolean(options && options.debug);
      const override = Boolean(options && options.override);
      if (typeof parsed !== "object") {
        const err = new Error("OBJECT_REQUIRED: Please check the processEnv argument being passed to populate");
        err.code = "OBJECT_REQUIRED";
        throw err;
      }
      for (const key of Object.keys(parsed)) {
        if (Object.prototype.hasOwnProperty.call(processEnv, key)) {
          if (override === true) {
            processEnv[key] = parsed[key];
          }
          if (debug) {
            if (override === true) {
              _debug(`"${key}" is already defined and WAS overwritten`);
            } else {
              _debug(`"${key}" is already defined and was NOT overwritten`);
            }
          }
        } else {
          processEnv[key] = parsed[key];
        }
      }
    }
    var DotenvModule = {
      configDotenv,
      _configVault,
      _parseVault,
      config,
      decrypt,
      parse,
      populate
    };
    module2.exports.configDotenv = DotenvModule.configDotenv;
    module2.exports._configVault = DotenvModule._configVault;
    module2.exports._parseVault = DotenvModule._parseVault;
    module2.exports.config = DotenvModule.config;
    module2.exports.decrypt = DotenvModule.decrypt;
    module2.exports.parse = DotenvModule.parse;
    module2.exports.populate = DotenvModule.populate;
    module2.exports = DotenvModule;
  }
});

// node_modules/undici/lib/core/symbols.js
var require_symbols4 = __commonJS({
  "node_modules/undici/lib/core/symbols.js"(exports2, module2) {
    "use strict";
    module2.exports = {
      kClose: Symbol("close"),
      kDestroy: Symbol("destroy"),
      kDispatch: Symbol("dispatch"),
      kUrl: Symbol("url"),
      kWriting: Symbol("writing"),
      kResuming: Symbol("resuming"),
      kQueue: Symbol("queue"),
      kConnect: Symbol("connect"),
      kConnecting: Symbol("connecting"),
      kKeepAliveDefaultTimeout: Symbol("default keep alive timeout"),
      kKeepAliveMaxTimeout: Symbol("max keep alive timeout"),
      kKeepAliveTimeoutThreshold: Symbol("keep alive timeout threshold"),
      kKeepAliveTimeoutValue: Symbol("keep alive timeout"),
      kKeepAlive: Symbol("keep alive"),
      kHeadersTimeout: Symbol("headers timeout"),
      kBodyTimeout: Symbol("body timeout"),
      kServerName: Symbol("server name"),
      kLocalAddress: Symbol("local address"),
      kHost: Symbol("host"),
      kNoRef: Symbol("no ref"),
      kBodyUsed: Symbol("used"),
      kBody: Symbol("abstracted request body"),
      kRunning: Symbol("running"),
      kBlocking: Symbol("blocking"),
      kPending: Symbol("pending"),
      kSize: Symbol("size"),
      kBusy: Symbol("busy"),
      kQueued: Symbol("queued"),
      kFree: Symbol("free"),
      kConnected: Symbol("connected"),
      kClosed: Symbol("closed"),
      kNeedDrain: Symbol("need drain"),
      kReset: Symbol("reset"),
      kDestroyed: Symbol.for("nodejs.stream.destroyed"),
      kResume: Symbol("resume"),
      kOnError: Symbol("on error"),
      kMaxHeadersSize: Symbol("max headers size"),
      kRunningIdx: Symbol("running index"),
      kPendingIdx: Symbol("pending index"),
      kError: Symbol("error"),
      kClients: Symbol("clients"),
      kClient: Symbol("client"),
      kParser: Symbol("parser"),
      kOnDestroyed: Symbol("destroy callbacks"),
      kPipelining: Symbol("pipelining"),
      kSocket: Symbol("socket"),
      kHostHeader: Symbol("host header"),
      kConnector: Symbol("connector"),
      kStrictContentLength: Symbol("strict content length"),
      kMaxRedirections: Symbol("maxRedirections"),
      kMaxRequests: Symbol("maxRequestsPerClient"),
      kProxy: Symbol("proxy agent options"),
      kCounter: Symbol("socket request counter"),
      kMaxResponseSize: Symbol("max response size"),
      kHTTP2Session: Symbol("http2Session"),
      kHTTP2SessionState: Symbol("http2Session state"),
      kRetryHandlerDefaultRetry: Symbol("retry agent default retry"),
      kConstruct: Symbol("constructable"),
      kListeners: Symbol("listeners"),
      kHTTPContext: Symbol("http context"),
      kMaxConcurrentStreams: Symbol("max concurrent streams"),
      kNoProxyAgent: Symbol("no proxy agent"),
      kHttpProxyAgent: Symbol("http proxy agent"),
      kHttpsProxyAgent: Symbol("https proxy agent")
    };
  }
});

// node_modules/undici/lib/util/timers.js
var require_timers = __commonJS({
  "node_modules/undici/lib/util/timers.js"(exports2, module2) {
    "use strict";
    var fastNow = 0;
    var RESOLUTION_MS = 1e3;
    var TICK_MS = (RESOLUTION_MS >> 1) - 1;
    var fastNowTimeout;
    var kFastTimer = Symbol("kFastTimer");
    var fastTimers = [];
    var NOT_IN_LIST = -2;
    var TO_BE_CLEARED = -1;
    var PENDING = 0;
    var ACTIVE = 1;
    function onTick() {
      fastNow += TICK_MS;
      let idx = 0;
      let len = fastTimers.length;
      while (idx < len) {
        const timer = fastTimers[idx];
        if (timer._state === PENDING) {
          timer._idleStart = fastNow - TICK_MS;
          timer._state = ACTIVE;
        } else if (timer._state === ACTIVE && fastNow >= timer._idleStart + timer._idleTimeout) {
          timer._state = TO_BE_CLEARED;
          timer._idleStart = -1;
          timer._onTimeout(timer._timerArg);
        }
        if (timer._state === TO_BE_CLEARED) {
          timer._state = NOT_IN_LIST;
          if (--len !== 0) {
            fastTimers[idx] = fastTimers[len];
          }
        } else {
          ++idx;
        }
      }
      fastTimers.length = len;
      if (fastTimers.length !== 0) {
        refreshTimeout();
      }
    }
    function refreshTimeout() {
      if (fastNowTimeout?.refresh) {
        fastNowTimeout.refresh();
      } else {
        clearTimeout(fastNowTimeout);
        fastNowTimeout = setTimeout(onTick, TICK_MS);
        fastNowTimeout?.unref();
      }
    }
    var FastTimer = class {
      [kFastTimer] = true;
      /**
       * The state of the timer, which can be one of the following:
       * - NOT_IN_LIST (-2)
       * - TO_BE_CLEARED (-1)
       * - PENDING (0)
       * - ACTIVE (1)
       *
       * @type {-2|-1|0|1}
       * @private
       */
      _state = NOT_IN_LIST;
      /**
       * The number of milliseconds to wait before calling the callback.
       *
       * @type {number}
       * @private
       */
      _idleTimeout = -1;
      /**
       * The time in milliseconds when the timer was started. This value is used to
       * calculate when the timer should expire.
       *
       * @type {number}
       * @default -1
       * @private
       */
      _idleStart = -1;
      /**
       * The function to be executed when the timer expires.
       * @type {Function}
       * @private
       */
      _onTimeout;
      /**
       * The argument to be passed to the callback when the timer expires.
       *
       * @type {*}
       * @private
       */
      _timerArg;
      /**
       * @constructor
       * @param {Function} callback A function to be executed after the timer
       * expires.
       * @param {number} delay The time, in milliseconds that the timer should wait
       * before the specified function or code is executed.
       * @param {*} arg
       */
      constructor(callback, delay, arg) {
        this._onTimeout = callback;
        this._idleTimeout = delay;
        this._timerArg = arg;
        this.refresh();
      }
      /**
       * Sets the timer's start time to the current time, and reschedules the timer
       * to call its callback at the previously specified duration adjusted to the
       * current time.
       * Using this on a timer that has already called its callback will reactivate
       * the timer.
       *
       * @returns {void}
       */
      refresh() {
        if (this._state === NOT_IN_LIST) {
          fastTimers.push(this);
        }
        if (!fastNowTimeout || fastTimers.length === 1) {
          refreshTimeout();
        }
        this._state = PENDING;
      }
      /**
       * The `clear` method cancels the timer, preventing it from executing.
       *
       * @returns {void}
       * @private
       */
      clear() {
        this._state = TO_BE_CLEARED;
        this._idleStart = -1;
      }
    };
    module2.exports = {
      /**
       * The setTimeout() method sets a timer which executes a function once the
       * timer expires.
       * @param {Function} callback A function to be executed after the timer
       * expires.
       * @param {number} delay The time, in milliseconds that the timer should
       * wait before the specified function or code is executed.
       * @param {*} [arg] An optional argument to be passed to the callback function
       * when the timer expires.
       * @returns {NodeJS.Timeout|FastTimer}
       */
      setTimeout(callback, delay, arg) {
        return delay <= RESOLUTION_MS ? setTimeout(callback, delay, arg) : new FastTimer(callback, delay, arg);
      },
      /**
       * The clearTimeout method cancels an instantiated Timer previously created
       * by calling setTimeout.
       *
       * @param {NodeJS.Timeout|FastTimer} timeout
       */
      clearTimeout(timeout) {
        if (timeout[kFastTimer]) {
          timeout.clear();
        } else {
          clearTimeout(timeout);
        }
      },
      /**
       * The setFastTimeout() method sets a fastTimer which executes a function once
       * the timer expires.
       * @param {Function} callback A function to be executed after the timer
       * expires.
       * @param {number} delay The time, in milliseconds that the timer should
       * wait before the specified function or code is executed.
       * @param {*} [arg] An optional argument to be passed to the callback function
       * when the timer expires.
       * @returns {FastTimer}
       */
      setFastTimeout(callback, delay, arg) {
        return new FastTimer(callback, delay, arg);
      },
      /**
       * The clearTimeout method cancels an instantiated FastTimer previously
       * created by calling setFastTimeout.
       *
       * @param {FastTimer} timeout
       */
      clearFastTimeout(timeout) {
        timeout.clear();
      },
      /**
       * The now method returns the value of the internal fast timer clock.
       *
       * @returns {number}
       */
      now() {
        return fastNow;
      },
      /**
       * Trigger the onTick function to process the fastTimers array.
       * Exported for testing purposes only.
       * Marking as deprecated to discourage any use outside of testing.
       * @deprecated
       * @param {number} [delay=0] The delay in milliseconds to add to the now value.
       */
      tick(delay = 0) {
        fastNow += delay - RESOLUTION_MS + 1;
        onTick();
        onTick();
      },
      /**
       * Reset FastTimers.
       * Exported for testing purposes only.
       * Marking as deprecated to discourage any use outside of testing.
       * @deprecated
       */
      reset() {
        fastNow = 0;
        fastTimers.length = 0;
        clearTimeout(fastNowTimeout);
        fastNowTimeout = null;
      },
      /**
       * Exporting for testing purposes only.
       * Marking as deprecated to discourage any use outside of testing.
       * @deprecated
       */
      kFastTimer
    };
  }
});

// node_modules/undici/lib/core/errors.js
var require_errors5 = __commonJS({
  "node_modules/undici/lib/core/errors.js"(exports2, module2) {
    "use strict";
    var UndiciError = class extends Error {
      constructor(message, options) {
        super(message, options);
        this.name = "UndiciError";
        this.code = "UND_ERR";
      }
    };
    var ConnectTimeoutError = class extends UndiciError {
      constructor(message) {
        super(message);
        this.name = "ConnectTimeoutError";
        this.message = message || "Connect Timeout Error";
        this.code = "UND_ERR_CONNECT_TIMEOUT";
      }
    };
    var HeadersTimeoutError = class extends UndiciError {
      constructor(message) {
        super(message);
        this.name = "HeadersTimeoutError";
        this.message = message || "Headers Timeout Error";
        this.code = "UND_ERR_HEADERS_TIMEOUT";
      }
    };
    var HeadersOverflowError = class extends UndiciError {
      constructor(message) {
        super(message);
        this.name = "HeadersOverflowError";
        this.message = message || "Headers Overflow Error";
        this.code = "UND_ERR_HEADERS_OVERFLOW";
      }
    };
    var BodyTimeoutError = class extends UndiciError {
      constructor(message) {
        super(message);
        this.name = "BodyTimeoutError";
        this.message = message || "Body Timeout Error";
        this.code = "UND_ERR_BODY_TIMEOUT";
      }
    };
    var ResponseStatusCodeError = class extends UndiciError {
      constructor(message, statusCode, headers, body) {
        super(message);
        this.name = "ResponseStatusCodeError";
        this.message = message || "Response Status Code Error";
        this.code = "UND_ERR_RESPONSE_STATUS_CODE";
        this.body = body;
        this.status = statusCode;
        this.statusCode = statusCode;
        this.headers = headers;
      }
    };
    var InvalidArgumentError = class extends UndiciError {
      constructor(message) {
        super(message);
        this.name = "InvalidArgumentError";
        this.message = message || "Invalid Argument Error";
        this.code = "UND_ERR_INVALID_ARG";
      }
    };
    var InvalidReturnValueError = class extends UndiciError {
      constructor(message) {
        super(message);
        this.name = "InvalidReturnValueError";
        this.message = message || "Invalid Return Value Error";
        this.code = "UND_ERR_INVALID_RETURN_VALUE";
      }
    };
    var AbortError = class extends UndiciError {
      constructor(message) {
        super(message);
        this.name = "AbortError";
        this.message = message || "The operation was aborted";
      }
    };
    var RequestAbortedError = class extends AbortError {
      constructor(message) {
        super(message);
        this.name = "AbortError";
        this.message = message || "Request aborted";
        this.code = "UND_ERR_ABORTED";
      }
    };
    var InformationalError = class extends UndiciError {
      constructor(message) {
        super(message);
        this.name = "InformationalError";
        this.message = message || "Request information";
        this.code = "UND_ERR_INFO";
      }
    };
    var RequestContentLengthMismatchError = class extends UndiciError {
      constructor(message) {
        super(message);
        this.name = "RequestContentLengthMismatchError";
        this.message = message || "Request body length does not match content-length header";
        this.code = "UND_ERR_REQ_CONTENT_LENGTH_MISMATCH";
      }
    };
    var ResponseContentLengthMismatchError = class extends UndiciError {
      constructor(message) {
        super(message);
        this.name = "ResponseContentLengthMismatchError";
        this.message = message || "Response body length does not match content-length header";
        this.code = "UND_ERR_RES_CONTENT_LENGTH_MISMATCH";
      }
    };
    var ClientDestroyedError = class extends UndiciError {
      constructor(message) {
        super(message);
        this.name = "ClientDestroyedError";
        this.message = message || "The client is destroyed";
        this.code = "UND_ERR_DESTROYED";
      }
    };
    var ClientClosedError = class extends UndiciError {
      constructor(message) {
        super(message);
        this.name = "ClientClosedError";
        this.message = message || "The client is closed";
        this.code = "UND_ERR_CLOSED";
      }
    };
    var SocketError = class extends UndiciError {
      constructor(message, socket) {
        super(message);
        this.name = "SocketError";
        this.message = message || "Socket error";
        this.code = "UND_ERR_SOCKET";
        this.socket = socket;
      }
    };
    var NotSupportedError = class extends UndiciError {
      constructor(message) {
        super(message);
        this.name = "NotSupportedError";
        this.message = message || "Not supported error";
        this.code = "UND_ERR_NOT_SUPPORTED";
      }
    };
    var BalancedPoolMissingUpstreamError = class extends UndiciError {
      constructor(message) {
        super(message);
        this.name = "MissingUpstreamError";
        this.message = message || "No upstream has been added to the BalancedPool";
        this.code = "UND_ERR_BPL_MISSING_UPSTREAM";
      }
    };
    var HTTPParserError = class extends Error {
      constructor(message, code, data) {
        super(message);
        this.name = "HTTPParserError";
        this.code = code ? `HPE_${code}` : void 0;
        this.data = data ? data.toString() : void 0;
      }
    };
    var ResponseExceededMaxSizeError = class extends UndiciError {
      constructor(message) {
        super(message);
        this.name = "ResponseExceededMaxSizeError";
        this.message = message || "Response content exceeded max size";
        this.code = "UND_ERR_RES_EXCEEDED_MAX_SIZE";
      }
    };
    var RequestRetryError = class extends UndiciError {
      constructor(message, code, { headers, data }) {
        super(message);
        this.name = "RequestRetryError";
        this.message = message || "Request retry error";
        this.code = "UND_ERR_REQ_RETRY";
        this.statusCode = code;
        this.data = data;
        this.headers = headers;
      }
    };
    var ResponseError = class extends UndiciError {
      constructor(message, code, { headers, body }) {
        super(message);
        this.name = "ResponseError";
        this.message = message || "Response error";
        this.code = "UND_ERR_RESPONSE";
        this.statusCode = code;
        this.body = body;
        this.headers = headers;
      }
    };
    var SecureProxyConnectionError = class extends UndiciError {
      constructor(cause, message, options = {}) {
        super(message, { cause, ...options });
        this.name = "SecureProxyConnectionError";
        this.message = message || "Secure Proxy Connection failed";
        this.code = "UND_ERR_PRX_TLS";
        this.cause = cause;
      }
    };
    module2.exports = {
      AbortError,
      HTTPParserError,
      UndiciError,
      HeadersTimeoutError,
      HeadersOverflowError,
      BodyTimeoutError,
      RequestContentLengthMismatchError,
      ConnectTimeoutError,
      ResponseStatusCodeError,
      InvalidArgumentError,
      InvalidReturnValueError,
      RequestAbortedError,
      ClientDestroyedError,
      ClientClosedError,
      InformationalError,
      SocketError,
      NotSupportedError,
      ResponseContentLengthMismatchError,
      BalancedPoolMissingUpstreamError,
      ResponseExceededMaxSizeError,
      RequestRetryError,
      ResponseError,
      SecureProxyConnectionError
    };
  }
});

// node_modules/undici/lib/core/constants.js
var require_constants3 = __commonJS({
  "node_modules/undici/lib/core/constants.js"(exports2, module2) {
    "use strict";
    var wellknownHeaderNames = (
      /** @type {const} */
      [
        "Accept",
        "Accept-Encoding",
        "Accept-Language",
        "Accept-Ranges",
        "Access-Control-Allow-Credentials",
        "Access-Control-Allow-Headers",
        "Access-Control-Allow-Methods",
        "Access-Control-Allow-Origin",
        "Access-Control-Expose-Headers",
        "Access-Control-Max-Age",
        "Access-Control-Request-Headers",
        "Access-Control-Request-Method",
        "Age",
        "Allow",
        "Alt-Svc",
        "Alt-Used",
        "Authorization",
        "Cache-Control",
        "Clear-Site-Data",
        "Connection",
        "Content-Disposition",
        "Content-Encoding",
        "Content-Language",
        "Content-Length",
        "Content-Location",
        "Content-Range",
        "Content-Security-Policy",
        "Content-Security-Policy-Report-Only",
        "Content-Type",
        "Cookie",
        "Cross-Origin-Embedder-Policy",
        "Cross-Origin-Opener-Policy",
        "Cross-Origin-Resource-Policy",
        "Date",
        "Device-Memory",
        "Downlink",
        "ECT",
        "ETag",
        "Expect",
        "Expect-CT",
        "Expires",
        "Forwarded",
        "From",
        "Host",
        "If-Match",
        "If-Modified-Since",
        "If-None-Match",
        "If-Range",
        "If-Unmodified-Since",
        "Keep-Alive",
        "Last-Modified",
        "Link",
        "Location",
        "Max-Forwards",
        "Origin",
        "Permissions-Policy",
        "Pragma",
        "Proxy-Authenticate",
        "Proxy-Authorization",
        "RTT",
        "Range",
        "Referer",
        "Referrer-Policy",
        "Refresh",
        "Retry-After",
        "Sec-WebSocket-Accept",
        "Sec-WebSocket-Extensions",
        "Sec-WebSocket-Key",
        "Sec-WebSocket-Protocol",
        "Sec-WebSocket-Version",
        "Server",
        "Server-Timing",
        "Service-Worker-Allowed",
        "Service-Worker-Navigation-Preload",
        "Set-Cookie",
        "SourceMap",
        "Strict-Transport-Security",
        "Supports-Loading-Mode",
        "TE",
        "Timing-Allow-Origin",
        "Trailer",
        "Transfer-Encoding",
        "Upgrade",
        "Upgrade-Insecure-Requests",
        "User-Agent",
        "Vary",
        "Via",
        "WWW-Authenticate",
        "X-Content-Type-Options",
        "X-DNS-Prefetch-Control",
        "X-Frame-Options",
        "X-Permitted-Cross-Domain-Policies",
        "X-Powered-By",
        "X-Requested-With",
        "X-XSS-Protection"
      ]
    );
    var headerNameLowerCasedRecord = {};
    Object.setPrototypeOf(headerNameLowerCasedRecord, null);
    var wellknownHeaderNameBuffers = {};
    Object.setPrototypeOf(wellknownHeaderNameBuffers, null);
    function getHeaderNameAsBuffer(header) {
      let buffer = wellknownHeaderNameBuffers[header];
      if (buffer === void 0) {
        buffer = Buffer.from(header);
      }
      return buffer;
    }
    for (let i = 0; i < wellknownHeaderNames.length; ++i) {
      const key = wellknownHeaderNames[i];
      const lowerCasedKey = key.toLowerCase();
      headerNameLowerCasedRecord[key] = headerNameLowerCasedRecord[lowerCasedKey] = lowerCasedKey;
    }
    module2.exports = {
      wellknownHeaderNames,
      headerNameLowerCasedRecord,
      getHeaderNameAsBuffer
    };
  }
});

// node_modules/undici/lib/core/tree.js
var require_tree = __commonJS({
  "node_modules/undici/lib/core/tree.js"(exports2, module2) {
    "use strict";
    var {
      wellknownHeaderNames,
      headerNameLowerCasedRecord
    } = require_constants3();
    var TstNode = class _TstNode {
      /** @type {any} */
      value = null;
      /** @type {null | TstNode} */
      left = null;
      /** @type {null | TstNode} */
      middle = null;
      /** @type {null | TstNode} */
      right = null;
      /** @type {number} */
      code;
      /**
       * @param {string} key
       * @param {any} value
       * @param {number} index
       */
      constructor(key, value, index) {
        if (index === void 0 || index >= key.length) {
          throw new TypeError("Unreachable");
        }
        const code = this.code = key.charCodeAt(index);
        if (code > 127) {
          throw new TypeError("key must be ascii string");
        }
        if (key.length !== ++index) {
          this.middle = new _TstNode(key, value, index);
        } else {
          this.value = value;
        }
      }
      /**
       * @param {string} key
       * @param {any} value
       * @returns {void}
       */
      add(key, value) {
        const length = key.length;
        if (length === 0) {
          throw new TypeError("Unreachable");
        }
        let index = 0;
        let node = this;
        while (true) {
          const code = key.charCodeAt(index);
          if (code > 127) {
            throw new TypeError("key must be ascii string");
          }
          if (node.code === code) {
            if (length === ++index) {
              node.value = value;
              break;
            } else if (node.middle !== null) {
              node = node.middle;
            } else {
              node.middle = new _TstNode(key, value, index);
              break;
            }
          } else if (node.code < code) {
            if (node.left !== null) {
              node = node.left;
            } else {
              node.left = new _TstNode(key, value, index);
              break;
            }
          } else if (node.right !== null) {
            node = node.right;
          } else {
            node.right = new _TstNode(key, value, index);
            break;
          }
        }
      }
      /**
       * @param {Uint8Array} key
       * @returns {TstNode | null}
       */
      search(key) {
        const keylength = key.length;
        let index = 0;
        let node = this;
        while (node !== null && index < keylength) {
          let code = key[index];
          if (code <= 90 && code >= 65) {
            code |= 32;
          }
          while (node !== null) {
            if (code === node.code) {
              if (keylength === ++index) {
                return node;
              }
              node = node.middle;
              break;
            }
            node = node.code < code ? node.left : node.right;
          }
        }
        return null;
      }
    };
    var TernarySearchTree = class {
      /** @type {TstNode | null} */
      node = null;
      /**
       * @param {string} key
       * @param {any} value
       * @returns {void}
       * */
      insert(key, value) {
        if (this.node === null) {
          this.node = new TstNode(key, value, 0);
        } else {
          this.node.add(key, value);
        }
      }
      /**
       * @param {Uint8Array} key
       * @returns {any}
       */
      lookup(key) {
        return this.node?.search(key)?.value ?? null;
      }
    };
    var tree = new TernarySearchTree();
    for (let i = 0; i < wellknownHeaderNames.length; ++i) {
      const key = headerNameLowerCasedRecord[wellknownHeaderNames[i]];
      tree.insert(key, key);
    }
    module2.exports = {
      TernarySearchTree,
      tree
    };
  }
});

// node_modules/undici/lib/core/util.js
var require_util4 = __commonJS({
  "node_modules/undici/lib/core/util.js"(exports2, module2) {
    "use strict";
    var assert = require("node:assert");
    var { kDestroyed, kBodyUsed, kListeners, kBody } = require_symbols4();
    var { IncomingMessage } = require("node:http");
    var stream = require("node:stream");
    var net = require("node:net");
    var { stringify } = require("node:querystring");
    var { EventEmitter: EE } = require("node:events");
    var timers = require_timers();
    var { InvalidArgumentError, ConnectTimeoutError } = require_errors5();
    var { headerNameLowerCasedRecord } = require_constants3();
    var { tree } = require_tree();
    var [nodeMajor, nodeMinor] = process.versions.node.split(".", 2).map((v) => Number(v));
    var BodyAsyncIterable = class {
      constructor(body) {
        this[kBody] = body;
        this[kBodyUsed] = false;
      }
      async *[Symbol.asyncIterator]() {
        assert(!this[kBodyUsed], "disturbed");
        this[kBodyUsed] = true;
        yield* this[kBody];
      }
    };
    function noop() {
    }
    function wrapRequestBody(body) {
      if (isStream(body)) {
        if (bodyLength(body) === 0) {
          body.on("data", function() {
            assert(false);
          });
        }
        if (typeof body.readableDidRead !== "boolean") {
          body[kBodyUsed] = false;
          EE.prototype.on.call(body, "data", function() {
            this[kBodyUsed] = true;
          });
        }
        return body;
      } else if (body && typeof body.pipeTo === "function") {
        return new BodyAsyncIterable(body);
      } else if (body && typeof body !== "string" && !ArrayBuffer.isView(body) && isIterable(body)) {
        return new BodyAsyncIterable(body);
      } else {
        return body;
      }
    }
    function isStream(obj) {
      return obj && typeof obj === "object" && typeof obj.pipe === "function" && typeof obj.on === "function";
    }
    function isBlobLike(object) {
      if (object === null) {
        return false;
      } else if (object instanceof Blob) {
        return true;
      } else if (typeof object !== "object") {
        return false;
      } else {
        const sTag = object[Symbol.toStringTag];
        return (sTag === "Blob" || sTag === "File") && ("stream" in object && typeof object.stream === "function" || "arrayBuffer" in object && typeof object.arrayBuffer === "function");
      }
    }
    function serializePathWithQuery(url, queryParams) {
      if (url.includes("?") || url.includes("#")) {
        throw new Error('Query params cannot be passed when url already contains "?" or "#".');
      }
      const stringified = stringify(queryParams);
      if (stringified) {
        url += "?" + stringified;
      }
      return url;
    }
    function isValidPort(port) {
      const value = parseInt(port, 10);
      return value === Number(port) && value >= 0 && value <= 65535;
    }
    function isHttpOrHttpsPrefixed(value) {
      return value != null && value[0] === "h" && value[1] === "t" && value[2] === "t" && value[3] === "p" && (value[4] === ":" || value[4] === "s" && value[5] === ":");
    }
    function parseURL(url) {
      if (typeof url === "string") {
        url = new URL(url);
        if (!isHttpOrHttpsPrefixed(url.origin || url.protocol)) {
          throw new InvalidArgumentError("Invalid URL protocol: the URL must start with `http:` or `https:`.");
        }
        return url;
      }
      if (!url || typeof url !== "object") {
        throw new InvalidArgumentError("Invalid URL: The URL argument must be a non-null object.");
      }
      if (!(url instanceof URL)) {
        if (url.port != null && url.port !== "" && isValidPort(url.port) === false) {
          throw new InvalidArgumentError("Invalid URL: port must be a valid integer or a string representation of an integer.");
        }
        if (url.path != null && typeof url.path !== "string") {
          throw new InvalidArgumentError("Invalid URL path: the path must be a string or null/undefined.");
        }
        if (url.pathname != null && typeof url.pathname !== "string") {
          throw new InvalidArgumentError("Invalid URL pathname: the pathname must be a string or null/undefined.");
        }
        if (url.hostname != null && typeof url.hostname !== "string") {
          throw new InvalidArgumentError("Invalid URL hostname: the hostname must be a string or null/undefined.");
        }
        if (url.origin != null && typeof url.origin !== "string") {
          throw new InvalidArgumentError("Invalid URL origin: the origin must be a string or null/undefined.");
        }
        if (!isHttpOrHttpsPrefixed(url.origin || url.protocol)) {
          throw new InvalidArgumentError("Invalid URL protocol: the URL must start with `http:` or `https:`.");
        }
        const port = url.port != null ? url.port : url.protocol === "https:" ? 443 : 80;
        let origin = url.origin != null ? url.origin : `${url.protocol || ""}//${url.hostname || ""}:${port}`;
        let path4 = url.path != null ? url.path : `${url.pathname || ""}${url.search || ""}`;
        if (origin[origin.length - 1] === "/") {
          origin = origin.slice(0, origin.length - 1);
        }
        if (path4 && path4[0] !== "/") {
          path4 = `/${path4}`;
        }
        return new URL(`${origin}${path4}`);
      }
      if (!isHttpOrHttpsPrefixed(url.origin || url.protocol)) {
        throw new InvalidArgumentError("Invalid URL protocol: the URL must start with `http:` or `https:`.");
      }
      return url;
    }
    function parseOrigin(url) {
      url = parseURL(url);
      if (url.pathname !== "/" || url.search || url.hash) {
        throw new InvalidArgumentError("invalid url");
      }
      return url;
    }
    function getHostname(host) {
      if (host[0] === "[") {
        const idx2 = host.indexOf("]");
        assert(idx2 !== -1);
        return host.substring(1, idx2);
      }
      const idx = host.indexOf(":");
      if (idx === -1) return host;
      return host.substring(0, idx);
    }
    function getServerName(host) {
      if (!host) {
        return null;
      }
      assert(typeof host === "string");
      const servername = getHostname(host);
      if (net.isIP(servername)) {
        return "";
      }
      return servername;
    }
    function deepClone(obj) {
      return JSON.parse(JSON.stringify(obj));
    }
    function isAsyncIterable(obj) {
      return !!(obj != null && typeof obj[Symbol.asyncIterator] === "function");
    }
    function isIterable(obj) {
      return !!(obj != null && (typeof obj[Symbol.iterator] === "function" || typeof obj[Symbol.asyncIterator] === "function"));
    }
    function bodyLength(body) {
      if (body == null) {
        return 0;
      } else if (isStream(body)) {
        const state = body._readableState;
        return state && state.objectMode === false && state.ended === true && Number.isFinite(state.length) ? state.length : null;
      } else if (isBlobLike(body)) {
        return body.size != null ? body.size : null;
      } else if (isBuffer(body)) {
        return body.byteLength;
      }
      return null;
    }
    function isDestroyed(body) {
      return body && !!(body.destroyed || body[kDestroyed] || stream.isDestroyed?.(body));
    }
    function destroy(stream2, err) {
      if (stream2 == null || !isStream(stream2) || isDestroyed(stream2)) {
        return;
      }
      if (typeof stream2.destroy === "function") {
        if (Object.getPrototypeOf(stream2).constructor === IncomingMessage) {
          stream2.socket = null;
        }
        stream2.destroy(err);
      } else if (err) {
        queueMicrotask(() => {
          stream2.emit("error", err);
        });
      }
      if (stream2.destroyed !== true) {
        stream2[kDestroyed] = true;
      }
    }
    var KEEPALIVE_TIMEOUT_EXPR = /timeout=(\d+)/;
    function parseKeepAliveTimeout(val) {
      const m = val.match(KEEPALIVE_TIMEOUT_EXPR);
      return m ? parseInt(m[1], 10) * 1e3 : null;
    }
    function headerNameToString(value) {
      return typeof value === "string" ? headerNameLowerCasedRecord[value] ?? value.toLowerCase() : tree.lookup(value) ?? value.toString("latin1").toLowerCase();
    }
    function bufferToLowerCasedHeaderName(value) {
      return tree.lookup(value) ?? value.toString("latin1").toLowerCase();
    }
    function parseHeaders(headers, obj) {
      if (obj === void 0) obj = {};
      for (let i = 0; i < headers.length; i += 2) {
        const key = headerNameToString(headers[i]);
        let val = obj[key];
        if (val) {
          if (typeof val === "string") {
            val = [val];
            obj[key] = val;
          }
          val.push(headers[i + 1].toString("utf8"));
        } else {
          const headersValue = headers[i + 1];
          if (typeof headersValue === "string") {
            obj[key] = headersValue;
          } else {
            obj[key] = Array.isArray(headersValue) ? headersValue.map((x) => x.toString("utf8")) : headersValue.toString("utf8");
          }
        }
      }
      if ("content-length" in obj && "content-disposition" in obj) {
        obj["content-disposition"] = Buffer.from(obj["content-disposition"]).toString("latin1");
      }
      return obj;
    }
    function parseRawHeaders(headers) {
      const headersLength = headers.length;
      const ret = new Array(headersLength);
      let hasContentLength = false;
      let contentDispositionIdx = -1;
      let key;
      let val;
      let kLen = 0;
      for (let n = 0; n < headersLength; n += 2) {
        key = headers[n];
        val = headers[n + 1];
        typeof key !== "string" && (key = key.toString());
        typeof val !== "string" && (val = val.toString("utf8"));
        kLen = key.length;
        if (kLen === 14 && key[7] === "-" && (key === "content-length" || key.toLowerCase() === "content-length")) {
          hasContentLength = true;
        } else if (kLen === 19 && key[7] === "-" && (key === "content-disposition" || key.toLowerCase() === "content-disposition")) {
          contentDispositionIdx = n + 1;
        }
        ret[n] = key;
        ret[n + 1] = val;
      }
      if (hasContentLength && contentDispositionIdx !== -1) {
        ret[contentDispositionIdx] = Buffer.from(ret[contentDispositionIdx]).toString("latin1");
      }
      return ret;
    }
    function encodeRawHeaders(headers) {
      if (!Array.isArray(headers)) {
        throw new TypeError("expected headers to be an array");
      }
      return headers.map((x) => Buffer.from(x));
    }
    function isBuffer(buffer) {
      return buffer instanceof Uint8Array || Buffer.isBuffer(buffer);
    }
    function assertRequestHandler(handler, method, upgrade) {
      if (!handler || typeof handler !== "object") {
        throw new InvalidArgumentError("handler must be an object");
      }
      if (typeof handler.onRequestStart === "function") {
        return;
      }
      if (typeof handler.onConnect !== "function") {
        throw new InvalidArgumentError("invalid onConnect method");
      }
      if (typeof handler.onError !== "function") {
        throw new InvalidArgumentError("invalid onError method");
      }
      if (typeof handler.onBodySent !== "function" && handler.onBodySent !== void 0) {
        throw new InvalidArgumentError("invalid onBodySent method");
      }
      if (upgrade || method === "CONNECT") {
        if (typeof handler.onUpgrade !== "function") {
          throw new InvalidArgumentError("invalid onUpgrade method");
        }
      } else {
        if (typeof handler.onHeaders !== "function") {
          throw new InvalidArgumentError("invalid onHeaders method");
        }
        if (typeof handler.onData !== "function") {
          throw new InvalidArgumentError("invalid onData method");
        }
        if (typeof handler.onComplete !== "function") {
          throw new InvalidArgumentError("invalid onComplete method");
        }
      }
    }
    function isDisturbed(body) {
      return !!(body && (stream.isDisturbed(body) || body[kBodyUsed]));
    }
    function getSocketInfo(socket) {
      return {
        localAddress: socket.localAddress,
        localPort: socket.localPort,
        remoteAddress: socket.remoteAddress,
        remotePort: socket.remotePort,
        remoteFamily: socket.remoteFamily,
        timeout: socket.timeout,
        bytesWritten: socket.bytesWritten,
        bytesRead: socket.bytesRead
      };
    }
    function ReadableStreamFrom(iterable) {
      let iterator;
      return new ReadableStream(
        {
          async start() {
            iterator = iterable[Symbol.asyncIterator]();
          },
          pull(controller) {
            async function pull() {
              const { done, value } = await iterator.next();
              if (done) {
                queueMicrotask(() => {
                  controller.close();
                  controller.byobRequest?.respond(0);
                });
              } else {
                const buf = Buffer.isBuffer(value) ? value : Buffer.from(value);
                if (buf.byteLength) {
                  controller.enqueue(new Uint8Array(buf));
                } else {
                  return await pull();
                }
              }
            }
            return pull();
          },
          async cancel() {
            await iterator.return();
          },
          type: "bytes"
        }
      );
    }
    function isFormDataLike(object) {
      return object && typeof object === "object" && typeof object.append === "function" && typeof object.delete === "function" && typeof object.get === "function" && typeof object.getAll === "function" && typeof object.has === "function" && typeof object.set === "function" && object[Symbol.toStringTag] === "FormData";
    }
    function addAbortListener(signal, listener) {
      if ("addEventListener" in signal) {
        signal.addEventListener("abort", listener, { once: true });
        return () => signal.removeEventListener("abort", listener);
      }
      signal.once("abort", listener);
      return () => signal.removeListener("abort", listener);
    }
    function isTokenCharCode(c) {
      switch (c) {
        case 34:
        case 40:
        case 41:
        case 44:
        case 47:
        case 58:
        case 59:
        case 60:
        case 61:
        case 62:
        case 63:
        case 64:
        case 91:
        case 92:
        case 93:
        case 123:
        case 125:
          return false;
        default:
          return c >= 33 && c <= 126;
      }
    }
    function isValidHTTPToken(characters) {
      if (characters.length === 0) {
        return false;
      }
      for (let i = 0; i < characters.length; ++i) {
        if (!isTokenCharCode(characters.charCodeAt(i))) {
          return false;
        }
      }
      return true;
    }
    var headerCharRegex = /[^\t\x20-\x7e\x80-\xff]/;
    function isValidHeaderValue(characters) {
      return !headerCharRegex.test(characters);
    }
    var rangeHeaderRegex = /^bytes (\d+)-(\d+)\/(\d+)?$/;
    function parseRangeHeader(range) {
      if (range == null || range === "") return { start: 0, end: null, size: null };
      const m = range ? range.match(rangeHeaderRegex) : null;
      return m ? {
        start: parseInt(m[1]),
        end: m[2] ? parseInt(m[2]) : null,
        size: m[3] ? parseInt(m[3]) : null
      } : null;
    }
    function addListener(obj, name, listener) {
      const listeners = obj[kListeners] ??= [];
      listeners.push([name, listener]);
      obj.on(name, listener);
      return obj;
    }
    function removeAllListeners(obj) {
      if (obj[kListeners] != null) {
        for (const [name, listener] of obj[kListeners]) {
          obj.removeListener(name, listener);
        }
        obj[kListeners] = null;
      }
      return obj;
    }
    function errorRequest(client, request, err) {
      try {
        request.onError(err);
        assert(request.aborted);
      } catch (err2) {
        client.emit("error", err2);
      }
    }
    var setupConnectTimeout = process.platform === "win32" ? (socketWeakRef, opts) => {
      if (!opts.timeout) {
        return noop;
      }
      let s1 = null;
      let s2 = null;
      const fastTimer = timers.setFastTimeout(() => {
        s1 = setImmediate(() => {
          s2 = setImmediate(() => onConnectTimeout(socketWeakRef.deref(), opts));
        });
      }, opts.timeout);
      return () => {
        timers.clearFastTimeout(fastTimer);
        clearImmediate(s1);
        clearImmediate(s2);
      };
    } : (socketWeakRef, opts) => {
      if (!opts.timeout) {
        return noop;
      }
      let s1 = null;
      const fastTimer = timers.setFastTimeout(() => {
        s1 = setImmediate(() => {
          onConnectTimeout(socketWeakRef.deref(), opts);
        });
      }, opts.timeout);
      return () => {
        timers.clearFastTimeout(fastTimer);
        clearImmediate(s1);
      };
    };
    function onConnectTimeout(socket, opts) {
      if (socket == null) {
        return;
      }
      let message = "Connect Timeout Error";
      if (Array.isArray(socket.autoSelectFamilyAttemptedAddresses)) {
        message += ` (attempted addresses: ${socket.autoSelectFamilyAttemptedAddresses.join(", ")},`;
      } else {
        message += ` (attempted address: ${opts.hostname}:${opts.port},`;
      }
      message += ` timeout: ${opts.timeout}ms)`;
      destroy(socket, new ConnectTimeoutError(message));
    }
    var kEnumerableProperty = /* @__PURE__ */ Object.create(null);
    kEnumerableProperty.enumerable = true;
    var normalizedMethodRecordsBase = {
      delete: "DELETE",
      DELETE: "DELETE",
      get: "GET",
      GET: "GET",
      head: "HEAD",
      HEAD: "HEAD",
      options: "OPTIONS",
      OPTIONS: "OPTIONS",
      post: "POST",
      POST: "POST",
      put: "PUT",
      PUT: "PUT"
    };
    var normalizedMethodRecords = {
      ...normalizedMethodRecordsBase,
      patch: "patch",
      PATCH: "PATCH"
    };
    Object.setPrototypeOf(normalizedMethodRecordsBase, null);
    Object.setPrototypeOf(normalizedMethodRecords, null);
    module2.exports = {
      kEnumerableProperty,
      isDisturbed,
      isBlobLike,
      parseOrigin,
      parseURL,
      getServerName,
      isStream,
      isIterable,
      isAsyncIterable,
      isDestroyed,
      headerNameToString,
      bufferToLowerCasedHeaderName,
      addListener,
      removeAllListeners,
      errorRequest,
      parseRawHeaders,
      encodeRawHeaders,
      parseHeaders,
      parseKeepAliveTimeout,
      destroy,
      bodyLength,
      deepClone,
      ReadableStreamFrom,
      isBuffer,
      assertRequestHandler,
      getSocketInfo,
      isFormDataLike,
      serializePathWithQuery,
      addAbortListener,
      isValidHTTPToken,
      isValidHeaderValue,
      isTokenCharCode,
      parseRangeHeader,
      normalizedMethodRecordsBase,
      normalizedMethodRecords,
      isValidPort,
      isHttpOrHttpsPrefixed,
      nodeMajor,
      nodeMinor,
      safeHTTPMethods: Object.freeze(["GET", "HEAD", "OPTIONS", "TRACE"]),
      wrapRequestBody,
      setupConnectTimeout
    };
  }
});

// node_modules/undici/lib/util/stats.js
var require_stats = __commonJS({
  "node_modules/undici/lib/util/stats.js"(exports2, module2) {
    "use strict";
    var {
      kConnected,
      kPending,
      kRunning,
      kSize,
      kFree,
      kQueued
    } = require_symbols4();
    var ClientStats = class {
      constructor(client) {
        this.connected = client[kConnected];
        this.pending = client[kPending];
        this.running = client[kRunning];
        this.size = client[kSize];
      }
    };
    var PoolStats = class {
      constructor(pool) {
        this.connected = pool[kConnected];
        this.free = pool[kFree];
        this.pending = pool[kPending];
        this.queued = pool[kQueued];
        this.running = pool[kRunning];
        this.size = pool[kSize];
      }
    };
    module2.exports = { ClientStats, PoolStats };
  }
});

// node_modules/undici/lib/core/diagnostics.js
var require_diagnostics = __commonJS({
  "node_modules/undici/lib/core/diagnostics.js"(exports2, module2) {
    "use strict";
    var diagnosticsChannel = require("node:diagnostics_channel");
    var util = require("node:util");
    var undiciDebugLog = util.debuglog("undici");
    var fetchDebuglog = util.debuglog("fetch");
    var websocketDebuglog = util.debuglog("websocket");
    var channels = {
      // Client
      beforeConnect: diagnosticsChannel.channel("undici:client:beforeConnect"),
      connected: diagnosticsChannel.channel("undici:client:connected"),
      connectError: diagnosticsChannel.channel("undici:client:connectError"),
      sendHeaders: diagnosticsChannel.channel("undici:client:sendHeaders"),
      // Request
      create: diagnosticsChannel.channel("undici:request:create"),
      bodySent: diagnosticsChannel.channel("undici:request:bodySent"),
      bodyChunkSent: diagnosticsChannel.channel("undici:request:bodyChunkSent"),
      bodyChunkReceived: diagnosticsChannel.channel("undici:request:bodyChunkReceived"),
      headers: diagnosticsChannel.channel("undici:request:headers"),
      trailers: diagnosticsChannel.channel("undici:request:trailers"),
      error: diagnosticsChannel.channel("undici:request:error"),
      // WebSocket
      open: diagnosticsChannel.channel("undici:websocket:open"),
      close: diagnosticsChannel.channel("undici:websocket:close"),
      socketError: diagnosticsChannel.channel("undici:websocket:socket_error"),
      ping: diagnosticsChannel.channel("undici:websocket:ping"),
      pong: diagnosticsChannel.channel("undici:websocket:pong")
    };
    var isTrackingClientEvents = false;
    function trackClientEvents(debugLog = undiciDebugLog) {
      if (isTrackingClientEvents) {
        return;
      }
      isTrackingClientEvents = true;
      diagnosticsChannel.subscribe(
        "undici:client:beforeConnect",
        (evt) => {
          const {
            connectParams: { version: version2, protocol, port, host }
          } = evt;
          debugLog(
            "connecting to %s%s using %s%s",
            host,
            port ? `:${port}` : "",
            protocol,
            version2
          );
        }
      );
      diagnosticsChannel.subscribe(
        "undici:client:connected",
        (evt) => {
          const {
            connectParams: { version: version2, protocol, port, host }
          } = evt;
          debugLog(
            "connected to %s%s using %s%s",
            host,
            port ? `:${port}` : "",
            protocol,
            version2
          );
        }
      );
      diagnosticsChannel.subscribe(
        "undici:client:connectError",
        (evt) => {
          const {
            connectParams: { version: version2, protocol, port, host },
            error
          } = evt;
          debugLog(
            "connection to %s%s using %s%s errored - %s",
            host,
            port ? `:${port}` : "",
            protocol,
            version2,
            error.message
          );
        }
      );
      diagnosticsChannel.subscribe(
        "undici:client:sendHeaders",
        (evt) => {
          const {
            request: { method, path: path4, origin }
          } = evt;
          debugLog("sending request to %s %s%s", method, origin, path4);
        }
      );
    }
    var isTrackingRequestEvents = false;
    function trackRequestEvents(debugLog = undiciDebugLog) {
      if (isTrackingRequestEvents) {
        return;
      }
      isTrackingRequestEvents = true;
      diagnosticsChannel.subscribe(
        "undici:request:headers",
        (evt) => {
          const {
            request: { method, path: path4, origin },
            response: { statusCode }
          } = evt;
          debugLog(
            "received response to %s %s%s - HTTP %d",
            method,
            origin,
            path4,
            statusCode
          );
        }
      );
      diagnosticsChannel.subscribe(
        "undici:request:trailers",
        (evt) => {
          const {
            request: { method, path: path4, origin }
          } = evt;
          debugLog("trailers received from %s %s%s", method, origin, path4);
        }
      );
      diagnosticsChannel.subscribe(
        "undici:request:error",
        (evt) => {
          const {
            request: { method, path: path4, origin },
            error
          } = evt;
          debugLog(
            "request to %s %s%s errored - %s",
            method,
            origin,
            path4,
            error.message
          );
        }
      );
    }
    var isTrackingWebSocketEvents = false;
    function trackWebSocketEvents(debugLog = websocketDebuglog) {
      if (isTrackingWebSocketEvents) {
        return;
      }
      isTrackingWebSocketEvents = true;
      diagnosticsChannel.subscribe(
        "undici:websocket:open",
        (evt) => {
          const {
            address: { address, port }
          } = evt;
          debugLog("connection opened %s%s", address, port ? `:${port}` : "");
        }
      );
      diagnosticsChannel.subscribe(
        "undici:websocket:close",
        (evt) => {
          const { websocket, code, reason } = evt;
          debugLog(
            "closed connection to %s - %s %s",
            websocket.url,
            code,
            reason
          );
        }
      );
      diagnosticsChannel.subscribe(
        "undici:websocket:socket_error",
        (err) => {
          debugLog("connection errored - %s", err.message);
        }
      );
      diagnosticsChannel.subscribe(
        "undici:websocket:ping",
        (evt) => {
          debugLog("ping received");
        }
      );
      diagnosticsChannel.subscribe(
        "undici:websocket:pong",
        (evt) => {
          debugLog("pong received");
        }
      );
    }
    if (undiciDebugLog.enabled || fetchDebuglog.enabled) {
      trackClientEvents(fetchDebuglog.enabled ? fetchDebuglog : undiciDebugLog);
      trackRequestEvents(fetchDebuglog.enabled ? fetchDebuglog : undiciDebugLog);
    }
    if (websocketDebuglog.enabled) {
      trackClientEvents(undiciDebugLog.enabled ? undiciDebugLog : websocketDebuglog);
      trackWebSocketEvents(websocketDebuglog);
    }
    module2.exports = {
      channels
    };
  }
});

// node_modules/undici/lib/core/request.js
var require_request3 = __commonJS({
  "node_modules/undici/lib/core/request.js"(exports2, module2) {
    "use strict";
    var {
      InvalidArgumentError,
      NotSupportedError
    } = require_errors5();
    var assert = require("node:assert");
    var {
      isValidHTTPToken,
      isValidHeaderValue,
      isStream,
      destroy,
      isBuffer,
      isFormDataLike,
      isIterable,
      isBlobLike,
      serializePathWithQuery,
      assertRequestHandler,
      getServerName,
      normalizedMethodRecords
    } = require_util4();
    var { channels } = require_diagnostics();
    var { headerNameLowerCasedRecord } = require_constants3();
    var invalidPathRegex = /[^\u0021-\u00ff]/;
    var kHandler = Symbol("handler");
    var Request = class {
      constructor(origin, {
        path: path4,
        method,
        body,
        headers,
        query,
        idempotent,
        blocking,
        upgrade,
        headersTimeout,
        bodyTimeout,
        reset,
        expectContinue,
        servername,
        throwOnError,
        maxRedirections
      }, handler) {
        if (typeof path4 !== "string") {
          throw new InvalidArgumentError("path must be a string");
        } else if (path4[0] !== "/" && !(path4.startsWith("http://") || path4.startsWith("https://")) && method !== "CONNECT") {
          throw new InvalidArgumentError("path must be an absolute URL or start with a slash");
        } else if (invalidPathRegex.test(path4)) {
          throw new InvalidArgumentError("invalid request path");
        }
        if (typeof method !== "string") {
          throw new InvalidArgumentError("method must be a string");
        } else if (normalizedMethodRecords[method] === void 0 && !isValidHTTPToken(method)) {
          throw new InvalidArgumentError("invalid request method");
        }
        if (upgrade && typeof upgrade !== "string") {
          throw new InvalidArgumentError("upgrade must be a string");
        }
        if (headersTimeout != null && (!Number.isFinite(headersTimeout) || headersTimeout < 0)) {
          throw new InvalidArgumentError("invalid headersTimeout");
        }
        if (bodyTimeout != null && (!Number.isFinite(bodyTimeout) || bodyTimeout < 0)) {
          throw new InvalidArgumentError("invalid bodyTimeout");
        }
        if (reset != null && typeof reset !== "boolean") {
          throw new InvalidArgumentError("invalid reset");
        }
        if (expectContinue != null && typeof expectContinue !== "boolean") {
          throw new InvalidArgumentError("invalid expectContinue");
        }
        if (throwOnError != null) {
          throw new InvalidArgumentError("invalid throwOnError");
        }
        if (maxRedirections != null && maxRedirections !== 0) {
          throw new InvalidArgumentError("maxRedirections is not supported, use the redirect interceptor");
        }
        this.headersTimeout = headersTimeout;
        this.bodyTimeout = bodyTimeout;
        this.method = method;
        this.abort = null;
        if (body == null) {
          this.body = null;
        } else if (isStream(body)) {
          this.body = body;
          const rState = this.body._readableState;
          if (!rState || !rState.autoDestroy) {
            this.endHandler = function autoDestroy() {
              destroy(this);
            };
            this.body.on("end", this.endHandler);
          }
          this.errorHandler = (err) => {
            if (this.abort) {
              this.abort(err);
            } else {
              this.error = err;
            }
          };
          this.body.on("error", this.errorHandler);
        } else if (isBuffer(body)) {
          this.body = body.byteLength ? body : null;
        } else if (ArrayBuffer.isView(body)) {
          this.body = body.buffer.byteLength ? Buffer.from(body.buffer, body.byteOffset, body.byteLength) : null;
        } else if (body instanceof ArrayBuffer) {
          this.body = body.byteLength ? Buffer.from(body) : null;
        } else if (typeof body === "string") {
          this.body = body.length ? Buffer.from(body) : null;
        } else if (isFormDataLike(body) || isIterable(body) || isBlobLike(body)) {
          this.body = body;
        } else {
          throw new InvalidArgumentError("body must be a string, a Buffer, a Readable stream, an iterable, or an async iterable");
        }
        this.completed = false;
        this.aborted = false;
        this.upgrade = upgrade || null;
        this.path = query ? serializePathWithQuery(path4, query) : path4;
        this.origin = origin;
        this.idempotent = idempotent == null ? method === "HEAD" || method === "GET" : idempotent;
        this.blocking = blocking ?? this.method !== "HEAD";
        this.reset = reset == null ? null : reset;
        this.host = null;
        this.contentLength = null;
        this.contentType = null;
        this.headers = [];
        this.expectContinue = expectContinue != null ? expectContinue : false;
        if (Array.isArray(headers)) {
          if (headers.length % 2 !== 0) {
            throw new InvalidArgumentError("headers array must be even");
          }
          for (let i = 0; i < headers.length; i += 2) {
            processHeader(this, headers[i], headers[i + 1]);
          }
        } else if (headers && typeof headers === "object") {
          if (headers[Symbol.iterator]) {
            for (const header of headers) {
              if (!Array.isArray(header) || header.length !== 2) {
                throw new InvalidArgumentError("headers must be in key-value pair format");
              }
              processHeader(this, header[0], header[1]);
            }
          } else {
            const keys = Object.keys(headers);
            for (let i = 0; i < keys.length; ++i) {
              processHeader(this, keys[i], headers[keys[i]]);
            }
          }
        } else if (headers != null) {
          throw new InvalidArgumentError("headers must be an object or an array");
        }
        assertRequestHandler(handler, method, upgrade);
        this.servername = servername || getServerName(this.host) || null;
        this[kHandler] = handler;
        if (channels.create.hasSubscribers) {
          channels.create.publish({ request: this });
        }
      }
      onBodySent(chunk) {
        if (channels.bodyChunkSent.hasSubscribers) {
          channels.bodyChunkSent.publish({ request: this, chunk });
        }
        if (this[kHandler].onBodySent) {
          try {
            return this[kHandler].onBodySent(chunk);
          } catch (err) {
            this.abort(err);
          }
        }
      }
      onRequestSent() {
        if (channels.bodySent.hasSubscribers) {
          channels.bodySent.publish({ request: this });
        }
        if (this[kHandler].onRequestSent) {
          try {
            return this[kHandler].onRequestSent();
          } catch (err) {
            this.abort(err);
          }
        }
      }
      onConnect(abort) {
        assert(!this.aborted);
        assert(!this.completed);
        if (this.error) {
          abort(this.error);
        } else {
          this.abort = abort;
          return this[kHandler].onConnect(abort);
        }
      }
      onResponseStarted() {
        return this[kHandler].onResponseStarted?.();
      }
      onHeaders(statusCode, headers, resume, statusText) {
        assert(!this.aborted);
        assert(!this.completed);
        if (channels.headers.hasSubscribers) {
          channels.headers.publish({ request: this, response: { statusCode, headers, statusText } });
        }
        try {
          return this[kHandler].onHeaders(statusCode, headers, resume, statusText);
        } catch (err) {
          this.abort(err);
        }
      }
      onData(chunk) {
        assert(!this.aborted);
        assert(!this.completed);
        if (channels.bodyChunkReceived.hasSubscribers) {
          channels.bodyChunkReceived.publish({ request: this, chunk });
        }
        try {
          return this[kHandler].onData(chunk);
        } catch (err) {
          this.abort(err);
          return false;
        }
      }
      onUpgrade(statusCode, headers, socket) {
        assert(!this.aborted);
        assert(!this.completed);
        return this[kHandler].onUpgrade(statusCode, headers, socket);
      }
      onComplete(trailers) {
        this.onFinally();
        assert(!this.aborted);
        assert(!this.completed);
        this.completed = true;
        if (channels.trailers.hasSubscribers) {
          channels.trailers.publish({ request: this, trailers });
        }
        try {
          return this[kHandler].onComplete(trailers);
        } catch (err) {
          this.onError(err);
        }
      }
      onError(error) {
        this.onFinally();
        if (channels.error.hasSubscribers) {
          channels.error.publish({ request: this, error });
        }
        if (this.aborted) {
          return;
        }
        this.aborted = true;
        return this[kHandler].onError(error);
      }
      onFinally() {
        if (this.errorHandler) {
          this.body.off("error", this.errorHandler);
          this.errorHandler = null;
        }
        if (this.endHandler) {
          this.body.off("end", this.endHandler);
          this.endHandler = null;
        }
      }
      addHeader(key, value) {
        processHeader(this, key, value);
        return this;
      }
    };
    function processHeader(request, key, val) {
      if (val && (typeof val === "object" && !Array.isArray(val))) {
        throw new InvalidArgumentError(`invalid ${key} header`);
      } else if (val === void 0) {
        return;
      }
      let headerName = headerNameLowerCasedRecord[key];
      if (headerName === void 0) {
        headerName = key.toLowerCase();
        if (headerNameLowerCasedRecord[headerName] === void 0 && !isValidHTTPToken(headerName)) {
          throw new InvalidArgumentError("invalid header key");
        }
      }
      if (Array.isArray(val)) {
        const arr = [];
        for (let i = 0; i < val.length; i++) {
          if (typeof val[i] === "string") {
            if (!isValidHeaderValue(val[i])) {
              throw new InvalidArgumentError(`invalid ${key} header`);
            }
            arr.push(val[i]);
          } else if (val[i] === null) {
            arr.push("");
          } else if (typeof val[i] === "object") {
            throw new InvalidArgumentError(`invalid ${key} header`);
          } else {
            arr.push(`${val[i]}`);
          }
        }
        val = arr;
      } else if (typeof val === "string") {
        if (!isValidHeaderValue(val)) {
          throw new InvalidArgumentError(`invalid ${key} header`);
        }
      } else if (val === null) {
        val = "";
      } else {
        val = `${val}`;
      }
      if (request.host === null && headerName === "host") {
        if (typeof val !== "string") {
          throw new InvalidArgumentError("invalid host header");
        }
        request.host = val;
      } else if (request.contentLength === null && headerName === "content-length") {
        request.contentLength = parseInt(val, 10);
        if (!Number.isFinite(request.contentLength)) {
          throw new InvalidArgumentError("invalid content-length header");
        }
      } else if (request.contentType === null && headerName === "content-type") {
        request.contentType = val;
        request.headers.push(key, val);
      } else if (headerName === "transfer-encoding" || headerName === "keep-alive" || headerName === "upgrade") {
        throw new InvalidArgumentError(`invalid ${headerName} header`);
      } else if (headerName === "connection") {
        const value = typeof val === "string" ? val.toLowerCase() : null;
        if (value !== "close" && value !== "keep-alive") {
          throw new InvalidArgumentError("invalid connection header");
        }
        if (value === "close") {
          request.reset = true;
        }
      } else if (headerName === "expect") {
        throw new NotSupportedError("expect header not supported");
      } else {
        request.headers.push(key, val);
      }
    }
    module2.exports = Request;
  }
});

// node_modules/undici/lib/handler/wrap-handler.js
var require_wrap_handler = __commonJS({
  "node_modules/undici/lib/handler/wrap-handler.js"(exports2, module2) {
    "use strict";
    var { InvalidArgumentError } = require_errors5();
    module2.exports = class WrapHandler {
      #handler;
      constructor(handler) {
        this.#handler = handler;
      }
      static wrap(handler) {
        return handler.onRequestStart ? handler : new WrapHandler(handler);
      }
      // Unwrap Interface
      onConnect(abort, context) {
        return this.#handler.onConnect?.(abort, context);
      }
      onHeaders(statusCode, rawHeaders, resume, statusMessage) {
        return this.#handler.onHeaders?.(statusCode, rawHeaders, resume, statusMessage);
      }
      onUpgrade(statusCode, rawHeaders, socket) {
        return this.#handler.onUpgrade?.(statusCode, rawHeaders, socket);
      }
      onData(data) {
        return this.#handler.onData?.(data);
      }
      onComplete(trailers) {
        return this.#handler.onComplete?.(trailers);
      }
      onError(err) {
        if (!this.#handler.onError) {
          throw err;
        }
        return this.#handler.onError?.(err);
      }
      // Wrap Interface
      onRequestStart(controller, context) {
        this.#handler.onConnect?.((reason) => controller.abort(reason), context);
      }
      onRequestUpgrade(controller, statusCode, headers, socket) {
        const rawHeaders = [];
        for (const [key, val] of Object.entries(headers)) {
          rawHeaders.push(Buffer.from(key), Array.isArray(val) ? val.map((v) => Buffer.from(v)) : Buffer.from(val));
        }
        this.#handler.onUpgrade?.(statusCode, rawHeaders, socket);
      }
      onResponseStart(controller, statusCode, headers, statusMessage) {
        const rawHeaders = [];
        for (const [key, val] of Object.entries(headers)) {
          rawHeaders.push(Buffer.from(key), Array.isArray(val) ? val.map((v) => Buffer.from(v)) : Buffer.from(val));
        }
        if (this.#handler.onHeaders?.(statusCode, rawHeaders, () => controller.resume(), statusMessage) === false) {
          controller.pause();
        }
      }
      onResponseData(controller, data) {
        if (this.#handler.onData?.(data) === false) {
          controller.pause();
        }
      }
      onResponseEnd(controller, trailers) {
        const rawTrailers = [];
        for (const [key, val] of Object.entries(trailers)) {
          rawTrailers.push(Buffer.from(key), Array.isArray(val) ? val.map((v) => Buffer.from(v)) : Buffer.from(val));
        }
        this.#handler.onComplete?.(rawTrailers);
      }
      onResponseError(controller, err) {
        if (!this.#handler.onError) {
          throw new InvalidArgumentError("invalid onError method");
        }
        this.#handler.onError?.(err);
      }
    };
  }
});

// node_modules/undici/lib/dispatcher/dispatcher.js
var require_dispatcher = __commonJS({
  "node_modules/undici/lib/dispatcher/dispatcher.js"(exports2, module2) {
    "use strict";
    var EventEmitter = require("node:events");
    var WrapHandler = require_wrap_handler();
    var wrapInterceptor = (dispatch) => (opts, handler) => dispatch(opts, WrapHandler.wrap(handler));
    var Dispatcher = class extends EventEmitter {
      dispatch() {
        throw new Error("not implemented");
      }
      close() {
        throw new Error("not implemented");
      }
      destroy() {
        throw new Error("not implemented");
      }
      compose(...args) {
        const interceptors = Array.isArray(args[0]) ? args[0] : args;
        let dispatch = this.dispatch.bind(this);
        for (const interceptor of interceptors) {
          if (interceptor == null) {
            continue;
          }
          if (typeof interceptor !== "function") {
            throw new TypeError(`invalid interceptor, expected function received ${typeof interceptor}`);
          }
          dispatch = interceptor(dispatch);
          dispatch = wrapInterceptor(dispatch);
          if (dispatch == null || typeof dispatch !== "function" || dispatch.length !== 2) {
            throw new TypeError("invalid interceptor");
          }
        }
        return new Proxy(this, {
          get: (target, key) => key === "dispatch" ? dispatch : target[key]
        });
      }
    };
    module2.exports = Dispatcher;
  }
});

// node_modules/undici/lib/handler/unwrap-handler.js
var require_unwrap_handler = __commonJS({
  "node_modules/undici/lib/handler/unwrap-handler.js"(exports2, module2) {
    "use strict";
    var { parseHeaders } = require_util4();
    var { InvalidArgumentError } = require_errors5();
    var kResume = Symbol("resume");
    var UnwrapController = class {
      #paused = false;
      #reason = null;
      #aborted = false;
      #abort;
      [kResume] = null;
      constructor(abort) {
        this.#abort = abort;
      }
      pause() {
        this.#paused = true;
      }
      resume() {
        if (this.#paused) {
          this.#paused = false;
          this[kResume]?.();
        }
      }
      abort(reason) {
        if (!this.#aborted) {
          this.#aborted = true;
          this.#reason = reason;
          this.#abort(reason);
        }
      }
      get aborted() {
        return this.#aborted;
      }
      get reason() {
        return this.#reason;
      }
      get paused() {
        return this.#paused;
      }
    };
    module2.exports = class UnwrapHandler {
      #handler;
      #controller;
      constructor(handler) {
        this.#handler = handler;
      }
      static unwrap(handler) {
        return !handler.onRequestStart ? handler : new UnwrapHandler(handler);
      }
      onConnect(abort, context) {
        this.#controller = new UnwrapController(abort);
        this.#handler.onRequestStart?.(this.#controller, context);
      }
      onUpgrade(statusCode, rawHeaders, socket) {
        this.#handler.onRequestUpgrade?.(this.#controller, statusCode, parseHeaders(rawHeaders), socket);
      }
      onHeaders(statusCode, rawHeaders, resume, statusMessage) {
        this.#controller[kResume] = resume;
        this.#handler.onResponseStart?.(this.#controller, statusCode, parseHeaders(rawHeaders), statusMessage);
        return !this.#controller.paused;
      }
      onData(data) {
        this.#handler.onResponseData?.(this.#controller, data);
        return !this.#controller.paused;
      }
      onComplete(rawTrailers) {
        this.#handler.onResponseEnd?.(this.#controller, parseHeaders(rawTrailers));
      }
      onError(err) {
        if (!this.#handler.onResponseError) {
          throw new InvalidArgumentError("invalid onError method");
        }
        this.#handler.onResponseError?.(this.#controller, err);
      }
    };
  }
});

// node_modules/undici/lib/dispatcher/dispatcher-base.js
var require_dispatcher_base = __commonJS({
  "node_modules/undici/lib/dispatcher/dispatcher-base.js"(exports2, module2) {
    "use strict";
    var Dispatcher = require_dispatcher();
    var UnwrapHandler = require_unwrap_handler();
    var {
      ClientDestroyedError,
      ClientClosedError,
      InvalidArgumentError
    } = require_errors5();
    var { kDestroy, kClose, kClosed, kDestroyed, kDispatch } = require_symbols4();
    var kOnDestroyed = Symbol("onDestroyed");
    var kOnClosed = Symbol("onClosed");
    var DispatcherBase = class extends Dispatcher {
      constructor() {
        super();
        this[kDestroyed] = false;
        this[kOnDestroyed] = null;
        this[kClosed] = false;
        this[kOnClosed] = [];
      }
      get destroyed() {
        return this[kDestroyed];
      }
      get closed() {
        return this[kClosed];
      }
      close(callback) {
        if (callback === void 0) {
          return new Promise((resolve, reject) => {
            this.close((err, data) => {
              return err ? reject(err) : resolve(data);
            });
          });
        }
        if (typeof callback !== "function") {
          throw new InvalidArgumentError("invalid callback");
        }
        if (this[kDestroyed]) {
          queueMicrotask(() => callback(new ClientDestroyedError(), null));
          return;
        }
        if (this[kClosed]) {
          if (this[kOnClosed]) {
            this[kOnClosed].push(callback);
          } else {
            queueMicrotask(() => callback(null, null));
          }
          return;
        }
        this[kClosed] = true;
        this[kOnClosed].push(callback);
        const onClosed = () => {
          const callbacks = this[kOnClosed];
          this[kOnClosed] = null;
          for (let i = 0; i < callbacks.length; i++) {
            callbacks[i](null, null);
          }
        };
        this[kClose]().then(() => this.destroy()).then(() => {
          queueMicrotask(onClosed);
        });
      }
      destroy(err, callback) {
        if (typeof err === "function") {
          callback = err;
          err = null;
        }
        if (callback === void 0) {
          return new Promise((resolve, reject) => {
            this.destroy(err, (err2, data) => {
              return err2 ? (
                /* istanbul ignore next: should never error */
                reject(err2)
              ) : resolve(data);
            });
          });
        }
        if (typeof callback !== "function") {
          throw new InvalidArgumentError("invalid callback");
        }
        if (this[kDestroyed]) {
          if (this[kOnDestroyed]) {
            this[kOnDestroyed].push(callback);
          } else {
            queueMicrotask(() => callback(null, null));
          }
          return;
        }
        if (!err) {
          err = new ClientDestroyedError();
        }
        this[kDestroyed] = true;
        this[kOnDestroyed] = this[kOnDestroyed] || [];
        this[kOnDestroyed].push(callback);
        const onDestroyed = () => {
          const callbacks = this[kOnDestroyed];
          this[kOnDestroyed] = null;
          for (let i = 0; i < callbacks.length; i++) {
            callbacks[i](null, null);
          }
        };
        this[kDestroy](err).then(() => {
          queueMicrotask(onDestroyed);
        });
      }
      dispatch(opts, handler) {
        if (!handler || typeof handler !== "object") {
          throw new InvalidArgumentError("handler must be an object");
        }
        handler = UnwrapHandler.unwrap(handler);
        try {
          if (!opts || typeof opts !== "object") {
            throw new InvalidArgumentError("opts must be an object.");
          }
          if (this[kDestroyed] || this[kOnDestroyed]) {
            throw new ClientDestroyedError();
          }
          if (this[kClosed]) {
            throw new ClientClosedError();
          }
          return this[kDispatch](opts, handler);
        } catch (err) {
          if (typeof handler.onError !== "function") {
            throw err;
          }
          handler.onError(err);
          return false;
        }
      }
    };
    module2.exports = DispatcherBase;
  }
});

// node_modules/undici/lib/core/connect.js
var require_connect = __commonJS({
  "node_modules/undici/lib/core/connect.js"(exports2, module2) {
    "use strict";
    var net = require("node:net");
    var assert = require("node:assert");
    var util = require_util4();
    var { InvalidArgumentError } = require_errors5();
    var tls;
    var SessionCache = class WeakSessionCache {
      constructor(maxCachedSessions) {
        this._maxCachedSessions = maxCachedSessions;
        this._sessionCache = /* @__PURE__ */ new Map();
        this._sessionRegistry = new FinalizationRegistry((key) => {
          if (this._sessionCache.size < this._maxCachedSessions) {
            return;
          }
          const ref = this._sessionCache.get(key);
          if (ref !== void 0 && ref.deref() === void 0) {
            this._sessionCache.delete(key);
          }
        });
      }
      get(sessionKey) {
        const ref = this._sessionCache.get(sessionKey);
        return ref ? ref.deref() : null;
      }
      set(sessionKey, session) {
        if (this._maxCachedSessions === 0) {
          return;
        }
        this._sessionCache.set(sessionKey, new WeakRef(session));
        this._sessionRegistry.register(session, sessionKey);
      }
    };
    function buildConnector({ allowH2, maxCachedSessions, socketPath, timeout, session: customSession, ...opts }) {
      if (maxCachedSessions != null && (!Number.isInteger(maxCachedSessions) || maxCachedSessions < 0)) {
        throw new InvalidArgumentError("maxCachedSessions must be a positive integer or zero");
      }
      const options = { path: socketPath, ...opts };
      const sessionCache = new SessionCache(maxCachedSessions == null ? 100 : maxCachedSessions);
      timeout = timeout == null ? 1e4 : timeout;
      allowH2 = allowH2 != null ? allowH2 : false;
      return function connect({ hostname, host, protocol, port, servername, localAddress, httpSocket }, callback) {
        let socket;
        if (protocol === "https:") {
          if (!tls) {
            tls = require("node:tls");
          }
          servername = servername || options.servername || util.getServerName(host) || null;
          const sessionKey = servername || hostname;
          assert(sessionKey);
          const session = customSession || sessionCache.get(sessionKey) || null;
          port = port || 443;
          socket = tls.connect({
            highWaterMark: 16384,
            // TLS in node can't have bigger HWM anyway...
            ...options,
            servername,
            session,
            localAddress,
            ALPNProtocols: allowH2 ? ["http/1.1", "h2"] : ["http/1.1"],
            socket: httpSocket,
            // upgrade socket connection
            port,
            host: hostname
          });
          socket.on("session", function(session2) {
            sessionCache.set(sessionKey, session2);
          });
        } else {
          assert(!httpSocket, "httpSocket can only be sent on TLS update");
          port = port || 80;
          socket = net.connect({
            highWaterMark: 64 * 1024,
            // Same as nodejs fs streams.
            ...options,
            localAddress,
            port,
            host: hostname
          });
        }
        if (options.keepAlive == null || options.keepAlive) {
          const keepAliveInitialDelay = options.keepAliveInitialDelay === void 0 ? 6e4 : options.keepAliveInitialDelay;
          socket.setKeepAlive(true, keepAliveInitialDelay);
        }
        const clearConnectTimeout = util.setupConnectTimeout(new WeakRef(socket), { timeout, hostname, port });
        socket.setNoDelay(true).once(protocol === "https:" ? "secureConnect" : "connect", function() {
          queueMicrotask(clearConnectTimeout);
          if (callback) {
            const cb = callback;
            callback = null;
            cb(null, this);
          }
        }).on("error", function(err) {
          queueMicrotask(clearConnectTimeout);
          if (callback) {
            const cb = callback;
            callback = null;
            cb(err);
          }
        });
        return socket;
      };
    }
    module2.exports = buildConnector;
  }
});

// node_modules/undici/lib/llhttp/utils.js
var require_utils2 = __commonJS({
  "node_modules/undici/lib/llhttp/utils.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.enumToMap = void 0;
    function enumToMap(obj, filter = [], exceptions = []) {
      var _a, _b;
      const emptyFilter = ((_a = filter === null || filter === void 0 ? void 0 : filter.length) !== null && _a !== void 0 ? _a : 0) === 0;
      const emptyExceptions = ((_b = exceptions === null || exceptions === void 0 ? void 0 : exceptions.length) !== null && _b !== void 0 ? _b : 0) === 0;
      return Object.fromEntries(Object.entries(obj).filter(([, value]) => {
        return typeof value === "number" && (emptyFilter || filter.includes(value)) && (emptyExceptions || !exceptions.includes(value));
      }));
    }
    exports2.enumToMap = enumToMap;
  }
});

// node_modules/undici/lib/llhttp/constants.js
var require_constants4 = __commonJS({
  "node_modules/undici/lib/llhttp/constants.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.SPECIAL_HEADERS = exports2.MINOR = exports2.MAJOR = exports2.HTAB_SP_VCHAR_OBS_TEXT = exports2.QUOTED_STRING = exports2.CONNECTION_TOKEN_CHARS = exports2.HEADER_CHARS = exports2.TOKEN = exports2.HEX = exports2.URL_CHAR = exports2.USERINFO_CHARS = exports2.MARK = exports2.ALPHANUM = exports2.NUM = exports2.HEX_MAP = exports2.NUM_MAP = exports2.ALPHA = exports2.STATUSES_HTTP = exports2.H_METHOD_MAP = exports2.METHOD_MAP = exports2.METHODS_RTSP = exports2.METHODS_ICE = exports2.METHODS_HTTP = exports2.HEADER_STATE = exports2.FINISH = exports2.STATUSES = exports2.METHODS = exports2.LENIENT_FLAGS = exports2.FLAGS = exports2.TYPE = exports2.ERROR = void 0;
    var utils_1 = require_utils2();
    exports2.ERROR = {
      OK: 0,
      INTERNAL: 1,
      STRICT: 2,
      CR_EXPECTED: 25,
      LF_EXPECTED: 3,
      UNEXPECTED_CONTENT_LENGTH: 4,
      UNEXPECTED_SPACE: 30,
      CLOSED_CONNECTION: 5,
      INVALID_METHOD: 6,
      INVALID_URL: 7,
      INVALID_CONSTANT: 8,
      INVALID_VERSION: 9,
      INVALID_HEADER_TOKEN: 10,
      INVALID_CONTENT_LENGTH: 11,
      INVALID_CHUNK_SIZE: 12,
      INVALID_STATUS: 13,
      INVALID_EOF_STATE: 14,
      INVALID_TRANSFER_ENCODING: 15,
      CB_MESSAGE_BEGIN: 16,
      CB_HEADERS_COMPLETE: 17,
      CB_MESSAGE_COMPLETE: 18,
      CB_CHUNK_HEADER: 19,
      CB_CHUNK_COMPLETE: 20,
      PAUSED: 21,
      PAUSED_UPGRADE: 22,
      PAUSED_H2_UPGRADE: 23,
      USER: 24,
      CB_URL_COMPLETE: 26,
      CB_STATUS_COMPLETE: 27,
      CB_METHOD_COMPLETE: 32,
      CB_VERSION_COMPLETE: 33,
      CB_HEADER_FIELD_COMPLETE: 28,
      CB_HEADER_VALUE_COMPLETE: 29,
      CB_CHUNK_EXTENSION_NAME_COMPLETE: 34,
      CB_CHUNK_EXTENSION_VALUE_COMPLETE: 35,
      CB_RESET: 31
    };
    exports2.TYPE = {
      BOTH: 0,
      // default
      REQUEST: 1,
      RESPONSE: 2
    };
    exports2.FLAGS = {
      CONNECTION_KEEP_ALIVE: 1 << 0,
      CONNECTION_CLOSE: 1 << 1,
      CONNECTION_UPGRADE: 1 << 2,
      CHUNKED: 1 << 3,
      UPGRADE: 1 << 4,
      CONTENT_LENGTH: 1 << 5,
      SKIPBODY: 1 << 6,
      TRAILING: 1 << 7,
      // 1 << 8 is unused
      TRANSFER_ENCODING: 1 << 9
    };
    exports2.LENIENT_FLAGS = {
      HEADERS: 1 << 0,
      CHUNKED_LENGTH: 1 << 1,
      KEEP_ALIVE: 1 << 2,
      TRANSFER_ENCODING: 1 << 3,
      VERSION: 1 << 4,
      DATA_AFTER_CLOSE: 1 << 5,
      OPTIONAL_LF_AFTER_CR: 1 << 6,
      OPTIONAL_CRLF_AFTER_CHUNK: 1 << 7,
      OPTIONAL_CR_BEFORE_LF: 1 << 8,
      SPACES_AFTER_CHUNK_SIZE: 1 << 9
    };
    exports2.METHODS = {
      "DELETE": 0,
      "GET": 1,
      "HEAD": 2,
      "POST": 3,
      "PUT": 4,
      /* pathological */
      "CONNECT": 5,
      "OPTIONS": 6,
      "TRACE": 7,
      /* WebDAV */
      "COPY": 8,
      "LOCK": 9,
      "MKCOL": 10,
      "MOVE": 11,
      "PROPFIND": 12,
      "PROPPATCH": 13,
      "SEARCH": 14,
      "UNLOCK": 15,
      "BIND": 16,
      "REBIND": 17,
      "UNBIND": 18,
      "ACL": 19,
      /* subversion */
      "REPORT": 20,
      "MKACTIVITY": 21,
      "CHECKOUT": 22,
      "MERGE": 23,
      /* upnp */
      "M-SEARCH": 24,
      "NOTIFY": 25,
      "SUBSCRIBE": 26,
      "UNSUBSCRIBE": 27,
      /* RFC-5789 */
      "PATCH": 28,
      "PURGE": 29,
      /* CalDAV */
      "MKCALENDAR": 30,
      /* RFC-2068, section 19.6.1.2 */
      "LINK": 31,
      "UNLINK": 32,
      /* icecast */
      "SOURCE": 33,
      /* RFC-7540, section 11.6 */
      "PRI": 34,
      /* RFC-2326 RTSP */
      "DESCRIBE": 35,
      "ANNOUNCE": 36,
      "SETUP": 37,
      "PLAY": 38,
      "PAUSE": 39,
      "TEARDOWN": 40,
      "GET_PARAMETER": 41,
      "SET_PARAMETER": 42,
      "REDIRECT": 43,
      "RECORD": 44,
      /* RAOP */
      "FLUSH": 45,
      /* DRAFT https://www.ietf.org/archive/id/draft-ietf-httpbis-safe-method-w-body-02.html */
      "QUERY": 46
    };
    exports2.STATUSES = {
      CONTINUE: 100,
      SWITCHING_PROTOCOLS: 101,
      PROCESSING: 102,
      EARLY_HINTS: 103,
      RESPONSE_IS_STALE: 110,
      // Unofficial
      REVALIDATION_FAILED: 111,
      // Unofficial
      DISCONNECTED_OPERATION: 112,
      // Unofficial
      HEURISTIC_EXPIRATION: 113,
      // Unofficial
      MISCELLANEOUS_WARNING: 199,
      // Unofficial
      OK: 200,
      CREATED: 201,
      ACCEPTED: 202,
      NON_AUTHORITATIVE_INFORMATION: 203,
      NO_CONTENT: 204,
      RESET_CONTENT: 205,
      PARTIAL_CONTENT: 206,
      MULTI_STATUS: 207,
      ALREADY_REPORTED: 208,
      TRANSFORMATION_APPLIED: 214,
      // Unofficial
      IM_USED: 226,
      MISCELLANEOUS_PERSISTENT_WARNING: 299,
      // Unofficial
      MULTIPLE_CHOICES: 300,
      MOVED_PERMANENTLY: 301,
      FOUND: 302,
      SEE_OTHER: 303,
      NOT_MODIFIED: 304,
      USE_PROXY: 305,
      SWITCH_PROXY: 306,
      // No longer used
      TEMPORARY_REDIRECT: 307,
      PERMANENT_REDIRECT: 308,
      BAD_REQUEST: 400,
      UNAUTHORIZED: 401,
      PAYMENT_REQUIRED: 402,
      FORBIDDEN: 403,
      NOT_FOUND: 404,
      METHOD_NOT_ALLOWED: 405,
      NOT_ACCEPTABLE: 406,
      PROXY_AUTHENTICATION_REQUIRED: 407,
      REQUEST_TIMEOUT: 408,
      CONFLICT: 409,
      GONE: 410,
      LENGTH_REQUIRED: 411,
      PRECONDITION_FAILED: 412,
      PAYLOAD_TOO_LARGE: 413,
      URI_TOO_LONG: 414,
      UNSUPPORTED_MEDIA_TYPE: 415,
      RANGE_NOT_SATISFIABLE: 416,
      EXPECTATION_FAILED: 417,
      IM_A_TEAPOT: 418,
      PAGE_EXPIRED: 419,
      // Unofficial
      ENHANCE_YOUR_CALM: 420,
      // Unofficial
      MISDIRECTED_REQUEST: 421,
      UNPROCESSABLE_ENTITY: 422,
      LOCKED: 423,
      FAILED_DEPENDENCY: 424,
      TOO_EARLY: 425,
      UPGRADE_REQUIRED: 426,
      PRECONDITION_REQUIRED: 428,
      TOO_MANY_REQUESTS: 429,
      REQUEST_HEADER_FIELDS_TOO_LARGE_UNOFFICIAL: 430,
      // Unofficial
      REQUEST_HEADER_FIELDS_TOO_LARGE: 431,
      LOGIN_TIMEOUT: 440,
      // Unofficial
      NO_RESPONSE: 444,
      // Unofficial
      RETRY_WITH: 449,
      // Unofficial
      BLOCKED_BY_PARENTAL_CONTROL: 450,
      // Unofficial
      UNAVAILABLE_FOR_LEGAL_REASONS: 451,
      CLIENT_CLOSED_LOAD_BALANCED_REQUEST: 460,
      // Unofficial
      INVALID_X_FORWARDED_FOR: 463,
      // Unofficial
      REQUEST_HEADER_TOO_LARGE: 494,
      // Unofficial
      SSL_CERTIFICATE_ERROR: 495,
      // Unofficial
      SSL_CERTIFICATE_REQUIRED: 496,
      // Unofficial
      HTTP_REQUEST_SENT_TO_HTTPS_PORT: 497,
      // Unofficial
      INVALID_TOKEN: 498,
      // Unofficial
      CLIENT_CLOSED_REQUEST: 499,
      // Unofficial
      INTERNAL_SERVER_ERROR: 500,
      NOT_IMPLEMENTED: 501,
      BAD_GATEWAY: 502,
      SERVICE_UNAVAILABLE: 503,
      GATEWAY_TIMEOUT: 504,
      HTTP_VERSION_NOT_SUPPORTED: 505,
      VARIANT_ALSO_NEGOTIATES: 506,
      INSUFFICIENT_STORAGE: 507,
      LOOP_DETECTED: 508,
      BANDWIDTH_LIMIT_EXCEEDED: 509,
      NOT_EXTENDED: 510,
      NETWORK_AUTHENTICATION_REQUIRED: 511,
      WEB_SERVER_UNKNOWN_ERROR: 520,
      // Unofficial
      WEB_SERVER_IS_DOWN: 521,
      // Unofficial
      CONNECTION_TIMEOUT: 522,
      // Unofficial
      ORIGIN_IS_UNREACHABLE: 523,
      // Unofficial
      TIMEOUT_OCCURED: 524,
      // Unofficial
      SSL_HANDSHAKE_FAILED: 525,
      // Unofficial
      INVALID_SSL_CERTIFICATE: 526,
      // Unofficial
      RAILGUN_ERROR: 527,
      // Unofficial
      SITE_IS_OVERLOADED: 529,
      // Unofficial
      SITE_IS_FROZEN: 530,
      // Unofficial
      IDENTITY_PROVIDER_AUTHENTICATION_ERROR: 561,
      // Unofficial
      NETWORK_READ_TIMEOUT: 598,
      // Unofficial
      NETWORK_CONNECT_TIMEOUT: 599
      // Unofficial
    };
    exports2.FINISH = {
      SAFE: 0,
      SAFE_WITH_CB: 1,
      UNSAFE: 2
    };
    exports2.HEADER_STATE = {
      GENERAL: 0,
      CONNECTION: 1,
      CONTENT_LENGTH: 2,
      TRANSFER_ENCODING: 3,
      UPGRADE: 4,
      CONNECTION_KEEP_ALIVE: 5,
      CONNECTION_CLOSE: 6,
      CONNECTION_UPGRADE: 7,
      TRANSFER_ENCODING_CHUNKED: 8
    };
    exports2.METHODS_HTTP = [
      exports2.METHODS.DELETE,
      exports2.METHODS.GET,
      exports2.METHODS.HEAD,
      exports2.METHODS.POST,
      exports2.METHODS.PUT,
      exports2.METHODS.CONNECT,
      exports2.METHODS.OPTIONS,
      exports2.METHODS.TRACE,
      exports2.METHODS.COPY,
      exports2.METHODS.LOCK,
      exports2.METHODS.MKCOL,
      exports2.METHODS.MOVE,
      exports2.METHODS.PROPFIND,
      exports2.METHODS.PROPPATCH,
      exports2.METHODS.SEARCH,
      exports2.METHODS.UNLOCK,
      exports2.METHODS.BIND,
      exports2.METHODS.REBIND,
      exports2.METHODS.UNBIND,
      exports2.METHODS.ACL,
      exports2.METHODS.REPORT,
      exports2.METHODS.MKACTIVITY,
      exports2.METHODS.CHECKOUT,
      exports2.METHODS.MERGE,
      exports2.METHODS["M-SEARCH"],
      exports2.METHODS.NOTIFY,
      exports2.METHODS.SUBSCRIBE,
      exports2.METHODS.UNSUBSCRIBE,
      exports2.METHODS.PATCH,
      exports2.METHODS.PURGE,
      exports2.METHODS.MKCALENDAR,
      exports2.METHODS.LINK,
      exports2.METHODS.UNLINK,
      exports2.METHODS.PRI,
      // TODO(indutny): should we allow it with HTTP?
      exports2.METHODS.SOURCE,
      exports2.METHODS.QUERY
    ];
    exports2.METHODS_ICE = [
      exports2.METHODS.SOURCE
    ];
    exports2.METHODS_RTSP = [
      exports2.METHODS.OPTIONS,
      exports2.METHODS.DESCRIBE,
      exports2.METHODS.ANNOUNCE,
      exports2.METHODS.SETUP,
      exports2.METHODS.PLAY,
      exports2.METHODS.PAUSE,
      exports2.METHODS.TEARDOWN,
      exports2.METHODS.GET_PARAMETER,
      exports2.METHODS.SET_PARAMETER,
      exports2.METHODS.REDIRECT,
      exports2.METHODS.RECORD,
      exports2.METHODS.FLUSH,
      // For AirPlay
      exports2.METHODS.GET,
      exports2.METHODS.POST
    ];
    exports2.METHOD_MAP = (0, utils_1.enumToMap)(exports2.METHODS);
    exports2.H_METHOD_MAP = Object.fromEntries(Object.entries(exports2.METHODS).filter(([k]) => k.startsWith("H")));
    exports2.STATUSES_HTTP = [
      exports2.STATUSES.CONTINUE,
      exports2.STATUSES.SWITCHING_PROTOCOLS,
      exports2.STATUSES.PROCESSING,
      exports2.STATUSES.EARLY_HINTS,
      exports2.STATUSES.RESPONSE_IS_STALE,
      exports2.STATUSES.REVALIDATION_FAILED,
      exports2.STATUSES.DISCONNECTED_OPERATION,
      exports2.STATUSES.HEURISTIC_EXPIRATION,
      exports2.STATUSES.MISCELLANEOUS_WARNING,
      exports2.STATUSES.OK,
      exports2.STATUSES.CREATED,
      exports2.STATUSES.ACCEPTED,
      exports2.STATUSES.NON_AUTHORITATIVE_INFORMATION,
      exports2.STATUSES.NO_CONTENT,
      exports2.STATUSES.RESET_CONTENT,
      exports2.STATUSES.PARTIAL_CONTENT,
      exports2.STATUSES.MULTI_STATUS,
      exports2.STATUSES.ALREADY_REPORTED,
      exports2.STATUSES.TRANSFORMATION_APPLIED,
      exports2.STATUSES.IM_USED,
      exports2.STATUSES.MISCELLANEOUS_PERSISTENT_WARNING,
      exports2.STATUSES.MULTIPLE_CHOICES,
      exports2.STATUSES.MOVED_PERMANENTLY,
      exports2.STATUSES.FOUND,
      exports2.STATUSES.SEE_OTHER,
      exports2.STATUSES.NOT_MODIFIED,
      exports2.STATUSES.USE_PROXY,
      exports2.STATUSES.SWITCH_PROXY,
      exports2.STATUSES.TEMPORARY_REDIRECT,
      exports2.STATUSES.PERMANENT_REDIRECT,
      exports2.STATUSES.BAD_REQUEST,
      exports2.STATUSES.UNAUTHORIZED,
      exports2.STATUSES.PAYMENT_REQUIRED,
      exports2.STATUSES.FORBIDDEN,
      exports2.STATUSES.NOT_FOUND,
      exports2.STATUSES.METHOD_NOT_ALLOWED,
      exports2.STATUSES.NOT_ACCEPTABLE,
      exports2.STATUSES.PROXY_AUTHENTICATION_REQUIRED,
      exports2.STATUSES.REQUEST_TIMEOUT,
      exports2.STATUSES.CONFLICT,
      exports2.STATUSES.GONE,
      exports2.STATUSES.LENGTH_REQUIRED,
      exports2.STATUSES.PRECONDITION_FAILED,
      exports2.STATUSES.PAYLOAD_TOO_LARGE,
      exports2.STATUSES.URI_TOO_LONG,
      exports2.STATUSES.UNSUPPORTED_MEDIA_TYPE,
      exports2.STATUSES.RANGE_NOT_SATISFIABLE,
      exports2.STATUSES.EXPECTATION_FAILED,
      exports2.STATUSES.IM_A_TEAPOT,
      exports2.STATUSES.PAGE_EXPIRED,
      exports2.STATUSES.ENHANCE_YOUR_CALM,
      exports2.STATUSES.MISDIRECTED_REQUEST,
      exports2.STATUSES.UNPROCESSABLE_ENTITY,
      exports2.STATUSES.LOCKED,
      exports2.STATUSES.FAILED_DEPENDENCY,
      exports2.STATUSES.TOO_EARLY,
      exports2.STATUSES.UPGRADE_REQUIRED,
      exports2.STATUSES.PRECONDITION_REQUIRED,
      exports2.STATUSES.TOO_MANY_REQUESTS,
      exports2.STATUSES.REQUEST_HEADER_FIELDS_TOO_LARGE_UNOFFICIAL,
      exports2.STATUSES.REQUEST_HEADER_FIELDS_TOO_LARGE,
      exports2.STATUSES.LOGIN_TIMEOUT,
      exports2.STATUSES.NO_RESPONSE,
      exports2.STATUSES.RETRY_WITH,
      exports2.STATUSES.BLOCKED_BY_PARENTAL_CONTROL,
      exports2.STATUSES.UNAVAILABLE_FOR_LEGAL_REASONS,
      exports2.STATUSES.CLIENT_CLOSED_LOAD_BALANCED_REQUEST,
      exports2.STATUSES.INVALID_X_FORWARDED_FOR,
      exports2.STATUSES.REQUEST_HEADER_TOO_LARGE,
      exports2.STATUSES.SSL_CERTIFICATE_ERROR,
      exports2.STATUSES.SSL_CERTIFICATE_REQUIRED,
      exports2.STATUSES.HTTP_REQUEST_SENT_TO_HTTPS_PORT,
      exports2.STATUSES.INVALID_TOKEN,
      exports2.STATUSES.CLIENT_CLOSED_REQUEST,
      exports2.STATUSES.INTERNAL_SERVER_ERROR,
      exports2.STATUSES.NOT_IMPLEMENTED,
      exports2.STATUSES.BAD_GATEWAY,
      exports2.STATUSES.SERVICE_UNAVAILABLE,
      exports2.STATUSES.GATEWAY_TIMEOUT,
      exports2.STATUSES.HTTP_VERSION_NOT_SUPPORTED,
      exports2.STATUSES.VARIANT_ALSO_NEGOTIATES,
      exports2.STATUSES.INSUFFICIENT_STORAGE,
      exports2.STATUSES.LOOP_DETECTED,
      exports2.STATUSES.BANDWIDTH_LIMIT_EXCEEDED,
      exports2.STATUSES.NOT_EXTENDED,
      exports2.STATUSES.NETWORK_AUTHENTICATION_REQUIRED,
      exports2.STATUSES.WEB_SERVER_UNKNOWN_ERROR,
      exports2.STATUSES.WEB_SERVER_IS_DOWN,
      exports2.STATUSES.CONNECTION_TIMEOUT,
      exports2.STATUSES.ORIGIN_IS_UNREACHABLE,
      exports2.STATUSES.TIMEOUT_OCCURED,
      exports2.STATUSES.SSL_HANDSHAKE_FAILED,
      exports2.STATUSES.INVALID_SSL_CERTIFICATE,
      exports2.STATUSES.RAILGUN_ERROR,
      exports2.STATUSES.SITE_IS_OVERLOADED,
      exports2.STATUSES.SITE_IS_FROZEN,
      exports2.STATUSES.IDENTITY_PROVIDER_AUTHENTICATION_ERROR,
      exports2.STATUSES.NETWORK_READ_TIMEOUT,
      exports2.STATUSES.NETWORK_CONNECT_TIMEOUT
    ];
    exports2.ALPHA = [];
    for (let i = "A".charCodeAt(0); i <= "Z".charCodeAt(0); i++) {
      exports2.ALPHA.push(String.fromCharCode(i));
      exports2.ALPHA.push(String.fromCharCode(i + 32));
    }
    exports2.NUM_MAP = {
      0: 0,
      1: 1,
      2: 2,
      3: 3,
      4: 4,
      5: 5,
      6: 6,
      7: 7,
      8: 8,
      9: 9
    };
    exports2.HEX_MAP = {
      0: 0,
      1: 1,
      2: 2,
      3: 3,
      4: 4,
      5: 5,
      6: 6,
      7: 7,
      8: 8,
      9: 9,
      A: 10,
      B: 11,
      C: 12,
      D: 13,
      E: 14,
      F: 15,
      a: 10,
      b: 11,
      c: 12,
      d: 13,
      e: 14,
      f: 15
    };
    exports2.NUM = [
      "0",
      "1",
      "2",
      "3",
      "4",
      "5",
      "6",
      "7",
      "8",
      "9"
    ];
    exports2.ALPHANUM = exports2.ALPHA.concat(exports2.NUM);
    exports2.MARK = ["-", "_", ".", "!", "~", "*", "'", "(", ")"];
    exports2.USERINFO_CHARS = exports2.ALPHANUM.concat(exports2.MARK).concat(["%", ";", ":", "&", "=", "+", "$", ","]);
    exports2.URL_CHAR = [
      "!",
      '"',
      "$",
      "%",
      "&",
      "'",
      "(",
      ")",
      "*",
      "+",
      ",",
      "-",
      ".",
      "/",
      ":",
      ";",
      "<",
      "=",
      ">",
      "@",
      "[",
      "\\",
      "]",
      "^",
      "_",
      "`",
      "{",
      "|",
      "}",
      "~"
    ].concat(exports2.ALPHANUM);
    exports2.HEX = exports2.NUM.concat(["a", "b", "c", "d", "e", "f", "A", "B", "C", "D", "E", "F"]);
    exports2.TOKEN = [
      "!",
      "#",
      "$",
      "%",
      "&",
      "'",
      "*",
      "+",
      "-",
      ".",
      "^",
      "_",
      "`",
      "|",
      "~"
    ].concat(exports2.ALPHANUM);
    exports2.HEADER_CHARS = ["	"];
    for (let i = 32; i <= 255; i++) {
      if (i !== 127) {
        exports2.HEADER_CHARS.push(i);
      }
    }
    exports2.CONNECTION_TOKEN_CHARS = exports2.HEADER_CHARS.filter((c) => c !== 44);
    exports2.QUOTED_STRING = ["	", " "];
    for (let i = 33; i <= 255; i++) {
      if (i !== 34 && i !== 92) {
        exports2.QUOTED_STRING.push(i);
      }
    }
    exports2.HTAB_SP_VCHAR_OBS_TEXT = ["	", " "];
    for (let i = 33; i <= 126; i++) {
      exports2.HTAB_SP_VCHAR_OBS_TEXT.push(i);
    }
    for (let i = 128; i <= 255; i++) {
      exports2.HTAB_SP_VCHAR_OBS_TEXT.push(i);
    }
    exports2.MAJOR = exports2.NUM_MAP;
    exports2.MINOR = exports2.MAJOR;
    exports2.SPECIAL_HEADERS = {
      "connection": exports2.HEADER_STATE.CONNECTION,
      "content-length": exports2.HEADER_STATE.CONTENT_LENGTH,
      "proxy-connection": exports2.HEADER_STATE.CONNECTION,
      "transfer-encoding": exports2.HEADER_STATE.TRANSFER_ENCODING,
      "upgrade": exports2.HEADER_STATE.UPGRADE
    };
  }
});

// node_modules/undici/lib/llhttp/llhttp-wasm.js
var require_llhttp_wasm = __commonJS({
  "node_modules/undici/lib/llhttp/llhttp-wasm.js"(exports2, module2) {
    "use strict";
    var { Buffer: Buffer2 } = require("node:buffer");
    var wasmBase64 = "AGFzbQEAAAABJwdgAX8Bf2ADf39/AX9gAn9/AGABfwBgBH9/f38Bf2AAAGADf39/AALLAQgDZW52GHdhc21fb25faGVhZGVyc19jb21wbGV0ZQAEA2VudhV3YXNtX29uX21lc3NhZ2VfYmVnaW4AAANlbnYLd2FzbV9vbl91cmwAAQNlbnYOd2FzbV9vbl9zdGF0dXMAAQNlbnYUd2FzbV9vbl9oZWFkZXJfZmllbGQAAQNlbnYUd2FzbV9vbl9oZWFkZXJfdmFsdWUAAQNlbnYMd2FzbV9vbl9ib2R5AAEDZW52GHdhc21fb25fbWVzc2FnZV9jb21wbGV0ZQAAAzQzBQYAAAMAAAAAAAADAQMAAwMDAAACAAAAAAICAgICAgICAgIBAQEBAQEBAQEDAAADAAAABAUBcAESEgUDAQACBggBfwFBgNgECwfFBygGbWVtb3J5AgALX2luaXRpYWxpemUACBlfX2luZGlyZWN0X2Z1bmN0aW9uX3RhYmxlAQALbGxodHRwX2luaXQACRhsbGh0dHBfc2hvdWxkX2tlZXBfYWxpdmUANgxsbGh0dHBfYWxsb2MACwZtYWxsb2MAOAtsbGh0dHBfZnJlZQAMBGZyZWUADA9sbGh0dHBfZ2V0X3R5cGUADRVsbGh0dHBfZ2V0X2h0dHBfbWFqb3IADhVsbGh0dHBfZ2V0X2h0dHBfbWlub3IADxFsbGh0dHBfZ2V0X21ldGhvZAAQFmxsaHR0cF9nZXRfc3RhdHVzX2NvZGUAERJsbGh0dHBfZ2V0X3VwZ3JhZGUAEgxsbGh0dHBfcmVzZXQAEw5sbGh0dHBfZXhlY3V0ZQAUFGxsaHR0cF9zZXR0aW5nc19pbml0ABUNbGxodHRwX2ZpbmlzaAAWDGxsaHR0cF9wYXVzZQAXDWxsaHR0cF9yZXN1bWUAGBtsbGh0dHBfcmVzdW1lX2FmdGVyX3VwZ3JhZGUAGRBsbGh0dHBfZ2V0X2Vycm5vABoXbGxodHRwX2dldF9lcnJvcl9yZWFzb24AGxdsbGh0dHBfc2V0X2Vycm9yX3JlYXNvbgAcFGxsaHR0cF9nZXRfZXJyb3JfcG9zAB0RbGxodHRwX2Vycm5vX25hbWUAHhJsbGh0dHBfbWV0aG9kX25hbWUAHxJsbGh0dHBfc3RhdHVzX25hbWUAIBpsbGh0dHBfc2V0X2xlbmllbnRfaGVhZGVycwAhIWxsaHR0cF9zZXRfbGVuaWVudF9jaHVua2VkX2xlbmd0aAAiHWxsaHR0cF9zZXRfbGVuaWVudF9rZWVwX2FsaXZlACMkbGxodHRwX3NldF9sZW5pZW50X3RyYW5zZmVyX2VuY29kaW5nACQabGxodHRwX3NldF9sZW5pZW50X3ZlcnNpb24AJSNsbGh0dHBfc2V0X2xlbmllbnRfZGF0YV9hZnRlcl9jbG9zZQAmJ2xsaHR0cF9zZXRfbGVuaWVudF9vcHRpb25hbF9sZl9hZnRlcl9jcgAnLGxsaHR0cF9zZXRfbGVuaWVudF9vcHRpb25hbF9jcmxmX2FmdGVyX2NodW5rACgobGxodHRwX3NldF9sZW5pZW50X29wdGlvbmFsX2NyX2JlZm9yZV9sZgApKmxsaHR0cF9zZXRfbGVuaWVudF9zcGFjZXNfYWZ0ZXJfY2h1bmtfc2l6ZQAqGGxsaHR0cF9tZXNzYWdlX25lZWRzX2VvZgA1CRcBAEEBCxEBAgMEBQoGBzEzMi0uLCsvMAq8ywIzFgBB/NMAKAIABEAAC0H80wBBATYCAAsUACAAEDcgACACNgI4IAAgAToAKAsUACAAIAAvATQgAC0AMCAAEDYQAAseAQF/QcAAEDkiARA3IAFBgAg2AjggASAAOgAoIAELjwwBB38CQCAARQ0AIABBCGsiASAAQQRrKAIAIgBBeHEiBGohBQJAIABBAXENACAAQQNxRQ0BIAEgASgCACIAayIBQZDUACgCAEkNASAAIARqIQQCQAJAQZTUACgCACABRwRAIABB/wFNBEAgAEEDdiEDIAEoAggiACABKAIMIgJGBEBBgNQAQYDUACgCAEF+IAN3cTYCAAwFCyACIAA2AgggACACNgIMDAQLIAEoAhghBiABIAEoAgwiAEcEQCAAIAEoAggiAjYCCCACIAA2AgwMAwsgAUEUaiIDKAIAIgJFBEAgASgCECICRQ0CIAFBEGohAwsDQCADIQcgAiIAQRRqIgMoAgAiAg0AIABBEGohAyAAKAIQIgINAAsgB0EANgIADAILIAUoAgQiAEEDcUEDRw0CIAUgAEF+cTYCBEGI1AAgBDYCACAFIAQ2AgAgASAEQQFyNgIEDAMLQQAhAAsgBkUNAAJAIAEoAhwiAkECdEGw1gBqIgMoAgAgAUYEQCADIAA2AgAgAA0BQYTUAEGE1AAoAgBBfiACd3E2AgAMAgsgBkEQQRQgBigCECABRhtqIAA2AgAgAEUNAQsgACAGNgIYIAEoAhAiAgRAIAAgAjYCECACIAA2AhgLIAFBFGooAgAiAkUNACAAQRRqIAI2AgAgAiAANgIYCyABIAVPDQAgBSgCBCIAQQFxRQ0AAkACQAJAAkAgAEECcUUEQEGY1AAoAgAgBUYEQEGY1AAgATYCAEGM1ABBjNQAKAIAIARqIgA2AgAgASAAQQFyNgIEIAFBlNQAKAIARw0GQYjUAEEANgIAQZTUAEEANgIADAYLQZTUACgCACAFRgRAQZTUACABNgIAQYjUAEGI1AAoAgAgBGoiADYCACABIABBAXI2AgQgACABaiAANgIADAYLIABBeHEgBGohBCAAQf8BTQRAIABBA3YhAyAFKAIIIgAgBSgCDCICRgRAQYDUAEGA1AAoAgBBfiADd3E2AgAMBQsgAiAANgIIIAAgAjYCDAwECyAFKAIYIQYgBSAFKAIMIgBHBEBBkNQAKAIAGiAAIAUoAggiAjYCCCACIAA2AgwMAwsgBUEUaiIDKAIAIgJFBEAgBSgCECICRQ0CIAVBEGohAwsDQCADIQcgAiIAQRRqIgMoAgAiAg0AIABBEGohAyAAKAIQIgINAAsgB0EANgIADAILIAUgAEF+cTYCBCABIARqIAQ2AgAgASAEQQFyNgIEDAMLQQAhAAsgBkUNAAJAIAUoAhwiAkECdEGw1gBqIgMoAgAgBUYEQCADIAA2AgAgAA0BQYTUAEGE1AAoAgBBfiACd3E2AgAMAgsgBkEQQRQgBigCECAFRhtqIAA2AgAgAEUNAQsgACAGNgIYIAUoAhAiAgRAIAAgAjYCECACIAA2AhgLIAVBFGooAgAiAkUNACAAQRRqIAI2AgAgAiAANgIYCyABIARqIAQ2AgAgASAEQQFyNgIEIAFBlNQAKAIARw0AQYjUACAENgIADAELIARB/wFNBEAgBEF4cUGo1ABqIQACf0GA1AAoAgAiAkEBIARBA3Z0IgNxRQRAQYDUACACIANyNgIAIAAMAQsgACgCCAsiAiABNgIMIAAgATYCCCABIAA2AgwgASACNgIIDAELQR8hAiAEQf///wdNBEAgBEEmIARBCHZnIgBrdkEBcSAAQQF0a0E+aiECCyABIAI2AhwgAUIANwIQIAJBAnRBsNYAaiEAAkBBhNQAKAIAIgNBASACdCIHcUUEQCAAIAE2AgBBhNQAIAMgB3I2AgAgASAANgIYIAEgATYCCCABIAE2AgwMAQsgBEEZIAJBAXZrQQAgAkEfRxt0IQIgACgCACEAAkADQCAAIgMoAgRBeHEgBEYNASACQR12IQAgAkEBdCECIAMgAEEEcWpBEGoiBygCACIADQALIAcgATYCACABIAM2AhggASABNgIMIAEgATYCCAwBCyADKAIIIgAgATYCDCADIAE2AgggAUEANgIYIAEgAzYCDCABIAA2AggLQaDUAEGg1AAoAgBBAWsiAEF/IAAbNgIACwsHACAALQAoCwcAIAAtACoLBwAgAC0AKwsHACAALQApCwcAIAAvATQLBwAgAC0AMAtAAQR/IAAoAhghASAALwEuIQIgAC0AKCEDIAAoAjghBCAAEDcgACAENgI4IAAgAzoAKCAAIAI7AS4gACABNgIYC8X4AQIHfwN+IAEgAmohBAJAIAAiAygCDCIADQAgAygCBARAIAMgATYCBAsjAEEQayIJJAACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAn8CQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkAgAygCHCICQQFrDuwB7gEB6AECAwQFBgcICQoLDA0ODxAREucBE+YBFBXlARYX5AEYGRobHB0eHyDvAe0BIeMBIiMkJSYnKCkqK+IBLC0uLzAxMuEB4AEzNN8B3gE1Njc4OTo7PD0+P0BBQkNERUZHSElKS0xNTk/pAVBRUlPdAdwBVNsBVdoBVldYWVpbXF1eX2BhYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5ent8fX5/gAGBAYIBgwGEAYUBhgGHAYgBiQGKAYsBjAGNAY4BjwGQAZEBkgGTAZQBlQGWAZcBmAGZAZoBmwGcAZ0BngGfAaABoQGiAaMBpAGlAaYBpwGoAakBqgGrAawBrQGuAa8BsAGxAbIBswG0AbUBtgG3AbgBuQG6AbsBvAG9Ab4BvwHAAcEBwgHDAcQBxQHZAdgBxgHXAccB1gHIAckBygHLAcwBzQHOAc8B0AHRAdIB0wHUAQDqAQtBAAzUAQtBDgzTAQtBDQzSAQtBDwzRAQtBEAzQAQtBEQzPAQtBEgzOAQtBEwzNAQtBFAzMAQtBFQzLAQtBFgzKAQtBFwzJAQtBGAzIAQtBGQzHAQtBGgzGAQtBGwzFAQtBHAzEAQtBHQzDAQtBHgzCAQtBHwzBAQtBCAzAAQtBIAy/AQtBIgy+AQtBIQy9AQtBBwy8AQtBIwy7AQtBJAy6AQtBJQy5AQtBJgy4AQtBJwy3AQtBzgEMtgELQSgMtQELQSkMtAELQSoMswELQSsMsgELQc8BDLEBC0EtDLABC0EuDK8BC0EvDK4BC0EwDK0BC0ExDKwBC0EyDKsBC0EzDKoBC0HQAQypAQtBNAyoAQtBOAynAQtBDAymAQtBNQylAQtBNgykAQtBNwyjAQtBPQyiAQtBOQyhAQtB0QEMoAELQQsMnwELQT4MngELQToMnQELQQoMnAELQTsMmwELQTwMmgELQdIBDJkBC0HAAAyYAQtBPwyXAQtBwQAMlgELQQkMlQELQSwMlAELQcIADJMBC0HDAAySAQtBxAAMkQELQcUADJABC0HGAAyPAQtBxwAMjgELQcgADI0BC0HJAAyMAQtBygAMiwELQcsADIoBC0HMAAyJAQtBzQAMiAELQc4ADIcBC0HPAAyGAQtB0AAMhQELQdEADIQBC0HSAAyDAQtB1AAMggELQdMADIEBC0HVAAyAAQtB1gAMfwtB1wAMfgtB2AAMfQtB2QAMfAtB2gAMewtB2wAMegtB0wEMeQtB3AAMeAtB3QAMdwtBBgx2C0HeAAx1C0EFDHQLQd8ADHMLQQQMcgtB4AAMcQtB4QAMcAtB4gAMbwtB4wAMbgtBAwxtC0HkAAxsC0HlAAxrC0HmAAxqC0HoAAxpC0HnAAxoC0HpAAxnC0HqAAxmC0HrAAxlC0HsAAxkC0ECDGMLQe0ADGILQe4ADGELQe8ADGALQfAADF8LQfEADF4LQfIADF0LQfMADFwLQfQADFsLQfUADFoLQfYADFkLQfcADFgLQfgADFcLQfkADFYLQfoADFULQfsADFQLQfwADFMLQf0ADFILQf4ADFELQf8ADFALQYABDE8LQYEBDE4LQYIBDE0LQYMBDEwLQYQBDEsLQYUBDEoLQYYBDEkLQYcBDEgLQYgBDEcLQYkBDEYLQYoBDEULQYsBDEQLQYwBDEMLQY0BDEILQY4BDEELQY8BDEALQZABDD8LQZEBDD4LQZIBDD0LQZMBDDwLQZQBDDsLQZUBDDoLQZYBDDkLQZcBDDgLQZgBDDcLQZkBDDYLQZoBDDULQZsBDDQLQZwBDDMLQZ0BDDILQZ4BDDELQZ8BDDALQaABDC8LQaEBDC4LQaIBDC0LQaMBDCwLQaQBDCsLQaUBDCoLQaYBDCkLQacBDCgLQagBDCcLQakBDCYLQaoBDCULQasBDCQLQawBDCMLQa0BDCILQa4BDCELQa8BDCALQbABDB8LQbEBDB4LQbIBDB0LQbMBDBwLQbQBDBsLQbUBDBoLQbYBDBkLQbcBDBgLQbgBDBcLQQEMFgtBuQEMFQtBugEMFAtBuwEMEwtBvAEMEgtBvQEMEQtBvgEMEAtBvwEMDwtBwAEMDgtBwQEMDQtBwgEMDAtBwwEMCwtBxAEMCgtBxQEMCQtBxgEMCAtB1AEMBwtBxwEMBgtByAEMBQtByQEMBAtBygEMAwtBywEMAgtBzQEMAQtBzAELIQIDQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAIAMCfwJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACfwJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAn8CQAJAAkACQAJAAkACQAJ/AkACQAJAAn8CQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAIAMCfwJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACfwJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQCACDtQBAAECAwQFBgcICQoLDA0ODxARFBUWFxgZGhscHR4fICEjJCUnKCmIA4cDhQOEA/wC9QLuAusC6ALmAuMC4ALfAt0C2wLWAtUC1ALTAtICygLJAsgCxwLGAsUCxALDAr0CvAK6ArkCuAK3ArYCtQK0ArICsQKsAqoCqAKnAqYCpQKkAqMCogKhAqACnwKbApoCmQKYApcCkAKIAoQCgwKCAvkB9gH1AfQB8wHyAfEB8AHvAe0B6wHoAeMB4QHgAd8B3gHdAdwB2wHaAdkB2AHXAdYB1QHUAdIB0QHQAc8BzgHNAcwBywHKAckByAHHAcYBxQHEAcMBwgHBAcABvwG+Ab0BvAG7AboBuQG4AbcBtgG1AbQBswGyAbEBsAGvAa4BrQGsAasBqgGpAagBpwGmAaUBpAGjAaIBoQGgAZ8BngGdAZwBmwGaAZcBlgGRAZABjwGOAY0BjAGLAYoBiQGIAYUBhAGDAX59fHt6d3Z1LFFSU1RVVgsgASAERw1zQewBIQIMqQMLIAEgBEcNkAFB0QEhAgyoAwsgASAERw3pAUGEASECDKcDCyABIARHDfQBQfoAIQIMpgMLIAEgBEcNggJB9QAhAgylAwsgASAERw2JAkHzACECDKQDCyABIARHDYwCQfEAIQIMowMLIAEgBEcNHkEeIQIMogMLIAEgBEcNGUEYIQIMoQMLIAEgBEcNuAJBzQAhAgygAwsgASAERw3DAkHGACECDJ8DCyABIARHDcQCQcMAIQIMngMLIAEgBEcNygJBOCECDJ0DCyADLQAwQQFGDZUDDPICC0EAIQACQAJAAkAgAy0AKkUNACADLQArRQ0AIAMvATIiAkECcUUNAQwCCyADLwEyIgJBAXFFDQELQQEhACADLQAoQQFGDQAgAy8BNCIGQeQAa0HkAEkNACAGQcwBRg0AIAZBsAJGDQAgAkHAAHENAEEAIQAgAkGIBHFBgARGDQAgAkEocUEARyEACyADQQA7ATIgA0EAOgAxAkAgAEUEQCADQQA6ADEgAy0ALkEEcQ0BDJwDCyADQgA3AyALIANBADoAMSADQQE6ADYMSQtBACEAAkAgAygCOCICRQ0AIAIoAiwiAkUNACADIAIRAAAhAAsgAEUNSSAAQRVHDWMgA0EENgIcIAMgATYCFCADQb0aNgIQIANBFTYCDEEAIQIMmgMLIAEgBEYEQEEGIQIMmgMLIAEtAABBCkYNGQwBCyABIARGBEBBByECDJkDCwJAIAEtAABBCmsOBAIBAQABCyABQQFqIQFBECECDP4CCyADLQAuQYABcQ0YQQAhAiADQQA2AhwgAyABNgIUIANBqR82AhAgA0ECNgIMDJcDCyABQQFqIQEgA0Evai0AAEEBcQ0XQQAhAiADQQA2AhwgAyABNgIUIANBhB82AhAgA0EZNgIMDJYDCyADIAMpAyAiDCAEIAFrrSIKfSILQgAgCyAMWBs3AyAgCiAMWg0ZQQghAgyVAwsgASAERwRAIANBCTYCCCADIAE2AgRBEiECDPsCC0EJIQIMlAMLIAMpAyBQDZwCDEQLIAEgBEYEQEELIQIMkwMLIAEtAABBCkcNFyABQQFqIQEMGAsgA0Evai0AAEEBcUUNGgwnC0EAIQACQCADKAI4IgJFDQAgAigCSCICRQ0AIAMgAhEAACEACyAADRoMQwtBACEAAkAgAygCOCICRQ0AIAIoAkgiAkUNACADIAIRAAAhAAsgAA0bDCULQQAhAAJAIAMoAjgiAkUNACACKAJIIgJFDQAgAyACEQAAIQALIAANHAwzCyADQS9qLQAAQQFxRQ0dDCMLQQAhAAJAIAMoAjgiAkUNACACKAJMIgJFDQAgAyACEQAAIQALIAANHQxDC0EAIQACQCADKAI4IgJFDQAgAigCTCICRQ0AIAMgAhEAACEACyAADR4MIQsgASAERgRAQRMhAgyLAwsCQCABLQAAIgBBCmsOBCAkJAAjCyABQQFqIQEMIAtBACEAAkAgAygCOCICRQ0AIAIoAkwiAkUNACADIAIRAAAhAAsgAA0jDEMLIAEgBEYEQEEWIQIMiQMLIAEtAABB8D9qLQAAQQFHDSQM7QILAkADQCABLQAAQeA5ai0AACIAQQFHBEACQCAAQQJrDgIDACgLIAFBAWohAUEfIQIM8AILIAQgAUEBaiIBRw0AC0EYIQIMiAMLIAMoAgQhAEEAIQIgA0EANgIEIAMgACABQQFqIgEQMyIADSIMQgtBACEAAkAgAygCOCICRQ0AIAIoAkwiAkUNACADIAIRAAAhAAsgAA0kDCsLIAEgBEYEQEEcIQIMhgMLIANBCjYCCCADIAE2AgRBACEAAkAgAygCOCICRQ0AIAIoAkgiAkUNACADIAIRAAAhAAsgAA0mQSIhAgzrAgsgASAERwRAA0AgAS0AAEHgO2otAAAiAEEDRwRAIABBAWsOBRkbJ+wCJicLIAQgAUEBaiIBRw0AC0EbIQIMhQMLQRshAgyEAwsDQCABLQAAQeA9ai0AACIAQQNHBEAgAEEBaw4FEBIoFCcoCyAEIAFBAWoiAUcNAAtBHiECDIMDCyABIARHBEAgA0ELNgIIIAMgATYCBEEHIQIM6QILQR8hAgyCAwsgASAERgRAQSAhAgyCAwsCQCABLQAAQQ1rDhQvQEBAQEBAQEBAQEBAQEBAQEBAAEALQQAhAiADQQA2AhwgA0G3CzYCECADQQI2AgwgAyABQQFqNgIUDIEDCyADQS9qIQIDQCABIARGBEBBISECDIIDCwJAAkACQCABLQAAIgBBCWsOGAIAKioBKioqKioqKioqKioqKioqKioqAigLIAFBAWohASADQS9qLQAAQQFxRQ0LDBkLIAFBAWohAQwYCyABQQFqIQEgAi0AAEECcQ0AC0EAIQIgA0EANgIcIAMgATYCFCADQc4UNgIQIANBDDYCDAyAAwsgAUEBaiEBC0EAIQACQCADKAI4IgJFDQAgAigCVCICRQ0AIAMgAhEAACEACyAADQEM0QILIANCADcDIAw8CyAAQRVGBEAgA0EkNgIcIAMgATYCFCADQYYaNgIQIANBFTYCDEEAIQIM/QILQQAhAiADQQA2AhwgAyABNgIUIANB4g02AhAgA0EUNgIMDPwCCyADKAIEIQBBACECIANBADYCBCADIAAgASAMp2oiARAxIgBFDSsgA0EHNgIcIAMgATYCFCADIAA2AgwM+wILIAMtAC5BwABxRQ0BC0EAIQACQCADKAI4IgJFDQAgAigCUCICRQ0AIAMgAhEAACEACyAARQ0rIABBFUYEQCADQQo2AhwgAyABNgIUIANB8Rg2AhAgA0EVNgIMQQAhAgz6AgtBACECIANBADYCHCADIAE2AhQgA0GLDDYCECADQRM2AgwM+QILQQAhAiADQQA2AhwgAyABNgIUIANBsRQ2AhAgA0ECNgIMDPgCC0EAIQIgA0EANgIcIAMgATYCFCADQYwUNgIQIANBGTYCDAz3AgtBACECIANBADYCHCADIAE2AhQgA0HRHDYCECADQRk2AgwM9gILIABBFUYNPUEAIQIgA0EANgIcIAMgATYCFCADQaIPNgIQIANBIjYCDAz1AgsgAygCBCEAQQAhAiADQQA2AgQgAyAAIAEQMiIARQ0oIANBDTYCHCADIAE2AhQgAyAANgIMDPQCCyAAQRVGDTpBACECIANBADYCHCADIAE2AhQgA0GiDzYCECADQSI2AgwM8wILIAMoAgQhAEEAIQIgA0EANgIEIAMgACABEDIiAEUEQCABQQFqIQEMKAsgA0EONgIcIAMgADYCDCADIAFBAWo2AhQM8gILIABBFUYNN0EAIQIgA0EANgIcIAMgATYCFCADQaIPNgIQIANBIjYCDAzxAgsgAygCBCEAQQAhAiADQQA2AgQgAyAAIAEQMiIARQRAIAFBAWohAQwnCyADQQ82AhwgAyAANgIMIAMgAUEBajYCFAzwAgtBACECIANBADYCHCADIAE2AhQgA0HoFjYCECADQRk2AgwM7wILIABBFUYNM0EAIQIgA0EANgIcIAMgATYCFCADQc4MNgIQIANBIzYCDAzuAgsgAygCBCEAQQAhAiADQQA2AgQgAyAAIAEQMyIARQ0lIANBETYCHCADIAE2AhQgAyAANgIMDO0CCyAAQRVGDTBBACECIANBADYCHCADIAE2AhQgA0HODDYCECADQSM2AgwM7AILIAMoAgQhAEEAIQIgA0EANgIEIAMgACABEDMiAEUEQCABQQFqIQEMJQsgA0ESNgIcIAMgADYCDCADIAFBAWo2AhQM6wILIANBL2otAABBAXFFDQELQRUhAgzPAgtBACECIANBADYCHCADIAE2AhQgA0HoFjYCECADQRk2AgwM6AILIABBO0cNACABQQFqIQEMDAtBACECIANBADYCHCADIAE2AhQgA0GYFzYCECADQQI2AgwM5gILIABBFUYNKEEAIQIgA0EANgIcIAMgATYCFCADQc4MNgIQIANBIzYCDAzlAgsgA0EUNgIcIAMgATYCFCADIAA2AgwM5AILIAMoAgQhAEEAIQIgA0EANgIEIAMgACABEDMiAEUEQCABQQFqIQEM3AILIANBFTYCHCADIAA2AgwgAyABQQFqNgIUDOMCCyADKAIEIQBBACECIANBADYCBCADIAAgARAzIgBFBEAgAUEBaiEBDNoCCyADQRc2AhwgAyAANgIMIAMgAUEBajYCFAziAgsgAEEVRg0jQQAhAiADQQA2AhwgAyABNgIUIANBzgw2AhAgA0EjNgIMDOECCyADKAIEIQBBACECIANBADYCBCADIAAgARAzIgBFBEAgAUEBaiEBDB0LIANBGTYCHCADIAA2AgwgAyABQQFqNgIUDOACCyADKAIEIQBBACECIANBADYCBCADIAAgARAzIgBFBEAgAUEBaiEBDNYCCyADQRo2AhwgAyAANgIMIAMgAUEBajYCFAzfAgsgAEEVRg0fQQAhAiADQQA2AhwgAyABNgIUIANBog82AhAgA0EiNgIMDN4CCyADKAIEIQBBACECIANBADYCBCADIAAgARAyIgBFBEAgAUEBaiEBDBsLIANBHDYCHCADIAA2AgwgAyABQQFqNgIUDN0CCyADKAIEIQBBACECIANBADYCBCADIAAgARAyIgBFBEAgAUEBaiEBDNICCyADQR02AhwgAyAANgIMIAMgAUEBajYCFAzcAgsgAEE7Rw0BIAFBAWohAQtBJCECDMACC0EAIQIgA0EANgIcIAMgATYCFCADQc4UNgIQIANBDDYCDAzZAgsgASAERwRAA0AgAS0AAEEgRw3xASAEIAFBAWoiAUcNAAtBLCECDNkCC0EsIQIM2AILIAEgBEYEQEE0IQIM2AILAkACQANAAkAgAS0AAEEKaw4EAgAAAwALIAQgAUEBaiIBRw0AC0E0IQIM2QILIAMoAgQhACADQQA2AgQgAyAAIAEQMCIARQ2MAiADQTI2AhwgAyABNgIUIAMgADYCDEEAIQIM2AILIAMoAgQhACADQQA2AgQgAyAAIAEQMCIARQRAIAFBAWohAQyMAgsgA0EyNgIcIAMgADYCDCADIAFBAWo2AhRBACECDNcCCyABIARHBEACQANAIAEtAABBMGsiAEH/AXFBCk8EQEE5IQIMwAILIAMpAyAiC0KZs+bMmbPmzBlWDQEgAyALQgp+Igo3AyAgCiAArUL/AYMiC0J/hVYNASADIAogC3w3AyAgBCABQQFqIgFHDQALQcAAIQIM2AILIAMoAgQhACADQQA2AgQgAyAAIAFBAWoiARAwIgANFwzJAgtBwAAhAgzWAgsgASAERgRAQckAIQIM1gILAkADQAJAIAEtAABBCWsOGAACjwKPApMCjwKPAo8CjwKPAo8CjwKPAo8CjwKPAo8CjwKPAo8CjwKPAo8CAI8CCyAEIAFBAWoiAUcNAAtByQAhAgzWAgsgAUEBaiEBIANBL2otAABBAXENjwIgA0EANgIcIAMgATYCFCADQekPNgIQIANBCjYCDEEAIQIM1QILIAEgBEcEQANAIAEtAAAiAEEgRwRAAkACQAJAIABByABrDgsAAc0BzQHNAc0BzQHNAc0BzQECzQELIAFBAWohAUHZACECDL8CCyABQQFqIQFB2gAhAgy+AgsgAUEBaiEBQdsAIQIMvQILIAQgAUEBaiIBRw0AC0HuACECDNUCC0HuACECDNQCCyADQQI6ACgMMAtBACECIANBADYCHCADQbcLNgIQIANBAjYCDCADIAFBAWo2AhQM0gILQQAhAgy3AgtBDSECDLYCC0ERIQIMtQILQRMhAgy0AgtBFCECDLMCC0EWIQIMsgILQRchAgyxAgtBGCECDLACC0EZIQIMrwILQRohAgyuAgtBGyECDK0CC0EcIQIMrAILQR0hAgyrAgtBHiECDKoCC0EgIQIMqQILQSEhAgyoAgtBIyECDKcCC0EnIQIMpgILIANBPTYCHCADIAE2AhQgAyAANgIMQQAhAgy/AgsgA0EbNgIcIAMgATYCFCADQY8bNgIQIANBFTYCDEEAIQIMvgILIANBIDYCHCADIAE2AhQgA0GeGTYCECADQRU2AgxBACECDL0CCyADQRM2AhwgAyABNgIUIANBnhk2AhAgA0EVNgIMQQAhAgy8AgsgA0ELNgIcIAMgATYCFCADQZ4ZNgIQIANBFTYCDEEAIQIMuwILIANBEDYCHCADIAE2AhQgA0GeGTYCECADQRU2AgxBACECDLoCCyADQSA2AhwgAyABNgIUIANBjxs2AhAgA0EVNgIMQQAhAgy5AgsgA0ELNgIcIAMgATYCFCADQY8bNgIQIANBFTYCDEEAIQIMuAILIANBDDYCHCADIAE2AhQgA0GPGzYCECADQRU2AgxBACECDLcCC0EAIQIgA0EANgIcIAMgATYCFCADQa8ONgIQIANBEjYCDAy2AgsCQANAAkAgAS0AAEEKaw4EAAICAAILIAQgAUEBaiIBRw0AC0HsASECDLYCCwJAAkAgAy0ANkEBRw0AQQAhAAJAIAMoAjgiAkUNACACKAJYIgJFDQAgAyACEQAAIQALIABFDQAgAEEVRw0BIANB6wE2AhwgAyABNgIUIANB4hg2AhAgA0EVNgIMQQAhAgy3AgtBzAEhAgycAgsgA0EANgIcIAMgATYCFCADQfELNgIQIANBHzYCDEEAIQIMtQILAkACQCADLQAoQQFrDgIEAQALQcsBIQIMmwILQcQBIQIMmgILIANBAjoAMUEAIQACQCADKAI4IgJFDQAgAigCACICRQ0AIAMgAhEAACEACyAARQRAQc0BIQIMmgILIABBFUcEQCADQQA2AhwgAyABNgIUIANBrAw2AhAgA0EQNgIMQQAhAgy0AgsgA0HqATYCHCADIAE2AhQgA0GHGTYCECADQRU2AgxBACECDLMCCyABIARGBEBB6QEhAgyzAgsgAS0AAEHIAEYNASADQQE6ACgLQbYBIQIMlwILQcoBIQIMlgILIAEgBEcEQCADQQw2AgggAyABNgIEQckBIQIMlgILQegBIQIMrwILIAEgBEYEQEHnASECDK8CCyABLQAAQcgARw0EIAFBAWohAUHIASECDJQCCyABIARGBEBB5gEhAgyuAgsCQAJAIAEtAABBxQBrDhAABQUFBQUFBQUFBQUFBQUBBQsgAUEBaiEBQcYBIQIMlAILIAFBAWohAUHHASECDJMCC0HlASECIAEgBEYNrAIgAygCACIAIAQgAWtqIQUgASAAa0ECaiEGAkADQCABLQAAIABB99MAai0AAEcNAyAAQQJGDQEgAEEBaiEAIAQgAUEBaiIBRw0ACyADIAU2AgAMrQILIAMoAgQhACADQgA3AwAgAyAAIAZBAWoiARAtIgBFBEBB1AEhAgyTAgsgA0HkATYCHCADIAE2AhQgAyAANgIMQQAhAgysAgtB4wEhAiABIARGDasCIAMoAgAiACAEIAFraiEFIAEgAGtBAWohBgJAA0AgAS0AACAAQfXTAGotAABHDQIgAEEBRg0BIABBAWohACAEIAFBAWoiAUcNAAsgAyAFNgIADKwCCyADQYEEOwEoIAMoAgQhACADQgA3AwAgAyAAIAZBAWoiARAtIgANAwwCCyADQQA2AgALQQAhAiADQQA2AhwgAyABNgIUIANB0B42AhAgA0EINgIMDKkCC0HFASECDI4CCyADQeIBNgIcIAMgATYCFCADIAA2AgxBACECDKcCC0EAIQACQCADKAI4IgJFDQAgAigCOCICRQ0AIAMgAhEAACEACyAARQ1lIABBFUcEQCADQQA2AhwgAyABNgIUIANB1A42AhAgA0EgNgIMQQAhAgynAgsgA0GFATYCHCADIAE2AhQgA0HXGjYCECADQRU2AgxBACECDKYCC0HhASECIAQgASIARg2lAiAEIAFrIAMoAgAiAWohBSAAIAFrQQRqIQYCQANAIAAtAAAgAUHw0wBqLQAARw0BIAFBBEYNAyABQQFqIQEgBCAAQQFqIgBHDQALIAMgBTYCAAymAgsgA0EANgIcIAMgADYCFCADQYQ3NgIQIANBCDYCDCADQQA2AgBBACECDKUCCyABIARHBEAgA0ENNgIIIAMgATYCBEHCASECDIsCC0HgASECDKQCCyADQQA2AgAgBkEBaiEBC0HDASECDIgCCyABIARGBEBB3wEhAgyiAgsgAS0AAEEwayIAQf8BcUEKSQRAIAMgADoAKiABQQFqIQFBwQEhAgyIAgsgAygCBCEAIANBADYCBCADIAAgARAuIgBFDYgCIANB3gE2AhwgAyABNgIUIAMgADYCDEEAIQIMoQILIAEgBEYEQEHdASECDKECCwJAIAEtAABBLkYEQCABQQFqIQEMAQsgAygCBCEAIANBADYCBCADIAAgARAuIgBFDYkCIANB3AE2AhwgAyABNgIUIAMgADYCDEEAIQIMoQILQcABIQIMhgILIAEgBEYEQEHbASECDKACC0EAIQBBASEFQQEhB0EAIQICQAJAAkACQAJAAn8CQAJAAkACQAJAAkACQCABLQAAQTBrDgoKCQABAgMEBQYICwtBAgwGC0EDDAULQQQMBAtBBQwDC0EGDAILQQcMAQtBCAshAkEAIQVBACEHDAILQQkhAkEBIQBBACEFQQAhBwwBC0EAIQVBASECCyADIAI6ACsgAUEBaiEBAkACQCADLQAuQRBxDQACQAJAAkAgAy0AKg4DAQACBAsgB0UNAwwCCyAADQEMAgsgBUUNAQsgAygCBCEAIANBADYCBCADIAAgARAuIgBFDQIgA0HYATYCHCADIAE2AhQgAyAANgIMQQAhAgyiAgsgAygCBCEAIANBADYCBCADIAAgARAuIgBFDYsCIANB2QE2AhwgAyABNgIUIAMgADYCDEEAIQIMoQILIAMoAgQhACADQQA2AgQgAyAAIAEQLiIARQ2JAiADQdoBNgIcIAMgATYCFCADIAA2AgwMoAILQb8BIQIMhQILQQAhAAJAIAMoAjgiAkUNACACKAI8IgJFDQAgAyACEQAAIQALAkAgAARAIABBFUYNASADQQA2AhwgAyABNgIUIANBnA02AhAgA0EhNgIMQQAhAgygAgtBvgEhAgyFAgsgA0HXATYCHCADIAE2AhQgA0HWGTYCECADQRU2AgxBACECDJ4CCyABIARGBEBB1wEhAgyeAgsCQCABLQAAQSBGBEAgA0EAOwE0IAFBAWohAQwBCyADQQA2AhwgAyABNgIUIANB6xA2AhAgA0EJNgIMQQAhAgyeAgtBvQEhAgyDAgsgASAERgRAQdYBIQIMnQILAkAgAS0AAEEwa0H/AXEiAkEKSQRAIAFBAWohAQJAIAMvATQiAEGZM0sNACADIABBCmwiADsBNCAAQf7/A3EgAkH//wNzSw0AIAMgACACajsBNAwCC0EAIQIgA0EANgIcIAMgATYCFCADQYAdNgIQIANBDTYCDAyeAgsgA0EANgIcIAMgATYCFCADQYAdNgIQIANBDTYCDEEAIQIMnQILQbwBIQIMggILIAEgBEYEQEHVASECDJwCCwJAIAEtAABBMGtB/wFxIgJBCkkEQCABQQFqIQECQCADLwE0IgBBmTNLDQAgAyAAQQpsIgA7ATQgAEH+/wNxIAJB//8Dc0sNACADIAAgAmo7ATQMAgtBACECIANBADYCHCADIAE2AhQgA0GAHTYCECADQQ02AgwMnQILIANBADYCHCADIAE2AhQgA0GAHTYCECADQQ02AgxBACECDJwCC0G7ASECDIECCyABIARGBEBB1AEhAgybAgsCQCABLQAAQTBrQf8BcSICQQpJBEAgAUEBaiEBAkAgAy8BNCIAQZkzSw0AIAMgAEEKbCIAOwE0IABB/v8DcSACQf//A3NLDQAgAyAAIAJqOwE0DAILQQAhAiADQQA2AhwgAyABNgIUIANBgB02AhAgA0ENNgIMDJwCCyADQQA2AhwgAyABNgIUIANBgB02AhAgA0ENNgIMQQAhAgybAgtBugEhAgyAAgsgASAERgRAQdMBIQIMmgILAkACQAJAAkAgAS0AAEEKaw4XAgMDAAMDAwMDAwMDAwMDAwMDAwMDAwEDCyABQQFqDAULIAFBAWohAUG5ASECDIECCyABQQFqIQEgA0Evai0AAEEBcQ0IIANBADYCHCADIAE2AhQgA0GFCzYCECADQQ02AgxBACECDJoCCyADQQA2AhwgAyABNgIUIANBhQs2AhAgA0ENNgIMQQAhAgyZAgsgASAERwRAIANBDjYCCCADIAE2AgRBASECDP8BC0HSASECDJgCCwJAAkADQAJAIAEtAABBCmsOBAIAAAMACyAEIAFBAWoiAUcNAAtB0QEhAgyZAgsgAygCBCEAIANBADYCBCADIAAgARAsIgBFBEAgAUEBaiEBDAQLIANB0AE2AhwgAyAANgIMIAMgAUEBajYCFEEAIQIMmAILIAMoAgQhACADQQA2AgQgAyAAIAEQLCIADQEgAUEBagshAUG3ASECDPwBCyADQc8BNgIcIAMgADYCDCADIAFBAWo2AhRBACECDJUCC0G4ASECDPoBCyADQS9qLQAAQQFxDQEgA0EANgIcIAMgATYCFCADQc8bNgIQIANBGTYCDEEAIQIMkwILIAEgBEYEQEHPASECDJMCCwJAAkACQCABLQAAQQprDgQBAgIAAgsgAUEBaiEBDAILIAFBAWohAQwBCyADLQAuQcAAcUUNAQtBACEAAkAgAygCOCICRQ0AIAIoAjQiAkUNACADIAIRAAAhAAsgAEUNlgEgAEEVRgRAIANB2QA2AhwgAyABNgIUIANBvRk2AhAgA0EVNgIMQQAhAgySAgsgA0EANgIcIAMgATYCFCADQfgMNgIQIANBGzYCDEEAIQIMkQILIANBADYCHCADIAE2AhQgA0HHJzYCECADQQI2AgxBACECDJACCyABIARHBEAgA0EMNgIIIAMgATYCBEG1ASECDPYBC0HOASECDI8CCyABIARGBEBBzQEhAgyPAgsCQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAIAEtAABBwQBrDhUAAQIDWgQFBlpaWgcICQoLDA0ODxBaCyABQQFqIQFB8QAhAgyEAgsgAUEBaiEBQfIAIQIMgwILIAFBAWohAUH3ACECDIICCyABQQFqIQFB+wAhAgyBAgsgAUEBaiEBQfwAIQIMgAILIAFBAWohAUH/ACECDP8BCyABQQFqIQFBgAEhAgz+AQsgAUEBaiEBQYMBIQIM/QELIAFBAWohAUGMASECDPwBCyABQQFqIQFBjQEhAgz7AQsgAUEBaiEBQY4BIQIM+gELIAFBAWohAUGbASECDPkBCyABQQFqIQFBnAEhAgz4AQsgAUEBaiEBQaIBIQIM9wELIAFBAWohAUGqASECDPYBCyABQQFqIQFBrQEhAgz1AQsgAUEBaiEBQbQBIQIM9AELIAEgBEYEQEHMASECDI4CCyABLQAAQc4ARw1IIAFBAWohAUGzASECDPMBCyABIARGBEBBywEhAgyNAgsCQAJAAkAgAS0AAEHCAGsOEgBKSkpKSkpKSkoBSkpKSkpKAkoLIAFBAWohAUGuASECDPQBCyABQQFqIQFBsQEhAgzzAQsgAUEBaiEBQbIBIQIM8gELQcoBIQIgASAERg2LAiADKAIAIgAgBCABa2ohBSABIABrQQdqIQYCQANAIAEtAAAgAEHo0wBqLQAARw1FIABBB0YNASAAQQFqIQAgBCABQQFqIgFHDQALIAMgBTYCAAyMAgsgA0EANgIAIAZBAWohAUEbDEULIAEgBEYEQEHJASECDIsCCwJAAkAgAS0AAEHJAGsOBwBHR0dHRwFHCyABQQFqIQFBrwEhAgzxAQsgAUEBaiEBQbABIQIM8AELQcgBIQIgASAERg2JAiADKAIAIgAgBCABa2ohBSABIABrQQFqIQYCQANAIAEtAAAgAEHm0wBqLQAARw1DIABBAUYNASAAQQFqIQAgBCABQQFqIgFHDQALIAMgBTYCAAyKAgsgA0EANgIAIAZBAWohAUEPDEMLQccBIQIgASAERg2IAiADKAIAIgAgBCABa2ohBSABIABrQQFqIQYCQANAIAEtAAAgAEHk0wBqLQAARw1CIABBAUYNASAAQQFqIQAgBCABQQFqIgFHDQALIAMgBTYCAAyJAgsgA0EANgIAIAZBAWohAUEgDEILQcYBIQIgASAERg2HAiADKAIAIgAgBCABa2ohBSABIABrQQJqIQYCQANAIAEtAAAgAEHh0wBqLQAARw1BIABBAkYNASAAQQFqIQAgBCABQQFqIgFHDQALIAMgBTYCAAyIAgsgA0EANgIAIAZBAWohAUESDEELIAEgBEYEQEHFASECDIcCCwJAAkAgAS0AAEHFAGsODgBDQ0NDQ0NDQ0NDQ0MBQwsgAUEBaiEBQasBIQIM7QELIAFBAWohAUGsASECDOwBC0HEASECIAEgBEYNhQIgAygCACIAIAQgAWtqIQUgASAAa0ECaiEGAkADQCABLQAAIABB3tMAai0AAEcNPyAAQQJGDQEgAEEBaiEAIAQgAUEBaiIBRw0ACyADIAU2AgAMhgILIANBADYCACAGQQFqIQFBBww/C0HDASECIAEgBEYNhAIgAygCACIAIAQgAWtqIQUgASAAa0EFaiEGAkADQCABLQAAIABB2NMAai0AAEcNPiAAQQVGDQEgAEEBaiEAIAQgAUEBaiIBRw0ACyADIAU2AgAMhQILIANBADYCACAGQQFqIQFBKAw+CyABIARGBEBBwgEhAgyEAgsCQAJAAkAgAS0AAEHFAGsOEQBBQUFBQUFBQUEBQUFBQUECQQsgAUEBaiEBQacBIQIM6wELIAFBAWohAUGoASECDOoBCyABQQFqIQFBqQEhAgzpAQtBwQEhAiABIARGDYICIAMoAgAiACAEIAFraiEFIAEgAGtBBmohBgJAA0AgAS0AACAAQdHTAGotAABHDTwgAEEGRg0BIABBAWohACAEIAFBAWoiAUcNAAsgAyAFNgIADIMCCyADQQA2AgAgBkEBaiEBQRoMPAtBwAEhAiABIARGDYECIAMoAgAiACAEIAFraiEFIAEgAGtBA2ohBgJAA0AgAS0AACAAQc3TAGotAABHDTsgAEEDRg0BIABBAWohACAEIAFBAWoiAUcNAAsgAyAFNgIADIICCyADQQA2AgAgBkEBaiEBQSEMOwsgASAERgRAQb8BIQIMgQILAkACQCABLQAAQcEAaw4UAD09PT09PT09PT09PT09PT09PQE9CyABQQFqIQFBowEhAgznAQsgAUEBaiEBQaYBIQIM5gELIAEgBEYEQEG+ASECDIACCwJAAkAgAS0AAEHVAGsOCwA8PDw8PDw8PDwBPAsgAUEBaiEBQaQBIQIM5gELIAFBAWohAUGlASECDOUBC0G9ASECIAEgBEYN/gEgAygCACIAIAQgAWtqIQUgASAAa0EIaiEGAkADQCABLQAAIABBxNMAai0AAEcNOCAAQQhGDQEgAEEBaiEAIAQgAUEBaiIBRw0ACyADIAU2AgAM/wELIANBADYCACAGQQFqIQFBKgw4CyABIARGBEBBvAEhAgz+AQsgAS0AAEHQAEcNOCABQQFqIQFBJQw3C0G7ASECIAEgBEYN/AEgAygCACIAIAQgAWtqIQUgASAAa0ECaiEGAkADQCABLQAAIABBwdMAai0AAEcNNiAAQQJGDQEgAEEBaiEAIAQgAUEBaiIBRw0ACyADIAU2AgAM/QELIANBADYCACAGQQFqIQFBDgw2CyABIARGBEBBugEhAgz8AQsgAS0AAEHFAEcNNiABQQFqIQFBoQEhAgzhAQsgASAERgRAQbkBIQIM+wELAkACQAJAAkAgAS0AAEHCAGsODwABAjk5OTk5OTk5OTk5AzkLIAFBAWohAUGdASECDOMBCyABQQFqIQFBngEhAgziAQsgAUEBaiEBQZ8BIQIM4QELIAFBAWohAUGgASECDOABC0G4ASECIAEgBEYN+QEgAygCACIAIAQgAWtqIQUgASAAa0ECaiEGAkADQCABLQAAIABBvtMAai0AAEcNMyAAQQJGDQEgAEEBaiEAIAQgAUEBaiIBRw0ACyADIAU2AgAM+gELIANBADYCACAGQQFqIQFBFAwzC0G3ASECIAEgBEYN+AEgAygCACIAIAQgAWtqIQUgASAAa0EEaiEGAkADQCABLQAAIABBudMAai0AAEcNMiAAQQRGDQEgAEEBaiEAIAQgAUEBaiIBRw0ACyADIAU2AgAM+QELIANBADYCACAGQQFqIQFBKwwyC0G2ASECIAEgBEYN9wEgAygCACIAIAQgAWtqIQUgASAAa0ECaiEGAkADQCABLQAAIABBttMAai0AAEcNMSAAQQJGDQEgAEEBaiEAIAQgAUEBaiIBRw0ACyADIAU2AgAM+AELIANBADYCACAGQQFqIQFBLAwxC0G1ASECIAEgBEYN9gEgAygCACIAIAQgAWtqIQUgASAAa0ECaiEGAkADQCABLQAAIABB4dMAai0AAEcNMCAAQQJGDQEgAEEBaiEAIAQgAUEBaiIBRw0ACyADIAU2AgAM9wELIANBADYCACAGQQFqIQFBEQwwC0G0ASECIAEgBEYN9QEgAygCACIAIAQgAWtqIQUgASAAa0EDaiEGAkADQCABLQAAIABBstMAai0AAEcNLyAAQQNGDQEgAEEBaiEAIAQgAUEBaiIBRw0ACyADIAU2AgAM9gELIANBADYCACAGQQFqIQFBLgwvCyABIARGBEBBswEhAgz1AQsCQAJAAkACQAJAIAEtAABBwQBrDhUANDQ0NDQ0NDQ0NAE0NAI0NAM0NAQ0CyABQQFqIQFBkQEhAgzeAQsgAUEBaiEBQZIBIQIM3QELIAFBAWohAUGTASECDNwBCyABQQFqIQFBmAEhAgzbAQsgAUEBaiEBQZoBIQIM2gELIAEgBEYEQEGyASECDPQBCwJAAkAgAS0AAEHSAGsOAwAwATALIAFBAWohAUGZASECDNoBCyABQQFqIQFBBAwtC0GxASECIAEgBEYN8gEgAygCACIAIAQgAWtqIQUgASAAa0EBaiEGAkADQCABLQAAIABBsNMAai0AAEcNLCAAQQFGDQEgAEEBaiEAIAQgAUEBaiIBRw0ACyADIAU2AgAM8wELIANBADYCACAGQQFqIQFBHQwsCyABIARGBEBBsAEhAgzyAQsCQAJAIAEtAABByQBrDgcBLi4uLi4ALgsgAUEBaiEBQZcBIQIM2AELIAFBAWohAUEiDCsLIAEgBEYEQEGvASECDPEBCyABLQAAQdAARw0rIAFBAWohAUGWASECDNYBCyABIARGBEBBrgEhAgzwAQsCQAJAIAEtAABBxgBrDgsALCwsLCwsLCwsASwLIAFBAWohAUGUASECDNYBCyABQQFqIQFBlQEhAgzVAQtBrQEhAiABIARGDe4BIAMoAgAiACAEIAFraiEFIAEgAGtBA2ohBgJAA0AgAS0AACAAQazTAGotAABHDSggAEEDRg0BIABBAWohACAEIAFBAWoiAUcNAAsgAyAFNgIADO8BCyADQQA2AgAgBkEBaiEBQQ0MKAtBrAEhAiABIARGDe0BIAMoAgAiACAEIAFraiEFIAEgAGtBAmohBgJAA0AgAS0AACAAQeHTAGotAABHDScgAEECRg0BIABBAWohACAEIAFBAWoiAUcNAAsgAyAFNgIADO4BCyADQQA2AgAgBkEBaiEBQQwMJwtBqwEhAiABIARGDewBIAMoAgAiACAEIAFraiEFIAEgAGtBAWohBgJAA0AgAS0AACAAQarTAGotAABHDSYgAEEBRg0BIABBAWohACAEIAFBAWoiAUcNAAsgAyAFNgIADO0BCyADQQA2AgAgBkEBaiEBQQMMJgtBqgEhAiABIARGDesBIAMoAgAiACAEIAFraiEFIAEgAGtBAWohBgJAA0AgAS0AACAAQajTAGotAABHDSUgAEEBRg0BIABBAWohACAEIAFBAWoiAUcNAAsgAyAFNgIADOwBCyADQQA2AgAgBkEBaiEBQSYMJQsgASAERgRAQakBIQIM6wELAkACQCABLQAAQdQAaw4CAAEnCyABQQFqIQFBjwEhAgzRAQsgAUEBaiEBQZABIQIM0AELQagBIQIgASAERg3pASADKAIAIgAgBCABa2ohBSABIABrQQFqIQYCQANAIAEtAAAgAEGm0wBqLQAARw0jIABBAUYNASAAQQFqIQAgBCABQQFqIgFHDQALIAMgBTYCAAzqAQsgA0EANgIAIAZBAWohAUEnDCMLQacBIQIgASAERg3oASADKAIAIgAgBCABa2ohBSABIABrQQFqIQYCQANAIAEtAAAgAEGk0wBqLQAARw0iIABBAUYNASAAQQFqIQAgBCABQQFqIgFHDQALIAMgBTYCAAzpAQsgA0EANgIAIAZBAWohAUEcDCILQaYBIQIgASAERg3nASADKAIAIgAgBCABa2ohBSABIABrQQVqIQYCQANAIAEtAAAgAEGe0wBqLQAARw0hIABBBUYNASAAQQFqIQAgBCABQQFqIgFHDQALIAMgBTYCAAzoAQsgA0EANgIAIAZBAWohAUEGDCELQaUBIQIgASAERg3mASADKAIAIgAgBCABa2ohBSABIABrQQRqIQYCQANAIAEtAAAgAEGZ0wBqLQAARw0gIABBBEYNASAAQQFqIQAgBCABQQFqIgFHDQALIAMgBTYCAAznAQsgA0EANgIAIAZBAWohAUEZDCALIAEgBEYEQEGkASECDOYBCwJAAkACQAJAIAEtAABBLWsOIwAkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJAEkJCQkJAIkJCQDJAsgAUEBaiEBQYQBIQIMzgELIAFBAWohAUGFASECDM0BCyABQQFqIQFBigEhAgzMAQsgAUEBaiEBQYsBIQIMywELQaMBIQIgASAERg3kASADKAIAIgAgBCABa2ohBSABIABrQQFqIQYCQANAIAEtAAAgAEGX0wBqLQAARw0eIABBAUYNASAAQQFqIQAgBCABQQFqIgFHDQALIAMgBTYCAAzlAQsgA0EANgIAIAZBAWohAUELDB4LIAEgBEYEQEGiASECDOQBCwJAAkAgAS0AAEHBAGsOAwAgASALIAFBAWohAUGGASECDMoBCyABQQFqIQFBiQEhAgzJAQsgASAERgRAQaEBIQIM4wELAkACQCABLQAAQcEAaw4PAB8fHx8fHx8fHx8fHx8BHwsgAUEBaiEBQYcBIQIMyQELIAFBAWohAUGIASECDMgBCyABIARGBEBBoAEhAgziAQsgAS0AAEHMAEcNHCABQQFqIQFBCgwbC0GfASECIAEgBEYN4AEgAygCACIAIAQgAWtqIQUgASAAa0EFaiEGAkADQCABLQAAIABBkdMAai0AAEcNGiAAQQVGDQEgAEEBaiEAIAQgAUEBaiIBRw0ACyADIAU2AgAM4QELIANBADYCACAGQQFqIQFBHgwaC0GeASECIAEgBEYN3wEgAygCACIAIAQgAWtqIQUgASAAa0EGaiEGAkADQCABLQAAIABBitMAai0AAEcNGSAAQQZGDQEgAEEBaiEAIAQgAUEBaiIBRw0ACyADIAU2AgAM4AELIANBADYCACAGQQFqIQFBFQwZC0GdASECIAEgBEYN3gEgAygCACIAIAQgAWtqIQUgASAAa0ECaiEGAkADQCABLQAAIABBh9MAai0AAEcNGCAAQQJGDQEgAEEBaiEAIAQgAUEBaiIBRw0ACyADIAU2AgAM3wELIANBADYCACAGQQFqIQFBFwwYC0GcASECIAEgBEYN3QEgAygCACIAIAQgAWtqIQUgASAAa0EFaiEGAkADQCABLQAAIABBgdMAai0AAEcNFyAAQQVGDQEgAEEBaiEAIAQgAUEBaiIBRw0ACyADIAU2AgAM3gELIANBADYCACAGQQFqIQFBGAwXCyABIARGBEBBmwEhAgzdAQsCQAJAIAEtAABByQBrDgcAGRkZGRkBGQsgAUEBaiEBQYEBIQIMwwELIAFBAWohAUGCASECDMIBC0GaASECIAEgBEYN2wEgAygCACIAIAQgAWtqIQUgASAAa0EBaiEGAkADQCABLQAAIABB5tMAai0AAEcNFSAAQQFGDQEgAEEBaiEAIAQgAUEBaiIBRw0ACyADIAU2AgAM3AELIANBADYCACAGQQFqIQFBCQwVC0GZASECIAEgBEYN2gEgAygCACIAIAQgAWtqIQUgASAAa0EBaiEGAkADQCABLQAAIABB5NMAai0AAEcNFCAAQQFGDQEgAEEBaiEAIAQgAUEBaiIBRw0ACyADIAU2AgAM2wELIANBADYCACAGQQFqIQFBHwwUC0GYASECIAEgBEYN2QEgAygCACIAIAQgAWtqIQUgASAAa0ECaiEGAkADQCABLQAAIABB/tIAai0AAEcNEyAAQQJGDQEgAEEBaiEAIAQgAUEBaiIBRw0ACyADIAU2AgAM2gELIANBADYCACAGQQFqIQFBAgwTC0GXASECIAEgBEYN2AEgAygCACIAIAQgAWtqIQUgASAAa0EBaiEGA0AgAS0AACAAQfzSAGotAABHDREgAEEBRg0CIABBAWohACAEIAFBAWoiAUcNAAsgAyAFNgIADNgBCyABIARGBEBBlgEhAgzYAQtBASABLQAAQd8ARw0RGiABQQFqIQFB/QAhAgy9AQsgA0EANgIAIAZBAWohAUH+ACECDLwBC0GVASECIAEgBEYN1QEgAygCACIAIAQgAWtqIQUgASAAa0EIaiEGAkADQCABLQAAIABBxNMAai0AAEcNDyAAQQhGDQEgAEEBaiEAIAQgAUEBaiIBRw0ACyADIAU2AgAM1gELIANBADYCACAGQQFqIQFBKQwPC0GUASECIAEgBEYN1AEgAygCACIAIAQgAWtqIQUgASAAa0EDaiEGAkADQCABLQAAIABB+NIAai0AAEcNDiAAQQNGDQEgAEEBaiEAIAQgAUEBaiIBRw0ACyADIAU2AgAM1QELIANBADYCACAGQQFqIQFBLQwOCyABIARGBEBBkwEhAgzUAQsgAS0AAEHFAEcNDiABQQFqIQFB+gAhAgy5AQsgASAERgRAQZIBIQIM0wELAkACQCABLQAAQcwAaw4IAA8PDw8PDwEPCyABQQFqIQFB+AAhAgy5AQsgAUEBaiEBQfkAIQIMuAELQZEBIQIgASAERg3RASADKAIAIgAgBCABa2ohBSABIABrQQRqIQYCQANAIAEtAAAgAEHz0gBqLQAARw0LIABBBEYNASAAQQFqIQAgBCABQQFqIgFHDQALIAMgBTYCAAzSAQsgA0EANgIAIAZBAWohAUEjDAsLQZABIQIgASAERg3QASADKAIAIgAgBCABa2ohBSABIABrQQJqIQYCQANAIAEtAAAgAEHw0gBqLQAARw0KIABBAkYNASAAQQFqIQAgBCABQQFqIgFHDQALIAMgBTYCAAzRAQsgA0EANgIAIAZBAWohAUEADAoLIAEgBEYEQEGPASECDNABCwJAAkAgAS0AAEHIAGsOCAAMDAwMDAwBDAsgAUEBaiEBQfMAIQIMtgELIAFBAWohAUH2ACECDLUBCyABIARGBEBBjgEhAgzPAQsCQAJAIAEtAABBzgBrDgMACwELCyABQQFqIQFB9AAhAgy1AQsgAUEBaiEBQfUAIQIMtAELIAEgBEYEQEGNASECDM4BCyABLQAAQdkARw0IIAFBAWohAUEIDAcLQYwBIQIgASAERg3MASADKAIAIgAgBCABa2ohBSABIABrQQNqIQYCQANAIAEtAAAgAEHs0gBqLQAARw0GIABBA0YNASAAQQFqIQAgBCABQQFqIgFHDQALIAMgBTYCAAzNAQsgA0EANgIAIAZBAWohAUEFDAYLQYsBIQIgASAERg3LASADKAIAIgAgBCABa2ohBSABIABrQQVqIQYCQANAIAEtAAAgAEHm0gBqLQAARw0FIABBBUYNASAAQQFqIQAgBCABQQFqIgFHDQALIAMgBTYCAAzMAQsgA0EANgIAIAZBAWohAUEWDAULQYoBIQIgASAERg3KASADKAIAIgAgBCABa2ohBSABIABrQQJqIQYCQANAIAEtAAAgAEHh0wBqLQAARw0EIABBAkYNASAAQQFqIQAgBCABQQFqIgFHDQALIAMgBTYCAAzLAQsgA0EANgIAIAZBAWohAUEQDAQLIAEgBEYEQEGJASECDMoBCwJAAkAgAS0AAEHDAGsODAAGBgYGBgYGBgYGAQYLIAFBAWohAUHvACECDLABCyABQQFqIQFB8AAhAgyvAQtBiAEhAiABIARGDcgBIAMoAgAiACAEIAFraiEFIAEgAGtBBWohBgJAA0AgAS0AACAAQeDSAGotAABHDQIgAEEFRg0BIABBAWohACAEIAFBAWoiAUcNAAsgAyAFNgIADMkBCyADQQA2AgAgBkEBaiEBQSQMAgsgA0EANgIADAILIAEgBEYEQEGHASECDMcBCyABLQAAQcwARw0BIAFBAWohAUETCzoAKSADKAIEIQAgA0EANgIEIAMgACABEC0iAA0CDAELQQAhAiADQQA2AhwgAyABNgIUIANB6R42AhAgA0EGNgIMDMQBC0HuACECDKkBCyADQYYBNgIcIAMgATYCFCADIAA2AgxBACECDMIBC0EAIQACQCADKAI4IgJFDQAgAigCOCICRQ0AIAMgAhEAACEACyAARQ0AIABBFUYNASADQQA2AhwgAyABNgIUIANB1A42AhAgA0EgNgIMQQAhAgzBAQtB7QAhAgymAQsgA0GFATYCHCADIAE2AhQgA0HXGjYCECADQRU2AgxBACECDL8BCyABIARGBEBBhQEhAgy/AQsCQCABLQAAQSBGBEAgAUEBaiEBDAELIANBADYCHCADIAE2AhQgA0GGHjYCECADQQY2AgxBACECDL8BC0ECIQIMpAELA0AgAS0AAEEgRw0CIAQgAUEBaiIBRw0AC0GEASECDL0BCyABIARGBEBBgwEhAgy9AQsCQCABLQAAQQlrDgRAAABAAAtB6wAhAgyiAQsgAy0AKUEFRgRAQewAIQIMogELQeoAIQIMoQELIAEgBEYEQEGCASECDLsBCyADQQ82AgggAyABNgIEDAoLIAEgBEYEQEGBASECDLoBCwJAIAEtAABBCWsOBD0AAD0AC0HpACECDJ8BCyABIARHBEAgA0EPNgIIIAMgATYCBEHnACECDJ8BC0GAASECDLgBCwJAIAEgBEcEQANAIAEtAABB4M4Aai0AACIAQQNHBEACQCAAQQFrDgI/AAQLQeYAIQIMoQELIAQgAUEBaiIBRw0AC0H+ACECDLkBC0H+ACECDLgBCyADQQA2AhwgAyABNgIUIANBxh82AhAgA0EHNgIMQQAhAgy3AQsgASAERgRAQf8AIQIMtwELAkACQAJAIAEtAABB4NAAai0AAEEBaw4DPAIAAQtB6AAhAgyeAQsgA0EANgIcIAMgATYCFCADQYYSNgIQIANBBzYCDEEAIQIMtwELQeAAIQIMnAELIAEgBEcEQCABQQFqIQFB5QAhAgycAQtB/QAhAgy1AQsgBCABIgBGBEBB/AAhAgy1AQsgAC0AACIBQS9GBEAgAEEBaiEBQeQAIQIMmwELIAFBCWsiAkEXSw0BIAAhAUEBIAJ0QZuAgARxDTcMAQsgBCABIgBGBEBB+wAhAgy0AQsgAC0AAEEvRw0AIABBAWohAQwDC0EAIQIgA0EANgIcIAMgADYCFCADQcYfNgIQIANBBzYCDAyyAQsCQAJAAkACQAJAA0AgAS0AAEHgzABqLQAAIgBBBUcEQAJAAkAgAEEBaw4IPQUGBwgABAEIC0HhACECDJ8BCyABQQFqIQFB4wAhAgyeAQsgBCABQQFqIgFHDQALQfoAIQIMtgELIAFBAWoMFAsgAygCBCEAIANBADYCBCADIAAgARArIgBFDR4gA0HbADYCHCADIAE2AhQgAyAANgIMQQAhAgy0AQsgAygCBCEAIANBADYCBCADIAAgARArIgBFDR4gA0HdADYCHCADIAE2AhQgAyAANgIMQQAhAgyzAQsgAygCBCEAIANBADYCBCADIAAgARArIgBFDR4gA0HwADYCHCADIAE2AhQgAyAANgIMQQAhAgyyAQsgA0EANgIcIAMgATYCFCADQcsPNgIQIANBBzYCDEEAIQIMsQELIAEgBEYEQEH5ACECDLEBCwJAIAEtAABB4MwAai0AAEEBaw4INAQFBgAIAgMHCyABQQFqIQELQQMhAgyVAQsgAUEBagwNC0EAIQIgA0EANgIcIANBoxI2AhAgA0EHNgIMIAMgAUEBajYCFAytAQsgAygCBCEAIANBADYCBCADIAAgARArIgBFDRYgA0HbADYCHCADIAE2AhQgAyAANgIMQQAhAgysAQsgAygCBCEAIANBADYCBCADIAAgARArIgBFDRYgA0HdADYCHCADIAE2AhQgAyAANgIMQQAhAgyrAQsgAygCBCEAIANBADYCBCADIAAgARArIgBFDRYgA0HwADYCHCADIAE2AhQgAyAANgIMQQAhAgyqAQsgA0EANgIcIAMgATYCFCADQcsPNgIQIANBBzYCDEEAIQIMqQELQeIAIQIMjgELIAEgBEYEQEH4ACECDKgBCyABQQFqDAILIAEgBEYEQEH3ACECDKcBCyABQQFqDAELIAEgBEYNASABQQFqCyEBQQQhAgyKAQtB9gAhAgyjAQsDQCABLQAAQeDKAGotAAAiAEECRwRAIABBAUcEQEHfACECDIsBCwwnCyAEIAFBAWoiAUcNAAtB9QAhAgyiAQsgASAERgRAQfQAIQIMogELAkAgAS0AAEEJaw43JQMGJQQGBgYGBgYGBgYGBgYGBgYGBgYFBgYCBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGAAYLIAFBAWoLIQFBBSECDIYBCyABQQFqDAYLIAMoAgQhACADQQA2AgQgAyAAIAEQKyIARQ0IIANB2wA2AhwgAyABNgIUIAMgADYCDEEAIQIMngELIAMoAgQhACADQQA2AgQgAyAAIAEQKyIARQ0IIANB3QA2AhwgAyABNgIUIAMgADYCDEEAIQIMnQELIAMoAgQhACADQQA2AgQgAyAAIAEQKyIARQ0IIANB8AA2AhwgAyABNgIUIAMgADYCDEEAIQIMnAELIANBADYCHCADIAE2AhQgA0G8EzYCECADQQc2AgxBACECDJsBCwJAAkACQAJAA0AgAS0AAEHgyABqLQAAIgBBBUcEQAJAIABBAWsOBiQDBAUGAAYLQd4AIQIMhgELIAQgAUEBaiIBRw0AC0HzACECDJ4BCyADKAIEIQAgA0EANgIEIAMgACABECsiAEUNByADQdsANgIcIAMgATYCFCADIAA2AgxBACECDJ0BCyADKAIEIQAgA0EANgIEIAMgACABECsiAEUNByADQd0ANgIcIAMgATYCFCADIAA2AgxBACECDJwBCyADKAIEIQAgA0EANgIEIAMgACABECsiAEUNByADQfAANgIcIAMgATYCFCADIAA2AgxBACECDJsBCyADQQA2AhwgAyABNgIUIANB3Ag2AhAgA0EHNgIMQQAhAgyaAQsgASAERg0BIAFBAWoLIQFBBiECDH4LQfIAIQIMlwELAkACQAJAAkADQCABLQAAQeDGAGotAAAiAEEFRwRAIABBAWsOBB8CAwQFCyAEIAFBAWoiAUcNAAtB8QAhAgyaAQsgAygCBCEAIANBADYCBCADIAAgARArIgBFDQMgA0HbADYCHCADIAE2AhQgAyAANgIMQQAhAgyZAQsgAygCBCEAIANBADYCBCADIAAgARArIgBFDQMgA0HdADYCHCADIAE2AhQgAyAANgIMQQAhAgyYAQsgAygCBCEAIANBADYCBCADIAAgARArIgBFDQMgA0HwADYCHCADIAE2AhQgAyAANgIMQQAhAgyXAQsgA0EANgIcIAMgATYCFCADQbQKNgIQIANBBzYCDEEAIQIMlgELQc4AIQIMewtB0AAhAgx6C0HdACECDHkLIAEgBEYEQEHwACECDJMBCwJAIAEtAABBCWsOBBYAABYACyABQQFqIQFB3AAhAgx4CyABIARGBEBB7wAhAgySAQsCQCABLQAAQQlrDgQVAAAVAAtBACEAAkAgAygCOCICRQ0AIAIoAjAiAkUNACADIAIRAAAhAAsgAEUEQEHTASECDHgLIABBFUcEQCADQQA2AhwgAyABNgIUIANBwQ02AhAgA0EaNgIMQQAhAgySAQsgA0HuADYCHCADIAE2AhQgA0HwGTYCECADQRU2AgxBACECDJEBC0HtACECIAEgBEYNkAEgAygCACIAIAQgAWtqIQUgASAAa0EDaiEGAkADQCABLQAAIABB18YAai0AAEcNBCAAQQNGDQEgAEEBaiEAIAQgAUEBaiIBRw0ACyADIAU2AgAMkQELIANBADYCACAGQQFqIQEgAy0AKSIAQSNrQQtJDQQCQCAAQQZLDQBBASAAdEHKAHFFDQAMBQtBACECIANBADYCHCADIAE2AhQgA0HlCTYCECADQQg2AgwMkAELQewAIQIgASAERg2PASADKAIAIgAgBCABa2ohBSABIABrQQJqIQYCQANAIAEtAAAgAEHUxgBqLQAARw0DIABBAkYNASAAQQFqIQAgBCABQQFqIgFHDQALIAMgBTYCAAyQAQsgA0EANgIAIAZBAWohASADLQApQSFGDQMgA0EANgIcIAMgATYCFCADQYkKNgIQIANBCDYCDEEAIQIMjwELQesAIQIgASAERg2OASADKAIAIgAgBCABa2ohBSABIABrQQNqIQYCQANAIAEtAAAgAEHQxgBqLQAARw0CIABBA0YNASAAQQFqIQAgBCABQQFqIgFHDQALIAMgBTYCAAyPAQsgA0EANgIAIAZBAWohASADLQApIgBBI0kNAiAAQS5GDQIgA0EANgIcIAMgATYCFCADQcEJNgIQIANBCDYCDEEAIQIMjgELIANBADYCAAtBACECIANBADYCHCADIAE2AhQgA0GENzYCECADQQg2AgwMjAELQdgAIQIMcQsgASAERwRAIANBDTYCCCADIAE2AgRB1wAhAgxxC0HqACECDIoBCyABIARGBEBB6QAhAgyKAQsgAS0AAEEwayIAQf8BcUEKSQRAIAMgADoAKiABQQFqIQFB1gAhAgxwCyADKAIEIQAgA0EANgIEIAMgACABEC4iAEUNdCADQegANgIcIAMgATYCFCADIAA2AgxBACECDIkBCyABIARGBEBB5wAhAgyJAQsCQCABLQAAQS5GBEAgAUEBaiEBDAELIAMoAgQhACADQQA2AgQgAyAAIAEQLiIARQ11IANB5gA2AhwgAyABNgIUIAMgADYCDEEAIQIMiQELQdUAIQIMbgsgASAERgRAQeUAIQIMiAELQQAhAEEBIQVBASEHQQAhAgJAAkACQAJAAkACfwJAAkACQAJAAkACQAJAIAEtAABBMGsOCgoJAAECAwQFBggLC0ECDAYLQQMMBQtBBAwEC0EFDAMLQQYMAgtBBwwBC0EICyECQQAhBUEAIQcMAgtBCSECQQEhAEEAIQVBACEHDAELQQAhBUEBIQILIAMgAjoAKyABQQFqIQECQAJAIAMtAC5BEHENAAJAAkACQCADLQAqDgMBAAIECyAHRQ0DDAILIAANAQwCCyAFRQ0BCyADKAIEIQAgA0EANgIEIAMgACABEC4iAEUNAiADQeIANgIcIAMgATYCFCADIAA2AgxBACECDIoBCyADKAIEIQAgA0EANgIEIAMgACABEC4iAEUNdyADQeMANgIcIAMgATYCFCADIAA2AgxBACECDIkBCyADKAIEIQAgA0EANgIEIAMgACABEC4iAEUNdSADQeQANgIcIAMgATYCFCADIAA2AgwMiAELQdMAIQIMbQsgAy0AKUEiRg2AAUHSACECDGwLQQAhAAJAIAMoAjgiAkUNACACKAI8IgJFDQAgAyACEQAAIQALIABFBEBB1AAhAgxsCyAAQRVHBEAgA0EANgIcIAMgATYCFCADQZwNNgIQIANBITYCDEEAIQIMhgELIANB4QA2AhwgAyABNgIUIANB1hk2AhAgA0EVNgIMQQAhAgyFAQsgASAERgRAQeAAIQIMhQELAkACQAJAAkACQCABLQAAQQprDgQBBAQABAsgAUEBaiEBDAELIAFBAWohASADQS9qLQAAQQFxRQ0BC0HRACECDGwLIANBADYCHCADIAE2AhQgA0GIETYCECADQQk2AgxBACECDIUBCyADQQA2AhwgAyABNgIUIANBiBE2AhAgA0EJNgIMQQAhAgyEAQsgASAERgRAQd8AIQIMhAELIAEtAABBCkYEQCABQQFqIQEMCQsgAy0ALkHAAHENCCADQQA2AhwgAyABNgIUIANBiBE2AhAgA0ECNgIMQQAhAgyDAQsgASAERgRAQd0AIQIMgwELIAEtAAAiAkENRgRAIAFBAWohAUHPACECDGkLIAEhACACQQlrDgQFAQEFAQsgBCABIgBGBEBB3AAhAgyCAQsgAC0AAEEKRw0AIABBAWoMAgtBACECIANBADYCHCADIAA2AhQgA0G1LDYCECADQQc2AgwMgAELIAEgBEYEQEHbACECDIABCwJAIAEtAABBCWsOBAMAAAMACyABQQFqCyEBQc0AIQIMZAsgASAERgRAQdoAIQIMfgsgAS0AAEEJaw4EAAEBAAELQQAhAiADQQA2AhwgA0HsETYCECADQQc2AgwgAyABQQFqNgIUDHwLIANBgBI7ASpBACEAAkAgAygCOCICRQ0AIAIoAjAiAkUNACADIAIRAAAhAAsgAEUNACAAQRVHDQEgA0HZADYCHCADIAE2AhQgA0HwGTYCECADQRU2AgxBACECDHsLQcwAIQIMYAsgA0EANgIcIAMgATYCFCADQcENNgIQIANBGjYCDEEAIQIMeQsgASAERgRAQdkAIQIMeQsgAS0AAEEgRw06IAFBAWohASADLQAuQQFxDTogA0EANgIcIAMgATYCFCADQa0bNgIQIANBHjYCDEEAIQIMeAsgASAERgRAQdgAIQIMeAsCQAJAAkACQAJAIAEtAAAiAEEKaw4EAgMDAAELIAFBAWohAUErIQIMYQsgAEE6Rw0BIANBADYCHCADIAE2AhQgA0G5ETYCECADQQo2AgxBACECDHoLIAFBAWohASADQS9qLQAAQQFxRQ1tIAMtADJBgAFxRQRAIANBMmohAiADEDRBACEAAkAgAygCOCIGRQ0AIAYoAiQiBkUNACADIAYRAAAhAAsCQAJAIAAOFkpJSAEBAQEBAQEBAQEBAQEBAQEBAQABCyADQSk2AhwgAyABNgIUIANBshg2AhAgA0EVNgIMQQAhAgx7CyADQQA2AhwgAyABNgIUIANB3Qs2AhAgA0ERNgIMQQAhAgx6C0EAIQACQCADKAI4IgJFDQAgAigCVCICRQ0AIAMgAhEAACEACyAARQ1VIABBFUcNASADQQU2AhwgAyABNgIUIANBhho2AhAgA0EVNgIMQQAhAgx5C0HKACECDF4LQQAhAiADQQA2AhwgAyABNgIUIANB4g02AhAgA0EUNgIMDHcLIAMgAy8BMkGAAXI7ATIMOAsgASAERwRAIANBEDYCCCADIAE2AgRByQAhAgxcC0HXACECDHULIAEgBEYEQEHWACECDHULAkACQAJAAkAgAS0AACIAQSByIAAgAEHBAGtB/wFxQRpJG0H/AXFB4wBrDhMAPT09PT09PT09PT09AT09PQIDPQsgAUEBaiEBQcUAIQIMXQsgAUEBaiEBQcYAIQIMXAsgAUEBaiEBQccAIQIMWwsgAUEBaiEBQcgAIQIMWgtB1QAhAiAEIAEiAEYNcyAEIAFrIAMoAgAiAWohBiAAIAFrQQVqIQcDQCABQcDGAGotAAAgAC0AACIFQSByIAUgBUHBAGtB/wFxQRpJG0H/AXFHDQhBBCABQQVGDQoaIAFBAWohASAEIABBAWoiAEcNAAsgAyAGNgIADHMLQdQAIQIgBCABIgBGDXIgBCABayADKAIAIgFqIQYgACABa0EPaiEHA0AgAUGwxgBqLQAAIAAtAAAiBUEgciAFIAVBwQBrQf8BcUEaSRtB/wFxRw0HQQMgAUEPRg0JGiABQQFqIQEgBCAAQQFqIgBHDQALIAMgBjYCAAxyC0HTACECIAQgASIARg1xIAQgAWsgAygCACIBaiEGIAAgAWtBDmohBwNAIAFBksYAai0AACAALQAAIgVBIHIgBSAFQcEAa0H/AXFBGkkbQf8BcUcNBiABQQ5GDQcgAUEBaiEBIAQgAEEBaiIARw0ACyADIAY2AgAMcQtB0gAhAiAEIAEiAEYNcCAEIAFrIAMoAgAiAWohBSAAIAFrQQFqIQYDQCABQZDGAGotAAAgAC0AACIHQSByIAcgB0HBAGtB/wFxQRpJG0H/AXFHDQUgAUEBRg0CIAFBAWohASAEIABBAWoiAEcNAAsgAyAFNgIADHALIAEgBEYEQEHRACECDHALAkACQCABLQAAIgBBIHIgACAAQcEAa0H/AXFBGkkbQf8BcUHuAGsOBwA2NjY2NgE2CyABQQFqIQFBwgAhAgxWCyABQQFqIQFBwwAhAgxVCyADQQA2AgAgBkEBaiEBQcQAIQIMVAtB0AAhAiAEIAEiAEYNbSAEIAFrIAMoAgAiAWohBiAAIAFrQQlqIQcDQCABQYbGAGotAAAgAC0AACIFQSByIAUgBUHBAGtB/wFxQRpJG0H/AXFHDQJBAiABQQlGDQQaIAFBAWohASAEIABBAWoiAEcNAAsgAyAGNgIADG0LQc8AIQIgBCABIgBGDWwgBCABayADKAIAIgFqIQYgACABa0EFaiEHA0AgAUGAxgBqLQAAIAAtAAAiBUEgciAFIAVBwQBrQf8BcUEaSRtB/wFxRw0BIAFBBUYNAiABQQFqIQEgBCAAQQFqIgBHDQALIAMgBjYCAAxsCyAAIQEgA0EANgIADDALQQELOgAsIANBADYCACAHQQFqIQELQSwhAgxOCwJAA0AgAS0AAEGAxABqLQAAQQFHDQEgBCABQQFqIgFHDQALQc0AIQIMaAtBwQAhAgxNCyABIARGBEBBzAAhAgxnCyABLQAAQTpGBEAgAygCBCEAIANBADYCBCADIAAgARAvIgBFDTAgA0HLADYCHCADIAA2AgwgAyABQQFqNgIUQQAhAgxnCyADQQA2AhwgAyABNgIUIANBuRE2AhAgA0EKNgIMQQAhAgxmCwJAAkAgAy0ALEECaw4CAAEkCyADQTNqLQAAQQJxRQ0jIAMtAC5BAnENIyADQQA2AhwgAyABNgIUIANB1RM2AhAgA0ELNgIMQQAhAgxmCyADLQAyQSBxRQ0iIAMtAC5BAnENIiADQQA2AhwgAyABNgIUIANB7BI2AhAgA0EPNgIMQQAhAgxlC0EAIQACQCADKAI4IgJFDQAgAigCQCICRQ0AIAMgAhEAACEACyAARQRAQcAAIQIMSwsgAEEVRwRAIANBADYCHCADIAE2AhQgA0H4DjYCECADQRw2AgxBACECDGULIANBygA2AhwgAyABNgIUIANB8Bo2AhAgA0EVNgIMQQAhAgxkCyABIARHBEADQCABLQAAQfA/ai0AAEEBRw0XIAQgAUEBaiIBRw0AC0HEACECDGQLQcQAIQIMYwsgASAERwRAA0ACQCABLQAAIgBBIHIgACAAQcEAa0H/AXFBGkkbQf8BcSIAQQlGDQAgAEEgRg0AAkACQAJAAkAgAEHjAGsOEwADAwMDAwMDAQMDAwMDAwMDAwIDCyABQQFqIQFBNSECDE4LIAFBAWohAUE2IQIMTQsgAUEBaiEBQTchAgxMCwwVCyAEIAFBAWoiAUcNAAtBPCECDGMLQTwhAgxiCyABIARGBEBByAAhAgxiCyADQRE2AgggAyABNgIEAkACQAJAAkACQCADLQAsQQFrDgQUAAECCQsgAy0AMkEgcQ0DQdEBIQIMSwsCQCADLwEyIgBBCHFFDQAgAy0AKEEBRw0AIAMtAC5BCHFFDQILIAMgAEH3+wNxQYAEcjsBMgwLCyADIAMvATJBEHI7ATIMBAsgA0EANgIEIAMgASABEDAiAARAIANBwQA2AhwgAyAANgIMIAMgAUEBajYCFEEAIQIMYwsgAUEBaiEBDFILIANBADYCHCADIAE2AhQgA0GjEzYCECADQQQ2AgxBACECDGELQccAIQIgASAERg1gIAMoAgAiACAEIAFraiEFIAEgAGtBBmohBgJAA0AgAEHwwwBqLQAAIAEtAABBIHJHDQEgAEEGRg1GIABBAWohACAEIAFBAWoiAUcNAAsgAyAFNgIADGELIANBADYCAAwFCwJAIAEgBEcEQANAIAEtAABB8MEAai0AACIAQQFHBEAgAEECRw0DIAFBAWohAQwFCyAEIAFBAWoiAUcNAAtBxQAhAgxhC0HFACECDGALCyADQQA6ACwMAQtBCyECDEMLQT4hAgxCCwJAAkADQCABLQAAIgBBIEcEQAJAIABBCmsOBAMFBQMACyAAQSxGDQMMBAsgBCABQQFqIgFHDQALQcYAIQIMXQsgA0EIOgAsDA4LIAMtAChBAUcNAiADLQAuQQhxDQIgAygCBCEAIANBADYCBCADIAAgARAwIgAEQCADQcIANgIcIAMgADYCDCADIAFBAWo2AhRBACECDFwLIAFBAWohAQxKC0E6IQIMQAsCQANAIAEtAAAiAEEgRyAAQQlHcQ0BIAQgAUEBaiIBRw0AC0HDACECDFoLC0E7IQIMPgsCQAJAIAEgBEcEQANAIAEtAAAiAEEgRwRAIABBCmsOBAMEBAMECyAEIAFBAWoiAUcNAAtBPyECDFoLQT8hAgxZCyADIAMvATJBIHI7ATIMCgsgAygCBCEAIANBADYCBCADIAAgARAwIgBFDUggA0E+NgIcIAMgATYCFCADIAA2AgxBACECDFcLAkAgASAERwRAA0AgAS0AAEHwwQBqLQAAIgBBAUcEQCAAQQJGDQMMDAsgBCABQQFqIgFHDQALQTchAgxYC0E3IQIMVwsgAUEBaiEBDAQLQTshAiAEIAEiAEYNVSAEIAFrIAMoAgAiAWohBiAAIAFrQQVqIQcCQANAIAFBwMYAai0AACAALQAAIgVBIHIgBSAFQcEAa0H/AXFBGkkbQf8BcUcNASABQQVGBEBBByEBDDsLIAFBAWohASAEIABBAWoiAEcNAAsgAyAGNgIADFYLIANBADYCACAAIQEMBQtBOiECIAQgASIARg1UIAQgAWsgAygCACIBaiEGIAAgAWtBCGohBwJAA0AgAUHkP2otAAAgAC0AACIFQSByIAUgBUHBAGtB/wFxQRpJG0H/AXFHDQEgAUEIRgRAQQUhAQw6CyABQQFqIQEgBCAAQQFqIgBHDQALIAMgBjYCAAxVCyADQQA2AgAgACEBDAQLQTkhAiAEIAEiAEYNUyAEIAFrIAMoAgAiAWohBiAAIAFrQQNqIQcCQANAIAFB4D9qLQAAIAAtAAAiBUEgciAFIAVBwQBrQf8BcUEaSRtB/wFxRw0BIAFBA0YEQEEGIQEMOQsgAUEBaiEBIAQgAEEBaiIARw0ACyADIAY2AgAMVAsgA0EANgIAIAAhAQwDCwJAA0AgAS0AACIAQSBHBEAgAEEKaw4EBwQEBwILIAQgAUEBaiIBRw0AC0E4IQIMUwsgAEEsRw0BIAFBAWohAEEBIQECQAJAAkACQAJAIAMtACxBBWsOBAMBAgQACyAAIQEMBAtBAiEBDAELQQQhAQsgA0EBOgAsIAMgAy8BMiABcjsBMiAAIQEMAQsgAyADLwEyQQhyOwEyIAAhAQtBPSECDDcLIANBADoALAtBOCECDDULIAEgBEYEQEE2IQIMTwsCQAJAAkACQAJAIAEtAABBCmsOBAACAgECCyADKAIEIQAgA0EANgIEIAMgACABEDAiAEUNAiADQTM2AhwgAyABNgIUIAMgADYCDEEAIQIMUgsgAygCBCEAIANBADYCBCADIAAgARAwIgBFBEAgAUEBaiEBDAYLIANBMjYCHCADIAA2AgwgAyABQQFqNgIUQQAhAgxRCyADLQAuQQFxBEBB0AEhAgw3CyADKAIEIQAgA0EANgIEIAMgACABEDAiAA0BDEMLQTMhAgw1CyADQTU2AhwgAyABNgIUIAMgADYCDEEAIQIMTgtBNCECDDMLIANBL2otAABBAXENACADQQA2AhwgAyABNgIUIANB8RU2AhAgA0EZNgIMQQAhAgxMC0EyIQIMMQsgASAERgRAQTIhAgxLCwJAIAEtAABBCkYEQCABQQFqIQEMAQsgA0EANgIcIAMgATYCFCADQZgWNgIQIANBAzYCDEEAIQIMSwtBMSECDDALIAEgBEYEQEExIQIMSgsgAS0AACIAQQlHIABBIEdxDQEgAy0ALEEIRw0AIANBADoALAtBPCECDC4LQQEhAgJAAkACQAJAIAMtACxBBWsOBAMBAgAKCyADIAMvATJBCHI7ATIMCQtBAiECDAELQQQhAgsgA0EBOgAsIAMgAy8BMiACcjsBMgwGCyABIARGBEBBMCECDEcLIAEtAABBCkYEQCABQQFqIQEMAQsgAy0ALkEBcQ0AIANBADYCHCADIAE2AhQgA0HHJzYCECADQQI2AgxBACECDEYLQS8hAgwrCyABQQFqIQFBMCECDCoLIAEgBEYEQEEvIQIMRAsgAS0AACIAQQlHIABBIEdxRQRAIAFBAWohASADLQAuQQFxDQEgA0EANgIcIAMgATYCFCADQekPNgIQIANBCjYCDEEAIQIMRAtBASECAkACQAJAAkACQAJAIAMtACxBAmsOBwUEBAMBAgAECyADIAMvATJBCHI7ATIMAwtBAiECDAELQQQhAgsgA0EBOgAsIAMgAy8BMiACcjsBMgtBLiECDCoLIANBADYCHCADIAE2AhQgA0GzEjYCECADQQs2AgxBACECDEMLQdIBIQIMKAsgASAERgRAQS4hAgxCCyADQQA2AgQgA0ERNgIIIAMgASABEDAiAA0BC0EtIQIMJgsgA0EtNgIcIAMgATYCFCADIAA2AgxBACECDD8LQQAhAAJAIAMoAjgiAkUNACACKAJEIgJFDQAgAyACEQAAIQALIABFDQAgAEEVRw0BIANB2AA2AhwgAyABNgIUIANBnho2AhAgA0EVNgIMQQAhAgw+C0HLACECDCMLIANBADYCHCADIAE2AhQgA0GFDjYCECADQR02AgxBACECDDwLIAEgBEYEQEHOACECDDwLIAEtAAAiAEEgRg0CIABBOkYNAQsgA0EAOgAsQQkhAgwgCyADKAIEIQAgA0EANgIEIAMgACABEC8iAA0BDAILIAMtAC5BAXEEQEHPASECDB8LIAMoAgQhACADQQA2AgQgAyAAIAEQLyIARQ0CIANBKjYCHCADIAA2AgwgAyABQQFqNgIUQQAhAgw4CyADQcsANgIcIAMgADYCDCADIAFBAWo2AhRBACECDDcLIAFBAWohAUE/IQIMHAsgAUEBaiEBDCkLIAEgBEYEQEErIQIMNQsCQCABLQAAQQpGBEAgAUEBaiEBDAELIAMtAC5BwABxRQ0GCyADLQAyQYABcQRAQQAhAAJAIAMoAjgiAkUNACACKAJUIgJFDQAgAyACEQAAIQALIABFDREgAEEVRgRAIANBBTYCHCADIAE2AhQgA0GGGjYCECADQRU2AgxBACECDDYLIANBADYCHCADIAE2AhQgA0HiDTYCECADQRQ2AgxBACECDDULIANBMmohAiADEDRBACEAAkAgAygCOCIGRQ0AIAYoAiQiBkUNACADIAYRAAAhAAsgAA4WAgEABAQEBAQEBAQEBAQEBAQEBAQEAwQLIANBAToAMAsgAiACLwEAQcAAcjsBAAtBKiECDBcLIANBKTYCHCADIAE2AhQgA0GyGDYCECADQRU2AgxBACECDDALIANBADYCHCADIAE2AhQgA0HdCzYCECADQRE2AgxBACECDC8LIANBADYCHCADIAE2AhQgA0GdCzYCECADQQI2AgxBACECDC4LQQEhByADLwEyIgVBCHFFBEAgAykDIEIAUiEHCwJAIAMtADAEQEEBIQAgAy0AKUEFRg0BIAVBwABxRSAHcUUNAQsCQCADLQAoIgJBAkYEQEEBIQAgAy8BNCIGQeUARg0CQQAhACAFQcAAcQ0CIAZB5ABGDQIgBkHmAGtBAkkNAiAGQcwBRg0CIAZBsAJGDQIMAQtBACEAIAVBwABxDQELQQIhACAFQQhxDQAgBUGABHEEQAJAIAJBAUcNACADLQAuQQpxDQBBBSEADAILQQQhAAwBCyAFQSBxRQRAIAMQNUEAR0ECdCEADAELQQBBAyADKQMgUBshAAsCQCAAQQFrDgUAAQYHAgMLQQAhAgJAIAMoAjgiAEUNACAAKAIsIgBFDQAgAyAAEQAAIQILIAJFDSYgAkEVRgRAIANBAzYCHCADIAE2AhQgA0G9GjYCECADQRU2AgxBACECDC4LQQAhAiADQQA2AhwgAyABNgIUIANBrw42AhAgA0ESNgIMDC0LQc4BIQIMEgtBACECIANBADYCHCADIAE2AhQgA0HkHzYCECADQQ82AgwMKwtBACEAAkAgAygCOCICRQ0AIAIoAiwiAkUNACADIAIRAAAhAAsgAA0BC0EOIQIMDwsgAEEVRgRAIANBAjYCHCADIAE2AhQgA0G9GjYCECADQRU2AgxBACECDCkLQQAhAiADQQA2AhwgAyABNgIUIANBrw42AhAgA0ESNgIMDCgLQSkhAgwNCyADQQE6ADEMJAsgASAERwRAIANBCTYCCCADIAE2AgRBKCECDAwLQSYhAgwlCyADIAMpAyAiDCAEIAFrrSIKfSILQgAgCyAMWBs3AyAgCiAMVARAQSUhAgwlCyADKAIEIQBBACECIANBADYCBCADIAAgASAMp2oiARAxIgBFDQAgA0EFNgIcIAMgATYCFCADIAA2AgwMJAtBDyECDAkLIAEgBEYEQEEjIQIMIwtCACEKAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAIAEtAABBMGsONxcWAAECAwQFBgcUFBQUFBQUCAkKCwwNFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQODxAREhMUC0ICIQoMFgtCAyEKDBULQgQhCgwUC0IFIQoMEwtCBiEKDBILQgchCgwRC0IIIQoMEAtCCSEKDA8LQgohCgwOC0ILIQoMDQtCDCEKDAwLQg0hCgwLC0IOIQoMCgtCDyEKDAkLQgohCgwIC0ILIQoMBwtCDCEKDAYLQg0hCgwFC0IOIQoMBAtCDyEKDAMLQQAhAiADQQA2AhwgAyABNgIUIANBzhQ2AhAgA0EMNgIMDCILIAEgBEYEQEEiIQIMIgtCACEKAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQCABLQAAQTBrDjcVFAABAgMEBQYHFhYWFhYWFggJCgsMDRYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWDg8QERITFgtCAiEKDBQLQgMhCgwTC0IEIQoMEgtCBSEKDBELQgYhCgwQC0IHIQoMDwtCCCEKDA4LQgkhCgwNC0IKIQoMDAtCCyEKDAsLQgwhCgwKC0INIQoMCQtCDiEKDAgLQg8hCgwHC0IKIQoMBgtCCyEKDAULQgwhCgwEC0INIQoMAwtCDiEKDAILQg8hCgwBC0IBIQoLIAFBAWohASADKQMgIgtC//////////8PWARAIAMgC0IEhiAKhDcDIAwCC0EAIQIgA0EANgIcIAMgATYCFCADQa0JNgIQIANBDDYCDAwfC0ElIQIMBAtBJiECDAMLIAMgAToALCADQQA2AgAgB0EBaiEBQQwhAgwCCyADQQA2AgAgBkEBaiEBQQohAgwBCyABQQFqIQFBCCECDAALAAtBACECIANBADYCHCADIAE2AhQgA0HVEDYCECADQQk2AgwMGAtBACECIANBADYCHCADIAE2AhQgA0HXCjYCECADQQk2AgwMFwtBACECIANBADYCHCADIAE2AhQgA0G/EDYCECADQQk2AgwMFgtBACECIANBADYCHCADIAE2AhQgA0GkETYCECADQQk2AgwMFQtBACECIANBADYCHCADIAE2AhQgA0HVEDYCECADQQk2AgwMFAtBACECIANBADYCHCADIAE2AhQgA0HXCjYCECADQQk2AgwMEwtBACECIANBADYCHCADIAE2AhQgA0G/EDYCECADQQk2AgwMEgtBACECIANBADYCHCADIAE2AhQgA0GkETYCECADQQk2AgwMEQtBACECIANBADYCHCADIAE2AhQgA0G/FjYCECADQQ82AgwMEAtBACECIANBADYCHCADIAE2AhQgA0G/FjYCECADQQ82AgwMDwtBACECIANBADYCHCADIAE2AhQgA0HIEjYCECADQQs2AgwMDgtBACECIANBADYCHCADIAE2AhQgA0GVCTYCECADQQs2AgwMDQtBACECIANBADYCHCADIAE2AhQgA0HpDzYCECADQQo2AgwMDAtBACECIANBADYCHCADIAE2AhQgA0GDEDYCECADQQo2AgwMCwtBACECIANBADYCHCADIAE2AhQgA0GmHDYCECADQQI2AgwMCgtBACECIANBADYCHCADIAE2AhQgA0HFFTYCECADQQI2AgwMCQtBACECIANBADYCHCADIAE2AhQgA0H/FzYCECADQQI2AgwMCAtBACECIANBADYCHCADIAE2AhQgA0HKFzYCECADQQI2AgwMBwsgA0ECNgIcIAMgATYCFCADQZQdNgIQIANBFjYCDEEAIQIMBgtB3gAhAiABIARGDQUgCUEIaiEHIAMoAgAhBQJAAkAgASAERwRAIAVBxsYAaiEIIAQgBWogAWshBiAFQX9zQQpqIgUgAWohAANAIAEtAAAgCC0AAEcEQEECIQgMAwsgBUUEQEEAIQggACEBDAMLIAVBAWshBSAIQQFqIQggBCABQQFqIgFHDQALIAYhBSAEIQELIAdBATYCACADIAU2AgAMAQsgA0EANgIAIAcgCDYCAAsgByABNgIEIAkoAgwhACAJKAIIDgMBBQIACwALIANBADYCHCADQa0dNgIQIANBFzYCDCADIABBAWo2AhRBACECDAMLIANBADYCHCADIAA2AhQgA0HCHTYCECADQQk2AgxBACECDAILIAEgBEYEQEEoIQIMAgsgA0EJNgIIIAMgATYCBEEnIQIMAQsgASAERgRAQQEhAgwBCwNAAkACQAJAIAEtAABBCmsOBAABAQABCyABQQFqIQEMAQsgAUEBaiEBIAMtAC5BIHENAEEAIQIgA0EANgIcIAMgATYCFCADQYwgNgIQIANBBTYCDAwCC0EBIQIgASAERw0ACwsgCUEQaiQAIAJFBEAgAygCDCEADAELIAMgAjYCHEEAIQAgAygCBCIBRQ0AIAMgASAEIAMoAggRAQAiAUUNACADIAQ2AhQgAyABNgIMIAEhAAsgAAu+AgECfyAAQQA6AAAgAEHcAGoiAUEBa0EAOgAAIABBADoAAiAAQQA6AAEgAUEDa0EAOgAAIAFBAmtBADoAACAAQQA6AAMgAUEEa0EAOgAAQQAgAGtBA3EiASAAaiIAQQA2AgBB3AAgAWtBfHEiAiAAaiIBQQRrQQA2AgACQCACQQlJDQAgAEEANgIIIABBADYCBCABQQhrQQA2AgAgAUEMa0EANgIAIAJBGUkNACAAQQA2AhggAEEANgIUIABBADYCECAAQQA2AgwgAUEQa0EANgIAIAFBFGtBADYCACABQRhrQQA2AgAgAUEca0EANgIAIAIgAEEEcUEYciICayIBQSBJDQAgACACaiEAA0AgAEIANwMYIABCADcDECAAQgA3AwggAEIANwMAIABBIGohACABQSBrIgFBH0sNAAsLC1YBAX8CQCAAKAIMDQACQAJAAkACQCAALQAxDgMBAAMCCyAAKAI4IgFFDQAgASgCLCIBRQ0AIAAgAREAACIBDQMLQQAPCwALIABB0Bg2AhBBDiEBCyABCxoAIAAoAgxFBEAgAEHJHjYCECAAQRU2AgwLCxQAIAAoAgxBFUYEQCAAQQA2AgwLCxQAIAAoAgxBFkYEQCAAQQA2AgwLCwcAIAAoAgwLBwAgACgCEAsJACAAIAE2AhALBwAgACgCFAsXACAAQSRPBEAACyAAQQJ0QZQ3aigCAAsXACAAQS9PBEAACyAAQQJ0QaQ4aigCAAu/CQEBf0HfLCEBAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkAgAEHkAGsO9ANjYgABYWFhYWFhAgMEBWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWEGBwgJCgsMDQ4PYWFhYWEQYWFhYWFhYWFhYWERYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhEhMUFRYXGBkaG2FhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWEcHR4fICEiIyQlJicoKSorLC0uLzAxMjM0NTZhNzg5OmFhYWFhYWFhO2FhYTxhYWFhPT4/YWFhYWFhYWFAYWFBYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhQkNERUZHSElKS0xNTk9QUVJTYWFhYWFhYWFUVVZXWFlaW2FcXWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYV5hYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFfYGELQdUrDwtBgyUPC0G/MA8LQfI1DwtBtCgPC0GfKA8LQYEsDwtB1ioPC0H0Mw8LQa0zDwtByygPC0HOIw8LQcAjDwtB2SMPC0HRJA8LQZwzDwtBojYPC0H8Mw8LQeArDwtB4SUPC0HtIA8LQcQyDwtBqScPC0G5Ng8LQbggDwtBqyAPC0GjJA8LQbYkDwtBgSMPC0HhMg8LQZ80DwtByCkPC0HAMg8LQe4yDwtB8C8PC0HGNA8LQdAhDwtBmiQPC0HrLw8LQYQ1DwtByzUPC0GWMQ8LQcgrDwtB1C8PC0GTMA8LQd81DwtBtCMPC0G+NQ8LQdIpDwtBsyIPC0HNIA8LQZs2DwtBkCEPC0H/IA8LQa01DwtBsDQPC0HxJA8LQacqDwtB3TAPC0GLIg8LQcgvDwtB6yoPC0H0KQ8LQY8lDwtB3SIPC0HsJg8LQf0wDwtB1iYPC0GUNQ8LQY0jDwtBuikPC0HHIg8LQfIlDwtBtjMPC0GiIQ8LQf8vDwtBwCEPC0GBMw8LQcklDwtBqDEPC0HGMw8LQdM2DwtBxjYPC0HkNA8LQYgmDwtB7ScPC0H4IQ8LQakwDwtBjzQPC0GGNg8LQaovDwtBoSYPC0HsNg8LQZIpDwtBryYPC0GZIg8LQeAhDwsAC0G1JSEBCyABCxcAIAAgAC8BLkH+/wNxIAFBAEdyOwEuCxoAIAAgAC8BLkH9/wNxIAFBAEdBAXRyOwEuCxoAIAAgAC8BLkH7/wNxIAFBAEdBAnRyOwEuCxoAIAAgAC8BLkH3/wNxIAFBAEdBA3RyOwEuCxoAIAAgAC8BLkHv/wNxIAFBAEdBBHRyOwEuCxoAIAAgAC8BLkHf/wNxIAFBAEdBBXRyOwEuCxoAIAAgAC8BLkG//wNxIAFBAEdBBnRyOwEuCxoAIAAgAC8BLkH//gNxIAFBAEdBB3RyOwEuCxoAIAAgAC8BLkH//QNxIAFBAEdBCHRyOwEuCxoAIAAgAC8BLkH/+wNxIAFBAEdBCXRyOwEuCz4BAn8CQCAAKAI4IgNFDQAgAygCBCIDRQ0AIAAgASACIAFrIAMRAQAiBEF/Rw0AIABBzhE2AhBBGCEECyAECz4BAn8CQCAAKAI4IgNFDQAgAygCCCIDRQ0AIAAgASACIAFrIAMRAQAiBEF/Rw0AIABB5Ao2AhBBGCEECyAECz4BAn8CQCAAKAI4IgNFDQAgAygCDCIDRQ0AIAAgASACIAFrIAMRAQAiBEF/Rw0AIABB5R02AhBBGCEECyAECz4BAn8CQCAAKAI4IgNFDQAgAygCECIDRQ0AIAAgASACIAFrIAMRAQAiBEF/Rw0AIABBnRA2AhBBGCEECyAECz4BAn8CQCAAKAI4IgNFDQAgAygCFCIDRQ0AIAAgASACIAFrIAMRAQAiBEF/Rw0AIABBoh42AhBBGCEECyAECz4BAn8CQCAAKAI4IgNFDQAgAygCGCIDRQ0AIAAgASACIAFrIAMRAQAiBEF/Rw0AIABB7hQ2AhBBGCEECyAECz4BAn8CQCAAKAI4IgNFDQAgAygCKCIDRQ0AIAAgASACIAFrIAMRAQAiBEF/Rw0AIABB9gg2AhBBGCEECyAECz4BAn8CQCAAKAI4IgNFDQAgAygCHCIDRQ0AIAAgASACIAFrIAMRAQAiBEF/Rw0AIABB9xs2AhBBGCEECyAECz4BAn8CQCAAKAI4IgNFDQAgAygCICIDRQ0AIAAgASACIAFrIAMRAQAiBEF/Rw0AIABBlRU2AhBBGCEECyAECzgAIAACfyAALwEyQRRxQRRGBEBBASAALQAoQQFGDQEaIAAvATRB5QBGDAELIAAtAClBBUYLOgAwC1kBAn8CQCAALQAoQQFGDQAgAC8BNCIBQeQAa0HkAEkNACABQcwBRg0AIAFBsAJGDQAgAC8BMiIAQcAAcQ0AQQEhAiAAQYgEcUGABEYNACAAQShxRSECCyACC4wBAQJ/AkACQAJAIAAtACpFDQAgAC0AK0UNACAALwEyIgFBAnFFDQEMAgsgAC8BMiIBQQFxRQ0BC0EBIQIgAC0AKEEBRg0AIAAvATQiAEHkAGtB5ABJDQAgAEHMAUYNACAAQbACRg0AIAFBwABxDQBBACECIAFBiARxQYAERg0AIAFBKHFBAEchAgsgAgtXACAAQRhqQgA3AwAgAEIANwMAIABBOGpCADcDACAAQTBqQgA3AwAgAEEoakIANwMAIABBIGpCADcDACAAQRBqQgA3AwAgAEEIakIANwMAIABB7AE2AhwLBgAgABA5C5otAQt/IwBBEGsiCiQAQZjUACgCACIJRQRAQdjXACgCACIFRQRAQeTXAEJ/NwIAQdzXAEKAgISAgIDAADcCAEHY1wAgCkEIakFwcUHYqtWqBXMiBTYCAEHs1wBBADYCAEG81wBBADYCAAtBwNcAQYDYBDYCAEGQ1ABBgNgENgIAQaTUACAFNgIAQaDUAEF/NgIAQcTXAEGAqAM2AgADQCABQbzUAGogAUGw1ABqIgI2AgAgAiABQajUAGoiAzYCACABQbTUAGogAzYCACABQcTUAGogAUG41ABqIgM2AgAgAyACNgIAIAFBzNQAaiABQcDUAGoiAjYCACACIAM2AgAgAUHI1ABqIAI2AgAgAUEgaiIBQYACRw0AC0GM2ARBwacDNgIAQZzUAEHo1wAoAgA2AgBBjNQAQcCnAzYCAEGY1ABBiNgENgIAQcz/B0E4NgIAQYjYBCEJCwJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAIABB7AFNBEBBgNQAKAIAIgZBECAAQRNqQXBxIABBC0kbIgRBA3YiAHYiAUEDcQRAAkAgAUEBcSAAckEBcyICQQN0IgBBqNQAaiIBIABBsNQAaigCACIAKAIIIgNGBEBBgNQAIAZBfiACd3E2AgAMAQsgASADNgIIIAMgATYCDAsgAEEIaiEBIAAgAkEDdCICQQNyNgIEIAAgAmoiACAAKAIEQQFyNgIEDBELQYjUACgCACIIIARPDQEgAQRAAkBBAiAAdCICQQAgAmtyIAEgAHRxaCIAQQN0IgJBqNQAaiIBIAJBsNQAaigCACICKAIIIgNGBEBBgNQAIAZBfiAAd3EiBjYCAAwBCyABIAM2AgggAyABNgIMCyACIARBA3I2AgQgAEEDdCIAIARrIQUgACACaiAFNgIAIAIgBGoiBCAFQQFyNgIEIAgEQCAIQXhxQajUAGohAEGU1AAoAgAhAwJ/QQEgCEEDdnQiASAGcUUEQEGA1AAgASAGcjYCACAADAELIAAoAggLIgEgAzYCDCAAIAM2AgggAyAANgIMIAMgATYCCAsgAkEIaiEBQZTUACAENgIAQYjUACAFNgIADBELQYTUACgCACILRQ0BIAtoQQJ0QbDWAGooAgAiACgCBEF4cSAEayEFIAAhAgNAAkAgAigCECIBRQRAIAJBFGooAgAiAUUNAQsgASgCBEF4cSAEayIDIAVJIQIgAyAFIAIbIQUgASAAIAIbIQAgASECDAELCyAAKAIYIQkgACgCDCIDIABHBEBBkNQAKAIAGiADIAAoAggiATYCCCABIAM2AgwMEAsgAEEUaiICKAIAIgFFBEAgACgCECIBRQ0DIABBEGohAgsDQCACIQcgASIDQRRqIgIoAgAiAQ0AIANBEGohAiADKAIQIgENAAsgB0EANgIADA8LQX8hBCAAQb9/Sw0AIABBE2oiAUFwcSEEQYTUACgCACIIRQ0AQQAgBGshBQJAAkACQAJ/QQAgBEGAAkkNABpBHyAEQf///wdLDQAaIARBJiABQQh2ZyIAa3ZBAXEgAEEBdGtBPmoLIgZBAnRBsNYAaigCACICRQRAQQAhAUEAIQMMAQtBACEBIARBGSAGQQF2a0EAIAZBH0cbdCEAQQAhAwNAAkAgAigCBEF4cSAEayIHIAVPDQAgAiEDIAciBQ0AQQAhBSACIQEMAwsgASACQRRqKAIAIgcgByACIABBHXZBBHFqQRBqKAIAIgJGGyABIAcbIQEgAEEBdCEAIAINAAsLIAEgA3JFBEBBACEDQQIgBnQiAEEAIABrciAIcSIARQ0DIABoQQJ0QbDWAGooAgAhAQsgAUUNAQsDQCABKAIEQXhxIARrIgIgBUkhACACIAUgABshBSABIAMgABshAyABKAIQIgAEfyAABSABQRRqKAIACyIBDQALCyADRQ0AIAVBiNQAKAIAIARrTw0AIAMoAhghByADIAMoAgwiAEcEQEGQ1AAoAgAaIAAgAygCCCIBNgIIIAEgADYCDAwOCyADQRRqIgIoAgAiAUUEQCADKAIQIgFFDQMgA0EQaiECCwNAIAIhBiABIgBBFGoiAigCACIBDQAgAEEQaiECIAAoAhAiAQ0ACyAGQQA2AgAMDQtBiNQAKAIAIgMgBE8EQEGU1AAoAgAhAQJAIAMgBGsiAkEQTwRAIAEgBGoiACACQQFyNgIEIAEgA2ogAjYCACABIARBA3I2AgQMAQsgASADQQNyNgIEIAEgA2oiACAAKAIEQQFyNgIEQQAhAEEAIQILQYjUACACNgIAQZTUACAANgIAIAFBCGohAQwPC0GM1AAoAgAiAyAESwRAIAQgCWoiACADIARrIgFBAXI2AgRBmNQAIAA2AgBBjNQAIAE2AgAgCSAEQQNyNgIEIAlBCGohAQwPC0EAIQEgBAJ/QdjXACgCAARAQeDXACgCAAwBC0Hk1wBCfzcCAEHc1wBCgICEgICAwAA3AgBB2NcAIApBDGpBcHFB2KrVqgVzNgIAQezXAEEANgIAQbzXAEEANgIAQYCABAsiACAEQccAaiIFaiIGQQAgAGsiB3EiAk8EQEHw1wBBMDYCAAwPCwJAQbjXACgCACIBRQ0AQbDXACgCACIIIAJqIQAgACABTSAAIAhLcQ0AQQAhAUHw1wBBMDYCAAwPC0G81wAtAABBBHENBAJAAkAgCQRAQcDXACEBA0AgASgCACIAIAlNBEAgACABKAIEaiAJSw0DCyABKAIIIgENAAsLQQAQOiIAQX9GDQUgAiEGQdzXACgCACIBQQFrIgMgAHEEQCACIABrIAAgA2pBACABa3FqIQYLIAQgBk8NBSAGQf7///8HSw0FQbjXACgCACIDBEBBsNcAKAIAIgcgBmohASABIAdNDQYgASADSw0GCyAGEDoiASAARw0BDAcLIAYgA2sgB3EiBkH+////B0sNBCAGEDohACAAIAEoAgAgASgCBGpGDQMgACEBCwJAIAYgBEHIAGpPDQAgAUF/Rg0AQeDXACgCACIAIAUgBmtqQQAgAGtxIgBB/v///wdLBEAgASEADAcLIAAQOkF/RwRAIAAgBmohBiABIQAMBwtBACAGaxA6GgwECyABIgBBf0cNBQwDC0EAIQMMDAtBACEADAoLIABBf0cNAgtBvNcAQbzXACgCAEEEcjYCAAsgAkH+////B0sNASACEDohAEEAEDohASAAQX9GDQEgAUF/Rg0BIAAgAU8NASABIABrIgYgBEE4ak0NAQtBsNcAQbDXACgCACAGaiIBNgIAQbTXACgCACABSQRAQbTXACABNgIACwJAAkACQEGY1AAoAgAiAgRAQcDXACEBA0AgACABKAIAIgMgASgCBCIFakYNAiABKAIIIgENAAsMAgtBkNQAKAIAIgFBAEcgACABT3FFBEBBkNQAIAA2AgALQQAhAUHE1wAgBjYCAEHA1wAgADYCAEGg1ABBfzYCAEGk1ABB2NcAKAIANgIAQczXAEEANgIAA0AgAUG81ABqIAFBsNQAaiICNgIAIAIgAUGo1ABqIgM2AgAgAUG01ABqIAM2AgAgAUHE1ABqIAFBuNQAaiIDNgIAIAMgAjYCACABQczUAGogAUHA1ABqIgI2AgAgAiADNgIAIAFByNQAaiACNgIAIAFBIGoiAUGAAkcNAAtBeCAAa0EPcSIBIABqIgIgBkE4ayIDIAFrIgFBAXI2AgRBnNQAQejXACgCADYCAEGM1AAgATYCAEGY1AAgAjYCACAAIANqQTg2AgQMAgsgACACTQ0AIAIgA0kNACABKAIMQQhxDQBBeCACa0EPcSIAIAJqIgNBjNQAKAIAIAZqIgcgAGsiAEEBcjYCBCABIAUgBmo2AgRBnNQAQejXACgCADYCAEGM1AAgADYCAEGY1AAgAzYCACACIAdqQTg2AgQMAQsgAEGQ1AAoAgBJBEBBkNQAIAA2AgALIAAgBmohA0HA1wAhAQJAAkACQANAIAMgASgCAEcEQCABKAIIIgENAQwCCwsgAS0ADEEIcUUNAQtBwNcAIQEDQCABKAIAIgMgAk0EQCADIAEoAgRqIgUgAksNAwsgASgCCCEBDAALAAsgASAANgIAIAEgASgCBCAGajYCBCAAQXggAGtBD3FqIgkgBEEDcjYCBCADQXggA2tBD3FqIgYgBCAJaiIEayEBIAIgBkYEQEGY1AAgBDYCAEGM1ABBjNQAKAIAIAFqIgA2AgAgBCAAQQFyNgIEDAgLQZTUACgCACAGRgRAQZTUACAENgIAQYjUAEGI1AAoAgAgAWoiADYCACAEIABBAXI2AgQgACAEaiAANgIADAgLIAYoAgQiBUEDcUEBRw0GIAVBeHEhCCAFQf8BTQRAIAVBA3YhAyAGKAIIIgAgBigCDCICRgRAQYDUAEGA1AAoAgBBfiADd3E2AgAMBwsgAiAANgIIIAAgAjYCDAwGCyAGKAIYIQcgBiAGKAIMIgBHBEAgACAGKAIIIgI2AgggAiAANgIMDAULIAZBFGoiAigCACIFRQRAIAYoAhAiBUUNBCAGQRBqIQILA0AgAiEDIAUiAEEUaiICKAIAIgUNACAAQRBqIQIgACgCECIFDQALIANBADYCAAwEC0F4IABrQQ9xIgEgAGoiByAGQThrIgMgAWsiAUEBcjYCBCAAIANqQTg2AgQgAiAFQTcgBWtBD3FqQT9rIgMgAyACQRBqSRsiA0EjNgIEQZzUAEHo1wAoAgA2AgBBjNQAIAE2AgBBmNQAIAc2AgAgA0EQakHI1wApAgA3AgAgA0HA1wApAgA3AghByNcAIANBCGo2AgBBxNcAIAY2AgBBwNcAIAA2AgBBzNcAQQA2AgAgA0EkaiEBA0AgAUEHNgIAIAUgAUEEaiIBSw0ACyACIANGDQAgAyADKAIEQX5xNgIEIAMgAyACayIFNgIAIAIgBUEBcjYCBCAFQf8BTQRAIAVBeHFBqNQAaiEAAn9BgNQAKAIAIgFBASAFQQN2dCIDcUUEQEGA1AAgASADcjYCACAADAELIAAoAggLIgEgAjYCDCAAIAI2AgggAiAANgIMIAIgATYCCAwBC0EfIQEgBUH///8HTQRAIAVBJiAFQQh2ZyIAa3ZBAXEgAEEBdGtBPmohAQsgAiABNgIcIAJCADcCECABQQJ0QbDWAGohAEGE1AAoAgAiA0EBIAF0IgZxRQRAIAAgAjYCAEGE1AAgAyAGcjYCACACIAA2AhggAiACNgIIIAIgAjYCDAwBCyAFQRkgAUEBdmtBACABQR9HG3QhASAAKAIAIQMCQANAIAMiACgCBEF4cSAFRg0BIAFBHXYhAyABQQF0IQEgACADQQRxakEQaiIGKAIAIgMNAAsgBiACNgIAIAIgADYCGCACIAI2AgwgAiACNgIIDAELIAAoAggiASACNgIMIAAgAjYCCCACQQA2AhggAiAANgIMIAIgATYCCAtBjNQAKAIAIgEgBE0NAEGY1AAoAgAiACAEaiICIAEgBGsiAUEBcjYCBEGM1AAgATYCAEGY1AAgAjYCACAAIARBA3I2AgQgAEEIaiEBDAgLQQAhAUHw1wBBMDYCAAwHC0EAIQALIAdFDQACQCAGKAIcIgJBAnRBsNYAaiIDKAIAIAZGBEAgAyAANgIAIAANAUGE1ABBhNQAKAIAQX4gAndxNgIADAILIAdBEEEUIAcoAhAgBkYbaiAANgIAIABFDQELIAAgBzYCGCAGKAIQIgIEQCAAIAI2AhAgAiAANgIYCyAGQRRqKAIAIgJFDQAgAEEUaiACNgIAIAIgADYCGAsgASAIaiEBIAYgCGoiBigCBCEFCyAGIAVBfnE2AgQgASAEaiABNgIAIAQgAUEBcjYCBCABQf8BTQRAIAFBeHFBqNQAaiEAAn9BgNQAKAIAIgJBASABQQN2dCIBcUUEQEGA1AAgASACcjYCACAADAELIAAoAggLIgEgBDYCDCAAIAQ2AgggBCAANgIMIAQgATYCCAwBC0EfIQUgAUH///8HTQRAIAFBJiABQQh2ZyIAa3ZBAXEgAEEBdGtBPmohBQsgBCAFNgIcIARCADcCECAFQQJ0QbDWAGohAEGE1AAoAgAiAkEBIAV0IgNxRQRAIAAgBDYCAEGE1AAgAiADcjYCACAEIAA2AhggBCAENgIIIAQgBDYCDAwBCyABQRkgBUEBdmtBACAFQR9HG3QhBSAAKAIAIQACQANAIAAiAigCBEF4cSABRg0BIAVBHXYhACAFQQF0IQUgAiAAQQRxakEQaiIDKAIAIgANAAsgAyAENgIAIAQgAjYCGCAEIAQ2AgwgBCAENgIIDAELIAIoAggiACAENgIMIAIgBDYCCCAEQQA2AhggBCACNgIMIAQgADYCCAsgCUEIaiEBDAILAkAgB0UNAAJAIAMoAhwiAUECdEGw1gBqIgIoAgAgA0YEQCACIAA2AgAgAA0BQYTUACAIQX4gAXdxIgg2AgAMAgsgB0EQQRQgBygCECADRhtqIAA2AgAgAEUNAQsgACAHNgIYIAMoAhAiAQRAIAAgATYCECABIAA2AhgLIANBFGooAgAiAUUNACAAQRRqIAE2AgAgASAANgIYCwJAIAVBD00EQCADIAQgBWoiAEEDcjYCBCAAIANqIgAgACgCBEEBcjYCBAwBCyADIARqIgIgBUEBcjYCBCADIARBA3I2AgQgAiAFaiAFNgIAIAVB/wFNBEAgBUF4cUGo1ABqIQACf0GA1AAoAgAiAUEBIAVBA3Z0IgVxRQRAQYDUACABIAVyNgIAIAAMAQsgACgCCAsiASACNgIMIAAgAjYCCCACIAA2AgwgAiABNgIIDAELQR8hASAFQf///wdNBEAgBUEmIAVBCHZnIgBrdkEBcSAAQQF0a0E+aiEBCyACIAE2AhwgAkIANwIQIAFBAnRBsNYAaiEAQQEgAXQiBCAIcUUEQCAAIAI2AgBBhNQAIAQgCHI2AgAgAiAANgIYIAIgAjYCCCACIAI2AgwMAQsgBUEZIAFBAXZrQQAgAUEfRxt0IQEgACgCACEEAkADQCAEIgAoAgRBeHEgBUYNASABQR12IQQgAUEBdCEBIAAgBEEEcWpBEGoiBigCACIEDQALIAYgAjYCACACIAA2AhggAiACNgIMIAIgAjYCCAwBCyAAKAIIIgEgAjYCDCAAIAI2AgggAkEANgIYIAIgADYCDCACIAE2AggLIANBCGohAQwBCwJAIAlFDQACQCAAKAIcIgFBAnRBsNYAaiICKAIAIABGBEAgAiADNgIAIAMNAUGE1AAgC0F+IAF3cTYCAAwCCyAJQRBBFCAJKAIQIABGG2ogAzYCACADRQ0BCyADIAk2AhggACgCECIBBEAgAyABNgIQIAEgAzYCGAsgAEEUaigCACIBRQ0AIANBFGogATYCACABIAM2AhgLAkAgBUEPTQRAIAAgBCAFaiIBQQNyNgIEIAAgAWoiASABKAIEQQFyNgIEDAELIAAgBGoiByAFQQFyNgIEIAAgBEEDcjYCBCAFIAdqIAU2AgAgCARAIAhBeHFBqNQAaiEBQZTUACgCACEDAn9BASAIQQN2dCICIAZxRQRAQYDUACACIAZyNgIAIAEMAQsgASgCCAsiAiADNgIMIAEgAzYCCCADIAE2AgwgAyACNgIIC0GU1AAgBzYCAEGI1AAgBTYCAAsgAEEIaiEBCyAKQRBqJAAgAQtDACAARQRAPwBBEHQPCwJAIABB//8DcQ0AIABBAEgNACAAQRB2QAAiAEF/RgRAQfDXAEEwNgIAQX8PCyAAQRB0DwsACwvbQCIAQYAICwkBAAAAAgAAAAMAQZQICwUEAAAABQBBpAgLCQYAAAAHAAAACABB3AgLgjFJbnZhbGlkIGNoYXIgaW4gdXJsIHF1ZXJ5AFNwYW4gY2FsbGJhY2sgZXJyb3IgaW4gb25fYm9keQBDb250ZW50LUxlbmd0aCBvdmVyZmxvdwBDaHVuayBzaXplIG92ZXJmbG93AEludmFsaWQgbWV0aG9kIGZvciBIVFRQL3gueCByZXF1ZXN0AEludmFsaWQgbWV0aG9kIGZvciBSVFNQL3gueCByZXF1ZXN0AEV4cGVjdGVkIFNPVVJDRSBtZXRob2QgZm9yIElDRS94LnggcmVxdWVzdABJbnZhbGlkIGNoYXIgaW4gdXJsIGZyYWdtZW50IHN0YXJ0AEV4cGVjdGVkIGRvdABTcGFuIGNhbGxiYWNrIGVycm9yIGluIG9uX3N0YXR1cwBJbnZhbGlkIHJlc3BvbnNlIHN0YXR1cwBFeHBlY3RlZCBMRiBhZnRlciBoZWFkZXJzAEludmFsaWQgY2hhcmFjdGVyIGluIGNodW5rIGV4dGVuc2lvbnMAVXNlciBjYWxsYmFjayBlcnJvcgBgb25fcmVzZXRgIGNhbGxiYWNrIGVycm9yAGBvbl9jaHVua19oZWFkZXJgIGNhbGxiYWNrIGVycm9yAGBvbl9tZXNzYWdlX2JlZ2luYCBjYWxsYmFjayBlcnJvcgBgb25fY2h1bmtfZXh0ZW5zaW9uX3ZhbHVlYCBjYWxsYmFjayBlcnJvcgBgb25fc3RhdHVzX2NvbXBsZXRlYCBjYWxsYmFjayBlcnJvcgBgb25fdmVyc2lvbl9jb21wbGV0ZWAgY2FsbGJhY2sgZXJyb3IAYG9uX3VybF9jb21wbGV0ZWAgY2FsbGJhY2sgZXJyb3IAYG9uX2NodW5rX2NvbXBsZXRlYCBjYWxsYmFjayBlcnJvcgBgb25faGVhZGVyX3ZhbHVlX2NvbXBsZXRlYCBjYWxsYmFjayBlcnJvcgBgb25fbWVzc2FnZV9jb21wbGV0ZWAgY2FsbGJhY2sgZXJyb3IAYG9uX21ldGhvZF9jb21wbGV0ZWAgY2FsbGJhY2sgZXJyb3IAYG9uX2hlYWRlcl9maWVsZF9jb21wbGV0ZWAgY2FsbGJhY2sgZXJyb3IAYG9uX2NodW5rX2V4dGVuc2lvbl9uYW1lYCBjYWxsYmFjayBlcnJvcgBVbmV4cGVjdGVkIGNoYXIgaW4gdXJsIHNlcnZlcgBJbnZhbGlkIGhlYWRlciB2YWx1ZSBjaGFyAEludmFsaWQgaGVhZGVyIGZpZWxkIGNoYXIAU3BhbiBjYWxsYmFjayBlcnJvciBpbiBvbl92ZXJzaW9uAEludmFsaWQgbWlub3IgdmVyc2lvbgBJbnZhbGlkIG1ham9yIHZlcnNpb24ARXhwZWN0ZWQgc3BhY2UgYWZ0ZXIgdmVyc2lvbgBFeHBlY3RlZCBDUkxGIGFmdGVyIHZlcnNpb24ASW52YWxpZCBIVFRQIHZlcnNpb24ASW52YWxpZCBoZWFkZXIgdG9rZW4AU3BhbiBjYWxsYmFjayBlcnJvciBpbiBvbl91cmwASW52YWxpZCBjaGFyYWN0ZXJzIGluIHVybABVbmV4cGVjdGVkIHN0YXJ0IGNoYXIgaW4gdXJsAERvdWJsZSBAIGluIHVybABFbXB0eSBDb250ZW50LUxlbmd0aABJbnZhbGlkIGNoYXJhY3RlciBpbiBDb250ZW50LUxlbmd0aABUcmFuc2Zlci1FbmNvZGluZyBjYW4ndCBiZSBwcmVzZW50IHdpdGggQ29udGVudC1MZW5ndGgARHVwbGljYXRlIENvbnRlbnQtTGVuZ3RoAEludmFsaWQgY2hhciBpbiB1cmwgcGF0aABDb250ZW50LUxlbmd0aCBjYW4ndCBiZSBwcmVzZW50IHdpdGggVHJhbnNmZXItRW5jb2RpbmcATWlzc2luZyBleHBlY3RlZCBDUiBhZnRlciBjaHVuayBzaXplAEV4cGVjdGVkIExGIGFmdGVyIGNodW5rIHNpemUASW52YWxpZCBjaGFyYWN0ZXIgaW4gY2h1bmsgc2l6ZQBTcGFuIGNhbGxiYWNrIGVycm9yIGluIG9uX2hlYWRlcl92YWx1ZQBTcGFuIGNhbGxiYWNrIGVycm9yIGluIG9uX2NodW5rX2V4dGVuc2lvbl92YWx1ZQBJbnZhbGlkIGNoYXJhY3RlciBpbiBjaHVuayBleHRlbnNpb25zIHZhbHVlAE1pc3NpbmcgZXhwZWN0ZWQgQ1IgYWZ0ZXIgaGVhZGVyIHZhbHVlAE1pc3NpbmcgZXhwZWN0ZWQgTEYgYWZ0ZXIgaGVhZGVyIHZhbHVlAEludmFsaWQgYFRyYW5zZmVyLUVuY29kaW5nYCBoZWFkZXIgdmFsdWUATWlzc2luZyBleHBlY3RlZCBDUiBhZnRlciBjaHVuayBleHRlbnNpb24gdmFsdWUASW52YWxpZCBjaGFyYWN0ZXIgaW4gY2h1bmsgZXh0ZW5zaW9ucyBxdW90ZSB2YWx1ZQBJbnZhbGlkIHF1b3RlZC1wYWlyIGluIGNodW5rIGV4dGVuc2lvbnMgcXVvdGVkIHZhbHVlAEludmFsaWQgY2hhcmFjdGVyIGluIGNodW5rIGV4dGVuc2lvbnMgcXVvdGVkIHZhbHVlAFBhdXNlZCBieSBvbl9oZWFkZXJzX2NvbXBsZXRlAEludmFsaWQgRU9GIHN0YXRlAG9uX3Jlc2V0IHBhdXNlAG9uX2NodW5rX2hlYWRlciBwYXVzZQBvbl9tZXNzYWdlX2JlZ2luIHBhdXNlAG9uX2NodW5rX2V4dGVuc2lvbl92YWx1ZSBwYXVzZQBvbl9zdGF0dXNfY29tcGxldGUgcGF1c2UAb25fdmVyc2lvbl9jb21wbGV0ZSBwYXVzZQBvbl91cmxfY29tcGxldGUgcGF1c2UAb25fY2h1bmtfY29tcGxldGUgcGF1c2UAb25faGVhZGVyX3ZhbHVlX2NvbXBsZXRlIHBhdXNlAG9uX21lc3NhZ2VfY29tcGxldGUgcGF1c2UAb25fbWV0aG9kX2NvbXBsZXRlIHBhdXNlAG9uX2hlYWRlcl9maWVsZF9jb21wbGV0ZSBwYXVzZQBvbl9jaHVua19leHRlbnNpb25fbmFtZSBwYXVzZQBVbmV4cGVjdGVkIHNwYWNlIGFmdGVyIHN0YXJ0IGxpbmUATWlzc2luZyBleHBlY3RlZCBDUiBhZnRlciByZXNwb25zZSBsaW5lAFNwYW4gY2FsbGJhY2sgZXJyb3IgaW4gb25fY2h1bmtfZXh0ZW5zaW9uX25hbWUASW52YWxpZCBjaGFyYWN0ZXIgaW4gY2h1bmsgZXh0ZW5zaW9ucyBuYW1lAE1pc3NpbmcgZXhwZWN0ZWQgQ1IgYWZ0ZXIgY2h1bmsgZXh0ZW5zaW9uIG5hbWUASW52YWxpZCBzdGF0dXMgY29kZQBQYXVzZSBvbiBDT05ORUNUL1VwZ3JhZGUAUGF1c2Ugb24gUFJJL1VwZ3JhZGUARXhwZWN0ZWQgSFRUUC8yIENvbm5lY3Rpb24gUHJlZmFjZQBTcGFuIGNhbGxiYWNrIGVycm9yIGluIG9uX21ldGhvZABFeHBlY3RlZCBzcGFjZSBhZnRlciBtZXRob2QAU3BhbiBjYWxsYmFjayBlcnJvciBpbiBvbl9oZWFkZXJfZmllbGQAUGF1c2VkAEludmFsaWQgd29yZCBlbmNvdW50ZXJlZABJbnZhbGlkIG1ldGhvZCBlbmNvdW50ZXJlZABNaXNzaW5nIGV4cGVjdGVkIENSIGFmdGVyIGNodW5rIGRhdGEARXhwZWN0ZWQgTEYgYWZ0ZXIgY2h1bmsgZGF0YQBVbmV4cGVjdGVkIGNoYXIgaW4gdXJsIHNjaGVtYQBSZXF1ZXN0IGhhcyBpbnZhbGlkIGBUcmFuc2Zlci1FbmNvZGluZ2AARGF0YSBhZnRlciBgQ29ubmVjdGlvbjogY2xvc2VgAFNXSVRDSF9QUk9YWQBVU0VfUFJPWFkATUtBQ1RJVklUWQBVTlBST0NFU1NBQkxFX0VOVElUWQBRVUVSWQBDT1BZAE1PVkVEX1BFUk1BTkVOVExZAFRPT19FQVJMWQBOT1RJRlkARkFJTEVEX0RFUEVOREVOQ1kAQkFEX0dBVEVXQVkAUExBWQBQVVQAQ0hFQ0tPVVQAR0FURVdBWV9USU1FT1VUAFJFUVVFU1RfVElNRU9VVABORVRXT1JLX0NPTk5FQ1RfVElNRU9VVABDT05ORUNUSU9OX1RJTUVPVVQATE9HSU5fVElNRU9VVABORVRXT1JLX1JFQURfVElNRU9VVABQT1NUAE1JU0RJUkVDVEVEX1JFUVVFU1QAQ0xJRU5UX0NMT1NFRF9SRVFVRVNUAENMSUVOVF9DTE9TRURfTE9BRF9CQUxBTkNFRF9SRVFVRVNUAEJBRF9SRVFVRVNUAEhUVFBfUkVRVUVTVF9TRU5UX1RPX0hUVFBTX1BPUlQAUkVQT1JUAElNX0FfVEVBUE9UAFJFU0VUX0NPTlRFTlQATk9fQ09OVEVOVABQQVJUSUFMX0NPTlRFTlQASFBFX0lOVkFMSURfQ09OU1RBTlQASFBFX0NCX1JFU0VUAEdFVABIUEVfU1RSSUNUAENPTkZMSUNUAFRFTVBPUkFSWV9SRURJUkVDVABQRVJNQU5FTlRfUkVESVJFQ1QAQ09OTkVDVABNVUxUSV9TVEFUVVMASFBFX0lOVkFMSURfU1RBVFVTAFRPT19NQU5ZX1JFUVVFU1RTAEVBUkxZX0hJTlRTAFVOQVZBSUxBQkxFX0ZPUl9MRUdBTF9SRUFTT05TAE9QVElPTlMAU1dJVENISU5HX1BST1RPQ09MUwBWQVJJQU5UX0FMU09fTkVHT1RJQVRFUwBNVUxUSVBMRV9DSE9JQ0VTAElOVEVSTkFMX1NFUlZFUl9FUlJPUgBXRUJfU0VSVkVSX1VOS05PV05fRVJST1IAUkFJTEdVTl9FUlJPUgBJREVOVElUWV9QUk9WSURFUl9BVVRIRU5USUNBVElPTl9FUlJPUgBTU0xfQ0VSVElGSUNBVEVfRVJST1IASU5WQUxJRF9YX0ZPUldBUkRFRF9GT1IAU0VUX1BBUkFNRVRFUgBHRVRfUEFSQU1FVEVSAEhQRV9VU0VSAFNFRV9PVEhFUgBIUEVfQ0JfQ0hVTktfSEVBREVSAEV4cGVjdGVkIExGIGFmdGVyIENSAE1LQ0FMRU5EQVIAU0VUVVAAV0VCX1NFUlZFUl9JU19ET1dOAFRFQVJET1dOAEhQRV9DTE9TRURfQ09OTkVDVElPTgBIRVVSSVNUSUNfRVhQSVJBVElPTgBESVNDT05ORUNURURfT1BFUkFUSU9OAE5PTl9BVVRIT1JJVEFUSVZFX0lORk9STUFUSU9OAEhQRV9JTlZBTElEX1ZFUlNJT04ASFBFX0NCX01FU1NBR0VfQkVHSU4AU0lURV9JU19GUk9aRU4ASFBFX0lOVkFMSURfSEVBREVSX1RPS0VOAElOVkFMSURfVE9LRU4ARk9SQklEREVOAEVOSEFOQ0VfWU9VUl9DQUxNAEhQRV9JTlZBTElEX1VSTABCTE9DS0VEX0JZX1BBUkVOVEFMX0NPTlRST0wATUtDT0wAQUNMAEhQRV9JTlRFUk5BTABSRVFVRVNUX0hFQURFUl9GSUVMRFNfVE9PX0xBUkdFX1VOT0ZGSUNJQUwASFBFX09LAFVOTElOSwBVTkxPQ0sAUFJJAFJFVFJZX1dJVEgASFBFX0lOVkFMSURfQ09OVEVOVF9MRU5HVEgASFBFX1VORVhQRUNURURfQ09OVEVOVF9MRU5HVEgARkxVU0gAUFJPUFBBVENIAE0tU0VBUkNIAFVSSV9UT09fTE9ORwBQUk9DRVNTSU5HAE1JU0NFTExBTkVPVVNfUEVSU0lTVEVOVF9XQVJOSU5HAE1JU0NFTExBTkVPVVNfV0FSTklORwBIUEVfSU5WQUxJRF9UUkFOU0ZFUl9FTkNPRElORwBFeHBlY3RlZCBDUkxGAEhQRV9JTlZBTElEX0NIVU5LX1NJWkUATU9WRQBDT05USU5VRQBIUEVfQ0JfU1RBVFVTX0NPTVBMRVRFAEhQRV9DQl9IRUFERVJTX0NPTVBMRVRFAEhQRV9DQl9WRVJTSU9OX0NPTVBMRVRFAEhQRV9DQl9VUkxfQ09NUExFVEUASFBFX0NCX0NIVU5LX0NPTVBMRVRFAEhQRV9DQl9IRUFERVJfVkFMVUVfQ09NUExFVEUASFBFX0NCX0NIVU5LX0VYVEVOU0lPTl9WQUxVRV9DT01QTEVURQBIUEVfQ0JfQ0hVTktfRVhURU5TSU9OX05BTUVfQ09NUExFVEUASFBFX0NCX01FU1NBR0VfQ09NUExFVEUASFBFX0NCX01FVEhPRF9DT01QTEVURQBIUEVfQ0JfSEVBREVSX0ZJRUxEX0NPTVBMRVRFAERFTEVURQBIUEVfSU5WQUxJRF9FT0ZfU1RBVEUASU5WQUxJRF9TU0xfQ0VSVElGSUNBVEUAUEFVU0UATk9fUkVTUE9OU0UAVU5TVVBQT1JURURfTUVESUFfVFlQRQBHT05FAE5PVF9BQ0NFUFRBQkxFAFNFUlZJQ0VfVU5BVkFJTEFCTEUAUkFOR0VfTk9UX1NBVElTRklBQkxFAE9SSUdJTl9JU19VTlJFQUNIQUJMRQBSRVNQT05TRV9JU19TVEFMRQBQVVJHRQBNRVJHRQBSRVFVRVNUX0hFQURFUl9GSUVMRFNfVE9PX0xBUkdFAFJFUVVFU1RfSEVBREVSX1RPT19MQVJHRQBQQVlMT0FEX1RPT19MQVJHRQBJTlNVRkZJQ0lFTlRfU1RPUkFHRQBIUEVfUEFVU0VEX1VQR1JBREUASFBFX1BBVVNFRF9IMl9VUEdSQURFAFNPVVJDRQBBTk5PVU5DRQBUUkFDRQBIUEVfVU5FWFBFQ1RFRF9TUEFDRQBERVNDUklCRQBVTlNVQlNDUklCRQBSRUNPUkQASFBFX0lOVkFMSURfTUVUSE9EAE5PVF9GT1VORABQUk9QRklORABVTkJJTkQAUkVCSU5EAFVOQVVUSE9SSVpFRABNRVRIT0RfTk9UX0FMTE9XRUQASFRUUF9WRVJTSU9OX05PVF9TVVBQT1JURUQAQUxSRUFEWV9SRVBPUlRFRABBQ0NFUFRFRABOT1RfSU1QTEVNRU5URUQATE9PUF9ERVRFQ1RFRABIUEVfQ1JfRVhQRUNURUQASFBFX0xGX0VYUEVDVEVEAENSRUFURUQASU1fVVNFRABIUEVfUEFVU0VEAFRJTUVPVVRfT0NDVVJFRABQQVlNRU5UX1JFUVVJUkVEAFBSRUNPTkRJVElPTl9SRVFVSVJFRABQUk9YWV9BVVRIRU5USUNBVElPTl9SRVFVSVJFRABORVRXT1JLX0FVVEhFTlRJQ0FUSU9OX1JFUVVJUkVEAExFTkdUSF9SRVFVSVJFRABTU0xfQ0VSVElGSUNBVEVfUkVRVUlSRUQAVVBHUkFERV9SRVFVSVJFRABQQUdFX0VYUElSRUQAUFJFQ09ORElUSU9OX0ZBSUxFRABFWFBFQ1RBVElPTl9GQUlMRUQAUkVWQUxJREFUSU9OX0ZBSUxFRABTU0xfSEFORFNIQUtFX0ZBSUxFRABMT0NLRUQAVFJBTlNGT1JNQVRJT05fQVBQTElFRABOT1RfTU9ESUZJRUQATk9UX0VYVEVOREVEAEJBTkRXSURUSF9MSU1JVF9FWENFRURFRABTSVRFX0lTX09WRVJMT0FERUQASEVBRABFeHBlY3RlZCBIVFRQLwAAUhUAABoVAAAPEgAA5BkAAJEVAAAJFAAALRkAAOQUAADpEQAAaRQAAKEUAAB2FQAAQxYAAF4SAACUFwAAFxYAAH0UAAB/FgAAQRcAALMTAADDFgAABBoAAL0YAADQGAAAoBMAANQZAACvFgAAaBYAAHAXAADZFgAA/BgAAP4RAABZFwAAlxYAABwXAAD2FgAAjRcAAAsSAAB/GwAALhEAALMQAABJEgAArRIAAPYYAABoEAAAYhUAABAVAABaFgAAShkAALUVAADBFQAAYBUAAFwZAABaGQAAUxkAABYVAACtEQAAQhAAALcQAABXGAAAvxUAAIkQAAAcGQAAGhkAALkVAABRGAAA3BMAAFsVAABZFQAA5hgAAGcVAAARGQAA7RgAAOcTAACuEAAAwhcAAAAUAACSEwAAhBMAAEASAAAmGQAArxUAAGIQAEHpOQsBAQBBgDoL4AEBAQIBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEDAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQBB6jsLBAEAAAIAQYE8C14DBAMDAwMDAAADAwADAwADAwMDAwMDAwMDAAUAAAAAAAMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAAAAAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMAAwADAEHqPQsEAQAAAgBBgT4LXgMAAwMDAwMAAAMDAAMDAAMDAwMDAwMDAwMABAAFAAAAAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMAAAADAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwADAAMAQeA/Cw1sb3NlZWVwLWFsaXZlAEH5PwsBAQBBkMAAC+ABAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEAAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEAQfnBAAsBAQBBkMIAC+cBAQEBAQEBAQEBAQEBAgEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEAAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQFjaHVua2VkAEGhxAALXgEAAQEBAQEAAAEBAAEBAAEBAQEBAQEBAQEAAAAAAAAAAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEAAAABAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQABAAEAQYDGAAshZWN0aW9uZW50LWxlbmd0aG9ucm94eS1jb25uZWN0aW9uAEGwxgALK3JhbnNmZXItZW5jb2RpbmdwZ3JhZGUNCg0KU00NCg0KVFRQL0NFL1RTUC8AQenGAAsFAQIAAQMAQYDHAAtfBAUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUAQenIAAsFAQIAAQMAQYDJAAtfBAUFBgUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUAQenKAAsEAQAAAQBBgcsAC14CAgACAgICAgICAgICAgICAgICAgICAgICAgICAgIAAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAEHpzAALBQECAAEDAEGAzQALXwQFAAAFBQUFBQUFBQUFBQYFBQUFBQUFBQUFBQUABQAHCAUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQAFAAUABQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUAAAAFAEHpzgALBQEBAAEBAEGAzwALAQEAQZrPAAtBAgAAAAAAAAMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAAAAAAAAAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMAQenQAAsFAQEAAQEAQYDRAAsBAQBBitEACwYCAAAAAAIAQaHRAAs6AwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMAAAAAAAADAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwBB4NIAC5oBTk9VTkNFRUNLT1VUTkVDVEVURUNSSUJFTFVTSEVURUFEU0VBUkNIUkdFQ1RJVklUWUxFTkRBUlZFT1RJRllQVElPTlNDSFNFQVlTVEFUQ0hHRVVFUllPUkRJUkVDVE9SVFJDSFBBUkFNRVRFUlVSQ0VCU0NSSUJFQVJET1dOQUNFSU5ETktDS1VCU0NSSUJFSFRUUC9BRFRQLw==";
    var wasmBuffer;
    Object.defineProperty(module2, "exports", {
      get: () => {
        return wasmBuffer ? wasmBuffer : wasmBuffer = Buffer2.from(wasmBase64, "base64");
      }
    });
  }
});

// node_modules/undici/lib/llhttp/llhttp_simd-wasm.js
var require_llhttp_simd_wasm = __commonJS({
  "node_modules/undici/lib/llhttp/llhttp_simd-wasm.js"(exports2, module2) {
    "use strict";
    var { Buffer: Buffer2 } = require("node:buffer");
    var wasmBase64 = "AGFzbQEAAAABJwdgAX8Bf2ADf39/AX9gAn9/AGABfwBgBH9/f38Bf2AAAGADf39/AALLAQgDZW52GHdhc21fb25faGVhZGVyc19jb21wbGV0ZQAEA2VudhV3YXNtX29uX21lc3NhZ2VfYmVnaW4AAANlbnYLd2FzbV9vbl91cmwAAQNlbnYOd2FzbV9vbl9zdGF0dXMAAQNlbnYUd2FzbV9vbl9oZWFkZXJfZmllbGQAAQNlbnYUd2FzbV9vbl9oZWFkZXJfdmFsdWUAAQNlbnYMd2FzbV9vbl9ib2R5AAEDZW52GHdhc21fb25fbWVzc2FnZV9jb21wbGV0ZQAAAzQzBQYAAAMAAAAAAAADAQMAAwMDAAACAAAAAAICAgICAgICAgIBAQEBAQEBAQEDAAADAAAABAUBcAESEgUDAQACBggBfwFBgNgECwfFBygGbWVtb3J5AgALX2luaXRpYWxpemUACBlfX2luZGlyZWN0X2Z1bmN0aW9uX3RhYmxlAQALbGxodHRwX2luaXQACRhsbGh0dHBfc2hvdWxkX2tlZXBfYWxpdmUANgxsbGh0dHBfYWxsb2MACwZtYWxsb2MAOAtsbGh0dHBfZnJlZQAMBGZyZWUADA9sbGh0dHBfZ2V0X3R5cGUADRVsbGh0dHBfZ2V0X2h0dHBfbWFqb3IADhVsbGh0dHBfZ2V0X2h0dHBfbWlub3IADxFsbGh0dHBfZ2V0X21ldGhvZAAQFmxsaHR0cF9nZXRfc3RhdHVzX2NvZGUAERJsbGh0dHBfZ2V0X3VwZ3JhZGUAEgxsbGh0dHBfcmVzZXQAEw5sbGh0dHBfZXhlY3V0ZQAUFGxsaHR0cF9zZXR0aW5nc19pbml0ABUNbGxodHRwX2ZpbmlzaAAWDGxsaHR0cF9wYXVzZQAXDWxsaHR0cF9yZXN1bWUAGBtsbGh0dHBfcmVzdW1lX2FmdGVyX3VwZ3JhZGUAGRBsbGh0dHBfZ2V0X2Vycm5vABoXbGxodHRwX2dldF9lcnJvcl9yZWFzb24AGxdsbGh0dHBfc2V0X2Vycm9yX3JlYXNvbgAcFGxsaHR0cF9nZXRfZXJyb3JfcG9zAB0RbGxodHRwX2Vycm5vX25hbWUAHhJsbGh0dHBfbWV0aG9kX25hbWUAHxJsbGh0dHBfc3RhdHVzX25hbWUAIBpsbGh0dHBfc2V0X2xlbmllbnRfaGVhZGVycwAhIWxsaHR0cF9zZXRfbGVuaWVudF9jaHVua2VkX2xlbmd0aAAiHWxsaHR0cF9zZXRfbGVuaWVudF9rZWVwX2FsaXZlACMkbGxodHRwX3NldF9sZW5pZW50X3RyYW5zZmVyX2VuY29kaW5nACQabGxodHRwX3NldF9sZW5pZW50X3ZlcnNpb24AJSNsbGh0dHBfc2V0X2xlbmllbnRfZGF0YV9hZnRlcl9jbG9zZQAmJ2xsaHR0cF9zZXRfbGVuaWVudF9vcHRpb25hbF9sZl9hZnRlcl9jcgAnLGxsaHR0cF9zZXRfbGVuaWVudF9vcHRpb25hbF9jcmxmX2FmdGVyX2NodW5rACgobGxodHRwX3NldF9sZW5pZW50X29wdGlvbmFsX2NyX2JlZm9yZV9sZgApKmxsaHR0cF9zZXRfbGVuaWVudF9zcGFjZXNfYWZ0ZXJfY2h1bmtfc2l6ZQAqGGxsaHR0cF9tZXNzYWdlX25lZWRzX2VvZgA1CRcBAEEBCxEBAgMEBQoGBzEzMi0uLCsvMArYywIzFgBB/NMAKAIABEAAC0H80wBBATYCAAsUACAAEDcgACACNgI4IAAgAToAKAsUACAAIAAvATQgAC0AMCAAEDYQAAseAQF/QcAAEDkiARA3IAFBgAg2AjggASAAOgAoIAELjwwBB38CQCAARQ0AIABBCGsiASAAQQRrKAIAIgBBeHEiBGohBQJAIABBAXENACAAQQNxRQ0BIAEgASgCACIAayIBQZDUACgCAEkNASAAIARqIQQCQAJAQZTUACgCACABRwRAIABB/wFNBEAgAEEDdiEDIAEoAggiACABKAIMIgJGBEBBgNQAQYDUACgCAEF+IAN3cTYCAAwFCyACIAA2AgggACACNgIMDAQLIAEoAhghBiABIAEoAgwiAEcEQCAAIAEoAggiAjYCCCACIAA2AgwMAwsgAUEUaiIDKAIAIgJFBEAgASgCECICRQ0CIAFBEGohAwsDQCADIQcgAiIAQRRqIgMoAgAiAg0AIABBEGohAyAAKAIQIgINAAsgB0EANgIADAILIAUoAgQiAEEDcUEDRw0CIAUgAEF+cTYCBEGI1AAgBDYCACAFIAQ2AgAgASAEQQFyNgIEDAMLQQAhAAsgBkUNAAJAIAEoAhwiAkECdEGw1gBqIgMoAgAgAUYEQCADIAA2AgAgAA0BQYTUAEGE1AAoAgBBfiACd3E2AgAMAgsgBkEQQRQgBigCECABRhtqIAA2AgAgAEUNAQsgACAGNgIYIAEoAhAiAgRAIAAgAjYCECACIAA2AhgLIAFBFGooAgAiAkUNACAAQRRqIAI2AgAgAiAANgIYCyABIAVPDQAgBSgCBCIAQQFxRQ0AAkACQAJAAkAgAEECcUUEQEGY1AAoAgAgBUYEQEGY1AAgATYCAEGM1ABBjNQAKAIAIARqIgA2AgAgASAAQQFyNgIEIAFBlNQAKAIARw0GQYjUAEEANgIAQZTUAEEANgIADAYLQZTUACgCACAFRgRAQZTUACABNgIAQYjUAEGI1AAoAgAgBGoiADYCACABIABBAXI2AgQgACABaiAANgIADAYLIABBeHEgBGohBCAAQf8BTQRAIABBA3YhAyAFKAIIIgAgBSgCDCICRgRAQYDUAEGA1AAoAgBBfiADd3E2AgAMBQsgAiAANgIIIAAgAjYCDAwECyAFKAIYIQYgBSAFKAIMIgBHBEBBkNQAKAIAGiAAIAUoAggiAjYCCCACIAA2AgwMAwsgBUEUaiIDKAIAIgJFBEAgBSgCECICRQ0CIAVBEGohAwsDQCADIQcgAiIAQRRqIgMoAgAiAg0AIABBEGohAyAAKAIQIgINAAsgB0EANgIADAILIAUgAEF+cTYCBCABIARqIAQ2AgAgASAEQQFyNgIEDAMLQQAhAAsgBkUNAAJAIAUoAhwiAkECdEGw1gBqIgMoAgAgBUYEQCADIAA2AgAgAA0BQYTUAEGE1AAoAgBBfiACd3E2AgAMAgsgBkEQQRQgBigCECAFRhtqIAA2AgAgAEUNAQsgACAGNgIYIAUoAhAiAgRAIAAgAjYCECACIAA2AhgLIAVBFGooAgAiAkUNACAAQRRqIAI2AgAgAiAANgIYCyABIARqIAQ2AgAgASAEQQFyNgIEIAFBlNQAKAIARw0AQYjUACAENgIADAELIARB/wFNBEAgBEF4cUGo1ABqIQACf0GA1AAoAgAiAkEBIARBA3Z0IgNxRQRAQYDUACACIANyNgIAIAAMAQsgACgCCAsiAiABNgIMIAAgATYCCCABIAA2AgwgASACNgIIDAELQR8hAiAEQf///wdNBEAgBEEmIARBCHZnIgBrdkEBcSAAQQF0a0E+aiECCyABIAI2AhwgAUIANwIQIAJBAnRBsNYAaiEAAkBBhNQAKAIAIgNBASACdCIHcUUEQCAAIAE2AgBBhNQAIAMgB3I2AgAgASAANgIYIAEgATYCCCABIAE2AgwMAQsgBEEZIAJBAXZrQQAgAkEfRxt0IQIgACgCACEAAkADQCAAIgMoAgRBeHEgBEYNASACQR12IQAgAkEBdCECIAMgAEEEcWpBEGoiBygCACIADQALIAcgATYCACABIAM2AhggASABNgIMIAEgATYCCAwBCyADKAIIIgAgATYCDCADIAE2AgggAUEANgIYIAEgAzYCDCABIAA2AggLQaDUAEGg1AAoAgBBAWsiAEF/IAAbNgIACwsHACAALQAoCwcAIAAtACoLBwAgAC0AKwsHACAALQApCwcAIAAvATQLBwAgAC0AMAtAAQR/IAAoAhghASAALwEuIQIgAC0AKCEDIAAoAjghBCAAEDcgACAENgI4IAAgAzoAKCAAIAI7AS4gACABNgIYC8X4AQIHfwN+IAEgAmohBAJAIAAiAygCDCIADQAgAygCBARAIAMgATYCBAsjAEEQayIJJAACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAn8CQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkAgAygCHCICQQFrDuwB7gEB6AECAwQFBgcICQoLDA0ODxAREucBE+YBFBXlARYX5AEYGRobHB0eHyDvAe0BIeMBIiMkJSYnKCkqK+IBLC0uLzAxMuEB4AEzNN8B3gE1Njc4OTo7PD0+P0BBQkNERUZHSElKS0xNTk/pAVBRUlPdAdwBVNsBVdoBVldYWVpbXF1eX2BhYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5ent8fX5/gAGBAYIBgwGEAYUBhgGHAYgBiQGKAYsBjAGNAY4BjwGQAZEBkgGTAZQBlQGWAZcBmAGZAZoBmwGcAZ0BngGfAaABoQGiAaMBpAGlAaYBpwGoAakBqgGrAawBrQGuAa8BsAGxAbIBswG0AbUBtgG3AbgBuQG6AbsBvAG9Ab4BvwHAAcEBwgHDAcQBxQHZAdgBxgHXAccB1gHIAckBygHLAcwBzQHOAc8B0AHRAdIB0wHUAQDqAQtBAAzUAQtBDgzTAQtBDQzSAQtBDwzRAQtBEAzQAQtBEQzPAQtBEgzOAQtBEwzNAQtBFAzMAQtBFQzLAQtBFgzKAQtBFwzJAQtBGAzIAQtBGQzHAQtBGgzGAQtBGwzFAQtBHAzEAQtBHQzDAQtBHgzCAQtBHwzBAQtBCAzAAQtBIAy/AQtBIgy+AQtBIQy9AQtBBwy8AQtBIwy7AQtBJAy6AQtBJQy5AQtBJgy4AQtBJwy3AQtBzgEMtgELQSgMtQELQSkMtAELQSoMswELQSsMsgELQc8BDLEBC0EtDLABC0EuDK8BC0EvDK4BC0EwDK0BC0ExDKwBC0EyDKsBC0EzDKoBC0HQAQypAQtBNAyoAQtBOAynAQtBDAymAQtBNQylAQtBNgykAQtBNwyjAQtBPQyiAQtBOQyhAQtB0QEMoAELQQsMnwELQT4MngELQToMnQELQQoMnAELQTsMmwELQTwMmgELQdIBDJkBC0HAAAyYAQtBPwyXAQtBwQAMlgELQQkMlQELQSwMlAELQcIADJMBC0HDAAySAQtBxAAMkQELQcUADJABC0HGAAyPAQtBxwAMjgELQcgADI0BC0HJAAyMAQtBygAMiwELQcsADIoBC0HMAAyJAQtBzQAMiAELQc4ADIcBC0HPAAyGAQtB0AAMhQELQdEADIQBC0HSAAyDAQtB1AAMggELQdMADIEBC0HVAAyAAQtB1gAMfwtB1wAMfgtB2AAMfQtB2QAMfAtB2gAMewtB2wAMegtB0wEMeQtB3AAMeAtB3QAMdwtBBgx2C0HeAAx1C0EFDHQLQd8ADHMLQQQMcgtB4AAMcQtB4QAMcAtB4gAMbwtB4wAMbgtBAwxtC0HkAAxsC0HlAAxrC0HmAAxqC0HoAAxpC0HnAAxoC0HpAAxnC0HqAAxmC0HrAAxlC0HsAAxkC0ECDGMLQe0ADGILQe4ADGELQe8ADGALQfAADF8LQfEADF4LQfIADF0LQfMADFwLQfQADFsLQfUADFoLQfYADFkLQfcADFgLQfgADFcLQfkADFYLQfoADFULQfsADFQLQfwADFMLQf0ADFILQf4ADFELQf8ADFALQYABDE8LQYEBDE4LQYIBDE0LQYMBDEwLQYQBDEsLQYUBDEoLQYYBDEkLQYcBDEgLQYgBDEcLQYkBDEYLQYoBDEULQYsBDEQLQYwBDEMLQY0BDEILQY4BDEELQY8BDEALQZABDD8LQZEBDD4LQZIBDD0LQZMBDDwLQZQBDDsLQZUBDDoLQZYBDDkLQZcBDDgLQZgBDDcLQZkBDDYLQZoBDDULQZsBDDQLQZwBDDMLQZ0BDDILQZ4BDDELQZ8BDDALQaABDC8LQaEBDC4LQaIBDC0LQaMBDCwLQaQBDCsLQaUBDCoLQaYBDCkLQacBDCgLQagBDCcLQakBDCYLQaoBDCULQasBDCQLQawBDCMLQa0BDCILQa4BDCELQa8BDCALQbABDB8LQbEBDB4LQbIBDB0LQbMBDBwLQbQBDBsLQbUBDBoLQbYBDBkLQbcBDBgLQbgBDBcLQQEMFgtBuQEMFQtBugEMFAtBuwEMEwtBvAEMEgtBvQEMEQtBvgEMEAtBvwEMDwtBwAEMDgtBwQEMDQtBwgEMDAtBwwEMCwtBxAEMCgtBxQEMCQtBxgEMCAtB1AEMBwtBxwEMBgtByAEMBQtByQEMBAtBygEMAwtBywEMAgtBzQEMAQtBzAELIQIDQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAIAMCfwJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACfwJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAn8CQAJAAkACQAJAAkACQAJ/AkACQAJAAn8CQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAIAMCfwJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACfwJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQCACDtQBAAECAwQFBgcICQoLDA0ODxARFBUWFxgZGhscHR4fICEjJCUnKCmIA4cDhQOEA/wC9QLuAusC6ALmAuMC4ALfAt0C2wLWAtUC1ALTAtICygLJAsgCxwLGAsUCxALDAr0CvAK6ArkCuAK3ArYCtQK0ArICsQKsAqoCqAKnAqYCpQKkAqMCogKhAqACnwKbApoCmQKYApcCkAKIAoQCgwKCAvkB9gH1AfQB8wHyAfEB8AHvAe0B6wHoAeMB4QHgAd8B3gHdAdwB2wHaAdkB2AHXAdYB1QHUAdIB0QHQAc8BzgHNAcwBywHKAckByAHHAcYBxQHEAcMBwgHBAcABvwG+Ab0BvAG7AboBuQG4AbcBtgG1AbQBswGyAbEBsAGvAa4BrQGsAasBqgGpAagBpwGmAaUBpAGjAaIBoQGgAZ8BngGdAZwBmwGaAZcBlgGRAZABjwGOAY0BjAGLAYoBiQGIAYUBhAGDAX59fHt6d3Z1LFFSU1RVVgsgASAERw1zQewBIQIMqQMLIAEgBEcNkAFB0QEhAgyoAwsgASAERw3pAUGEASECDKcDCyABIARHDfQBQfoAIQIMpgMLIAEgBEcNggJB9QAhAgylAwsgASAERw2JAkHzACECDKQDCyABIARHDYwCQfEAIQIMowMLIAEgBEcNHkEeIQIMogMLIAEgBEcNGUEYIQIMoQMLIAEgBEcNuAJBzQAhAgygAwsgASAERw3DAkHGACECDJ8DCyABIARHDcQCQcMAIQIMngMLIAEgBEcNygJBOCECDJ0DCyADLQAwQQFGDZUDDPICC0EAIQACQAJAAkAgAy0AKkUNACADLQArRQ0AIAMvATIiAkECcUUNAQwCCyADLwEyIgJBAXFFDQELQQEhACADLQAoQQFGDQAgAy8BNCIGQeQAa0HkAEkNACAGQcwBRg0AIAZBsAJGDQAgAkHAAHENAEEAIQAgAkGIBHFBgARGDQAgAkEocUEARyEACyADQQA7ATIgA0EAOgAxAkAgAEUEQCADQQA6ADEgAy0ALkEEcQ0BDJwDCyADQgA3AyALIANBADoAMSADQQE6ADYMSQtBACEAAkAgAygCOCICRQ0AIAIoAiwiAkUNACADIAIRAAAhAAsgAEUNSSAAQRVHDWMgA0EENgIcIAMgATYCFCADQb0aNgIQIANBFTYCDEEAIQIMmgMLIAEgBEYEQEEGIQIMmgMLIAEtAABBCkYNGQwBCyABIARGBEBBByECDJkDCwJAIAEtAABBCmsOBAIBAQABCyABQQFqIQFBECECDP4CCyADLQAuQYABcQ0YQQAhAiADQQA2AhwgAyABNgIUIANBqR82AhAgA0ECNgIMDJcDCyABQQFqIQEgA0Evai0AAEEBcQ0XQQAhAiADQQA2AhwgAyABNgIUIANBhB82AhAgA0EZNgIMDJYDCyADIAMpAyAiDCAEIAFrrSIKfSILQgAgCyAMWBs3AyAgCiAMWg0ZQQghAgyVAwsgASAERwRAIANBCTYCCCADIAE2AgRBEiECDPsCC0EJIQIMlAMLIAMpAyBQDZwCDEQLIAEgBEYEQEELIQIMkwMLIAEtAABBCkcNFyABQQFqIQEMGAsgA0Evai0AAEEBcUUNGgwnC0EAIQACQCADKAI4IgJFDQAgAigCSCICRQ0AIAMgAhEAACEACyAADRoMQwtBACEAAkAgAygCOCICRQ0AIAIoAkgiAkUNACADIAIRAAAhAAsgAA0bDCULQQAhAAJAIAMoAjgiAkUNACACKAJIIgJFDQAgAyACEQAAIQALIAANHAwzCyADQS9qLQAAQQFxRQ0dDCMLQQAhAAJAIAMoAjgiAkUNACACKAJMIgJFDQAgAyACEQAAIQALIAANHQxDC0EAIQACQCADKAI4IgJFDQAgAigCTCICRQ0AIAMgAhEAACEACyAADR4MIQsgASAERgRAQRMhAgyLAwsCQCABLQAAIgBBCmsOBCAkJAAjCyABQQFqIQEMIAtBACEAAkAgAygCOCICRQ0AIAIoAkwiAkUNACADIAIRAAAhAAsgAA0jDEMLIAEgBEYEQEEWIQIMiQMLIAEtAABB8D9qLQAAQQFHDSQM7QILAkADQCABLQAAQeA5ai0AACIAQQFHBEACQCAAQQJrDgIDACgLIAFBAWohAUEfIQIM8AILIAQgAUEBaiIBRw0AC0EYIQIMiAMLIAMoAgQhAEEAIQIgA0EANgIEIAMgACABQQFqIgEQMyIADSIMQgtBACEAAkAgAygCOCICRQ0AIAIoAkwiAkUNACADIAIRAAAhAAsgAA0kDCsLIAEgBEYEQEEcIQIMhgMLIANBCjYCCCADIAE2AgRBACEAAkAgAygCOCICRQ0AIAIoAkgiAkUNACADIAIRAAAhAAsgAA0mQSIhAgzrAgsgASAERwRAA0AgAS0AAEHgO2otAAAiAEEDRwRAIABBAWsOBRkbJ+wCJicLIAQgAUEBaiIBRw0AC0EbIQIMhQMLQRshAgyEAwsDQCABLQAAQeA9ai0AACIAQQNHBEAgAEEBaw4FEBIoFCcoCyAEIAFBAWoiAUcNAAtBHiECDIMDCyABIARHBEAgA0ELNgIIIAMgATYCBEEHIQIM6QILQR8hAgyCAwsgASAERgRAQSAhAgyCAwsCQCABLQAAQQ1rDhQvQEBAQEBAQEBAQEBAQEBAQEBAAEALQQAhAiADQQA2AhwgA0G3CzYCECADQQI2AgwgAyABQQFqNgIUDIEDCyADQS9qIQIDQCABIARGBEBBISECDIIDCwJAAkACQCABLQAAIgBBCWsOGAIAKioBKioqKioqKioqKioqKioqKioqAigLIAFBAWohASADQS9qLQAAQQFxRQ0LDBkLIAFBAWohAQwYCyABQQFqIQEgAi0AAEECcQ0AC0EAIQIgA0EANgIcIAMgATYCFCADQc4UNgIQIANBDDYCDAyAAwsgAUEBaiEBC0EAIQACQCADKAI4IgJFDQAgAigCVCICRQ0AIAMgAhEAACEACyAADQEM0QILIANCADcDIAw8CyAAQRVGBEAgA0EkNgIcIAMgATYCFCADQYYaNgIQIANBFTYCDEEAIQIM/QILQQAhAiADQQA2AhwgAyABNgIUIANB4g02AhAgA0EUNgIMDPwCCyADKAIEIQBBACECIANBADYCBCADIAAgASAMp2oiARAxIgBFDSsgA0EHNgIcIAMgATYCFCADIAA2AgwM+wILIAMtAC5BwABxRQ0BC0EAIQACQCADKAI4IgJFDQAgAigCUCICRQ0AIAMgAhEAACEACyAARQ0rIABBFUYEQCADQQo2AhwgAyABNgIUIANB8Rg2AhAgA0EVNgIMQQAhAgz6AgtBACECIANBADYCHCADIAE2AhQgA0GLDDYCECADQRM2AgwM+QILQQAhAiADQQA2AhwgAyABNgIUIANBsRQ2AhAgA0ECNgIMDPgCC0EAIQIgA0EANgIcIAMgATYCFCADQYwUNgIQIANBGTYCDAz3AgtBACECIANBADYCHCADIAE2AhQgA0HRHDYCECADQRk2AgwM9gILIABBFUYNPUEAIQIgA0EANgIcIAMgATYCFCADQaIPNgIQIANBIjYCDAz1AgsgAygCBCEAQQAhAiADQQA2AgQgAyAAIAEQMiIARQ0oIANBDTYCHCADIAE2AhQgAyAANgIMDPQCCyAAQRVGDTpBACECIANBADYCHCADIAE2AhQgA0GiDzYCECADQSI2AgwM8wILIAMoAgQhAEEAIQIgA0EANgIEIAMgACABEDIiAEUEQCABQQFqIQEMKAsgA0EONgIcIAMgADYCDCADIAFBAWo2AhQM8gILIABBFUYNN0EAIQIgA0EANgIcIAMgATYCFCADQaIPNgIQIANBIjYCDAzxAgsgAygCBCEAQQAhAiADQQA2AgQgAyAAIAEQMiIARQRAIAFBAWohAQwnCyADQQ82AhwgAyAANgIMIAMgAUEBajYCFAzwAgtBACECIANBADYCHCADIAE2AhQgA0HoFjYCECADQRk2AgwM7wILIABBFUYNM0EAIQIgA0EANgIcIAMgATYCFCADQc4MNgIQIANBIzYCDAzuAgsgAygCBCEAQQAhAiADQQA2AgQgAyAAIAEQMyIARQ0lIANBETYCHCADIAE2AhQgAyAANgIMDO0CCyAAQRVGDTBBACECIANBADYCHCADIAE2AhQgA0HODDYCECADQSM2AgwM7AILIAMoAgQhAEEAIQIgA0EANgIEIAMgACABEDMiAEUEQCABQQFqIQEMJQsgA0ESNgIcIAMgADYCDCADIAFBAWo2AhQM6wILIANBL2otAABBAXFFDQELQRUhAgzPAgtBACECIANBADYCHCADIAE2AhQgA0HoFjYCECADQRk2AgwM6AILIABBO0cNACABQQFqIQEMDAtBACECIANBADYCHCADIAE2AhQgA0GYFzYCECADQQI2AgwM5gILIABBFUYNKEEAIQIgA0EANgIcIAMgATYCFCADQc4MNgIQIANBIzYCDAzlAgsgA0EUNgIcIAMgATYCFCADIAA2AgwM5AILIAMoAgQhAEEAIQIgA0EANgIEIAMgACABEDMiAEUEQCABQQFqIQEM3AILIANBFTYCHCADIAA2AgwgAyABQQFqNgIUDOMCCyADKAIEIQBBACECIANBADYCBCADIAAgARAzIgBFBEAgAUEBaiEBDNoCCyADQRc2AhwgAyAANgIMIAMgAUEBajYCFAziAgsgAEEVRg0jQQAhAiADQQA2AhwgAyABNgIUIANBzgw2AhAgA0EjNgIMDOECCyADKAIEIQBBACECIANBADYCBCADIAAgARAzIgBFBEAgAUEBaiEBDB0LIANBGTYCHCADIAA2AgwgAyABQQFqNgIUDOACCyADKAIEIQBBACECIANBADYCBCADIAAgARAzIgBFBEAgAUEBaiEBDNYCCyADQRo2AhwgAyAANgIMIAMgAUEBajYCFAzfAgsgAEEVRg0fQQAhAiADQQA2AhwgAyABNgIUIANBog82AhAgA0EiNgIMDN4CCyADKAIEIQBBACECIANBADYCBCADIAAgARAyIgBFBEAgAUEBaiEBDBsLIANBHDYCHCADIAA2AgwgAyABQQFqNgIUDN0CCyADKAIEIQBBACECIANBADYCBCADIAAgARAyIgBFBEAgAUEBaiEBDNICCyADQR02AhwgAyAANgIMIAMgAUEBajYCFAzcAgsgAEE7Rw0BIAFBAWohAQtBJCECDMACC0EAIQIgA0EANgIcIAMgATYCFCADQc4UNgIQIANBDDYCDAzZAgsgASAERwRAA0AgAS0AAEEgRw3xASAEIAFBAWoiAUcNAAtBLCECDNkCC0EsIQIM2AILIAEgBEYEQEE0IQIM2AILAkACQANAAkAgAS0AAEEKaw4EAgAAAwALIAQgAUEBaiIBRw0AC0E0IQIM2QILIAMoAgQhACADQQA2AgQgAyAAIAEQMCIARQ2MAiADQTI2AhwgAyABNgIUIAMgADYCDEEAIQIM2AILIAMoAgQhACADQQA2AgQgAyAAIAEQMCIARQRAIAFBAWohAQyMAgsgA0EyNgIcIAMgADYCDCADIAFBAWo2AhRBACECDNcCCyABIARHBEACQANAIAEtAABBMGsiAEH/AXFBCk8EQEE5IQIMwAILIAMpAyAiC0KZs+bMmbPmzBlWDQEgAyALQgp+Igo3AyAgCiAArUL/AYMiC0J/hVYNASADIAogC3w3AyAgBCABQQFqIgFHDQALQcAAIQIM2AILIAMoAgQhACADQQA2AgQgAyAAIAFBAWoiARAwIgANFwzJAgtBwAAhAgzWAgsgASAERgRAQckAIQIM1gILAkADQAJAIAEtAABBCWsOGAACjwKPApMCjwKPAo8CjwKPAo8CjwKPAo8CjwKPAo8CjwKPAo8CjwKPAo8CAI8CCyAEIAFBAWoiAUcNAAtByQAhAgzWAgsgAUEBaiEBIANBL2otAABBAXENjwIgA0EANgIcIAMgATYCFCADQekPNgIQIANBCjYCDEEAIQIM1QILIAEgBEcEQANAIAEtAAAiAEEgRwRAAkACQAJAIABByABrDgsAAc0BzQHNAc0BzQHNAc0BzQECzQELIAFBAWohAUHZACECDL8CCyABQQFqIQFB2gAhAgy+AgsgAUEBaiEBQdsAIQIMvQILIAQgAUEBaiIBRw0AC0HuACECDNUCC0HuACECDNQCCyADQQI6ACgMMAtBACECIANBADYCHCADQbcLNgIQIANBAjYCDCADIAFBAWo2AhQM0gILQQAhAgy3AgtBDSECDLYCC0ERIQIMtQILQRMhAgy0AgtBFCECDLMCC0EWIQIMsgILQRchAgyxAgtBGCECDLACC0EZIQIMrwILQRohAgyuAgtBGyECDK0CC0EcIQIMrAILQR0hAgyrAgtBHiECDKoCC0EgIQIMqQILQSEhAgyoAgtBIyECDKcCC0EnIQIMpgILIANBPTYCHCADIAE2AhQgAyAANgIMQQAhAgy/AgsgA0EbNgIcIAMgATYCFCADQY8bNgIQIANBFTYCDEEAIQIMvgILIANBIDYCHCADIAE2AhQgA0GeGTYCECADQRU2AgxBACECDL0CCyADQRM2AhwgAyABNgIUIANBnhk2AhAgA0EVNgIMQQAhAgy8AgsgA0ELNgIcIAMgATYCFCADQZ4ZNgIQIANBFTYCDEEAIQIMuwILIANBEDYCHCADIAE2AhQgA0GeGTYCECADQRU2AgxBACECDLoCCyADQSA2AhwgAyABNgIUIANBjxs2AhAgA0EVNgIMQQAhAgy5AgsgA0ELNgIcIAMgATYCFCADQY8bNgIQIANBFTYCDEEAIQIMuAILIANBDDYCHCADIAE2AhQgA0GPGzYCECADQRU2AgxBACECDLcCC0EAIQIgA0EANgIcIAMgATYCFCADQa8ONgIQIANBEjYCDAy2AgsCQANAAkAgAS0AAEEKaw4EAAICAAILIAQgAUEBaiIBRw0AC0HsASECDLYCCwJAAkAgAy0ANkEBRw0AQQAhAAJAIAMoAjgiAkUNACACKAJYIgJFDQAgAyACEQAAIQALIABFDQAgAEEVRw0BIANB6wE2AhwgAyABNgIUIANB4hg2AhAgA0EVNgIMQQAhAgy3AgtBzAEhAgycAgsgA0EANgIcIAMgATYCFCADQfELNgIQIANBHzYCDEEAIQIMtQILAkACQCADLQAoQQFrDgIEAQALQcsBIQIMmwILQcQBIQIMmgILIANBAjoAMUEAIQACQCADKAI4IgJFDQAgAigCACICRQ0AIAMgAhEAACEACyAARQRAQc0BIQIMmgILIABBFUcEQCADQQA2AhwgAyABNgIUIANBrAw2AhAgA0EQNgIMQQAhAgy0AgsgA0HqATYCHCADIAE2AhQgA0GHGTYCECADQRU2AgxBACECDLMCCyABIARGBEBB6QEhAgyzAgsgAS0AAEHIAEYNASADQQE6ACgLQbYBIQIMlwILQcoBIQIMlgILIAEgBEcEQCADQQw2AgggAyABNgIEQckBIQIMlgILQegBIQIMrwILIAEgBEYEQEHnASECDK8CCyABLQAAQcgARw0EIAFBAWohAUHIASECDJQCCyABIARGBEBB5gEhAgyuAgsCQAJAIAEtAABBxQBrDhAABQUFBQUFBQUFBQUFBQUBBQsgAUEBaiEBQcYBIQIMlAILIAFBAWohAUHHASECDJMCC0HlASECIAEgBEYNrAIgAygCACIAIAQgAWtqIQUgASAAa0ECaiEGAkADQCABLQAAIABB99MAai0AAEcNAyAAQQJGDQEgAEEBaiEAIAQgAUEBaiIBRw0ACyADIAU2AgAMrQILIAMoAgQhACADQgA3AwAgAyAAIAZBAWoiARAtIgBFBEBB1AEhAgyTAgsgA0HkATYCHCADIAE2AhQgAyAANgIMQQAhAgysAgtB4wEhAiABIARGDasCIAMoAgAiACAEIAFraiEFIAEgAGtBAWohBgJAA0AgAS0AACAAQfXTAGotAABHDQIgAEEBRg0BIABBAWohACAEIAFBAWoiAUcNAAsgAyAFNgIADKwCCyADQYEEOwEoIAMoAgQhACADQgA3AwAgAyAAIAZBAWoiARAtIgANAwwCCyADQQA2AgALQQAhAiADQQA2AhwgAyABNgIUIANB0B42AhAgA0EINgIMDKkCC0HFASECDI4CCyADQeIBNgIcIAMgATYCFCADIAA2AgxBACECDKcCC0EAIQACQCADKAI4IgJFDQAgAigCOCICRQ0AIAMgAhEAACEACyAARQ1lIABBFUcEQCADQQA2AhwgAyABNgIUIANB1A42AhAgA0EgNgIMQQAhAgynAgsgA0GFATYCHCADIAE2AhQgA0HXGjYCECADQRU2AgxBACECDKYCC0HhASECIAQgASIARg2lAiAEIAFrIAMoAgAiAWohBSAAIAFrQQRqIQYCQANAIAAtAAAgAUHw0wBqLQAARw0BIAFBBEYNAyABQQFqIQEgBCAAQQFqIgBHDQALIAMgBTYCAAymAgsgA0EANgIcIAMgADYCFCADQYQ3NgIQIANBCDYCDCADQQA2AgBBACECDKUCCyABIARHBEAgA0ENNgIIIAMgATYCBEHCASECDIsCC0HgASECDKQCCyADQQA2AgAgBkEBaiEBC0HDASECDIgCCyABIARGBEBB3wEhAgyiAgsgAS0AAEEwayIAQf8BcUEKSQRAIAMgADoAKiABQQFqIQFBwQEhAgyIAgsgAygCBCEAIANBADYCBCADIAAgARAuIgBFDYgCIANB3gE2AhwgAyABNgIUIAMgADYCDEEAIQIMoQILIAEgBEYEQEHdASECDKECCwJAIAEtAABBLkYEQCABQQFqIQEMAQsgAygCBCEAIANBADYCBCADIAAgARAuIgBFDYkCIANB3AE2AhwgAyABNgIUIAMgADYCDEEAIQIMoQILQcABIQIMhgILIAEgBEYEQEHbASECDKACC0EAIQBBASEFQQEhB0EAIQICQAJAAkACQAJAAn8CQAJAAkACQAJAAkACQCABLQAAQTBrDgoKCQABAgMEBQYICwtBAgwGC0EDDAULQQQMBAtBBQwDC0EGDAILQQcMAQtBCAshAkEAIQVBACEHDAILQQkhAkEBIQBBACEFQQAhBwwBC0EAIQVBASECCyADIAI6ACsgAUEBaiEBAkACQCADLQAuQRBxDQACQAJAAkAgAy0AKg4DAQACBAsgB0UNAwwCCyAADQEMAgsgBUUNAQsgAygCBCEAIANBADYCBCADIAAgARAuIgBFDQIgA0HYATYCHCADIAE2AhQgAyAANgIMQQAhAgyiAgsgAygCBCEAIANBADYCBCADIAAgARAuIgBFDYsCIANB2QE2AhwgAyABNgIUIAMgADYCDEEAIQIMoQILIAMoAgQhACADQQA2AgQgAyAAIAEQLiIARQ2JAiADQdoBNgIcIAMgATYCFCADIAA2AgwMoAILQb8BIQIMhQILQQAhAAJAIAMoAjgiAkUNACACKAI8IgJFDQAgAyACEQAAIQALAkAgAARAIABBFUYNASADQQA2AhwgAyABNgIUIANBnA02AhAgA0EhNgIMQQAhAgygAgtBvgEhAgyFAgsgA0HXATYCHCADIAE2AhQgA0HWGTYCECADQRU2AgxBACECDJ4CCyABIARGBEBB1wEhAgyeAgsCQCABLQAAQSBGBEAgA0EAOwE0IAFBAWohAQwBCyADQQA2AhwgAyABNgIUIANB6xA2AhAgA0EJNgIMQQAhAgyeAgtBvQEhAgyDAgsgASAERgRAQdYBIQIMnQILAkAgAS0AAEEwa0H/AXEiAkEKSQRAIAFBAWohAQJAIAMvATQiAEGZM0sNACADIABBCmwiADsBNCAAQf7/A3EgAkH//wNzSw0AIAMgACACajsBNAwCC0EAIQIgA0EANgIcIAMgATYCFCADQYAdNgIQIANBDTYCDAyeAgsgA0EANgIcIAMgATYCFCADQYAdNgIQIANBDTYCDEEAIQIMnQILQbwBIQIMggILIAEgBEYEQEHVASECDJwCCwJAIAEtAABBMGtB/wFxIgJBCkkEQCABQQFqIQECQCADLwE0IgBBmTNLDQAgAyAAQQpsIgA7ATQgAEH+/wNxIAJB//8Dc0sNACADIAAgAmo7ATQMAgtBACECIANBADYCHCADIAE2AhQgA0GAHTYCECADQQ02AgwMnQILIANBADYCHCADIAE2AhQgA0GAHTYCECADQQ02AgxBACECDJwCC0G7ASECDIECCyABIARGBEBB1AEhAgybAgsCQCABLQAAQTBrQf8BcSICQQpJBEAgAUEBaiEBAkAgAy8BNCIAQZkzSw0AIAMgAEEKbCIAOwE0IABB/v8DcSACQf//A3NLDQAgAyAAIAJqOwE0DAILQQAhAiADQQA2AhwgAyABNgIUIANBgB02AhAgA0ENNgIMDJwCCyADQQA2AhwgAyABNgIUIANBgB02AhAgA0ENNgIMQQAhAgybAgtBugEhAgyAAgsgASAERgRAQdMBIQIMmgILAkACQAJAAkAgAS0AAEEKaw4XAgMDAAMDAwMDAwMDAwMDAwMDAwMDAwEDCyABQQFqDAULIAFBAWohAUG5ASECDIECCyABQQFqIQEgA0Evai0AAEEBcQ0IIANBADYCHCADIAE2AhQgA0GFCzYCECADQQ02AgxBACECDJoCCyADQQA2AhwgAyABNgIUIANBhQs2AhAgA0ENNgIMQQAhAgyZAgsgASAERwRAIANBDjYCCCADIAE2AgRBASECDP8BC0HSASECDJgCCwJAAkADQAJAIAEtAABBCmsOBAIAAAMACyAEIAFBAWoiAUcNAAtB0QEhAgyZAgsgAygCBCEAIANBADYCBCADIAAgARAsIgBFBEAgAUEBaiEBDAQLIANB0AE2AhwgAyAANgIMIAMgAUEBajYCFEEAIQIMmAILIAMoAgQhACADQQA2AgQgAyAAIAEQLCIADQEgAUEBagshAUG3ASECDPwBCyADQc8BNgIcIAMgADYCDCADIAFBAWo2AhRBACECDJUCC0G4ASECDPoBCyADQS9qLQAAQQFxDQEgA0EANgIcIAMgATYCFCADQc8bNgIQIANBGTYCDEEAIQIMkwILIAEgBEYEQEHPASECDJMCCwJAAkACQCABLQAAQQprDgQBAgIAAgsgAUEBaiEBDAILIAFBAWohAQwBCyADLQAuQcAAcUUNAQtBACEAAkAgAygCOCICRQ0AIAIoAjQiAkUNACADIAIRAAAhAAsgAEUNlgEgAEEVRgRAIANB2QA2AhwgAyABNgIUIANBvRk2AhAgA0EVNgIMQQAhAgySAgsgA0EANgIcIAMgATYCFCADQfgMNgIQIANBGzYCDEEAIQIMkQILIANBADYCHCADIAE2AhQgA0HHJzYCECADQQI2AgxBACECDJACCyABIARHBEAgA0EMNgIIIAMgATYCBEG1ASECDPYBC0HOASECDI8CCyABIARGBEBBzQEhAgyPAgsCQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAIAEtAABBwQBrDhUAAQIDWgQFBlpaWgcICQoLDA0ODxBaCyABQQFqIQFB8QAhAgyEAgsgAUEBaiEBQfIAIQIMgwILIAFBAWohAUH3ACECDIICCyABQQFqIQFB+wAhAgyBAgsgAUEBaiEBQfwAIQIMgAILIAFBAWohAUH/ACECDP8BCyABQQFqIQFBgAEhAgz+AQsgAUEBaiEBQYMBIQIM/QELIAFBAWohAUGMASECDPwBCyABQQFqIQFBjQEhAgz7AQsgAUEBaiEBQY4BIQIM+gELIAFBAWohAUGbASECDPkBCyABQQFqIQFBnAEhAgz4AQsgAUEBaiEBQaIBIQIM9wELIAFBAWohAUGqASECDPYBCyABQQFqIQFBrQEhAgz1AQsgAUEBaiEBQbQBIQIM9AELIAEgBEYEQEHMASECDI4CCyABLQAAQc4ARw1IIAFBAWohAUGzASECDPMBCyABIARGBEBBywEhAgyNAgsCQAJAAkAgAS0AAEHCAGsOEgBKSkpKSkpKSkoBSkpKSkpKAkoLIAFBAWohAUGuASECDPQBCyABQQFqIQFBsQEhAgzzAQsgAUEBaiEBQbIBIQIM8gELQcoBIQIgASAERg2LAiADKAIAIgAgBCABa2ohBSABIABrQQdqIQYCQANAIAEtAAAgAEHo0wBqLQAARw1FIABBB0YNASAAQQFqIQAgBCABQQFqIgFHDQALIAMgBTYCAAyMAgsgA0EANgIAIAZBAWohAUEbDEULIAEgBEYEQEHJASECDIsCCwJAAkAgAS0AAEHJAGsOBwBHR0dHRwFHCyABQQFqIQFBrwEhAgzxAQsgAUEBaiEBQbABIQIM8AELQcgBIQIgASAERg2JAiADKAIAIgAgBCABa2ohBSABIABrQQFqIQYCQANAIAEtAAAgAEHm0wBqLQAARw1DIABBAUYNASAAQQFqIQAgBCABQQFqIgFHDQALIAMgBTYCAAyKAgsgA0EANgIAIAZBAWohAUEPDEMLQccBIQIgASAERg2IAiADKAIAIgAgBCABa2ohBSABIABrQQFqIQYCQANAIAEtAAAgAEHk0wBqLQAARw1CIABBAUYNASAAQQFqIQAgBCABQQFqIgFHDQALIAMgBTYCAAyJAgsgA0EANgIAIAZBAWohAUEgDEILQcYBIQIgASAERg2HAiADKAIAIgAgBCABa2ohBSABIABrQQJqIQYCQANAIAEtAAAgAEHh0wBqLQAARw1BIABBAkYNASAAQQFqIQAgBCABQQFqIgFHDQALIAMgBTYCAAyIAgsgA0EANgIAIAZBAWohAUESDEELIAEgBEYEQEHFASECDIcCCwJAAkAgAS0AAEHFAGsODgBDQ0NDQ0NDQ0NDQ0MBQwsgAUEBaiEBQasBIQIM7QELIAFBAWohAUGsASECDOwBC0HEASECIAEgBEYNhQIgAygCACIAIAQgAWtqIQUgASAAa0ECaiEGAkADQCABLQAAIABB3tMAai0AAEcNPyAAQQJGDQEgAEEBaiEAIAQgAUEBaiIBRw0ACyADIAU2AgAMhgILIANBADYCACAGQQFqIQFBBww/C0HDASECIAEgBEYNhAIgAygCACIAIAQgAWtqIQUgASAAa0EFaiEGAkADQCABLQAAIABB2NMAai0AAEcNPiAAQQVGDQEgAEEBaiEAIAQgAUEBaiIBRw0ACyADIAU2AgAMhQILIANBADYCACAGQQFqIQFBKAw+CyABIARGBEBBwgEhAgyEAgsCQAJAAkAgAS0AAEHFAGsOEQBBQUFBQUFBQUEBQUFBQUECQQsgAUEBaiEBQacBIQIM6wELIAFBAWohAUGoASECDOoBCyABQQFqIQFBqQEhAgzpAQtBwQEhAiABIARGDYICIAMoAgAiACAEIAFraiEFIAEgAGtBBmohBgJAA0AgAS0AACAAQdHTAGotAABHDTwgAEEGRg0BIABBAWohACAEIAFBAWoiAUcNAAsgAyAFNgIADIMCCyADQQA2AgAgBkEBaiEBQRoMPAtBwAEhAiABIARGDYECIAMoAgAiACAEIAFraiEFIAEgAGtBA2ohBgJAA0AgAS0AACAAQc3TAGotAABHDTsgAEEDRg0BIABBAWohACAEIAFBAWoiAUcNAAsgAyAFNgIADIICCyADQQA2AgAgBkEBaiEBQSEMOwsgASAERgRAQb8BIQIMgQILAkACQCABLQAAQcEAaw4UAD09PT09PT09PT09PT09PT09PQE9CyABQQFqIQFBowEhAgznAQsgAUEBaiEBQaYBIQIM5gELIAEgBEYEQEG+ASECDIACCwJAAkAgAS0AAEHVAGsOCwA8PDw8PDw8PDwBPAsgAUEBaiEBQaQBIQIM5gELIAFBAWohAUGlASECDOUBC0G9ASECIAEgBEYN/gEgAygCACIAIAQgAWtqIQUgASAAa0EIaiEGAkADQCABLQAAIABBxNMAai0AAEcNOCAAQQhGDQEgAEEBaiEAIAQgAUEBaiIBRw0ACyADIAU2AgAM/wELIANBADYCACAGQQFqIQFBKgw4CyABIARGBEBBvAEhAgz+AQsgAS0AAEHQAEcNOCABQQFqIQFBJQw3C0G7ASECIAEgBEYN/AEgAygCACIAIAQgAWtqIQUgASAAa0ECaiEGAkADQCABLQAAIABBwdMAai0AAEcNNiAAQQJGDQEgAEEBaiEAIAQgAUEBaiIBRw0ACyADIAU2AgAM/QELIANBADYCACAGQQFqIQFBDgw2CyABIARGBEBBugEhAgz8AQsgAS0AAEHFAEcNNiABQQFqIQFBoQEhAgzhAQsgASAERgRAQbkBIQIM+wELAkACQAJAAkAgAS0AAEHCAGsODwABAjk5OTk5OTk5OTk5AzkLIAFBAWohAUGdASECDOMBCyABQQFqIQFBngEhAgziAQsgAUEBaiEBQZ8BIQIM4QELIAFBAWohAUGgASECDOABC0G4ASECIAEgBEYN+QEgAygCACIAIAQgAWtqIQUgASAAa0ECaiEGAkADQCABLQAAIABBvtMAai0AAEcNMyAAQQJGDQEgAEEBaiEAIAQgAUEBaiIBRw0ACyADIAU2AgAM+gELIANBADYCACAGQQFqIQFBFAwzC0G3ASECIAEgBEYN+AEgAygCACIAIAQgAWtqIQUgASAAa0EEaiEGAkADQCABLQAAIABBudMAai0AAEcNMiAAQQRGDQEgAEEBaiEAIAQgAUEBaiIBRw0ACyADIAU2AgAM+QELIANBADYCACAGQQFqIQFBKwwyC0G2ASECIAEgBEYN9wEgAygCACIAIAQgAWtqIQUgASAAa0ECaiEGAkADQCABLQAAIABBttMAai0AAEcNMSAAQQJGDQEgAEEBaiEAIAQgAUEBaiIBRw0ACyADIAU2AgAM+AELIANBADYCACAGQQFqIQFBLAwxC0G1ASECIAEgBEYN9gEgAygCACIAIAQgAWtqIQUgASAAa0ECaiEGAkADQCABLQAAIABB4dMAai0AAEcNMCAAQQJGDQEgAEEBaiEAIAQgAUEBaiIBRw0ACyADIAU2AgAM9wELIANBADYCACAGQQFqIQFBEQwwC0G0ASECIAEgBEYN9QEgAygCACIAIAQgAWtqIQUgASAAa0EDaiEGAkADQCABLQAAIABBstMAai0AAEcNLyAAQQNGDQEgAEEBaiEAIAQgAUEBaiIBRw0ACyADIAU2AgAM9gELIANBADYCACAGQQFqIQFBLgwvCyABIARGBEBBswEhAgz1AQsCQAJAAkACQAJAIAEtAABBwQBrDhUANDQ0NDQ0NDQ0NAE0NAI0NAM0NAQ0CyABQQFqIQFBkQEhAgzeAQsgAUEBaiEBQZIBIQIM3QELIAFBAWohAUGTASECDNwBCyABQQFqIQFBmAEhAgzbAQsgAUEBaiEBQZoBIQIM2gELIAEgBEYEQEGyASECDPQBCwJAAkAgAS0AAEHSAGsOAwAwATALIAFBAWohAUGZASECDNoBCyABQQFqIQFBBAwtC0GxASECIAEgBEYN8gEgAygCACIAIAQgAWtqIQUgASAAa0EBaiEGAkADQCABLQAAIABBsNMAai0AAEcNLCAAQQFGDQEgAEEBaiEAIAQgAUEBaiIBRw0ACyADIAU2AgAM8wELIANBADYCACAGQQFqIQFBHQwsCyABIARGBEBBsAEhAgzyAQsCQAJAIAEtAABByQBrDgcBLi4uLi4ALgsgAUEBaiEBQZcBIQIM2AELIAFBAWohAUEiDCsLIAEgBEYEQEGvASECDPEBCyABLQAAQdAARw0rIAFBAWohAUGWASECDNYBCyABIARGBEBBrgEhAgzwAQsCQAJAIAEtAABBxgBrDgsALCwsLCwsLCwsASwLIAFBAWohAUGUASECDNYBCyABQQFqIQFBlQEhAgzVAQtBrQEhAiABIARGDe4BIAMoAgAiACAEIAFraiEFIAEgAGtBA2ohBgJAA0AgAS0AACAAQazTAGotAABHDSggAEEDRg0BIABBAWohACAEIAFBAWoiAUcNAAsgAyAFNgIADO8BCyADQQA2AgAgBkEBaiEBQQ0MKAtBrAEhAiABIARGDe0BIAMoAgAiACAEIAFraiEFIAEgAGtBAmohBgJAA0AgAS0AACAAQeHTAGotAABHDScgAEECRg0BIABBAWohACAEIAFBAWoiAUcNAAsgAyAFNgIADO4BCyADQQA2AgAgBkEBaiEBQQwMJwtBqwEhAiABIARGDewBIAMoAgAiACAEIAFraiEFIAEgAGtBAWohBgJAA0AgAS0AACAAQarTAGotAABHDSYgAEEBRg0BIABBAWohACAEIAFBAWoiAUcNAAsgAyAFNgIADO0BCyADQQA2AgAgBkEBaiEBQQMMJgtBqgEhAiABIARGDesBIAMoAgAiACAEIAFraiEFIAEgAGtBAWohBgJAA0AgAS0AACAAQajTAGotAABHDSUgAEEBRg0BIABBAWohACAEIAFBAWoiAUcNAAsgAyAFNgIADOwBCyADQQA2AgAgBkEBaiEBQSYMJQsgASAERgRAQakBIQIM6wELAkACQCABLQAAQdQAaw4CAAEnCyABQQFqIQFBjwEhAgzRAQsgAUEBaiEBQZABIQIM0AELQagBIQIgASAERg3pASADKAIAIgAgBCABa2ohBSABIABrQQFqIQYCQANAIAEtAAAgAEGm0wBqLQAARw0jIABBAUYNASAAQQFqIQAgBCABQQFqIgFHDQALIAMgBTYCAAzqAQsgA0EANgIAIAZBAWohAUEnDCMLQacBIQIgASAERg3oASADKAIAIgAgBCABa2ohBSABIABrQQFqIQYCQANAIAEtAAAgAEGk0wBqLQAARw0iIABBAUYNASAAQQFqIQAgBCABQQFqIgFHDQALIAMgBTYCAAzpAQsgA0EANgIAIAZBAWohAUEcDCILQaYBIQIgASAERg3nASADKAIAIgAgBCABa2ohBSABIABrQQVqIQYCQANAIAEtAAAgAEGe0wBqLQAARw0hIABBBUYNASAAQQFqIQAgBCABQQFqIgFHDQALIAMgBTYCAAzoAQsgA0EANgIAIAZBAWohAUEGDCELQaUBIQIgASAERg3mASADKAIAIgAgBCABa2ohBSABIABrQQRqIQYCQANAIAEtAAAgAEGZ0wBqLQAARw0gIABBBEYNASAAQQFqIQAgBCABQQFqIgFHDQALIAMgBTYCAAznAQsgA0EANgIAIAZBAWohAUEZDCALIAEgBEYEQEGkASECDOYBCwJAAkACQAJAIAEtAABBLWsOIwAkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJAEkJCQkJAIkJCQDJAsgAUEBaiEBQYQBIQIMzgELIAFBAWohAUGFASECDM0BCyABQQFqIQFBigEhAgzMAQsgAUEBaiEBQYsBIQIMywELQaMBIQIgASAERg3kASADKAIAIgAgBCABa2ohBSABIABrQQFqIQYCQANAIAEtAAAgAEGX0wBqLQAARw0eIABBAUYNASAAQQFqIQAgBCABQQFqIgFHDQALIAMgBTYCAAzlAQsgA0EANgIAIAZBAWohAUELDB4LIAEgBEYEQEGiASECDOQBCwJAAkAgAS0AAEHBAGsOAwAgASALIAFBAWohAUGGASECDMoBCyABQQFqIQFBiQEhAgzJAQsgASAERgRAQaEBIQIM4wELAkACQCABLQAAQcEAaw4PAB8fHx8fHx8fHx8fHx8BHwsgAUEBaiEBQYcBIQIMyQELIAFBAWohAUGIASECDMgBCyABIARGBEBBoAEhAgziAQsgAS0AAEHMAEcNHCABQQFqIQFBCgwbC0GfASECIAEgBEYN4AEgAygCACIAIAQgAWtqIQUgASAAa0EFaiEGAkADQCABLQAAIABBkdMAai0AAEcNGiAAQQVGDQEgAEEBaiEAIAQgAUEBaiIBRw0ACyADIAU2AgAM4QELIANBADYCACAGQQFqIQFBHgwaC0GeASECIAEgBEYN3wEgAygCACIAIAQgAWtqIQUgASAAa0EGaiEGAkADQCABLQAAIABBitMAai0AAEcNGSAAQQZGDQEgAEEBaiEAIAQgAUEBaiIBRw0ACyADIAU2AgAM4AELIANBADYCACAGQQFqIQFBFQwZC0GdASECIAEgBEYN3gEgAygCACIAIAQgAWtqIQUgASAAa0ECaiEGAkADQCABLQAAIABBh9MAai0AAEcNGCAAQQJGDQEgAEEBaiEAIAQgAUEBaiIBRw0ACyADIAU2AgAM3wELIANBADYCACAGQQFqIQFBFwwYC0GcASECIAEgBEYN3QEgAygCACIAIAQgAWtqIQUgASAAa0EFaiEGAkADQCABLQAAIABBgdMAai0AAEcNFyAAQQVGDQEgAEEBaiEAIAQgAUEBaiIBRw0ACyADIAU2AgAM3gELIANBADYCACAGQQFqIQFBGAwXCyABIARGBEBBmwEhAgzdAQsCQAJAIAEtAABByQBrDgcAGRkZGRkBGQsgAUEBaiEBQYEBIQIMwwELIAFBAWohAUGCASECDMIBC0GaASECIAEgBEYN2wEgAygCACIAIAQgAWtqIQUgASAAa0EBaiEGAkADQCABLQAAIABB5tMAai0AAEcNFSAAQQFGDQEgAEEBaiEAIAQgAUEBaiIBRw0ACyADIAU2AgAM3AELIANBADYCACAGQQFqIQFBCQwVC0GZASECIAEgBEYN2gEgAygCACIAIAQgAWtqIQUgASAAa0EBaiEGAkADQCABLQAAIABB5NMAai0AAEcNFCAAQQFGDQEgAEEBaiEAIAQgAUEBaiIBRw0ACyADIAU2AgAM2wELIANBADYCACAGQQFqIQFBHwwUC0GYASECIAEgBEYN2QEgAygCACIAIAQgAWtqIQUgASAAa0ECaiEGAkADQCABLQAAIABB/tIAai0AAEcNEyAAQQJGDQEgAEEBaiEAIAQgAUEBaiIBRw0ACyADIAU2AgAM2gELIANBADYCACAGQQFqIQFBAgwTC0GXASECIAEgBEYN2AEgAygCACIAIAQgAWtqIQUgASAAa0EBaiEGA0AgAS0AACAAQfzSAGotAABHDREgAEEBRg0CIABBAWohACAEIAFBAWoiAUcNAAsgAyAFNgIADNgBCyABIARGBEBBlgEhAgzYAQtBASABLQAAQd8ARw0RGiABQQFqIQFB/QAhAgy9AQsgA0EANgIAIAZBAWohAUH+ACECDLwBC0GVASECIAEgBEYN1QEgAygCACIAIAQgAWtqIQUgASAAa0EIaiEGAkADQCABLQAAIABBxNMAai0AAEcNDyAAQQhGDQEgAEEBaiEAIAQgAUEBaiIBRw0ACyADIAU2AgAM1gELIANBADYCACAGQQFqIQFBKQwPC0GUASECIAEgBEYN1AEgAygCACIAIAQgAWtqIQUgASAAa0EDaiEGAkADQCABLQAAIABB+NIAai0AAEcNDiAAQQNGDQEgAEEBaiEAIAQgAUEBaiIBRw0ACyADIAU2AgAM1QELIANBADYCACAGQQFqIQFBLQwOCyABIARGBEBBkwEhAgzUAQsgAS0AAEHFAEcNDiABQQFqIQFB+gAhAgy5AQsgASAERgRAQZIBIQIM0wELAkACQCABLQAAQcwAaw4IAA8PDw8PDwEPCyABQQFqIQFB+AAhAgy5AQsgAUEBaiEBQfkAIQIMuAELQZEBIQIgASAERg3RASADKAIAIgAgBCABa2ohBSABIABrQQRqIQYCQANAIAEtAAAgAEHz0gBqLQAARw0LIABBBEYNASAAQQFqIQAgBCABQQFqIgFHDQALIAMgBTYCAAzSAQsgA0EANgIAIAZBAWohAUEjDAsLQZABIQIgASAERg3QASADKAIAIgAgBCABa2ohBSABIABrQQJqIQYCQANAIAEtAAAgAEHw0gBqLQAARw0KIABBAkYNASAAQQFqIQAgBCABQQFqIgFHDQALIAMgBTYCAAzRAQsgA0EANgIAIAZBAWohAUEADAoLIAEgBEYEQEGPASECDNABCwJAAkAgAS0AAEHIAGsOCAAMDAwMDAwBDAsgAUEBaiEBQfMAIQIMtgELIAFBAWohAUH2ACECDLUBCyABIARGBEBBjgEhAgzPAQsCQAJAIAEtAABBzgBrDgMACwELCyABQQFqIQFB9AAhAgy1AQsgAUEBaiEBQfUAIQIMtAELIAEgBEYEQEGNASECDM4BCyABLQAAQdkARw0IIAFBAWohAUEIDAcLQYwBIQIgASAERg3MASADKAIAIgAgBCABa2ohBSABIABrQQNqIQYCQANAIAEtAAAgAEHs0gBqLQAARw0GIABBA0YNASAAQQFqIQAgBCABQQFqIgFHDQALIAMgBTYCAAzNAQsgA0EANgIAIAZBAWohAUEFDAYLQYsBIQIgASAERg3LASADKAIAIgAgBCABa2ohBSABIABrQQVqIQYCQANAIAEtAAAgAEHm0gBqLQAARw0FIABBBUYNASAAQQFqIQAgBCABQQFqIgFHDQALIAMgBTYCAAzMAQsgA0EANgIAIAZBAWohAUEWDAULQYoBIQIgASAERg3KASADKAIAIgAgBCABa2ohBSABIABrQQJqIQYCQANAIAEtAAAgAEHh0wBqLQAARw0EIABBAkYNASAAQQFqIQAgBCABQQFqIgFHDQALIAMgBTYCAAzLAQsgA0EANgIAIAZBAWohAUEQDAQLIAEgBEYEQEGJASECDMoBCwJAAkAgAS0AAEHDAGsODAAGBgYGBgYGBgYGAQYLIAFBAWohAUHvACECDLABCyABQQFqIQFB8AAhAgyvAQtBiAEhAiABIARGDcgBIAMoAgAiACAEIAFraiEFIAEgAGtBBWohBgJAA0AgAS0AACAAQeDSAGotAABHDQIgAEEFRg0BIABBAWohACAEIAFBAWoiAUcNAAsgAyAFNgIADMkBCyADQQA2AgAgBkEBaiEBQSQMAgsgA0EANgIADAILIAEgBEYEQEGHASECDMcBCyABLQAAQcwARw0BIAFBAWohAUETCzoAKSADKAIEIQAgA0EANgIEIAMgACABEC0iAA0CDAELQQAhAiADQQA2AhwgAyABNgIUIANB6R42AhAgA0EGNgIMDMQBC0HuACECDKkBCyADQYYBNgIcIAMgATYCFCADIAA2AgxBACECDMIBC0EAIQACQCADKAI4IgJFDQAgAigCOCICRQ0AIAMgAhEAACEACyAARQ0AIABBFUYNASADQQA2AhwgAyABNgIUIANB1A42AhAgA0EgNgIMQQAhAgzBAQtB7QAhAgymAQsgA0GFATYCHCADIAE2AhQgA0HXGjYCECADQRU2AgxBACECDL8BCyABIARGBEBBhQEhAgy/AQsCQCABLQAAQSBGBEAgAUEBaiEBDAELIANBADYCHCADIAE2AhQgA0GGHjYCECADQQY2AgxBACECDL8BC0ECIQIMpAELA0AgAS0AAEEgRw0CIAQgAUEBaiIBRw0AC0GEASECDL0BCyABIARGBEBBgwEhAgy9AQsCQCABLQAAQQlrDgRAAABAAAtB6wAhAgyiAQsgAy0AKUEFRgRAQewAIQIMogELQeoAIQIMoQELIAEgBEYEQEGCASECDLsBCyADQQ82AgggAyABNgIEDAoLIAEgBEYEQEGBASECDLoBCwJAIAEtAABBCWsOBD0AAD0AC0HpACECDJ8BCyABIARHBEAgA0EPNgIIIAMgATYCBEHnACECDJ8BC0GAASECDLgBCwJAIAEgBEcEQANAIAEtAABB4M4Aai0AACIAQQNHBEACQCAAQQFrDgI/AAQLQeYAIQIMoQELIAQgAUEBaiIBRw0AC0H+ACECDLkBC0H+ACECDLgBCyADQQA2AhwgAyABNgIUIANBxh82AhAgA0EHNgIMQQAhAgy3AQsgASAERgRAQf8AIQIMtwELAkACQAJAIAEtAABB4NAAai0AAEEBaw4DPAIAAQtB6AAhAgyeAQsgA0EANgIcIAMgATYCFCADQYYSNgIQIANBBzYCDEEAIQIMtwELQeAAIQIMnAELIAEgBEcEQCABQQFqIQFB5QAhAgycAQtB/QAhAgy1AQsgBCABIgBGBEBB/AAhAgy1AQsgAC0AACIBQS9GBEAgAEEBaiEBQeQAIQIMmwELIAFBCWsiAkEXSw0BIAAhAUEBIAJ0QZuAgARxDTcMAQsgBCABIgBGBEBB+wAhAgy0AQsgAC0AAEEvRw0AIABBAWohAQwDC0EAIQIgA0EANgIcIAMgADYCFCADQcYfNgIQIANBBzYCDAyyAQsCQAJAAkACQAJAA0AgAS0AAEHgzABqLQAAIgBBBUcEQAJAAkAgAEEBaw4IPQUGBwgABAEIC0HhACECDJ8BCyABQQFqIQFB4wAhAgyeAQsgBCABQQFqIgFHDQALQfoAIQIMtgELIAFBAWoMFAsgAygCBCEAIANBADYCBCADIAAgARArIgBFDR4gA0HbADYCHCADIAE2AhQgAyAANgIMQQAhAgy0AQsgAygCBCEAIANBADYCBCADIAAgARArIgBFDR4gA0HdADYCHCADIAE2AhQgAyAANgIMQQAhAgyzAQsgAygCBCEAIANBADYCBCADIAAgARArIgBFDR4gA0HwADYCHCADIAE2AhQgAyAANgIMQQAhAgyyAQsgA0EANgIcIAMgATYCFCADQcsPNgIQIANBBzYCDEEAIQIMsQELIAEgBEYEQEH5ACECDLEBCwJAIAEtAABB4MwAai0AAEEBaw4INAQFBgAIAgMHCyABQQFqIQELQQMhAgyVAQsgAUEBagwNC0EAIQIgA0EANgIcIANBoxI2AhAgA0EHNgIMIAMgAUEBajYCFAytAQsgAygCBCEAIANBADYCBCADIAAgARArIgBFDRYgA0HbADYCHCADIAE2AhQgAyAANgIMQQAhAgysAQsgAygCBCEAIANBADYCBCADIAAgARArIgBFDRYgA0HdADYCHCADIAE2AhQgAyAANgIMQQAhAgyrAQsgAygCBCEAIANBADYCBCADIAAgARArIgBFDRYgA0HwADYCHCADIAE2AhQgAyAANgIMQQAhAgyqAQsgA0EANgIcIAMgATYCFCADQcsPNgIQIANBBzYCDEEAIQIMqQELQeIAIQIMjgELIAEgBEYEQEH4ACECDKgBCyABQQFqDAILIAEgBEYEQEH3ACECDKcBCyABQQFqDAELIAEgBEYNASABQQFqCyEBQQQhAgyKAQtB9gAhAgyjAQsDQCABLQAAQeDKAGotAAAiAEECRwRAIABBAUcEQEHfACECDIsBCwwnCyAEIAFBAWoiAUcNAAtB9QAhAgyiAQsgASAERgRAQfQAIQIMogELAkAgAS0AAEEJaw43JQMGJQQGBgYGBgYGBgYGBgYGBgYGBgYFBgYCBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGAAYLIAFBAWoLIQFBBSECDIYBCyABQQFqDAYLIAMoAgQhACADQQA2AgQgAyAAIAEQKyIARQ0IIANB2wA2AhwgAyABNgIUIAMgADYCDEEAIQIMngELIAMoAgQhACADQQA2AgQgAyAAIAEQKyIARQ0IIANB3QA2AhwgAyABNgIUIAMgADYCDEEAIQIMnQELIAMoAgQhACADQQA2AgQgAyAAIAEQKyIARQ0IIANB8AA2AhwgAyABNgIUIAMgADYCDEEAIQIMnAELIANBADYCHCADIAE2AhQgA0G8EzYCECADQQc2AgxBACECDJsBCwJAAkACQAJAA0AgAS0AAEHgyABqLQAAIgBBBUcEQAJAIABBAWsOBiQDBAUGAAYLQd4AIQIMhgELIAQgAUEBaiIBRw0AC0HzACECDJ4BCyADKAIEIQAgA0EANgIEIAMgACABECsiAEUNByADQdsANgIcIAMgATYCFCADIAA2AgxBACECDJ0BCyADKAIEIQAgA0EANgIEIAMgACABECsiAEUNByADQd0ANgIcIAMgATYCFCADIAA2AgxBACECDJwBCyADKAIEIQAgA0EANgIEIAMgACABECsiAEUNByADQfAANgIcIAMgATYCFCADIAA2AgxBACECDJsBCyADQQA2AhwgAyABNgIUIANB3Ag2AhAgA0EHNgIMQQAhAgyaAQsgASAERg0BIAFBAWoLIQFBBiECDH4LQfIAIQIMlwELAkACQAJAAkADQCABLQAAQeDGAGotAAAiAEEFRwRAIABBAWsOBB8CAwQFCyAEIAFBAWoiAUcNAAtB8QAhAgyaAQsgAygCBCEAIANBADYCBCADIAAgARArIgBFDQMgA0HbADYCHCADIAE2AhQgAyAANgIMQQAhAgyZAQsgAygCBCEAIANBADYCBCADIAAgARArIgBFDQMgA0HdADYCHCADIAE2AhQgAyAANgIMQQAhAgyYAQsgAygCBCEAIANBADYCBCADIAAgARArIgBFDQMgA0HwADYCHCADIAE2AhQgAyAANgIMQQAhAgyXAQsgA0EANgIcIAMgATYCFCADQbQKNgIQIANBBzYCDEEAIQIMlgELQc4AIQIMewtB0AAhAgx6C0HdACECDHkLIAEgBEYEQEHwACECDJMBCwJAIAEtAABBCWsOBBYAABYACyABQQFqIQFB3AAhAgx4CyABIARGBEBB7wAhAgySAQsCQCABLQAAQQlrDgQVAAAVAAtBACEAAkAgAygCOCICRQ0AIAIoAjAiAkUNACADIAIRAAAhAAsgAEUEQEHTASECDHgLIABBFUcEQCADQQA2AhwgAyABNgIUIANBwQ02AhAgA0EaNgIMQQAhAgySAQsgA0HuADYCHCADIAE2AhQgA0HwGTYCECADQRU2AgxBACECDJEBC0HtACECIAEgBEYNkAEgAygCACIAIAQgAWtqIQUgASAAa0EDaiEGAkADQCABLQAAIABB18YAai0AAEcNBCAAQQNGDQEgAEEBaiEAIAQgAUEBaiIBRw0ACyADIAU2AgAMkQELIANBADYCACAGQQFqIQEgAy0AKSIAQSNrQQtJDQQCQCAAQQZLDQBBASAAdEHKAHFFDQAMBQtBACECIANBADYCHCADIAE2AhQgA0HlCTYCECADQQg2AgwMkAELQewAIQIgASAERg2PASADKAIAIgAgBCABa2ohBSABIABrQQJqIQYCQANAIAEtAAAgAEHUxgBqLQAARw0DIABBAkYNASAAQQFqIQAgBCABQQFqIgFHDQALIAMgBTYCAAyQAQsgA0EANgIAIAZBAWohASADLQApQSFGDQMgA0EANgIcIAMgATYCFCADQYkKNgIQIANBCDYCDEEAIQIMjwELQesAIQIgASAERg2OASADKAIAIgAgBCABa2ohBSABIABrQQNqIQYCQANAIAEtAAAgAEHQxgBqLQAARw0CIABBA0YNASAAQQFqIQAgBCABQQFqIgFHDQALIAMgBTYCAAyPAQsgA0EANgIAIAZBAWohASADLQApIgBBI0kNAiAAQS5GDQIgA0EANgIcIAMgATYCFCADQcEJNgIQIANBCDYCDEEAIQIMjgELIANBADYCAAtBACECIANBADYCHCADIAE2AhQgA0GENzYCECADQQg2AgwMjAELQdgAIQIMcQsgASAERwRAIANBDTYCCCADIAE2AgRB1wAhAgxxC0HqACECDIoBCyABIARGBEBB6QAhAgyKAQsgAS0AAEEwayIAQf8BcUEKSQRAIAMgADoAKiABQQFqIQFB1gAhAgxwCyADKAIEIQAgA0EANgIEIAMgACABEC4iAEUNdCADQegANgIcIAMgATYCFCADIAA2AgxBACECDIkBCyABIARGBEBB5wAhAgyJAQsCQCABLQAAQS5GBEAgAUEBaiEBDAELIAMoAgQhACADQQA2AgQgAyAAIAEQLiIARQ11IANB5gA2AhwgAyABNgIUIAMgADYCDEEAIQIMiQELQdUAIQIMbgsgASAERgRAQeUAIQIMiAELQQAhAEEBIQVBASEHQQAhAgJAAkACQAJAAkACfwJAAkACQAJAAkACQAJAIAEtAABBMGsOCgoJAAECAwQFBggLC0ECDAYLQQMMBQtBBAwEC0EFDAMLQQYMAgtBBwwBC0EICyECQQAhBUEAIQcMAgtBCSECQQEhAEEAIQVBACEHDAELQQAhBUEBIQILIAMgAjoAKyABQQFqIQECQAJAIAMtAC5BEHENAAJAAkACQCADLQAqDgMBAAIECyAHRQ0DDAILIAANAQwCCyAFRQ0BCyADKAIEIQAgA0EANgIEIAMgACABEC4iAEUNAiADQeIANgIcIAMgATYCFCADIAA2AgxBACECDIoBCyADKAIEIQAgA0EANgIEIAMgACABEC4iAEUNdyADQeMANgIcIAMgATYCFCADIAA2AgxBACECDIkBCyADKAIEIQAgA0EANgIEIAMgACABEC4iAEUNdSADQeQANgIcIAMgATYCFCADIAA2AgwMiAELQdMAIQIMbQsgAy0AKUEiRg2AAUHSACECDGwLQQAhAAJAIAMoAjgiAkUNACACKAI8IgJFDQAgAyACEQAAIQALIABFBEBB1AAhAgxsCyAAQRVHBEAgA0EANgIcIAMgATYCFCADQZwNNgIQIANBITYCDEEAIQIMhgELIANB4QA2AhwgAyABNgIUIANB1hk2AhAgA0EVNgIMQQAhAgyFAQsgASAERgRAQeAAIQIMhQELAkACQAJAAkACQCABLQAAQQprDgQBBAQABAsgAUEBaiEBDAELIAFBAWohASADQS9qLQAAQQFxRQ0BC0HRACECDGwLIANBADYCHCADIAE2AhQgA0GIETYCECADQQk2AgxBACECDIUBCyADQQA2AhwgAyABNgIUIANBiBE2AhAgA0EJNgIMQQAhAgyEAQsgASAERgRAQd8AIQIMhAELIAEtAABBCkYEQCABQQFqIQEMCQsgAy0ALkHAAHENCCADQQA2AhwgAyABNgIUIANBiBE2AhAgA0ECNgIMQQAhAgyDAQsgASAERgRAQd0AIQIMgwELIAEtAAAiAkENRgRAIAFBAWohAUHPACECDGkLIAEhACACQQlrDgQFAQEFAQsgBCABIgBGBEBB3AAhAgyCAQsgAC0AAEEKRw0AIABBAWoMAgtBACECIANBADYCHCADIAA2AhQgA0G1LDYCECADQQc2AgwMgAELIAEgBEYEQEHbACECDIABCwJAIAEtAABBCWsOBAMAAAMACyABQQFqCyEBQc0AIQIMZAsgASAERgRAQdoAIQIMfgsgAS0AAEEJaw4EAAEBAAELQQAhAiADQQA2AhwgA0HsETYCECADQQc2AgwgAyABQQFqNgIUDHwLIANBgBI7ASpBACEAAkAgAygCOCICRQ0AIAIoAjAiAkUNACADIAIRAAAhAAsgAEUNACAAQRVHDQEgA0HZADYCHCADIAE2AhQgA0HwGTYCECADQRU2AgxBACECDHsLQcwAIQIMYAsgA0EANgIcIAMgATYCFCADQcENNgIQIANBGjYCDEEAIQIMeQsgASAERgRAQdkAIQIMeQsgAS0AAEEgRw06IAFBAWohASADLQAuQQFxDTogA0EANgIcIAMgATYCFCADQa0bNgIQIANBHjYCDEEAIQIMeAsgASAERgRAQdgAIQIMeAsCQAJAAkACQAJAIAEtAAAiAEEKaw4EAgMDAAELIAFBAWohAUErIQIMYQsgAEE6Rw0BIANBADYCHCADIAE2AhQgA0G5ETYCECADQQo2AgxBACECDHoLIAFBAWohASADQS9qLQAAQQFxRQ1tIAMtADJBgAFxRQRAIANBMmohAiADEDRBACEAAkAgAygCOCIGRQ0AIAYoAiQiBkUNACADIAYRAAAhAAsCQAJAIAAOFkpJSAEBAQEBAQEBAQEBAQEBAQEBAQABCyADQSk2AhwgAyABNgIUIANBshg2AhAgA0EVNgIMQQAhAgx7CyADQQA2AhwgAyABNgIUIANB3Qs2AhAgA0ERNgIMQQAhAgx6C0EAIQACQCADKAI4IgJFDQAgAigCVCICRQ0AIAMgAhEAACEACyAARQ1VIABBFUcNASADQQU2AhwgAyABNgIUIANBhho2AhAgA0EVNgIMQQAhAgx5C0HKACECDF4LQQAhAiADQQA2AhwgAyABNgIUIANB4g02AhAgA0EUNgIMDHcLIAMgAy8BMkGAAXI7ATIMOAsgASAERwRAIANBEDYCCCADIAE2AgRByQAhAgxcC0HXACECDHULIAEgBEYEQEHWACECDHULAkACQAJAAkAgAS0AACIAQSByIAAgAEHBAGtB/wFxQRpJG0H/AXFB4wBrDhMAPT09PT09PT09PT09AT09PQIDPQsgAUEBaiEBQcUAIQIMXQsgAUEBaiEBQcYAIQIMXAsgAUEBaiEBQccAIQIMWwsgAUEBaiEBQcgAIQIMWgtB1QAhAiAEIAEiAEYNcyAEIAFrIAMoAgAiAWohBiAAIAFrQQVqIQcDQCABQcDGAGotAAAgAC0AACIFQSByIAUgBUHBAGtB/wFxQRpJG0H/AXFHDQhBBCABQQVGDQoaIAFBAWohASAEIABBAWoiAEcNAAsgAyAGNgIADHMLQdQAIQIgBCABIgBGDXIgBCABayADKAIAIgFqIQYgACABa0EPaiEHA0AgAUGwxgBqLQAAIAAtAAAiBUEgciAFIAVBwQBrQf8BcUEaSRtB/wFxRw0HQQMgAUEPRg0JGiABQQFqIQEgBCAAQQFqIgBHDQALIAMgBjYCAAxyC0HTACECIAQgASIARg1xIAQgAWsgAygCACIBaiEGIAAgAWtBDmohBwNAIAFBksYAai0AACAALQAAIgVBIHIgBSAFQcEAa0H/AXFBGkkbQf8BcUcNBiABQQ5GDQcgAUEBaiEBIAQgAEEBaiIARw0ACyADIAY2AgAMcQtB0gAhAiAEIAEiAEYNcCAEIAFrIAMoAgAiAWohBSAAIAFrQQFqIQYDQCABQZDGAGotAAAgAC0AACIHQSByIAcgB0HBAGtB/wFxQRpJG0H/AXFHDQUgAUEBRg0CIAFBAWohASAEIABBAWoiAEcNAAsgAyAFNgIADHALIAEgBEYEQEHRACECDHALAkACQCABLQAAIgBBIHIgACAAQcEAa0H/AXFBGkkbQf8BcUHuAGsOBwA2NjY2NgE2CyABQQFqIQFBwgAhAgxWCyABQQFqIQFBwwAhAgxVCyADQQA2AgAgBkEBaiEBQcQAIQIMVAtB0AAhAiAEIAEiAEYNbSAEIAFrIAMoAgAiAWohBiAAIAFrQQlqIQcDQCABQYbGAGotAAAgAC0AACIFQSByIAUgBUHBAGtB/wFxQRpJG0H/AXFHDQJBAiABQQlGDQQaIAFBAWohASAEIABBAWoiAEcNAAsgAyAGNgIADG0LQc8AIQIgBCABIgBGDWwgBCABayADKAIAIgFqIQYgACABa0EFaiEHA0AgAUGAxgBqLQAAIAAtAAAiBUEgciAFIAVBwQBrQf8BcUEaSRtB/wFxRw0BIAFBBUYNAiABQQFqIQEgBCAAQQFqIgBHDQALIAMgBjYCAAxsCyAAIQEgA0EANgIADDALQQELOgAsIANBADYCACAHQQFqIQELQSwhAgxOCwJAA0AgAS0AAEGAxABqLQAAQQFHDQEgBCABQQFqIgFHDQALQc0AIQIMaAtBwQAhAgxNCyABIARGBEBBzAAhAgxnCyABLQAAQTpGBEAgAygCBCEAIANBADYCBCADIAAgARAvIgBFDTAgA0HLADYCHCADIAA2AgwgAyABQQFqNgIUQQAhAgxnCyADQQA2AhwgAyABNgIUIANBuRE2AhAgA0EKNgIMQQAhAgxmCwJAAkAgAy0ALEECaw4CAAEkCyADQTNqLQAAQQJxRQ0jIAMtAC5BAnENIyADQQA2AhwgAyABNgIUIANB1RM2AhAgA0ELNgIMQQAhAgxmCyADLQAyQSBxRQ0iIAMtAC5BAnENIiADQQA2AhwgAyABNgIUIANB7BI2AhAgA0EPNgIMQQAhAgxlC0EAIQACQCADKAI4IgJFDQAgAigCQCICRQ0AIAMgAhEAACEACyAARQRAQcAAIQIMSwsgAEEVRwRAIANBADYCHCADIAE2AhQgA0H4DjYCECADQRw2AgxBACECDGULIANBygA2AhwgAyABNgIUIANB8Bo2AhAgA0EVNgIMQQAhAgxkCyABIARHBEADQCABLQAAQfA/ai0AAEEBRw0XIAQgAUEBaiIBRw0AC0HEACECDGQLQcQAIQIMYwsgASAERwRAA0ACQCABLQAAIgBBIHIgACAAQcEAa0H/AXFBGkkbQf8BcSIAQQlGDQAgAEEgRg0AAkACQAJAAkAgAEHjAGsOEwADAwMDAwMDAQMDAwMDAwMDAwIDCyABQQFqIQFBNSECDE4LIAFBAWohAUE2IQIMTQsgAUEBaiEBQTchAgxMCwwVCyAEIAFBAWoiAUcNAAtBPCECDGMLQTwhAgxiCyABIARGBEBByAAhAgxiCyADQRE2AgggAyABNgIEAkACQAJAAkACQCADLQAsQQFrDgQUAAECCQsgAy0AMkEgcQ0DQdEBIQIMSwsCQCADLwEyIgBBCHFFDQAgAy0AKEEBRw0AIAMtAC5BCHFFDQILIAMgAEH3+wNxQYAEcjsBMgwLCyADIAMvATJBEHI7ATIMBAsgA0EANgIEIAMgASABEDAiAARAIANBwQA2AhwgAyAANgIMIAMgAUEBajYCFEEAIQIMYwsgAUEBaiEBDFILIANBADYCHCADIAE2AhQgA0GjEzYCECADQQQ2AgxBACECDGELQccAIQIgASAERg1gIAMoAgAiACAEIAFraiEFIAEgAGtBBmohBgJAA0AgAEHwwwBqLQAAIAEtAABBIHJHDQEgAEEGRg1GIABBAWohACAEIAFBAWoiAUcNAAsgAyAFNgIADGELIANBADYCAAwFCwJAIAEgBEcEQANAIAEtAABB8MEAai0AACIAQQFHBEAgAEECRw0DIAFBAWohAQwFCyAEIAFBAWoiAUcNAAtBxQAhAgxhC0HFACECDGALCyADQQA6ACwMAQtBCyECDEMLQT4hAgxCCwJAAkADQCABLQAAIgBBIEcEQAJAIABBCmsOBAMFBQMACyAAQSxGDQMMBAsgBCABQQFqIgFHDQALQcYAIQIMXQsgA0EIOgAsDA4LIAMtAChBAUcNAiADLQAuQQhxDQIgAygCBCEAIANBADYCBCADIAAgARAwIgAEQCADQcIANgIcIAMgADYCDCADIAFBAWo2AhRBACECDFwLIAFBAWohAQxKC0E6IQIMQAsCQANAIAEtAAAiAEEgRyAAQQlHcQ0BIAQgAUEBaiIBRw0AC0HDACECDFoLC0E7IQIMPgsCQAJAIAEgBEcEQANAIAEtAAAiAEEgRwRAIABBCmsOBAMEBAMECyAEIAFBAWoiAUcNAAtBPyECDFoLQT8hAgxZCyADIAMvATJBIHI7ATIMCgsgAygCBCEAIANBADYCBCADIAAgARAwIgBFDUggA0E+NgIcIAMgATYCFCADIAA2AgxBACECDFcLAkAgASAERwRAA0AgAS0AAEHwwQBqLQAAIgBBAUcEQCAAQQJGDQMMDAsgBCABQQFqIgFHDQALQTchAgxYC0E3IQIMVwsgAUEBaiEBDAQLQTshAiAEIAEiAEYNVSAEIAFrIAMoAgAiAWohBiAAIAFrQQVqIQcCQANAIAFBwMYAai0AACAALQAAIgVBIHIgBSAFQcEAa0H/AXFBGkkbQf8BcUcNASABQQVGBEBBByEBDDsLIAFBAWohASAEIABBAWoiAEcNAAsgAyAGNgIADFYLIANBADYCACAAIQEMBQtBOiECIAQgASIARg1UIAQgAWsgAygCACIBaiEGIAAgAWtBCGohBwJAA0AgAUHkP2otAAAgAC0AACIFQSByIAUgBUHBAGtB/wFxQRpJG0H/AXFHDQEgAUEIRgRAQQUhAQw6CyABQQFqIQEgBCAAQQFqIgBHDQALIAMgBjYCAAxVCyADQQA2AgAgACEBDAQLQTkhAiAEIAEiAEYNUyAEIAFrIAMoAgAiAWohBiAAIAFrQQNqIQcCQANAIAFB4D9qLQAAIAAtAAAiBUEgciAFIAVBwQBrQf8BcUEaSRtB/wFxRw0BIAFBA0YEQEEGIQEMOQsgAUEBaiEBIAQgAEEBaiIARw0ACyADIAY2AgAMVAsgA0EANgIAIAAhAQwDCwJAA0AgAS0AACIAQSBHBEAgAEEKaw4EBwQEBwILIAQgAUEBaiIBRw0AC0E4IQIMUwsgAEEsRw0BIAFBAWohAEEBIQECQAJAAkACQAJAIAMtACxBBWsOBAMBAgQACyAAIQEMBAtBAiEBDAELQQQhAQsgA0EBOgAsIAMgAy8BMiABcjsBMiAAIQEMAQsgAyADLwEyQQhyOwEyIAAhAQtBPSECDDcLIANBADoALAtBOCECDDULIAEgBEYEQEE2IQIMTwsCQAJAAkACQAJAIAEtAABBCmsOBAACAgECCyADKAIEIQAgA0EANgIEIAMgACABEDAiAEUNAiADQTM2AhwgAyABNgIUIAMgADYCDEEAIQIMUgsgAygCBCEAIANBADYCBCADIAAgARAwIgBFBEAgAUEBaiEBDAYLIANBMjYCHCADIAA2AgwgAyABQQFqNgIUQQAhAgxRCyADLQAuQQFxBEBB0AEhAgw3CyADKAIEIQAgA0EANgIEIAMgACABEDAiAA0BDEMLQTMhAgw1CyADQTU2AhwgAyABNgIUIAMgADYCDEEAIQIMTgtBNCECDDMLIANBL2otAABBAXENACADQQA2AhwgAyABNgIUIANB8RU2AhAgA0EZNgIMQQAhAgxMC0EyIQIMMQsgASAERgRAQTIhAgxLCwJAIAEtAABBCkYEQCABQQFqIQEMAQsgA0EANgIcIAMgATYCFCADQZgWNgIQIANBAzYCDEEAIQIMSwtBMSECDDALIAEgBEYEQEExIQIMSgsgAS0AACIAQQlHIABBIEdxDQEgAy0ALEEIRw0AIANBADoALAtBPCECDC4LQQEhAgJAAkACQAJAIAMtACxBBWsOBAMBAgAKCyADIAMvATJBCHI7ATIMCQtBAiECDAELQQQhAgsgA0EBOgAsIAMgAy8BMiACcjsBMgwGCyABIARGBEBBMCECDEcLIAEtAABBCkYEQCABQQFqIQEMAQsgAy0ALkEBcQ0AIANBADYCHCADIAE2AhQgA0HHJzYCECADQQI2AgxBACECDEYLQS8hAgwrCyABQQFqIQFBMCECDCoLIAEgBEYEQEEvIQIMRAsgAS0AACIAQQlHIABBIEdxRQRAIAFBAWohASADLQAuQQFxDQEgA0EANgIcIAMgATYCFCADQekPNgIQIANBCjYCDEEAIQIMRAtBASECAkACQAJAAkACQAJAIAMtACxBAmsOBwUEBAMBAgAECyADIAMvATJBCHI7ATIMAwtBAiECDAELQQQhAgsgA0EBOgAsIAMgAy8BMiACcjsBMgtBLiECDCoLIANBADYCHCADIAE2AhQgA0GzEjYCECADQQs2AgxBACECDEMLQdIBIQIMKAsgASAERgRAQS4hAgxCCyADQQA2AgQgA0ERNgIIIAMgASABEDAiAA0BC0EtIQIMJgsgA0EtNgIcIAMgATYCFCADIAA2AgxBACECDD8LQQAhAAJAIAMoAjgiAkUNACACKAJEIgJFDQAgAyACEQAAIQALIABFDQAgAEEVRw0BIANB2AA2AhwgAyABNgIUIANBnho2AhAgA0EVNgIMQQAhAgw+C0HLACECDCMLIANBADYCHCADIAE2AhQgA0GFDjYCECADQR02AgxBACECDDwLIAEgBEYEQEHOACECDDwLIAEtAAAiAEEgRg0CIABBOkYNAQsgA0EAOgAsQQkhAgwgCyADKAIEIQAgA0EANgIEIAMgACABEC8iAA0BDAILIAMtAC5BAXEEQEHPASECDB8LIAMoAgQhACADQQA2AgQgAyAAIAEQLyIARQ0CIANBKjYCHCADIAA2AgwgAyABQQFqNgIUQQAhAgw4CyADQcsANgIcIAMgADYCDCADIAFBAWo2AhRBACECDDcLIAFBAWohAUE/IQIMHAsgAUEBaiEBDCkLIAEgBEYEQEErIQIMNQsCQCABLQAAQQpGBEAgAUEBaiEBDAELIAMtAC5BwABxRQ0GCyADLQAyQYABcQRAQQAhAAJAIAMoAjgiAkUNACACKAJUIgJFDQAgAyACEQAAIQALIABFDREgAEEVRgRAIANBBTYCHCADIAE2AhQgA0GGGjYCECADQRU2AgxBACECDDYLIANBADYCHCADIAE2AhQgA0HiDTYCECADQRQ2AgxBACECDDULIANBMmohAiADEDRBACEAAkAgAygCOCIGRQ0AIAYoAiQiBkUNACADIAYRAAAhAAsgAA4WAgEABAQEBAQEBAQEBAQEBAQEBAQEAwQLIANBAToAMAsgAiACLwEAQcAAcjsBAAtBKiECDBcLIANBKTYCHCADIAE2AhQgA0GyGDYCECADQRU2AgxBACECDDALIANBADYCHCADIAE2AhQgA0HdCzYCECADQRE2AgxBACECDC8LIANBADYCHCADIAE2AhQgA0GdCzYCECADQQI2AgxBACECDC4LQQEhByADLwEyIgVBCHFFBEAgAykDIEIAUiEHCwJAIAMtADAEQEEBIQAgAy0AKUEFRg0BIAVBwABxRSAHcUUNAQsCQCADLQAoIgJBAkYEQEEBIQAgAy8BNCIGQeUARg0CQQAhACAFQcAAcQ0CIAZB5ABGDQIgBkHmAGtBAkkNAiAGQcwBRg0CIAZBsAJGDQIMAQtBACEAIAVBwABxDQELQQIhACAFQQhxDQAgBUGABHEEQAJAIAJBAUcNACADLQAuQQpxDQBBBSEADAILQQQhAAwBCyAFQSBxRQRAIAMQNUEAR0ECdCEADAELQQBBAyADKQMgUBshAAsCQCAAQQFrDgUAAQYHAgMLQQAhAgJAIAMoAjgiAEUNACAAKAIsIgBFDQAgAyAAEQAAIQILIAJFDSYgAkEVRgRAIANBAzYCHCADIAE2AhQgA0G9GjYCECADQRU2AgxBACECDC4LQQAhAiADQQA2AhwgAyABNgIUIANBrw42AhAgA0ESNgIMDC0LQc4BIQIMEgtBACECIANBADYCHCADIAE2AhQgA0HkHzYCECADQQ82AgwMKwtBACEAAkAgAygCOCICRQ0AIAIoAiwiAkUNACADIAIRAAAhAAsgAA0BC0EOIQIMDwsgAEEVRgRAIANBAjYCHCADIAE2AhQgA0G9GjYCECADQRU2AgxBACECDCkLQQAhAiADQQA2AhwgAyABNgIUIANBrw42AhAgA0ESNgIMDCgLQSkhAgwNCyADQQE6ADEMJAsgASAERwRAIANBCTYCCCADIAE2AgRBKCECDAwLQSYhAgwlCyADIAMpAyAiDCAEIAFrrSIKfSILQgAgCyAMWBs3AyAgCiAMVARAQSUhAgwlCyADKAIEIQBBACECIANBADYCBCADIAAgASAMp2oiARAxIgBFDQAgA0EFNgIcIAMgATYCFCADIAA2AgwMJAtBDyECDAkLIAEgBEYEQEEjIQIMIwtCACEKAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAIAEtAABBMGsONxcWAAECAwQFBgcUFBQUFBQUCAkKCwwNFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQODxAREhMUC0ICIQoMFgtCAyEKDBULQgQhCgwUC0IFIQoMEwtCBiEKDBILQgchCgwRC0IIIQoMEAtCCSEKDA8LQgohCgwOC0ILIQoMDQtCDCEKDAwLQg0hCgwLC0IOIQoMCgtCDyEKDAkLQgohCgwIC0ILIQoMBwtCDCEKDAYLQg0hCgwFC0IOIQoMBAtCDyEKDAMLQQAhAiADQQA2AhwgAyABNgIUIANBzhQ2AhAgA0EMNgIMDCILIAEgBEYEQEEiIQIMIgtCACEKAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQCABLQAAQTBrDjcVFAABAgMEBQYHFhYWFhYWFggJCgsMDRYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWDg8QERITFgtCAiEKDBQLQgMhCgwTC0IEIQoMEgtCBSEKDBELQgYhCgwQC0IHIQoMDwtCCCEKDA4LQgkhCgwNC0IKIQoMDAtCCyEKDAsLQgwhCgwKC0INIQoMCQtCDiEKDAgLQg8hCgwHC0IKIQoMBgtCCyEKDAULQgwhCgwEC0INIQoMAwtCDiEKDAILQg8hCgwBC0IBIQoLIAFBAWohASADKQMgIgtC//////////8PWARAIAMgC0IEhiAKhDcDIAwCC0EAIQIgA0EANgIcIAMgATYCFCADQa0JNgIQIANBDDYCDAwfC0ElIQIMBAtBJiECDAMLIAMgAToALCADQQA2AgAgB0EBaiEBQQwhAgwCCyADQQA2AgAgBkEBaiEBQQohAgwBCyABQQFqIQFBCCECDAALAAtBACECIANBADYCHCADIAE2AhQgA0HVEDYCECADQQk2AgwMGAtBACECIANBADYCHCADIAE2AhQgA0HXCjYCECADQQk2AgwMFwtBACECIANBADYCHCADIAE2AhQgA0G/EDYCECADQQk2AgwMFgtBACECIANBADYCHCADIAE2AhQgA0GkETYCECADQQk2AgwMFQtBACECIANBADYCHCADIAE2AhQgA0HVEDYCECADQQk2AgwMFAtBACECIANBADYCHCADIAE2AhQgA0HXCjYCECADQQk2AgwMEwtBACECIANBADYCHCADIAE2AhQgA0G/EDYCECADQQk2AgwMEgtBACECIANBADYCHCADIAE2AhQgA0GkETYCECADQQk2AgwMEQtBACECIANBADYCHCADIAE2AhQgA0G/FjYCECADQQ82AgwMEAtBACECIANBADYCHCADIAE2AhQgA0G/FjYCECADQQ82AgwMDwtBACECIANBADYCHCADIAE2AhQgA0HIEjYCECADQQs2AgwMDgtBACECIANBADYCHCADIAE2AhQgA0GVCTYCECADQQs2AgwMDQtBACECIANBADYCHCADIAE2AhQgA0HpDzYCECADQQo2AgwMDAtBACECIANBADYCHCADIAE2AhQgA0GDEDYCECADQQo2AgwMCwtBACECIANBADYCHCADIAE2AhQgA0GmHDYCECADQQI2AgwMCgtBACECIANBADYCHCADIAE2AhQgA0HFFTYCECADQQI2AgwMCQtBACECIANBADYCHCADIAE2AhQgA0H/FzYCECADQQI2AgwMCAtBACECIANBADYCHCADIAE2AhQgA0HKFzYCECADQQI2AgwMBwsgA0ECNgIcIAMgATYCFCADQZQdNgIQIANBFjYCDEEAIQIMBgtB3gAhAiABIARGDQUgCUEIaiEHIAMoAgAhBQJAAkAgASAERwRAIAVBxsYAaiEIIAQgBWogAWshBiAFQX9zQQpqIgUgAWohAANAIAEtAAAgCC0AAEcEQEECIQgMAwsgBUUEQEEAIQggACEBDAMLIAVBAWshBSAIQQFqIQggBCABQQFqIgFHDQALIAYhBSAEIQELIAdBATYCACADIAU2AgAMAQsgA0EANgIAIAcgCDYCAAsgByABNgIEIAkoAgwhACAJKAIIDgMBBQIACwALIANBADYCHCADQa0dNgIQIANBFzYCDCADIABBAWo2AhRBACECDAMLIANBADYCHCADIAA2AhQgA0HCHTYCECADQQk2AgxBACECDAILIAEgBEYEQEEoIQIMAgsgA0EJNgIIIAMgATYCBEEnIQIMAQsgASAERgRAQQEhAgwBCwNAAkACQAJAIAEtAABBCmsOBAABAQABCyABQQFqIQEMAQsgAUEBaiEBIAMtAC5BIHENAEEAIQIgA0EANgIcIAMgATYCFCADQYwgNgIQIANBBTYCDAwCC0EBIQIgASAERw0ACwsgCUEQaiQAIAJFBEAgAygCDCEADAELIAMgAjYCHEEAIQAgAygCBCIBRQ0AIAMgASAEIAMoAggRAQAiAUUNACADIAQ2AhQgAyABNgIMIAEhAAsgAAu+AgECfyAAQQA6AAAgAEHcAGoiAUEBa0EAOgAAIABBADoAAiAAQQA6AAEgAUEDa0EAOgAAIAFBAmtBADoAACAAQQA6AAMgAUEEa0EAOgAAQQAgAGtBA3EiASAAaiIAQQA2AgBB3AAgAWtBfHEiAiAAaiIBQQRrQQA2AgACQCACQQlJDQAgAEEANgIIIABBADYCBCABQQhrQQA2AgAgAUEMa0EANgIAIAJBGUkNACAAQQA2AhggAEEANgIUIABBADYCECAAQQA2AgwgAUEQa0EANgIAIAFBFGtBADYCACABQRhrQQA2AgAgAUEca0EANgIAIAIgAEEEcUEYciICayIBQSBJDQAgACACaiEAA0AgAEIANwMYIABCADcDECAAQgA3AwggAEIANwMAIABBIGohACABQSBrIgFBH0sNAAsLC1YBAX8CQCAAKAIMDQACQAJAAkACQCAALQAxDgMBAAMCCyAAKAI4IgFFDQAgASgCLCIBRQ0AIAAgAREAACIBDQMLQQAPCwALIABB0Bg2AhBBDiEBCyABCxoAIAAoAgxFBEAgAEHJHjYCECAAQRU2AgwLCxQAIAAoAgxBFUYEQCAAQQA2AgwLCxQAIAAoAgxBFkYEQCAAQQA2AgwLCwcAIAAoAgwLBwAgACgCEAsJACAAIAE2AhALBwAgACgCFAsXACAAQSRPBEAACyAAQQJ0QZQ3aigCAAsXACAAQS9PBEAACyAAQQJ0QaQ4aigCAAu/CQEBf0HfLCEBAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkAgAEHkAGsO9ANjYgABYWFhYWFhAgMEBWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWEGBwgJCgsMDQ4PYWFhYWEQYWFhYWFhYWFhYWERYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhEhMUFRYXGBkaG2FhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWEcHR4fICEiIyQlJicoKSorLC0uLzAxMjM0NTZhNzg5OmFhYWFhYWFhO2FhYTxhYWFhPT4/YWFhYWFhYWFAYWFBYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhQkNERUZHSElKS0xNTk9QUVJTYWFhYWFhYWFUVVZXWFlaW2FcXWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYV5hYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFfYGELQdUrDwtBgyUPC0G/MA8LQfI1DwtBtCgPC0GfKA8LQYEsDwtB1ioPC0H0Mw8LQa0zDwtByygPC0HOIw8LQcAjDwtB2SMPC0HRJA8LQZwzDwtBojYPC0H8Mw8LQeArDwtB4SUPC0HtIA8LQcQyDwtBqScPC0G5Ng8LQbggDwtBqyAPC0GjJA8LQbYkDwtBgSMPC0HhMg8LQZ80DwtByCkPC0HAMg8LQe4yDwtB8C8PC0HGNA8LQdAhDwtBmiQPC0HrLw8LQYQ1DwtByzUPC0GWMQ8LQcgrDwtB1C8PC0GTMA8LQd81DwtBtCMPC0G+NQ8LQdIpDwtBsyIPC0HNIA8LQZs2DwtBkCEPC0H/IA8LQa01DwtBsDQPC0HxJA8LQacqDwtB3TAPC0GLIg8LQcgvDwtB6yoPC0H0KQ8LQY8lDwtB3SIPC0HsJg8LQf0wDwtB1iYPC0GUNQ8LQY0jDwtBuikPC0HHIg8LQfIlDwtBtjMPC0GiIQ8LQf8vDwtBwCEPC0GBMw8LQcklDwtBqDEPC0HGMw8LQdM2DwtBxjYPC0HkNA8LQYgmDwtB7ScPC0H4IQ8LQakwDwtBjzQPC0GGNg8LQaovDwtBoSYPC0HsNg8LQZIpDwtBryYPC0GZIg8LQeAhDwsAC0G1JSEBCyABCxcAIAAgAC8BLkH+/wNxIAFBAEdyOwEuCxoAIAAgAC8BLkH9/wNxIAFBAEdBAXRyOwEuCxoAIAAgAC8BLkH7/wNxIAFBAEdBAnRyOwEuCxoAIAAgAC8BLkH3/wNxIAFBAEdBA3RyOwEuCxoAIAAgAC8BLkHv/wNxIAFBAEdBBHRyOwEuCxoAIAAgAC8BLkHf/wNxIAFBAEdBBXRyOwEuCxoAIAAgAC8BLkG//wNxIAFBAEdBBnRyOwEuCxoAIAAgAC8BLkH//gNxIAFBAEdBB3RyOwEuCxoAIAAgAC8BLkH//QNxIAFBAEdBCHRyOwEuCxoAIAAgAC8BLkH/+wNxIAFBAEdBCXRyOwEuCz4BAn8CQCAAKAI4IgNFDQAgAygCBCIDRQ0AIAAgASACIAFrIAMRAQAiBEF/Rw0AIABBzhE2AhBBGCEECyAECz4BAn8CQCAAKAI4IgNFDQAgAygCCCIDRQ0AIAAgASACIAFrIAMRAQAiBEF/Rw0AIABB5Ao2AhBBGCEECyAECz4BAn8CQCAAKAI4IgNFDQAgAygCDCIDRQ0AIAAgASACIAFrIAMRAQAiBEF/Rw0AIABB5R02AhBBGCEECyAECz4BAn8CQCAAKAI4IgNFDQAgAygCECIDRQ0AIAAgASACIAFrIAMRAQAiBEF/Rw0AIABBnRA2AhBBGCEECyAECz4BAn8CQCAAKAI4IgNFDQAgAygCFCIDRQ0AIAAgASACIAFrIAMRAQAiBEF/Rw0AIABBoh42AhBBGCEECyAECz4BAn8CQCAAKAI4IgNFDQAgAygCGCIDRQ0AIAAgASACIAFrIAMRAQAiBEF/Rw0AIABB7hQ2AhBBGCEECyAECz4BAn8CQCAAKAI4IgNFDQAgAygCKCIDRQ0AIAAgASACIAFrIAMRAQAiBEF/Rw0AIABB9gg2AhBBGCEECyAECz4BAn8CQCAAKAI4IgNFDQAgAygCHCIDRQ0AIAAgASACIAFrIAMRAQAiBEF/Rw0AIABB9xs2AhBBGCEECyAECz4BAn8CQCAAKAI4IgNFDQAgAygCICIDRQ0AIAAgASACIAFrIAMRAQAiBEF/Rw0AIABBlRU2AhBBGCEECyAECzgAIAACfyAALwEyQRRxQRRGBEBBASAALQAoQQFGDQEaIAAvATRB5QBGDAELIAAtAClBBUYLOgAwC1kBAn8CQCAALQAoQQFGDQAgAC8BNCIBQeQAa0HkAEkNACABQcwBRg0AIAFBsAJGDQAgAC8BMiIAQcAAcQ0AQQEhAiAAQYgEcUGABEYNACAAQShxRSECCyACC4wBAQJ/AkACQAJAIAAtACpFDQAgAC0AK0UNACAALwEyIgFBAnFFDQEMAgsgAC8BMiIBQQFxRQ0BC0EBIQIgAC0AKEEBRg0AIAAvATQiAEHkAGtB5ABJDQAgAEHMAUYNACAAQbACRg0AIAFBwABxDQBBACECIAFBiARxQYAERg0AIAFBKHFBAEchAgsgAgtzACAAQRBq/QwAAAAAAAAAAAAAAAAAAAAA/QsDACAA/QwAAAAAAAAAAAAAAAAAAAAA/QsDACAAQTBq/QwAAAAAAAAAAAAAAAAAAAAA/QsDACAAQSBq/QwAAAAAAAAAAAAAAAAAAAAA/QsDACAAQewBNgIcCwYAIAAQOQuaLQELfyMAQRBrIgokAEGY1AAoAgAiCUUEQEHY1wAoAgAiBUUEQEHk1wBCfzcCAEHc1wBCgICEgICAwAA3AgBB2NcAIApBCGpBcHFB2KrVqgVzIgU2AgBB7NcAQQA2AgBBvNcAQQA2AgALQcDXAEGA2AQ2AgBBkNQAQYDYBDYCAEGk1AAgBTYCAEGg1ABBfzYCAEHE1wBBgKgDNgIAA0AgAUG81ABqIAFBsNQAaiICNgIAIAIgAUGo1ABqIgM2AgAgAUG01ABqIAM2AgAgAUHE1ABqIAFBuNQAaiIDNgIAIAMgAjYCACABQczUAGogAUHA1ABqIgI2AgAgAiADNgIAIAFByNQAaiACNgIAIAFBIGoiAUGAAkcNAAtBjNgEQcGnAzYCAEGc1ABB6NcAKAIANgIAQYzUAEHApwM2AgBBmNQAQYjYBDYCAEHM/wdBODYCAEGI2AQhCQsCQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQCAAQewBTQRAQYDUACgCACIGQRAgAEETakFwcSAAQQtJGyIEQQN2IgB2IgFBA3EEQAJAIAFBAXEgAHJBAXMiAkEDdCIAQajUAGoiASAAQbDUAGooAgAiACgCCCIDRgRAQYDUACAGQX4gAndxNgIADAELIAEgAzYCCCADIAE2AgwLIABBCGohASAAIAJBA3QiAkEDcjYCBCAAIAJqIgAgACgCBEEBcjYCBAwRC0GI1AAoAgAiCCAETw0BIAEEQAJAQQIgAHQiAkEAIAJrciABIAB0cWgiAEEDdCICQajUAGoiASACQbDUAGooAgAiAigCCCIDRgRAQYDUACAGQX4gAHdxIgY2AgAMAQsgASADNgIIIAMgATYCDAsgAiAEQQNyNgIEIABBA3QiACAEayEFIAAgAmogBTYCACACIARqIgQgBUEBcjYCBCAIBEAgCEF4cUGo1ABqIQBBlNQAKAIAIQMCf0EBIAhBA3Z0IgEgBnFFBEBBgNQAIAEgBnI2AgAgAAwBCyAAKAIICyIBIAM2AgwgACADNgIIIAMgADYCDCADIAE2AggLIAJBCGohAUGU1AAgBDYCAEGI1AAgBTYCAAwRC0GE1AAoAgAiC0UNASALaEECdEGw1gBqKAIAIgAoAgRBeHEgBGshBSAAIQIDQAJAIAIoAhAiAUUEQCACQRRqKAIAIgFFDQELIAEoAgRBeHEgBGsiAyAFSSECIAMgBSACGyEFIAEgACACGyEAIAEhAgwBCwsgACgCGCEJIAAoAgwiAyAARwRAQZDUACgCABogAyAAKAIIIgE2AgggASADNgIMDBALIABBFGoiAigCACIBRQRAIAAoAhAiAUUNAyAAQRBqIQILA0AgAiEHIAEiA0EUaiICKAIAIgENACADQRBqIQIgAygCECIBDQALIAdBADYCAAwPC0F/IQQgAEG/f0sNACAAQRNqIgFBcHEhBEGE1AAoAgAiCEUNAEEAIARrIQUCQAJAAkACf0EAIARBgAJJDQAaQR8gBEH///8HSw0AGiAEQSYgAUEIdmciAGt2QQFxIABBAXRrQT5qCyIGQQJ0QbDWAGooAgAiAkUEQEEAIQFBACEDDAELQQAhASAEQRkgBkEBdmtBACAGQR9HG3QhAEEAIQMDQAJAIAIoAgRBeHEgBGsiByAFTw0AIAIhAyAHIgUNAEEAIQUgAiEBDAMLIAEgAkEUaigCACIHIAcgAiAAQR12QQRxakEQaigCACICRhsgASAHGyEBIABBAXQhACACDQALCyABIANyRQRAQQAhA0ECIAZ0IgBBACAAa3IgCHEiAEUNAyAAaEECdEGw1gBqKAIAIQELIAFFDQELA0AgASgCBEF4cSAEayICIAVJIQAgAiAFIAAbIQUgASADIAAbIQMgASgCECIABH8gAAUgAUEUaigCAAsiAQ0ACwsgA0UNACAFQYjUACgCACAEa08NACADKAIYIQcgAyADKAIMIgBHBEBBkNQAKAIAGiAAIAMoAggiATYCCCABIAA2AgwMDgsgA0EUaiICKAIAIgFFBEAgAygCECIBRQ0DIANBEGohAgsDQCACIQYgASIAQRRqIgIoAgAiAQ0AIABBEGohAiAAKAIQIgENAAsgBkEANgIADA0LQYjUACgCACIDIARPBEBBlNQAKAIAIQECQCADIARrIgJBEE8EQCABIARqIgAgAkEBcjYCBCABIANqIAI2AgAgASAEQQNyNgIEDAELIAEgA0EDcjYCBCABIANqIgAgACgCBEEBcjYCBEEAIQBBACECC0GI1AAgAjYCAEGU1AAgADYCACABQQhqIQEMDwtBjNQAKAIAIgMgBEsEQCAEIAlqIgAgAyAEayIBQQFyNgIEQZjUACAANgIAQYzUACABNgIAIAkgBEEDcjYCBCAJQQhqIQEMDwtBACEBIAQCf0HY1wAoAgAEQEHg1wAoAgAMAQtB5NcAQn83AgBB3NcAQoCAhICAgMAANwIAQdjXACAKQQxqQXBxQdiq1aoFczYCAEHs1wBBADYCAEG81wBBADYCAEGAgAQLIgAgBEHHAGoiBWoiBkEAIABrIgdxIgJPBEBB8NcAQTA2AgAMDwsCQEG41wAoAgAiAUUNAEGw1wAoAgAiCCACaiEAIAAgAU0gACAIS3ENAEEAIQFB8NcAQTA2AgAMDwtBvNcALQAAQQRxDQQCQAJAIAkEQEHA1wAhAQNAIAEoAgAiACAJTQRAIAAgASgCBGogCUsNAwsgASgCCCIBDQALC0EAEDoiAEF/Rg0FIAIhBkHc1wAoAgAiAUEBayIDIABxBEAgAiAAayAAIANqQQAgAWtxaiEGCyAEIAZPDQUgBkH+////B0sNBUG41wAoAgAiAwRAQbDXACgCACIHIAZqIQEgASAHTQ0GIAEgA0sNBgsgBhA6IgEgAEcNAQwHCyAGIANrIAdxIgZB/v///wdLDQQgBhA6IQAgACABKAIAIAEoAgRqRg0DIAAhAQsCQCAGIARByABqTw0AIAFBf0YNAEHg1wAoAgAiACAFIAZrakEAIABrcSIAQf7///8HSwRAIAEhAAwHCyAAEDpBf0cEQCAAIAZqIQYgASEADAcLQQAgBmsQOhoMBAsgASIAQX9HDQUMAwtBACEDDAwLQQAhAAwKCyAAQX9HDQILQbzXAEG81wAoAgBBBHI2AgALIAJB/v///wdLDQEgAhA6IQBBABA6IQEgAEF/Rg0BIAFBf0YNASAAIAFPDQEgASAAayIGIARBOGpNDQELQbDXAEGw1wAoAgAgBmoiATYCAEG01wAoAgAgAUkEQEG01wAgATYCAAsCQAJAAkBBmNQAKAIAIgIEQEHA1wAhAQNAIAAgASgCACIDIAEoAgQiBWpGDQIgASgCCCIBDQALDAILQZDUACgCACIBQQBHIAAgAU9xRQRAQZDUACAANgIAC0EAIQFBxNcAIAY2AgBBwNcAIAA2AgBBoNQAQX82AgBBpNQAQdjXACgCADYCAEHM1wBBADYCAANAIAFBvNQAaiABQbDUAGoiAjYCACACIAFBqNQAaiIDNgIAIAFBtNQAaiADNgIAIAFBxNQAaiABQbjUAGoiAzYCACADIAI2AgAgAUHM1ABqIAFBwNQAaiICNgIAIAIgAzYCACABQcjUAGogAjYCACABQSBqIgFBgAJHDQALQXggAGtBD3EiASAAaiICIAZBOGsiAyABayIBQQFyNgIEQZzUAEHo1wAoAgA2AgBBjNQAIAE2AgBBmNQAIAI2AgAgACADakE4NgIEDAILIAAgAk0NACACIANJDQAgASgCDEEIcQ0AQXggAmtBD3EiACACaiIDQYzUACgCACAGaiIHIABrIgBBAXI2AgQgASAFIAZqNgIEQZzUAEHo1wAoAgA2AgBBjNQAIAA2AgBBmNQAIAM2AgAgAiAHakE4NgIEDAELIABBkNQAKAIASQRAQZDUACAANgIACyAAIAZqIQNBwNcAIQECQAJAAkADQCADIAEoAgBHBEAgASgCCCIBDQEMAgsLIAEtAAxBCHFFDQELQcDXACEBA0AgASgCACIDIAJNBEAgAyABKAIEaiIFIAJLDQMLIAEoAgghAQwACwALIAEgADYCACABIAEoAgQgBmo2AgQgAEF4IABrQQ9xaiIJIARBA3I2AgQgA0F4IANrQQ9xaiIGIAQgCWoiBGshASACIAZGBEBBmNQAIAQ2AgBBjNQAQYzUACgCACABaiIANgIAIAQgAEEBcjYCBAwIC0GU1AAoAgAgBkYEQEGU1AAgBDYCAEGI1ABBiNQAKAIAIAFqIgA2AgAgBCAAQQFyNgIEIAAgBGogADYCAAwICyAGKAIEIgVBA3FBAUcNBiAFQXhxIQggBUH/AU0EQCAFQQN2IQMgBigCCCIAIAYoAgwiAkYEQEGA1ABBgNQAKAIAQX4gA3dxNgIADAcLIAIgADYCCCAAIAI2AgwMBgsgBigCGCEHIAYgBigCDCIARwRAIAAgBigCCCICNgIIIAIgADYCDAwFCyAGQRRqIgIoAgAiBUUEQCAGKAIQIgVFDQQgBkEQaiECCwNAIAIhAyAFIgBBFGoiAigCACIFDQAgAEEQaiECIAAoAhAiBQ0ACyADQQA2AgAMBAtBeCAAa0EPcSIBIABqIgcgBkE4ayIDIAFrIgFBAXI2AgQgACADakE4NgIEIAIgBUE3IAVrQQ9xakE/ayIDIAMgAkEQakkbIgNBIzYCBEGc1ABB6NcAKAIANgIAQYzUACABNgIAQZjUACAHNgIAIANBEGpByNcAKQIANwIAIANBwNcAKQIANwIIQcjXACADQQhqNgIAQcTXACAGNgIAQcDXACAANgIAQczXAEEANgIAIANBJGohAQNAIAFBBzYCACAFIAFBBGoiAUsNAAsgAiADRg0AIAMgAygCBEF+cTYCBCADIAMgAmsiBTYCACACIAVBAXI2AgQgBUH/AU0EQCAFQXhxQajUAGohAAJ/QYDUACgCACIBQQEgBUEDdnQiA3FFBEBBgNQAIAEgA3I2AgAgAAwBCyAAKAIICyIBIAI2AgwgACACNgIIIAIgADYCDCACIAE2AggMAQtBHyEBIAVB////B00EQCAFQSYgBUEIdmciAGt2QQFxIABBAXRrQT5qIQELIAIgATYCHCACQgA3AhAgAUECdEGw1gBqIQBBhNQAKAIAIgNBASABdCIGcUUEQCAAIAI2AgBBhNQAIAMgBnI2AgAgAiAANgIYIAIgAjYCCCACIAI2AgwMAQsgBUEZIAFBAXZrQQAgAUEfRxt0IQEgACgCACEDAkADQCADIgAoAgRBeHEgBUYNASABQR12IQMgAUEBdCEBIAAgA0EEcWpBEGoiBigCACIDDQALIAYgAjYCACACIAA2AhggAiACNgIMIAIgAjYCCAwBCyAAKAIIIgEgAjYCDCAAIAI2AgggAkEANgIYIAIgADYCDCACIAE2AggLQYzUACgCACIBIARNDQBBmNQAKAIAIgAgBGoiAiABIARrIgFBAXI2AgRBjNQAIAE2AgBBmNQAIAI2AgAgACAEQQNyNgIEIABBCGohAQwIC0EAIQFB8NcAQTA2AgAMBwtBACEACyAHRQ0AAkAgBigCHCICQQJ0QbDWAGoiAygCACAGRgRAIAMgADYCACAADQFBhNQAQYTUACgCAEF+IAJ3cTYCAAwCCyAHQRBBFCAHKAIQIAZGG2ogADYCACAARQ0BCyAAIAc2AhggBigCECICBEAgACACNgIQIAIgADYCGAsgBkEUaigCACICRQ0AIABBFGogAjYCACACIAA2AhgLIAEgCGohASAGIAhqIgYoAgQhBQsgBiAFQX5xNgIEIAEgBGogATYCACAEIAFBAXI2AgQgAUH/AU0EQCABQXhxQajUAGohAAJ/QYDUACgCACICQQEgAUEDdnQiAXFFBEBBgNQAIAEgAnI2AgAgAAwBCyAAKAIICyIBIAQ2AgwgACAENgIIIAQgADYCDCAEIAE2AggMAQtBHyEFIAFB////B00EQCABQSYgAUEIdmciAGt2QQFxIABBAXRrQT5qIQULIAQgBTYCHCAEQgA3AhAgBUECdEGw1gBqIQBBhNQAKAIAIgJBASAFdCIDcUUEQCAAIAQ2AgBBhNQAIAIgA3I2AgAgBCAANgIYIAQgBDYCCCAEIAQ2AgwMAQsgAUEZIAVBAXZrQQAgBUEfRxt0IQUgACgCACEAAkADQCAAIgIoAgRBeHEgAUYNASAFQR12IQAgBUEBdCEFIAIgAEEEcWpBEGoiAygCACIADQALIAMgBDYCACAEIAI2AhggBCAENgIMIAQgBDYCCAwBCyACKAIIIgAgBDYCDCACIAQ2AgggBEEANgIYIAQgAjYCDCAEIAA2AggLIAlBCGohAQwCCwJAIAdFDQACQCADKAIcIgFBAnRBsNYAaiICKAIAIANGBEAgAiAANgIAIAANAUGE1AAgCEF+IAF3cSIINgIADAILIAdBEEEUIAcoAhAgA0YbaiAANgIAIABFDQELIAAgBzYCGCADKAIQIgEEQCAAIAE2AhAgASAANgIYCyADQRRqKAIAIgFFDQAgAEEUaiABNgIAIAEgADYCGAsCQCAFQQ9NBEAgAyAEIAVqIgBBA3I2AgQgACADaiIAIAAoAgRBAXI2AgQMAQsgAyAEaiICIAVBAXI2AgQgAyAEQQNyNgIEIAIgBWogBTYCACAFQf8BTQRAIAVBeHFBqNQAaiEAAn9BgNQAKAIAIgFBASAFQQN2dCIFcUUEQEGA1AAgASAFcjYCACAADAELIAAoAggLIgEgAjYCDCAAIAI2AgggAiAANgIMIAIgATYCCAwBC0EfIQEgBUH///8HTQRAIAVBJiAFQQh2ZyIAa3ZBAXEgAEEBdGtBPmohAQsgAiABNgIcIAJCADcCECABQQJ0QbDWAGohAEEBIAF0IgQgCHFFBEAgACACNgIAQYTUACAEIAhyNgIAIAIgADYCGCACIAI2AgggAiACNgIMDAELIAVBGSABQQF2a0EAIAFBH0cbdCEBIAAoAgAhBAJAA0AgBCIAKAIEQXhxIAVGDQEgAUEddiEEIAFBAXQhASAAIARBBHFqQRBqIgYoAgAiBA0ACyAGIAI2AgAgAiAANgIYIAIgAjYCDCACIAI2AggMAQsgACgCCCIBIAI2AgwgACACNgIIIAJBADYCGCACIAA2AgwgAiABNgIICyADQQhqIQEMAQsCQCAJRQ0AAkAgACgCHCIBQQJ0QbDWAGoiAigCACAARgRAIAIgAzYCACADDQFBhNQAIAtBfiABd3E2AgAMAgsgCUEQQRQgCSgCECAARhtqIAM2AgAgA0UNAQsgAyAJNgIYIAAoAhAiAQRAIAMgATYCECABIAM2AhgLIABBFGooAgAiAUUNACADQRRqIAE2AgAgASADNgIYCwJAIAVBD00EQCAAIAQgBWoiAUEDcjYCBCAAIAFqIgEgASgCBEEBcjYCBAwBCyAAIARqIgcgBUEBcjYCBCAAIARBA3I2AgQgBSAHaiAFNgIAIAgEQCAIQXhxQajUAGohAUGU1AAoAgAhAwJ/QQEgCEEDdnQiAiAGcUUEQEGA1AAgAiAGcjYCACABDAELIAEoAggLIgIgAzYCDCABIAM2AgggAyABNgIMIAMgAjYCCAtBlNQAIAc2AgBBiNQAIAU2AgALIABBCGohAQsgCkEQaiQAIAELQwAgAEUEQD8AQRB0DwsCQCAAQf//A3ENACAAQQBIDQAgAEEQdkAAIgBBf0YEQEHw1wBBMDYCAEF/DwsgAEEQdA8LAAsL20AiAEGACAsJAQAAAAIAAAADAEGUCAsFBAAAAAUAQaQICwkGAAAABwAAAAgAQdwIC4IxSW52YWxpZCBjaGFyIGluIHVybCBxdWVyeQBTcGFuIGNhbGxiYWNrIGVycm9yIGluIG9uX2JvZHkAQ29udGVudC1MZW5ndGggb3ZlcmZsb3cAQ2h1bmsgc2l6ZSBvdmVyZmxvdwBJbnZhbGlkIG1ldGhvZCBmb3IgSFRUUC94LnggcmVxdWVzdABJbnZhbGlkIG1ldGhvZCBmb3IgUlRTUC94LnggcmVxdWVzdABFeHBlY3RlZCBTT1VSQ0UgbWV0aG9kIGZvciBJQ0UveC54IHJlcXVlc3QASW52YWxpZCBjaGFyIGluIHVybCBmcmFnbWVudCBzdGFydABFeHBlY3RlZCBkb3QAU3BhbiBjYWxsYmFjayBlcnJvciBpbiBvbl9zdGF0dXMASW52YWxpZCByZXNwb25zZSBzdGF0dXMARXhwZWN0ZWQgTEYgYWZ0ZXIgaGVhZGVycwBJbnZhbGlkIGNoYXJhY3RlciBpbiBjaHVuayBleHRlbnNpb25zAFVzZXIgY2FsbGJhY2sgZXJyb3IAYG9uX3Jlc2V0YCBjYWxsYmFjayBlcnJvcgBgb25fY2h1bmtfaGVhZGVyYCBjYWxsYmFjayBlcnJvcgBgb25fbWVzc2FnZV9iZWdpbmAgY2FsbGJhY2sgZXJyb3IAYG9uX2NodW5rX2V4dGVuc2lvbl92YWx1ZWAgY2FsbGJhY2sgZXJyb3IAYG9uX3N0YXR1c19jb21wbGV0ZWAgY2FsbGJhY2sgZXJyb3IAYG9uX3ZlcnNpb25fY29tcGxldGVgIGNhbGxiYWNrIGVycm9yAGBvbl91cmxfY29tcGxldGVgIGNhbGxiYWNrIGVycm9yAGBvbl9jaHVua19jb21wbGV0ZWAgY2FsbGJhY2sgZXJyb3IAYG9uX2hlYWRlcl92YWx1ZV9jb21wbGV0ZWAgY2FsbGJhY2sgZXJyb3IAYG9uX21lc3NhZ2VfY29tcGxldGVgIGNhbGxiYWNrIGVycm9yAGBvbl9tZXRob2RfY29tcGxldGVgIGNhbGxiYWNrIGVycm9yAGBvbl9oZWFkZXJfZmllbGRfY29tcGxldGVgIGNhbGxiYWNrIGVycm9yAGBvbl9jaHVua19leHRlbnNpb25fbmFtZWAgY2FsbGJhY2sgZXJyb3IAVW5leHBlY3RlZCBjaGFyIGluIHVybCBzZXJ2ZXIASW52YWxpZCBoZWFkZXIgdmFsdWUgY2hhcgBJbnZhbGlkIGhlYWRlciBmaWVsZCBjaGFyAFNwYW4gY2FsbGJhY2sgZXJyb3IgaW4gb25fdmVyc2lvbgBJbnZhbGlkIG1pbm9yIHZlcnNpb24ASW52YWxpZCBtYWpvciB2ZXJzaW9uAEV4cGVjdGVkIHNwYWNlIGFmdGVyIHZlcnNpb24ARXhwZWN0ZWQgQ1JMRiBhZnRlciB2ZXJzaW9uAEludmFsaWQgSFRUUCB2ZXJzaW9uAEludmFsaWQgaGVhZGVyIHRva2VuAFNwYW4gY2FsbGJhY2sgZXJyb3IgaW4gb25fdXJsAEludmFsaWQgY2hhcmFjdGVycyBpbiB1cmwAVW5leHBlY3RlZCBzdGFydCBjaGFyIGluIHVybABEb3VibGUgQCBpbiB1cmwARW1wdHkgQ29udGVudC1MZW5ndGgASW52YWxpZCBjaGFyYWN0ZXIgaW4gQ29udGVudC1MZW5ndGgAVHJhbnNmZXItRW5jb2RpbmcgY2FuJ3QgYmUgcHJlc2VudCB3aXRoIENvbnRlbnQtTGVuZ3RoAER1cGxpY2F0ZSBDb250ZW50LUxlbmd0aABJbnZhbGlkIGNoYXIgaW4gdXJsIHBhdGgAQ29udGVudC1MZW5ndGggY2FuJ3QgYmUgcHJlc2VudCB3aXRoIFRyYW5zZmVyLUVuY29kaW5nAE1pc3NpbmcgZXhwZWN0ZWQgQ1IgYWZ0ZXIgY2h1bmsgc2l6ZQBFeHBlY3RlZCBMRiBhZnRlciBjaHVuayBzaXplAEludmFsaWQgY2hhcmFjdGVyIGluIGNodW5rIHNpemUAU3BhbiBjYWxsYmFjayBlcnJvciBpbiBvbl9oZWFkZXJfdmFsdWUAU3BhbiBjYWxsYmFjayBlcnJvciBpbiBvbl9jaHVua19leHRlbnNpb25fdmFsdWUASW52YWxpZCBjaGFyYWN0ZXIgaW4gY2h1bmsgZXh0ZW5zaW9ucyB2YWx1ZQBNaXNzaW5nIGV4cGVjdGVkIENSIGFmdGVyIGhlYWRlciB2YWx1ZQBNaXNzaW5nIGV4cGVjdGVkIExGIGFmdGVyIGhlYWRlciB2YWx1ZQBJbnZhbGlkIGBUcmFuc2Zlci1FbmNvZGluZ2AgaGVhZGVyIHZhbHVlAE1pc3NpbmcgZXhwZWN0ZWQgQ1IgYWZ0ZXIgY2h1bmsgZXh0ZW5zaW9uIHZhbHVlAEludmFsaWQgY2hhcmFjdGVyIGluIGNodW5rIGV4dGVuc2lvbnMgcXVvdGUgdmFsdWUASW52YWxpZCBxdW90ZWQtcGFpciBpbiBjaHVuayBleHRlbnNpb25zIHF1b3RlZCB2YWx1ZQBJbnZhbGlkIGNoYXJhY3RlciBpbiBjaHVuayBleHRlbnNpb25zIHF1b3RlZCB2YWx1ZQBQYXVzZWQgYnkgb25faGVhZGVyc19jb21wbGV0ZQBJbnZhbGlkIEVPRiBzdGF0ZQBvbl9yZXNldCBwYXVzZQBvbl9jaHVua19oZWFkZXIgcGF1c2UAb25fbWVzc2FnZV9iZWdpbiBwYXVzZQBvbl9jaHVua19leHRlbnNpb25fdmFsdWUgcGF1c2UAb25fc3RhdHVzX2NvbXBsZXRlIHBhdXNlAG9uX3ZlcnNpb25fY29tcGxldGUgcGF1c2UAb25fdXJsX2NvbXBsZXRlIHBhdXNlAG9uX2NodW5rX2NvbXBsZXRlIHBhdXNlAG9uX2hlYWRlcl92YWx1ZV9jb21wbGV0ZSBwYXVzZQBvbl9tZXNzYWdlX2NvbXBsZXRlIHBhdXNlAG9uX21ldGhvZF9jb21wbGV0ZSBwYXVzZQBvbl9oZWFkZXJfZmllbGRfY29tcGxldGUgcGF1c2UAb25fY2h1bmtfZXh0ZW5zaW9uX25hbWUgcGF1c2UAVW5leHBlY3RlZCBzcGFjZSBhZnRlciBzdGFydCBsaW5lAE1pc3NpbmcgZXhwZWN0ZWQgQ1IgYWZ0ZXIgcmVzcG9uc2UgbGluZQBTcGFuIGNhbGxiYWNrIGVycm9yIGluIG9uX2NodW5rX2V4dGVuc2lvbl9uYW1lAEludmFsaWQgY2hhcmFjdGVyIGluIGNodW5rIGV4dGVuc2lvbnMgbmFtZQBNaXNzaW5nIGV4cGVjdGVkIENSIGFmdGVyIGNodW5rIGV4dGVuc2lvbiBuYW1lAEludmFsaWQgc3RhdHVzIGNvZGUAUGF1c2Ugb24gQ09OTkVDVC9VcGdyYWRlAFBhdXNlIG9uIFBSSS9VcGdyYWRlAEV4cGVjdGVkIEhUVFAvMiBDb25uZWN0aW9uIFByZWZhY2UAU3BhbiBjYWxsYmFjayBlcnJvciBpbiBvbl9tZXRob2QARXhwZWN0ZWQgc3BhY2UgYWZ0ZXIgbWV0aG9kAFNwYW4gY2FsbGJhY2sgZXJyb3IgaW4gb25faGVhZGVyX2ZpZWxkAFBhdXNlZABJbnZhbGlkIHdvcmQgZW5jb3VudGVyZWQASW52YWxpZCBtZXRob2QgZW5jb3VudGVyZWQATWlzc2luZyBleHBlY3RlZCBDUiBhZnRlciBjaHVuayBkYXRhAEV4cGVjdGVkIExGIGFmdGVyIGNodW5rIGRhdGEAVW5leHBlY3RlZCBjaGFyIGluIHVybCBzY2hlbWEAUmVxdWVzdCBoYXMgaW52YWxpZCBgVHJhbnNmZXItRW5jb2RpbmdgAERhdGEgYWZ0ZXIgYENvbm5lY3Rpb246IGNsb3NlYABTV0lUQ0hfUFJPWFkAVVNFX1BST1hZAE1LQUNUSVZJVFkAVU5QUk9DRVNTQUJMRV9FTlRJVFkAUVVFUlkAQ09QWQBNT1ZFRF9QRVJNQU5FTlRMWQBUT09fRUFSTFkATk9USUZZAEZBSUxFRF9ERVBFTkRFTkNZAEJBRF9HQVRFV0FZAFBMQVkAUFVUAENIRUNLT1VUAEdBVEVXQVlfVElNRU9VVABSRVFVRVNUX1RJTUVPVVQATkVUV09SS19DT05ORUNUX1RJTUVPVVQAQ09OTkVDVElPTl9USU1FT1VUAExPR0lOX1RJTUVPVVQATkVUV09SS19SRUFEX1RJTUVPVVQAUE9TVABNSVNESVJFQ1RFRF9SRVFVRVNUAENMSUVOVF9DTE9TRURfUkVRVUVTVABDTElFTlRfQ0xPU0VEX0xPQURfQkFMQU5DRURfUkVRVUVTVABCQURfUkVRVUVTVABIVFRQX1JFUVVFU1RfU0VOVF9UT19IVFRQU19QT1JUAFJFUE9SVABJTV9BX1RFQVBPVABSRVNFVF9DT05URU5UAE5PX0NPTlRFTlQAUEFSVElBTF9DT05URU5UAEhQRV9JTlZBTElEX0NPTlNUQU5UAEhQRV9DQl9SRVNFVABHRVQASFBFX1NUUklDVABDT05GTElDVABURU1QT1JBUllfUkVESVJFQ1QAUEVSTUFORU5UX1JFRElSRUNUAENPTk5FQ1QATVVMVElfU1RBVFVTAEhQRV9JTlZBTElEX1NUQVRVUwBUT09fTUFOWV9SRVFVRVNUUwBFQVJMWV9ISU5UUwBVTkFWQUlMQUJMRV9GT1JfTEVHQUxfUkVBU09OUwBPUFRJT05TAFNXSVRDSElOR19QUk9UT0NPTFMAVkFSSUFOVF9BTFNPX05FR09USUFURVMATVVMVElQTEVfQ0hPSUNFUwBJTlRFUk5BTF9TRVJWRVJfRVJST1IAV0VCX1NFUlZFUl9VTktOT1dOX0VSUk9SAFJBSUxHVU5fRVJST1IASURFTlRJVFlfUFJPVklERVJfQVVUSEVOVElDQVRJT05fRVJST1IAU1NMX0NFUlRJRklDQVRFX0VSUk9SAElOVkFMSURfWF9GT1JXQVJERURfRk9SAFNFVF9QQVJBTUVURVIAR0VUX1BBUkFNRVRFUgBIUEVfVVNFUgBTRUVfT1RIRVIASFBFX0NCX0NIVU5LX0hFQURFUgBFeHBlY3RlZCBMRiBhZnRlciBDUgBNS0NBTEVOREFSAFNFVFVQAFdFQl9TRVJWRVJfSVNfRE9XTgBURUFSRE9XTgBIUEVfQ0xPU0VEX0NPTk5FQ1RJT04ASEVVUklTVElDX0VYUElSQVRJT04ARElTQ09OTkVDVEVEX09QRVJBVElPTgBOT05fQVVUSE9SSVRBVElWRV9JTkZPUk1BVElPTgBIUEVfSU5WQUxJRF9WRVJTSU9OAEhQRV9DQl9NRVNTQUdFX0JFR0lOAFNJVEVfSVNfRlJPWkVOAEhQRV9JTlZBTElEX0hFQURFUl9UT0tFTgBJTlZBTElEX1RPS0VOAEZPUkJJRERFTgBFTkhBTkNFX1lPVVJfQ0FMTQBIUEVfSU5WQUxJRF9VUkwAQkxPQ0tFRF9CWV9QQVJFTlRBTF9DT05UUk9MAE1LQ09MAEFDTABIUEVfSU5URVJOQUwAUkVRVUVTVF9IRUFERVJfRklFTERTX1RPT19MQVJHRV9VTk9GRklDSUFMAEhQRV9PSwBVTkxJTksAVU5MT0NLAFBSSQBSRVRSWV9XSVRIAEhQRV9JTlZBTElEX0NPTlRFTlRfTEVOR1RIAEhQRV9VTkVYUEVDVEVEX0NPTlRFTlRfTEVOR1RIAEZMVVNIAFBST1BQQVRDSABNLVNFQVJDSABVUklfVE9PX0xPTkcAUFJPQ0VTU0lORwBNSVNDRUxMQU5FT1VTX1BFUlNJU1RFTlRfV0FSTklORwBNSVNDRUxMQU5FT1VTX1dBUk5JTkcASFBFX0lOVkFMSURfVFJBTlNGRVJfRU5DT0RJTkcARXhwZWN0ZWQgQ1JMRgBIUEVfSU5WQUxJRF9DSFVOS19TSVpFAE1PVkUAQ09OVElOVUUASFBFX0NCX1NUQVRVU19DT01QTEVURQBIUEVfQ0JfSEVBREVSU19DT01QTEVURQBIUEVfQ0JfVkVSU0lPTl9DT01QTEVURQBIUEVfQ0JfVVJMX0NPTVBMRVRFAEhQRV9DQl9DSFVOS19DT01QTEVURQBIUEVfQ0JfSEVBREVSX1ZBTFVFX0NPTVBMRVRFAEhQRV9DQl9DSFVOS19FWFRFTlNJT05fVkFMVUVfQ09NUExFVEUASFBFX0NCX0NIVU5LX0VYVEVOU0lPTl9OQU1FX0NPTVBMRVRFAEhQRV9DQl9NRVNTQUdFX0NPTVBMRVRFAEhQRV9DQl9NRVRIT0RfQ09NUExFVEUASFBFX0NCX0hFQURFUl9GSUVMRF9DT01QTEVURQBERUxFVEUASFBFX0lOVkFMSURfRU9GX1NUQVRFAElOVkFMSURfU1NMX0NFUlRJRklDQVRFAFBBVVNFAE5PX1JFU1BPTlNFAFVOU1VQUE9SVEVEX01FRElBX1RZUEUAR09ORQBOT1RfQUNDRVBUQUJMRQBTRVJWSUNFX1VOQVZBSUxBQkxFAFJBTkdFX05PVF9TQVRJU0ZJQUJMRQBPUklHSU5fSVNfVU5SRUFDSEFCTEUAUkVTUE9OU0VfSVNfU1RBTEUAUFVSR0UATUVSR0UAUkVRVUVTVF9IRUFERVJfRklFTERTX1RPT19MQVJHRQBSRVFVRVNUX0hFQURFUl9UT09fTEFSR0UAUEFZTE9BRF9UT09fTEFSR0UASU5TVUZGSUNJRU5UX1NUT1JBR0UASFBFX1BBVVNFRF9VUEdSQURFAEhQRV9QQVVTRURfSDJfVVBHUkFERQBTT1VSQ0UAQU5OT1VOQ0UAVFJBQ0UASFBFX1VORVhQRUNURURfU1BBQ0UAREVTQ1JJQkUAVU5TVUJTQ1JJQkUAUkVDT1JEAEhQRV9JTlZBTElEX01FVEhPRABOT1RfRk9VTkQAUFJPUEZJTkQAVU5CSU5EAFJFQklORABVTkFVVEhPUklaRUQATUVUSE9EX05PVF9BTExPV0VEAEhUVFBfVkVSU0lPTl9OT1RfU1VQUE9SVEVEAEFMUkVBRFlfUkVQT1JURUQAQUNDRVBURUQATk9UX0lNUExFTUVOVEVEAExPT1BfREVURUNURUQASFBFX0NSX0VYUEVDVEVEAEhQRV9MRl9FWFBFQ1RFRABDUkVBVEVEAElNX1VTRUQASFBFX1BBVVNFRABUSU1FT1VUX09DQ1VSRUQAUEFZTUVOVF9SRVFVSVJFRABQUkVDT05ESVRJT05fUkVRVUlSRUQAUFJPWFlfQVVUSEVOVElDQVRJT05fUkVRVUlSRUQATkVUV09SS19BVVRIRU5USUNBVElPTl9SRVFVSVJFRABMRU5HVEhfUkVRVUlSRUQAU1NMX0NFUlRJRklDQVRFX1JFUVVJUkVEAFVQR1JBREVfUkVRVUlSRUQAUEFHRV9FWFBJUkVEAFBSRUNPTkRJVElPTl9GQUlMRUQARVhQRUNUQVRJT05fRkFJTEVEAFJFVkFMSURBVElPTl9GQUlMRUQAU1NMX0hBTkRTSEFLRV9GQUlMRUQATE9DS0VEAFRSQU5TRk9STUFUSU9OX0FQUExJRUQATk9UX01PRElGSUVEAE5PVF9FWFRFTkRFRABCQU5EV0lEVEhfTElNSVRfRVhDRUVERUQAU0lURV9JU19PVkVSTE9BREVEAEhFQUQARXhwZWN0ZWQgSFRUUC8AAFIVAAAaFQAADxIAAOQZAACRFQAACRQAAC0ZAADkFAAA6REAAGkUAAChFAAAdhUAAEMWAABeEgAAlBcAABcWAAB9FAAAfxYAAEEXAACzEwAAwxYAAAQaAAC9GAAA0BgAAKATAADUGQAArxYAAGgWAABwFwAA2RYAAPwYAAD+EQAAWRcAAJcWAAAcFwAA9hYAAI0XAAALEgAAfxsAAC4RAACzEAAASRIAAK0SAAD2GAAAaBAAAGIVAAAQFQAAWhYAAEoZAAC1FQAAwRUAAGAVAABcGQAAWhkAAFMZAAAWFQAArREAAEIQAAC3EAAAVxgAAL8VAACJEAAAHBkAABoZAAC5FQAAURgAANwTAABbFQAAWRUAAOYYAABnFQAAERkAAO0YAADnEwAArhAAAMIXAAAAFAAAkhMAAIQTAABAEgAAJhkAAK8VAABiEABB6TkLAQEAQYA6C+ABAQECAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAwEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEAQeo7CwQBAAACAEGBPAteAwQDAwMDAwAAAwMAAwMAAwMDAwMDAwMDAwAFAAAAAAADAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwAAAAMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAAMAAwBB6j0LBAEAAAIAQYE+C14DAAMDAwMDAAADAwADAwADAwMDAwMDAwMDAAQABQAAAAMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAAAAAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMAAwADAEHgPwsNbG9zZWVlcC1hbGl2ZQBB+T8LAQEAQZDAAAvgAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAAEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAEH5wQALAQEAQZDCAAvnAQEBAQEBAQEBAQEBAQIBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAAEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBY2h1bmtlZABBocQAC14BAAEBAQEBAAABAQABAQABAQEBAQEBAQEBAAAAAAAAAAEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAAAAAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEAAQABAEGAxgALIWVjdGlvbmVudC1sZW5ndGhvbnJveHktY29ubmVjdGlvbgBBsMYACytyYW5zZmVyLWVuY29kaW5ncGdyYWRlDQoNClNNDQoNClRUUC9DRS9UU1AvAEHpxgALBQECAAEDAEGAxwALXwQFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFAEHpyAALBQECAAEDAEGAyQALXwQFBQYFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFAEHpygALBAEAAAEAQYHLAAteAgIAAgICAgICAgICAgICAgICAgICAgICAgICAgICAAICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgBB6cwACwUBAgABAwBBgM0AC18EBQAABQUFBQUFBQUFBQUGBQUFBQUFBQUFBQUFAAUABwgFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUABQAFAAUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFAAAABQBB6c4ACwUBAQABAQBBgM8ACwEBAEGazwALQQIAAAAAAAADAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwAAAAAAAAMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAEHp0AALBQEBAAEBAEGA0QALAQEAQYrRAAsGAgAAAAACAEGh0QALOgMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAAAAAAAAAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMAQeDSAAuaAU5PVU5DRUVDS09VVE5FQ1RFVEVDUklCRUxVU0hFVEVBRFNFQVJDSFJHRUNUSVZJVFlMRU5EQVJWRU9USUZZUFRJT05TQ0hTRUFZU1RBVENIR0VVRVJZT1JESVJFQ1RPUlRSQ0hQQVJBTUVURVJVUkNFQlNDUklCRUFSRE9XTkFDRUlORE5LQ0tVQlNDUklCRUhUVFAvQURUUC8=";
    var wasmBuffer;
    Object.defineProperty(module2, "exports", {
      get: () => {
        return wasmBuffer ? wasmBuffer : wasmBuffer = Buffer2.from(wasmBase64, "base64");
      }
    });
  }
});

// node_modules/undici/lib/web/fetch/constants.js
var require_constants5 = __commonJS({
  "node_modules/undici/lib/web/fetch/constants.js"(exports2, module2) {
    "use strict";
    var corsSafeListedMethods = (
      /** @type {const} */
      ["GET", "HEAD", "POST"]
    );
    var corsSafeListedMethodsSet = new Set(corsSafeListedMethods);
    var nullBodyStatus = (
      /** @type {const} */
      [101, 204, 205, 304]
    );
    var redirectStatus = (
      /** @type {const} */
      [301, 302, 303, 307, 308]
    );
    var redirectStatusSet = new Set(redirectStatus);
    var badPorts = (
      /** @type {const} */
      [
        "1",
        "7",
        "9",
        "11",
        "13",
        "15",
        "17",
        "19",
        "20",
        "21",
        "22",
        "23",
        "25",
        "37",
        "42",
        "43",
        "53",
        "69",
        "77",
        "79",
        "87",
        "95",
        "101",
        "102",
        "103",
        "104",
        "109",
        "110",
        "111",
        "113",
        "115",
        "117",
        "119",
        "123",
        "135",
        "137",
        "139",
        "143",
        "161",
        "179",
        "389",
        "427",
        "465",
        "512",
        "513",
        "514",
        "515",
        "526",
        "530",
        "531",
        "532",
        "540",
        "548",
        "554",
        "556",
        "563",
        "587",
        "601",
        "636",
        "989",
        "990",
        "993",
        "995",
        "1719",
        "1720",
        "1723",
        "2049",
        "3659",
        "4045",
        "4190",
        "5060",
        "5061",
        "6000",
        "6566",
        "6665",
        "6666",
        "6667",
        "6668",
        "6669",
        "6679",
        "6697",
        "10080"
      ]
    );
    var badPortsSet = new Set(badPorts);
    var referrerPolicyTokens = (
      /** @type {const} */
      [
        "no-referrer",
        "no-referrer-when-downgrade",
        "same-origin",
        "origin",
        "strict-origin",
        "origin-when-cross-origin",
        "strict-origin-when-cross-origin",
        "unsafe-url"
      ]
    );
    var referrerPolicy = (
      /** @type {const} */
      [
        "",
        ...referrerPolicyTokens
      ]
    );
    var referrerPolicyTokensSet = new Set(referrerPolicyTokens);
    var requestRedirect = (
      /** @type {const} */
      ["follow", "manual", "error"]
    );
    var safeMethods = (
      /** @type {const} */
      ["GET", "HEAD", "OPTIONS", "TRACE"]
    );
    var safeMethodsSet = new Set(safeMethods);
    var requestMode = (
      /** @type {const} */
      ["navigate", "same-origin", "no-cors", "cors"]
    );
    var requestCredentials = (
      /** @type {const} */
      ["omit", "same-origin", "include"]
    );
    var requestCache = (
      /** @type {const} */
      [
        "default",
        "no-store",
        "reload",
        "no-cache",
        "force-cache",
        "only-if-cached"
      ]
    );
    var requestBodyHeader = (
      /** @type {const} */
      [
        "content-encoding",
        "content-language",
        "content-location",
        "content-type",
        // See https://github.com/nodejs/undici/issues/2021
        // 'Content-Length' is a forbidden header name, which is typically
        // removed in the Headers implementation. However, undici doesn't
        // filter out headers, so we add it here.
        "content-length"
      ]
    );
    var requestDuplex = (
      /** @type {const} */
      [
        "half"
      ]
    );
    var forbiddenMethods = (
      /** @type {const} */
      ["CONNECT", "TRACE", "TRACK"]
    );
    var forbiddenMethodsSet = new Set(forbiddenMethods);
    var subresource = (
      /** @type {const} */
      [
        "audio",
        "audioworklet",
        "font",
        "image",
        "manifest",
        "paintworklet",
        "script",
        "style",
        "track",
        "video",
        "xslt",
        ""
      ]
    );
    var subresourceSet = new Set(subresource);
    module2.exports = {
      subresource,
      forbiddenMethods,
      requestBodyHeader,
      referrerPolicy,
      requestRedirect,
      requestMode,
      requestCredentials,
      requestCache,
      redirectStatus,
      corsSafeListedMethods,
      nullBodyStatus,
      safeMethods,
      badPorts,
      requestDuplex,
      subresourceSet,
      badPortsSet,
      redirectStatusSet,
      corsSafeListedMethodsSet,
      safeMethodsSet,
      forbiddenMethodsSet,
      referrerPolicyTokens: referrerPolicyTokensSet
    };
  }
});

// node_modules/undici/lib/web/fetch/global.js
var require_global = __commonJS({
  "node_modules/undici/lib/web/fetch/global.js"(exports2, module2) {
    "use strict";
    var globalOrigin = Symbol.for("undici.globalOrigin.1");
    function getGlobalOrigin() {
      return globalThis[globalOrigin];
    }
    function setGlobalOrigin(newOrigin) {
      if (newOrigin === void 0) {
        Object.defineProperty(globalThis, globalOrigin, {
          value: void 0,
          writable: true,
          enumerable: false,
          configurable: false
        });
        return;
      }
      const parsedURL = new URL(newOrigin);
      if (parsedURL.protocol !== "http:" && parsedURL.protocol !== "https:") {
        throw new TypeError(`Only http & https urls are allowed, received ${parsedURL.protocol}`);
      }
      Object.defineProperty(globalThis, globalOrigin, {
        value: parsedURL,
        writable: true,
        enumerable: false,
        configurable: false
      });
    }
    module2.exports = {
      getGlobalOrigin,
      setGlobalOrigin
    };
  }
});

// node_modules/undici/lib/web/fetch/data-url.js
var require_data_url = __commonJS({
  "node_modules/undici/lib/web/fetch/data-url.js"(exports2, module2) {
    "use strict";
    var assert = require("node:assert");
    var encoder = new TextEncoder();
    var HTTP_TOKEN_CODEPOINTS = /^[!#$%&'*+\-.^_|~A-Za-z0-9]+$/;
    var HTTP_WHITESPACE_REGEX = /[\u000A\u000D\u0009\u0020]/;
    var ASCII_WHITESPACE_REPLACE_REGEX = /[\u0009\u000A\u000C\u000D\u0020]/g;
    var HTTP_QUOTED_STRING_TOKENS = /^[\u0009\u0020-\u007E\u0080-\u00FF]+$/;
    function dataURLProcessor(dataURL) {
      assert(dataURL.protocol === "data:");
      let input = URLSerializer(dataURL, true);
      input = input.slice(5);
      const position = { position: 0 };
      let mimeType = collectASequenceOfCodePointsFast(
        ",",
        input,
        position
      );
      const mimeTypeLength = mimeType.length;
      mimeType = removeASCIIWhitespace(mimeType, true, true);
      if (position.position >= input.length) {
        return "failure";
      }
      position.position++;
      const encodedBody = input.slice(mimeTypeLength + 1);
      let body = stringPercentDecode(encodedBody);
      if (/;(\u0020){0,}base64$/i.test(mimeType)) {
        const stringBody = isomorphicDecode(body);
        body = forgivingBase64(stringBody);
        if (body === "failure") {
          return "failure";
        }
        mimeType = mimeType.slice(0, -6);
        mimeType = mimeType.replace(/(\u0020)+$/, "");
        mimeType = mimeType.slice(0, -1);
      }
      if (mimeType.startsWith(";")) {
        mimeType = "text/plain" + mimeType;
      }
      let mimeTypeRecord = parseMIMEType(mimeType);
      if (mimeTypeRecord === "failure") {
        mimeTypeRecord = parseMIMEType("text/plain;charset=US-ASCII");
      }
      return { mimeType: mimeTypeRecord, body };
    }
    function URLSerializer(url, excludeFragment = false) {
      if (!excludeFragment) {
        return url.href;
      }
      const href = url.href;
      const hashLength = url.hash.length;
      const serialized = hashLength === 0 ? href : href.substring(0, href.length - hashLength);
      if (!hashLength && href.endsWith("#")) {
        return serialized.slice(0, -1);
      }
      return serialized;
    }
    function collectASequenceOfCodePoints(condition, input, position) {
      let result = "";
      while (position.position < input.length && condition(input[position.position])) {
        result += input[position.position];
        position.position++;
      }
      return result;
    }
    function collectASequenceOfCodePointsFast(char, input, position) {
      const idx = input.indexOf(char, position.position);
      const start = position.position;
      if (idx === -1) {
        position.position = input.length;
        return input.slice(start);
      }
      position.position = idx;
      return input.slice(start, position.position);
    }
    function stringPercentDecode(input) {
      const bytes = encoder.encode(input);
      return percentDecode(bytes);
    }
    function isHexCharByte(byte) {
      return byte >= 48 && byte <= 57 || byte >= 65 && byte <= 70 || byte >= 97 && byte <= 102;
    }
    function hexByteToNumber(byte) {
      return (
        // 0-9
        byte >= 48 && byte <= 57 ? byte - 48 : (byte & 223) - 55
      );
    }
    function percentDecode(input) {
      const length = input.length;
      const output = new Uint8Array(length);
      let j = 0;
      for (let i = 0; i < length; ++i) {
        const byte = input[i];
        if (byte !== 37) {
          output[j++] = byte;
        } else if (byte === 37 && !(isHexCharByte(input[i + 1]) && isHexCharByte(input[i + 2]))) {
          output[j++] = 37;
        } else {
          output[j++] = hexByteToNumber(input[i + 1]) << 4 | hexByteToNumber(input[i + 2]);
          i += 2;
        }
      }
      return length === j ? output : output.subarray(0, j);
    }
    function parseMIMEType(input) {
      input = removeHTTPWhitespace(input, true, true);
      const position = { position: 0 };
      const type = collectASequenceOfCodePointsFast(
        "/",
        input,
        position
      );
      if (type.length === 0 || !HTTP_TOKEN_CODEPOINTS.test(type)) {
        return "failure";
      }
      if (position.position >= input.length) {
        return "failure";
      }
      position.position++;
      let subtype = collectASequenceOfCodePointsFast(
        ";",
        input,
        position
      );
      subtype = removeHTTPWhitespace(subtype, false, true);
      if (subtype.length === 0 || !HTTP_TOKEN_CODEPOINTS.test(subtype)) {
        return "failure";
      }
      const typeLowercase = type.toLowerCase();
      const subtypeLowercase = subtype.toLowerCase();
      const mimeType = {
        type: typeLowercase,
        subtype: subtypeLowercase,
        /** @type {Map<string, string>} */
        parameters: /* @__PURE__ */ new Map(),
        // https://mimesniff.spec.whatwg.org/#mime-type-essence
        essence: `${typeLowercase}/${subtypeLowercase}`
      };
      while (position.position < input.length) {
        position.position++;
        collectASequenceOfCodePoints(
          // https://fetch.spec.whatwg.org/#http-whitespace
          (char) => HTTP_WHITESPACE_REGEX.test(char),
          input,
          position
        );
        let parameterName = collectASequenceOfCodePoints(
          (char) => char !== ";" && char !== "=",
          input,
          position
        );
        parameterName = parameterName.toLowerCase();
        if (position.position < input.length) {
          if (input[position.position] === ";") {
            continue;
          }
          position.position++;
        }
        if (position.position >= input.length) {
          break;
        }
        let parameterValue = null;
        if (input[position.position] === '"') {
          parameterValue = collectAnHTTPQuotedString(input, position, true);
          collectASequenceOfCodePointsFast(
            ";",
            input,
            position
          );
        } else {
          parameterValue = collectASequenceOfCodePointsFast(
            ";",
            input,
            position
          );
          parameterValue = removeHTTPWhitespace(parameterValue, false, true);
          if (parameterValue.length === 0) {
            continue;
          }
        }
        if (parameterName.length !== 0 && HTTP_TOKEN_CODEPOINTS.test(parameterName) && (parameterValue.length === 0 || HTTP_QUOTED_STRING_TOKENS.test(parameterValue)) && !mimeType.parameters.has(parameterName)) {
          mimeType.parameters.set(parameterName, parameterValue);
        }
      }
      return mimeType;
    }
    function forgivingBase64(data) {
      data = data.replace(ASCII_WHITESPACE_REPLACE_REGEX, "");
      let dataLength = data.length;
      if (dataLength % 4 === 0) {
        if (data.charCodeAt(dataLength - 1) === 61) {
          --dataLength;
          if (data.charCodeAt(dataLength - 1) === 61) {
            --dataLength;
          }
        }
      }
      if (dataLength % 4 === 1) {
        return "failure";
      }
      if (/[^+/0-9A-Za-z]/.test(data.length === dataLength ? data : data.substring(0, dataLength))) {
        return "failure";
      }
      const buffer = Buffer.from(data, "base64");
      return new Uint8Array(buffer.buffer, buffer.byteOffset, buffer.byteLength);
    }
    function collectAnHTTPQuotedString(input, position, extractValue = false) {
      const positionStart = position.position;
      let value = "";
      assert(input[position.position] === '"');
      position.position++;
      while (true) {
        value += collectASequenceOfCodePoints(
          (char) => char !== '"' && char !== "\\",
          input,
          position
        );
        if (position.position >= input.length) {
          break;
        }
        const quoteOrBackslash = input[position.position];
        position.position++;
        if (quoteOrBackslash === "\\") {
          if (position.position >= input.length) {
            value += "\\";
            break;
          }
          value += input[position.position];
          position.position++;
        } else {
          assert(quoteOrBackslash === '"');
          break;
        }
      }
      if (extractValue) {
        return value;
      }
      return input.slice(positionStart, position.position);
    }
    function serializeAMimeType(mimeType) {
      assert(mimeType !== "failure");
      const { parameters, essence } = mimeType;
      let serialization = essence;
      for (let [name, value] of parameters.entries()) {
        serialization += ";";
        serialization += name;
        serialization += "=";
        if (!HTTP_TOKEN_CODEPOINTS.test(value)) {
          value = value.replace(/(\\|")/g, "\\$1");
          value = '"' + value;
          value += '"';
        }
        serialization += value;
      }
      return serialization;
    }
    function isHTTPWhiteSpace(char) {
      return char === 13 || char === 10 || char === 9 || char === 32;
    }
    function removeHTTPWhitespace(str, leading = true, trailing = true) {
      return removeChars(str, leading, trailing, isHTTPWhiteSpace);
    }
    function isASCIIWhitespace(char) {
      return char === 13 || char === 10 || char === 9 || char === 12 || char === 32;
    }
    function removeASCIIWhitespace(str, leading = true, trailing = true) {
      return removeChars(str, leading, trailing, isASCIIWhitespace);
    }
    function removeChars(str, leading, trailing, predicate) {
      let lead = 0;
      let trail = str.length - 1;
      if (leading) {
        while (lead < str.length && predicate(str.charCodeAt(lead))) lead++;
      }
      if (trailing) {
        while (trail > 0 && predicate(str.charCodeAt(trail))) trail--;
      }
      return lead === 0 && trail === str.length - 1 ? str : str.slice(lead, trail + 1);
    }
    function isomorphicDecode(input) {
      const length = input.length;
      if ((2 << 15) - 1 > length) {
        return String.fromCharCode.apply(null, input);
      }
      let result = "";
      let i = 0;
      let addition = (2 << 15) - 1;
      while (i < length) {
        if (i + addition > length) {
          addition = length - i;
        }
        result += String.fromCharCode.apply(null, input.subarray(i, i += addition));
      }
      return result;
    }
    function minimizeSupportedMimeType(mimeType) {
      switch (mimeType.essence) {
        case "application/ecmascript":
        case "application/javascript":
        case "application/x-ecmascript":
        case "application/x-javascript":
        case "text/ecmascript":
        case "text/javascript":
        case "text/javascript1.0":
        case "text/javascript1.1":
        case "text/javascript1.2":
        case "text/javascript1.3":
        case "text/javascript1.4":
        case "text/javascript1.5":
        case "text/jscript":
        case "text/livescript":
        case "text/x-ecmascript":
        case "text/x-javascript":
          return "text/javascript";
        case "application/json":
        case "text/json":
          return "application/json";
        case "image/svg+xml":
          return "image/svg+xml";
        case "text/xml":
        case "application/xml":
          return "application/xml";
      }
      if (mimeType.subtype.endsWith("+json")) {
        return "application/json";
      }
      if (mimeType.subtype.endsWith("+xml")) {
        return "application/xml";
      }
      return "";
    }
    module2.exports = {
      dataURLProcessor,
      URLSerializer,
      collectASequenceOfCodePoints,
      collectASequenceOfCodePointsFast,
      stringPercentDecode,
      parseMIMEType,
      collectAnHTTPQuotedString,
      serializeAMimeType,
      removeChars,
      removeHTTPWhitespace,
      minimizeSupportedMimeType,
      HTTP_TOKEN_CODEPOINTS,
      isomorphicDecode
    };
  }
});

// node_modules/undici/lib/web/webidl/index.js
var require_webidl = __commonJS({
  "node_modules/undici/lib/web/webidl/index.js"(exports2, module2) {
    "use strict";
    var { types, inspect } = require("node:util");
    var { markAsUncloneable } = require("node:worker_threads");
    var UNDEFINED = 1;
    var BOOLEAN = 2;
    var STRING = 3;
    var SYMBOL = 4;
    var NUMBER = 5;
    var BIGINT = 6;
    var NULL = 7;
    var OBJECT = 8;
    var FunctionPrototypeSymbolHasInstance = Function.call.bind(Function.prototype[Symbol.hasInstance]);
    var webidl = {
      converters: {},
      util: {},
      errors: {},
      is: {}
    };
    webidl.errors.exception = function(message) {
      return new TypeError(`${message.header}: ${message.message}`);
    };
    webidl.errors.conversionFailed = function(opts) {
      const plural = opts.types.length === 1 ? "" : " one of";
      const message = `${opts.argument} could not be converted to${plural}: ${opts.types.join(", ")}.`;
      return webidl.errors.exception({
        header: opts.prefix,
        message
      });
    };
    webidl.errors.invalidArgument = function(context) {
      return webidl.errors.exception({
        header: context.prefix,
        message: `"${context.value}" is an invalid ${context.type}.`
      });
    };
    webidl.brandCheck = function(V, I) {
      if (!FunctionPrototypeSymbolHasInstance(I, V)) {
        const err = new TypeError("Illegal invocation");
        err.code = "ERR_INVALID_THIS";
        throw err;
      }
    };
    webidl.brandCheckMultiple = function(List) {
      const prototypes = List.map((c) => webidl.util.MakeTypeAssertion(c));
      return (V) => {
        if (prototypes.every((typeCheck) => !typeCheck(V))) {
          const err = new TypeError("Illegal invocation");
          err.code = "ERR_INVALID_THIS";
          throw err;
        }
      };
    };
    webidl.argumentLengthCheck = function({ length }, min, ctx) {
      if (length < min) {
        throw webidl.errors.exception({
          message: `${min} argument${min !== 1 ? "s" : ""} required, but${length ? " only" : ""} ${length} found.`,
          header: ctx
        });
      }
    };
    webidl.illegalConstructor = function() {
      throw webidl.errors.exception({
        header: "TypeError",
        message: "Illegal constructor"
      });
    };
    webidl.util.MakeTypeAssertion = function(I) {
      return (O) => FunctionPrototypeSymbolHasInstance(I, O);
    };
    webidl.util.Type = function(V) {
      switch (typeof V) {
        case "undefined":
          return UNDEFINED;
        case "boolean":
          return BOOLEAN;
        case "string":
          return STRING;
        case "symbol":
          return SYMBOL;
        case "number":
          return NUMBER;
        case "bigint":
          return BIGINT;
        case "function":
        case "object": {
          if (V === null) {
            return NULL;
          }
          return OBJECT;
        }
      }
    };
    webidl.util.Types = {
      UNDEFINED,
      BOOLEAN,
      STRING,
      SYMBOL,
      NUMBER,
      BIGINT,
      NULL,
      OBJECT
    };
    webidl.util.TypeValueToString = function(o) {
      switch (webidl.util.Type(o)) {
        case UNDEFINED:
          return "Undefined";
        case BOOLEAN:
          return "Boolean";
        case STRING:
          return "String";
        case SYMBOL:
          return "Symbol";
        case NUMBER:
          return "Number";
        case BIGINT:
          return "BigInt";
        case NULL:
          return "Null";
        case OBJECT:
          return "Object";
      }
    };
    webidl.util.markAsUncloneable = markAsUncloneable || (() => {
    });
    webidl.util.ConvertToInt = function(V, bitLength, signedness, opts) {
      let upperBound;
      let lowerBound;
      if (bitLength === 64) {
        upperBound = Math.pow(2, 53) - 1;
        if (signedness === "unsigned") {
          lowerBound = 0;
        } else {
          lowerBound = Math.pow(-2, 53) + 1;
        }
      } else if (signedness === "unsigned") {
        lowerBound = 0;
        upperBound = Math.pow(2, bitLength) - 1;
      } else {
        lowerBound = Math.pow(-2, bitLength) - 1;
        upperBound = Math.pow(2, bitLength - 1) - 1;
      }
      let x = Number(V);
      if (x === 0) {
        x = 0;
      }
      if (opts?.enforceRange === true) {
        if (Number.isNaN(x) || x === Number.POSITIVE_INFINITY || x === Number.NEGATIVE_INFINITY) {
          throw webidl.errors.exception({
            header: "Integer conversion",
            message: `Could not convert ${webidl.util.Stringify(V)} to an integer.`
          });
        }
        x = webidl.util.IntegerPart(x);
        if (x < lowerBound || x > upperBound) {
          throw webidl.errors.exception({
            header: "Integer conversion",
            message: `Value must be between ${lowerBound}-${upperBound}, got ${x}.`
          });
        }
        return x;
      }
      if (!Number.isNaN(x) && opts?.clamp === true) {
        x = Math.min(Math.max(x, lowerBound), upperBound);
        if (Math.floor(x) % 2 === 0) {
          x = Math.floor(x);
        } else {
          x = Math.ceil(x);
        }
        return x;
      }
      if (Number.isNaN(x) || x === 0 && Object.is(0, x) || x === Number.POSITIVE_INFINITY || x === Number.NEGATIVE_INFINITY) {
        return 0;
      }
      x = webidl.util.IntegerPart(x);
      x = x % Math.pow(2, bitLength);
      if (signedness === "signed" && x >= Math.pow(2, bitLength) - 1) {
        return x - Math.pow(2, bitLength);
      }
      return x;
    };
    webidl.util.IntegerPart = function(n) {
      const r = Math.floor(Math.abs(n));
      if (n < 0) {
        return -1 * r;
      }
      return r;
    };
    webidl.util.Stringify = function(V) {
      const type = webidl.util.Type(V);
      switch (type) {
        case SYMBOL:
          return `Symbol(${V.description})`;
        case OBJECT:
          return inspect(V);
        case STRING:
          return `"${V}"`;
        case BIGINT:
          return `${V}n`;
        default:
          return `${V}`;
      }
    };
    webidl.sequenceConverter = function(converter) {
      return (V, prefix, argument, Iterable) => {
        if (webidl.util.Type(V) !== OBJECT) {
          throw webidl.errors.exception({
            header: prefix,
            message: `${argument} (${webidl.util.Stringify(V)}) is not iterable.`
          });
        }
        const method = typeof Iterable === "function" ? Iterable() : V?.[Symbol.iterator]?.();
        const seq = [];
        let index = 0;
        if (method === void 0 || typeof method.next !== "function") {
          throw webidl.errors.exception({
            header: prefix,
            message: `${argument} is not iterable.`
          });
        }
        while (true) {
          const { done, value } = method.next();
          if (done) {
            break;
          }
          seq.push(converter(value, prefix, `${argument}[${index++}]`));
        }
        return seq;
      };
    };
    webidl.recordConverter = function(keyConverter, valueConverter) {
      return (O, prefix, argument) => {
        if (webidl.util.Type(O) !== OBJECT) {
          throw webidl.errors.exception({
            header: prefix,
            message: `${argument} ("${webidl.util.TypeValueToString(O)}") is not an Object.`
          });
        }
        const result = {};
        if (!types.isProxy(O)) {
          const keys2 = [...Object.getOwnPropertyNames(O), ...Object.getOwnPropertySymbols(O)];
          for (const key of keys2) {
            const keyName = webidl.util.Stringify(key);
            const typedKey = keyConverter(key, prefix, `Key ${keyName} in ${argument}`);
            const typedValue = valueConverter(O[key], prefix, `${argument}[${keyName}]`);
            result[typedKey] = typedValue;
          }
          return result;
        }
        const keys = Reflect.ownKeys(O);
        for (const key of keys) {
          const desc = Reflect.getOwnPropertyDescriptor(O, key);
          if (desc?.enumerable) {
            const typedKey = keyConverter(key, prefix, argument);
            const typedValue = valueConverter(O[key], prefix, argument);
            result[typedKey] = typedValue;
          }
        }
        return result;
      };
    };
    webidl.interfaceConverter = function(TypeCheck, name) {
      return (V, prefix, argument) => {
        if (!TypeCheck(V)) {
          throw webidl.errors.exception({
            header: prefix,
            message: `Expected ${argument} ("${webidl.util.Stringify(V)}") to be an instance of ${name}.`
          });
        }
        return V;
      };
    };
    webidl.dictionaryConverter = function(converters) {
      return (dictionary, prefix, argument) => {
        const dict = {};
        if (dictionary != null && webidl.util.Type(dictionary) !== OBJECT) {
          throw webidl.errors.exception({
            header: prefix,
            message: `Expected ${dictionary} to be one of: Null, Undefined, Object.`
          });
        }
        for (const options of converters) {
          const { key, defaultValue, required, converter } = options;
          if (required === true) {
            if (dictionary == null || !Object.hasOwn(dictionary, key)) {
              throw webidl.errors.exception({
                header: prefix,
                message: `Missing required key "${key}".`
              });
            }
          }
          let value = dictionary?.[key];
          const hasDefault = defaultValue !== void 0;
          if (hasDefault && value === void 0) {
            value = defaultValue();
          }
          if (required || hasDefault || value !== void 0) {
            value = converter(value, prefix, `${argument}.${key}`);
            if (options.allowedValues && !options.allowedValues.includes(value)) {
              throw webidl.errors.exception({
                header: prefix,
                message: `${value} is not an accepted type. Expected one of ${options.allowedValues.join(", ")}.`
              });
            }
            dict[key] = value;
          }
        }
        return dict;
      };
    };
    webidl.nullableConverter = function(converter) {
      return (V, prefix, argument) => {
        if (V === null) {
          return V;
        }
        return converter(V, prefix, argument);
      };
    };
    webidl.is.USVString = function(value) {
      return typeof value === "string" && value.isWellFormed();
    };
    webidl.is.ReadableStream = webidl.util.MakeTypeAssertion(ReadableStream);
    webidl.is.Blob = webidl.util.MakeTypeAssertion(Blob);
    webidl.is.URLSearchParams = webidl.util.MakeTypeAssertion(URLSearchParams);
    webidl.is.File = webidl.util.MakeTypeAssertion(File);
    webidl.is.URL = webidl.util.MakeTypeAssertion(URL);
    webidl.is.AbortSignal = webidl.util.MakeTypeAssertion(AbortSignal);
    webidl.is.MessagePort = webidl.util.MakeTypeAssertion(MessagePort);
    webidl.converters.DOMString = function(V, prefix, argument, opts) {
      if (V === null && opts?.legacyNullToEmptyString) {
        return "";
      }
      if (typeof V === "symbol") {
        throw webidl.errors.exception({
          header: prefix,
          message: `${argument} is a symbol, which cannot be converted to a DOMString.`
        });
      }
      return String(V);
    };
    webidl.converters.ByteString = function(V, prefix, argument) {
      if (typeof V === "symbol") {
        throw webidl.errors.exception({
          header: prefix,
          message: `${argument} is a symbol, which cannot be converted to a ByteString.`
        });
      }
      const x = String(V);
      for (let index = 0; index < x.length; index++) {
        if (x.charCodeAt(index) > 255) {
          throw new TypeError(
            `Cannot convert argument to a ByteString because the character at index ${index} has a value of ${x.charCodeAt(index)} which is greater than 255.`
          );
        }
      }
      return x;
    };
    webidl.converters.USVString = function(value) {
      if (typeof value === "string") {
        return value.toWellFormed();
      }
      return `${value}`.toWellFormed();
    };
    webidl.converters.boolean = function(V) {
      const x = Boolean(V);
      return x;
    };
    webidl.converters.any = function(V) {
      return V;
    };
    webidl.converters["long long"] = function(V, prefix, argument) {
      const x = webidl.util.ConvertToInt(V, 64, "signed", void 0, prefix, argument);
      return x;
    };
    webidl.converters["unsigned long long"] = function(V, prefix, argument) {
      const x = webidl.util.ConvertToInt(V, 64, "unsigned", void 0, prefix, argument);
      return x;
    };
    webidl.converters["unsigned long"] = function(V, prefix, argument) {
      const x = webidl.util.ConvertToInt(V, 32, "unsigned", void 0, prefix, argument);
      return x;
    };
    webidl.converters["unsigned short"] = function(V, prefix, argument, opts) {
      const x = webidl.util.ConvertToInt(V, 16, "unsigned", opts, prefix, argument);
      return x;
    };
    webidl.converters.ArrayBuffer = function(V, prefix, argument, opts) {
      if (webidl.util.Type(V) !== OBJECT || !types.isAnyArrayBuffer(V)) {
        throw webidl.errors.conversionFailed({
          prefix,
          argument: `${argument} ("${webidl.util.Stringify(V)}")`,
          types: ["ArrayBuffer"]
        });
      }
      if (opts?.allowShared === false && types.isSharedArrayBuffer(V)) {
        throw webidl.errors.exception({
          header: "ArrayBuffer",
          message: "SharedArrayBuffer is not allowed."
        });
      }
      if (V.resizable || V.growable) {
        throw webidl.errors.exception({
          header: "ArrayBuffer",
          message: "Received a resizable ArrayBuffer."
        });
      }
      return V;
    };
    webidl.converters.TypedArray = function(V, T, prefix, name, opts) {
      if (webidl.util.Type(V) !== OBJECT || !types.isTypedArray(V) || V.constructor.name !== T.name) {
        throw webidl.errors.conversionFailed({
          prefix,
          argument: `${name} ("${webidl.util.Stringify(V)}")`,
          types: [T.name]
        });
      }
      if (opts?.allowShared === false && types.isSharedArrayBuffer(V.buffer)) {
        throw webidl.errors.exception({
          header: "ArrayBuffer",
          message: "SharedArrayBuffer is not allowed."
        });
      }
      if (V.buffer.resizable || V.buffer.growable) {
        throw webidl.errors.exception({
          header: "ArrayBuffer",
          message: "Received a resizable ArrayBuffer."
        });
      }
      return V;
    };
    webidl.converters.DataView = function(V, prefix, name, opts) {
      if (webidl.util.Type(V) !== OBJECT || !types.isDataView(V)) {
        throw webidl.errors.exception({
          header: prefix,
          message: `${name} is not a DataView.`
        });
      }
      if (opts?.allowShared === false && types.isSharedArrayBuffer(V.buffer)) {
        throw webidl.errors.exception({
          header: "ArrayBuffer",
          message: "SharedArrayBuffer is not allowed."
        });
      }
      if (V.buffer.resizable || V.buffer.growable) {
        throw webidl.errors.exception({
          header: "ArrayBuffer",
          message: "Received a resizable ArrayBuffer."
        });
      }
      return V;
    };
    webidl.converters["sequence<ByteString>"] = webidl.sequenceConverter(
      webidl.converters.ByteString
    );
    webidl.converters["sequence<sequence<ByteString>>"] = webidl.sequenceConverter(
      webidl.converters["sequence<ByteString>"]
    );
    webidl.converters["record<ByteString, ByteString>"] = webidl.recordConverter(
      webidl.converters.ByteString,
      webidl.converters.ByteString
    );
    webidl.converters.Blob = webidl.interfaceConverter(webidl.is.Blob, "Blob");
    webidl.converters.AbortSignal = webidl.interfaceConverter(
      webidl.is.AbortSignal,
      "AbortSignal"
    );
    module2.exports = {
      webidl
    };
  }
});

// node_modules/undici/lib/web/fetch/util.js
var require_util5 = __commonJS({
  "node_modules/undici/lib/web/fetch/util.js"(exports2, module2) {
    "use strict";
    var { Transform } = require("node:stream");
    var zlib = require("node:zlib");
    var { redirectStatusSet, referrerPolicyTokens, badPortsSet } = require_constants5();
    var { getGlobalOrigin } = require_global();
    var { collectASequenceOfCodePoints, collectAnHTTPQuotedString, removeChars, parseMIMEType } = require_data_url();
    var { performance: performance2 } = require("node:perf_hooks");
    var { ReadableStreamFrom, isValidHTTPToken, normalizedMethodRecordsBase } = require_util4();
    var assert = require("node:assert");
    var { isUint8Array } = require("node:util/types");
    var { webidl } = require_webidl();
    var supportedHashes = [];
    var crypto2;
    try {
      crypto2 = require("node:crypto");
      const possibleRelevantHashes = ["sha256", "sha384", "sha512"];
      supportedHashes = crypto2.getHashes().filter((hash) => possibleRelevantHashes.includes(hash));
    } catch {
    }
    function responseURL(response) {
      const urlList = response.urlList;
      const length = urlList.length;
      return length === 0 ? null : urlList[length - 1].toString();
    }
    function responseLocationURL(response, requestFragment) {
      if (!redirectStatusSet.has(response.status)) {
        return null;
      }
      let location = response.headersList.get("location", true);
      if (location !== null && isValidHeaderValue(location)) {
        if (!isValidEncodedURL(location)) {
          location = normalizeBinaryStringToUtf8(location);
        }
        location = new URL(location, responseURL(response));
      }
      if (location && !location.hash) {
        location.hash = requestFragment;
      }
      return location;
    }
    function isValidEncodedURL(url) {
      for (let i = 0; i < url.length; ++i) {
        const code = url.charCodeAt(i);
        if (code > 126 || // Non-US-ASCII + DEL
        code < 32) {
          return false;
        }
      }
      return true;
    }
    function normalizeBinaryStringToUtf8(value) {
      return Buffer.from(value, "binary").toString("utf8");
    }
    function requestCurrentURL(request) {
      return request.urlList[request.urlList.length - 1];
    }
    function requestBadPort(request) {
      const url = requestCurrentURL(request);
      if (urlIsHttpHttpsScheme(url) && badPortsSet.has(url.port)) {
        return "blocked";
      }
      return "allowed";
    }
    function isErrorLike(object) {
      return object instanceof Error || (object?.constructor?.name === "Error" || object?.constructor?.name === "DOMException");
    }
    function isValidReasonPhrase(statusText) {
      for (let i = 0; i < statusText.length; ++i) {
        const c = statusText.charCodeAt(i);
        if (!(c === 9 || // HTAB
        c >= 32 && c <= 126 || // SP / VCHAR
        c >= 128 && c <= 255)) {
          return false;
        }
      }
      return true;
    }
    var isValidHeaderName = isValidHTTPToken;
    function isValidHeaderValue(potentialValue) {
      return (potentialValue[0] === "	" || potentialValue[0] === " " || potentialValue[potentialValue.length - 1] === "	" || potentialValue[potentialValue.length - 1] === " " || potentialValue.includes("\n") || potentialValue.includes("\r") || potentialValue.includes("\0")) === false;
    }
    function parseReferrerPolicy(actualResponse) {
      const policyHeader = (actualResponse.headersList.get("referrer-policy", true) ?? "").split(",");
      let policy = "";
      if (policyHeader.length) {
        for (let i = policyHeader.length; i !== 0; i--) {
          const token = policyHeader[i - 1].trim();
          if (referrerPolicyTokens.has(token)) {
            policy = token;
            break;
          }
        }
      }
      return policy;
    }
    function setRequestReferrerPolicyOnRedirect(request, actualResponse) {
      const policy = parseReferrerPolicy(actualResponse);
      if (policy !== "") {
        request.referrerPolicy = policy;
      }
    }
    function crossOriginResourcePolicyCheck() {
      return "allowed";
    }
    function corsCheck() {
      return "success";
    }
    function TAOCheck() {
      return "success";
    }
    function appendFetchMetadata(httpRequest) {
      let header = null;
      header = httpRequest.mode;
      httpRequest.headersList.set("sec-fetch-mode", header, true);
    }
    function appendRequestOriginHeader(request) {
      let serializedOrigin = request.origin;
      if (serializedOrigin === "client" || serializedOrigin === void 0) {
        return;
      }
      if (request.responseTainting === "cors" || request.mode === "websocket") {
        request.headersList.append("origin", serializedOrigin, true);
      } else if (request.method !== "GET" && request.method !== "HEAD") {
        switch (request.referrerPolicy) {
          case "no-referrer":
            serializedOrigin = null;
            break;
          case "no-referrer-when-downgrade":
          case "strict-origin":
          case "strict-origin-when-cross-origin":
            if (request.origin && urlHasHttpsScheme(request.origin) && !urlHasHttpsScheme(requestCurrentURL(request))) {
              serializedOrigin = null;
            }
            break;
          case "same-origin":
            if (!sameOrigin(request, requestCurrentURL(request))) {
              serializedOrigin = null;
            }
            break;
          default:
        }
        request.headersList.append("origin", serializedOrigin, true);
      }
    }
    function coarsenTime(timestamp, crossOriginIsolatedCapability) {
      return timestamp;
    }
    function clampAndCoarsenConnectionTimingInfo(connectionTimingInfo, defaultStartTime, crossOriginIsolatedCapability) {
      if (!connectionTimingInfo?.startTime || connectionTimingInfo.startTime < defaultStartTime) {
        return {
          domainLookupStartTime: defaultStartTime,
          domainLookupEndTime: defaultStartTime,
          connectionStartTime: defaultStartTime,
          connectionEndTime: defaultStartTime,
          secureConnectionStartTime: defaultStartTime,
          ALPNNegotiatedProtocol: connectionTimingInfo?.ALPNNegotiatedProtocol
        };
      }
      return {
        domainLookupStartTime: coarsenTime(connectionTimingInfo.domainLookupStartTime, crossOriginIsolatedCapability),
        domainLookupEndTime: coarsenTime(connectionTimingInfo.domainLookupEndTime, crossOriginIsolatedCapability),
        connectionStartTime: coarsenTime(connectionTimingInfo.connectionStartTime, crossOriginIsolatedCapability),
        connectionEndTime: coarsenTime(connectionTimingInfo.connectionEndTime, crossOriginIsolatedCapability),
        secureConnectionStartTime: coarsenTime(connectionTimingInfo.secureConnectionStartTime, crossOriginIsolatedCapability),
        ALPNNegotiatedProtocol: connectionTimingInfo.ALPNNegotiatedProtocol
      };
    }
    function coarsenedSharedCurrentTime(crossOriginIsolatedCapability) {
      return coarsenTime(performance2.now(), crossOriginIsolatedCapability);
    }
    function createOpaqueTimingInfo(timingInfo) {
      return {
        startTime: timingInfo.startTime ?? 0,
        redirectStartTime: 0,
        redirectEndTime: 0,
        postRedirectStartTime: timingInfo.startTime ?? 0,
        finalServiceWorkerStartTime: 0,
        finalNetworkResponseStartTime: 0,
        finalNetworkRequestStartTime: 0,
        endTime: 0,
        encodedBodySize: 0,
        decodedBodySize: 0,
        finalConnectionTimingInfo: null
      };
    }
    function makePolicyContainer() {
      return {
        referrerPolicy: "strict-origin-when-cross-origin"
      };
    }
    function clonePolicyContainer(policyContainer) {
      return {
        referrerPolicy: policyContainer.referrerPolicy
      };
    }
    function determineRequestsReferrer(request) {
      const policy = request.referrerPolicy;
      assert(policy);
      let referrerSource = null;
      if (request.referrer === "client") {
        const globalOrigin = getGlobalOrigin();
        if (!globalOrigin || globalOrigin.origin === "null") {
          return "no-referrer";
        }
        referrerSource = new URL(globalOrigin);
      } else if (webidl.is.URL(request.referrer)) {
        referrerSource = request.referrer;
      }
      let referrerURL = stripURLForReferrer(referrerSource);
      const referrerOrigin = stripURLForReferrer(referrerSource, true);
      if (referrerURL.toString().length > 4096) {
        referrerURL = referrerOrigin;
      }
      switch (policy) {
        case "no-referrer":
          return "no-referrer";
        case "origin":
          if (referrerOrigin != null) {
            return referrerOrigin;
          }
          return stripURLForReferrer(referrerSource, true);
        case "unsafe-url":
          return referrerURL;
        case "strict-origin": {
          const currentURL = requestCurrentURL(request);
          if (isURLPotentiallyTrustworthy(referrerURL) && !isURLPotentiallyTrustworthy(currentURL)) {
            return "no-referrer";
          }
          return referrerOrigin;
        }
        case "strict-origin-when-cross-origin": {
          const currentURL = requestCurrentURL(request);
          if (sameOrigin(referrerURL, currentURL)) {
            return referrerURL;
          }
          if (isURLPotentiallyTrustworthy(referrerURL) && !isURLPotentiallyTrustworthy(currentURL)) {
            return "no-referrer";
          }
          return referrerOrigin;
        }
        case "same-origin":
          if (sameOrigin(request, referrerURL)) {
            return referrerURL;
          }
          return "no-referrer";
        case "origin-when-cross-origin":
          if (sameOrigin(request, referrerURL)) {
            return referrerURL;
          }
          return referrerOrigin;
        case "no-referrer-when-downgrade": {
          const currentURL = requestCurrentURL(request);
          if (isURLPotentiallyTrustworthy(referrerURL) && !isURLPotentiallyTrustworthy(currentURL)) {
            return "no-referrer";
          }
          return referrerOrigin;
        }
      }
    }
    function stripURLForReferrer(url, originOnly = false) {
      assert(webidl.is.URL(url));
      url = new URL(url);
      if (urlIsLocal(url)) {
        return "no-referrer";
      }
      url.username = "";
      url.password = "";
      url.hash = "";
      if (originOnly === true) {
        url.pathname = "";
        url.search = "";
      }
      return url;
    }
    var potentialleTrustworthyIPv4RegExp = new RegExp("^(?:(?:127\\.)(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\\.){2}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[1-9]))$");
    var potentialleTrustworthyIPv6RegExp = new RegExp("^(?:(?:(?:0{1,4}):){7}(?:(?:0{0,3}1))|(?:(?:0{1,4}):){1,6}(?::(?:0{0,3}1))|(?:::(?:0{0,3}1))|)$");
    function isOriginIPPotentiallyTrustworthy(origin) {
      if (origin.includes(":")) {
        if (origin[0] === "[" && origin[origin.length - 1] === "]") {
          origin = origin.slice(1, -1);
        }
        return potentialleTrustworthyIPv6RegExp.test(origin);
      }
      return potentialleTrustworthyIPv4RegExp.test(origin);
    }
    function isOriginPotentiallyTrustworthy(origin) {
      if (origin == null || origin === "null") {
        return false;
      }
      origin = new URL(origin);
      if (origin.protocol === "https:" || origin.protocol === "wss:") {
        return true;
      }
      if (isOriginIPPotentiallyTrustworthy(origin.hostname)) {
        return true;
      }
      if (origin.hostname === "localhost" || origin.hostname === "localhost.") {
        return true;
      }
      if (origin.hostname.endsWith(".localhost") || origin.hostname.endsWith(".localhost.")) {
        return true;
      }
      if (origin.protocol === "file:") {
        return true;
      }
      return false;
    }
    function isURLPotentiallyTrustworthy(url) {
      if (!webidl.is.URL(url)) {
        return false;
      }
      if (url.href === "about:blank" || url.href === "about:srcdoc") {
        return true;
      }
      if (url.protocol === "data:") return true;
      if (url.protocol === "blob:") return true;
      return isOriginPotentiallyTrustworthy(url.origin);
    }
    function bytesMatch(bytes, metadataList) {
      if (crypto2 === void 0) {
        return true;
      }
      const parsedMetadata = parseMetadata(metadataList);
      if (parsedMetadata === "no metadata") {
        return true;
      }
      if (parsedMetadata.length === 0) {
        return true;
      }
      const strongest = getStrongestMetadata(parsedMetadata);
      const metadata = filterMetadataListByAlgorithm(parsedMetadata, strongest);
      for (const item of metadata) {
        const algorithm = item.algo;
        const expectedValue = item.hash;
        let actualValue = crypto2.createHash(algorithm).update(bytes).digest("base64");
        if (actualValue[actualValue.length - 1] === "=") {
          if (actualValue[actualValue.length - 2] === "=") {
            actualValue = actualValue.slice(0, -2);
          } else {
            actualValue = actualValue.slice(0, -1);
          }
        }
        if (compareBase64Mixed(actualValue, expectedValue)) {
          return true;
        }
      }
      return false;
    }
    var parseHashWithOptions = /(?<algo>sha256|sha384|sha512)-((?<hash>[A-Za-z0-9+/]+|[A-Za-z0-9_-]+)={0,2}(?:\s|$)( +[!-~]*)?)?/i;
    function parseMetadata(metadata) {
      const result = [];
      let empty = true;
      for (const token of metadata.split(" ")) {
        empty = false;
        const parsedToken = parseHashWithOptions.exec(token);
        if (parsedToken === null || parsedToken.groups === void 0 || parsedToken.groups.algo === void 0) {
          continue;
        }
        const algorithm = parsedToken.groups.algo.toLowerCase();
        if (supportedHashes.includes(algorithm)) {
          result.push(parsedToken.groups);
        }
      }
      if (empty === true) {
        return "no metadata";
      }
      return result;
    }
    function getStrongestMetadata(metadataList) {
      let algorithm = metadataList[0].algo;
      if (algorithm[3] === "5") {
        return algorithm;
      }
      for (let i = 1; i < metadataList.length; ++i) {
        const metadata = metadataList[i];
        if (metadata.algo[3] === "5") {
          algorithm = "sha512";
          break;
        } else if (algorithm[3] === "3") {
          continue;
        } else if (metadata.algo[3] === "3") {
          algorithm = "sha384";
        }
      }
      return algorithm;
    }
    function filterMetadataListByAlgorithm(metadataList, algorithm) {
      if (metadataList.length === 1) {
        return metadataList;
      }
      let pos = 0;
      for (let i = 0; i < metadataList.length; ++i) {
        if (metadataList[i].algo === algorithm) {
          metadataList[pos++] = metadataList[i];
        }
      }
      metadataList.length = pos;
      return metadataList;
    }
    function compareBase64Mixed(actualValue, expectedValue) {
      if (actualValue.length !== expectedValue.length) {
        return false;
      }
      for (let i = 0; i < actualValue.length; ++i) {
        if (actualValue[i] !== expectedValue[i]) {
          if (actualValue[i] === "+" && expectedValue[i] === "-" || actualValue[i] === "/" && expectedValue[i] === "_") {
            continue;
          }
          return false;
        }
      }
      return true;
    }
    function tryUpgradeRequestToAPotentiallyTrustworthyURL(request) {
    }
    function sameOrigin(A, B) {
      if (A.origin === B.origin && A.origin === "null") {
        return true;
      }
      if (A.protocol === B.protocol && A.hostname === B.hostname && A.port === B.port) {
        return true;
      }
      return false;
    }
    function isAborted(fetchParams) {
      return fetchParams.controller.state === "aborted";
    }
    function isCancelled(fetchParams) {
      return fetchParams.controller.state === "aborted" || fetchParams.controller.state === "terminated";
    }
    function normalizeMethod(method) {
      return normalizedMethodRecordsBase[method.toLowerCase()] ?? method;
    }
    function serializeJavascriptValueToJSONString(value) {
      const result = JSON.stringify(value);
      if (result === void 0) {
        throw new TypeError("Value is not JSON serializable");
      }
      assert(typeof result === "string");
      return result;
    }
    var esIteratorPrototype = Object.getPrototypeOf(Object.getPrototypeOf([][Symbol.iterator]()));
    function createIterator(name, kInternalIterator, keyIndex = 0, valueIndex = 1) {
      class FastIterableIterator {
        /** @type {any} */
        #target;
        /** @type {'key' | 'value' | 'key+value'} */
        #kind;
        /** @type {number} */
        #index;
        /**
         * @see https://webidl.spec.whatwg.org/#dfn-default-iterator-object
         * @param {unknown} target
         * @param {'key' | 'value' | 'key+value'} kind
         */
        constructor(target, kind) {
          this.#target = target;
          this.#kind = kind;
          this.#index = 0;
        }
        next() {
          if (typeof this !== "object" || this === null || !(#target in this)) {
            throw new TypeError(
              `'next' called on an object that does not implement interface ${name} Iterator.`
            );
          }
          const index = this.#index;
          const values = kInternalIterator(this.#target);
          const len = values.length;
          if (index >= len) {
            return {
              value: void 0,
              done: true
            };
          }
          const { [keyIndex]: key, [valueIndex]: value } = values[index];
          this.#index = index + 1;
          let result;
          switch (this.#kind) {
            case "key":
              result = key;
              break;
            case "value":
              result = value;
              break;
            case "key+value":
              result = [key, value];
              break;
          }
          return {
            value: result,
            done: false
          };
        }
      }
      delete FastIterableIterator.prototype.constructor;
      Object.setPrototypeOf(FastIterableIterator.prototype, esIteratorPrototype);
      Object.defineProperties(FastIterableIterator.prototype, {
        [Symbol.toStringTag]: {
          writable: false,
          enumerable: false,
          configurable: true,
          value: `${name} Iterator`
        },
        next: { writable: true, enumerable: true, configurable: true }
      });
      return function(target, kind) {
        return new FastIterableIterator(target, kind);
      };
    }
    function iteratorMixin(name, object, kInternalIterator, keyIndex = 0, valueIndex = 1) {
      const makeIterator = createIterator(name, kInternalIterator, keyIndex, valueIndex);
      const properties = {
        keys: {
          writable: true,
          enumerable: true,
          configurable: true,
          value: function keys() {
            webidl.brandCheck(this, object);
            return makeIterator(this, "key");
          }
        },
        values: {
          writable: true,
          enumerable: true,
          configurable: true,
          value: function values() {
            webidl.brandCheck(this, object);
            return makeIterator(this, "value");
          }
        },
        entries: {
          writable: true,
          enumerable: true,
          configurable: true,
          value: function entries() {
            webidl.brandCheck(this, object);
            return makeIterator(this, "key+value");
          }
        },
        forEach: {
          writable: true,
          enumerable: true,
          configurable: true,
          value: function forEach(callbackfn, thisArg = globalThis) {
            webidl.brandCheck(this, object);
            webidl.argumentLengthCheck(arguments, 1, `${name}.forEach`);
            if (typeof callbackfn !== "function") {
              throw new TypeError(
                `Failed to execute 'forEach' on '${name}': parameter 1 is not of type 'Function'.`
              );
            }
            for (const { 0: key, 1: value } of makeIterator(this, "key+value")) {
              callbackfn.call(thisArg, value, key, this);
            }
          }
        }
      };
      return Object.defineProperties(object.prototype, {
        ...properties,
        [Symbol.iterator]: {
          writable: true,
          enumerable: false,
          configurable: true,
          value: properties.entries.value
        }
      });
    }
    function fullyReadBody(body, processBody, processBodyError) {
      const successSteps = processBody;
      const errorSteps = processBodyError;
      try {
        const reader = body.stream.getReader();
        readAllBytes(reader, successSteps, errorSteps);
      } catch (e) {
        errorSteps(e);
      }
    }
    function readableStreamClose(controller) {
      try {
        controller.close();
        controller.byobRequest?.respond(0);
      } catch (err) {
        if (!err.message.includes("Controller is already closed") && !err.message.includes("ReadableStream is already closed")) {
          throw err;
        }
      }
    }
    var invalidIsomorphicEncodeValueRegex = /[^\x00-\xFF]/;
    function isomorphicEncode(input) {
      assert(!invalidIsomorphicEncodeValueRegex.test(input));
      return input;
    }
    async function readAllBytes(reader, successSteps, failureSteps) {
      try {
        const bytes = [];
        let byteLength = 0;
        do {
          const { done, value: chunk } = await reader.read();
          if (done) {
            successSteps(Buffer.concat(bytes, byteLength));
            return;
          }
          if (!isUint8Array(chunk)) {
            failureSteps(new TypeError("Received non-Uint8Array chunk"));
            return;
          }
          bytes.push(chunk);
          byteLength += chunk.length;
        } while (true);
      } catch (e) {
        failureSteps(e);
      }
    }
    function urlIsLocal(url) {
      assert("protocol" in url);
      const protocol = url.protocol;
      return protocol === "about:" || protocol === "blob:" || protocol === "data:";
    }
    function urlHasHttpsScheme(url) {
      return typeof url === "string" && url[5] === ":" && url[0] === "h" && url[1] === "t" && url[2] === "t" && url[3] === "p" && url[4] === "s" || url.protocol === "https:";
    }
    function urlIsHttpHttpsScheme(url) {
      assert("protocol" in url);
      const protocol = url.protocol;
      return protocol === "http:" || protocol === "https:";
    }
    function simpleRangeHeaderValue(value, allowWhitespace) {
      const data = value;
      if (!data.startsWith("bytes")) {
        return "failure";
      }
      const position = { position: 5 };
      if (allowWhitespace) {
        collectASequenceOfCodePoints(
          (char) => char === "	" || char === " ",
          data,
          position
        );
      }
      if (data.charCodeAt(position.position) !== 61) {
        return "failure";
      }
      position.position++;
      if (allowWhitespace) {
        collectASequenceOfCodePoints(
          (char) => char === "	" || char === " ",
          data,
          position
        );
      }
      const rangeStart = collectASequenceOfCodePoints(
        (char) => {
          const code = char.charCodeAt(0);
          return code >= 48 && code <= 57;
        },
        data,
        position
      );
      const rangeStartValue = rangeStart.length ? Number(rangeStart) : null;
      if (allowWhitespace) {
        collectASequenceOfCodePoints(
          (char) => char === "	" || char === " ",
          data,
          position
        );
      }
      if (data.charCodeAt(position.position) !== 45) {
        return "failure";
      }
      position.position++;
      if (allowWhitespace) {
        collectASequenceOfCodePoints(
          (char) => char === "	" || char === " ",
          data,
          position
        );
      }
      const rangeEnd = collectASequenceOfCodePoints(
        (char) => {
          const code = char.charCodeAt(0);
          return code >= 48 && code <= 57;
        },
        data,
        position
      );
      const rangeEndValue = rangeEnd.length ? Number(rangeEnd) : null;
      if (position.position < data.length) {
        return "failure";
      }
      if (rangeEndValue === null && rangeStartValue === null) {
        return "failure";
      }
      if (rangeStartValue > rangeEndValue) {
        return "failure";
      }
      return { rangeStartValue, rangeEndValue };
    }
    function buildContentRange(rangeStart, rangeEnd, fullLength) {
      let contentRange = "bytes ";
      contentRange += isomorphicEncode(`${rangeStart}`);
      contentRange += "-";
      contentRange += isomorphicEncode(`${rangeEnd}`);
      contentRange += "/";
      contentRange += isomorphicEncode(`${fullLength}`);
      return contentRange;
    }
    var InflateStream = class extends Transform {
      #zlibOptions;
      /** @param {zlib.ZlibOptions} [zlibOptions] */
      constructor(zlibOptions) {
        super();
        this.#zlibOptions = zlibOptions;
      }
      _transform(chunk, encoding, callback) {
        if (!this._inflateStream) {
          if (chunk.length === 0) {
            callback();
            return;
          }
          this._inflateStream = (chunk[0] & 15) === 8 ? zlib.createInflate(this.#zlibOptions) : zlib.createInflateRaw(this.#zlibOptions);
          this._inflateStream.on("data", this.push.bind(this));
          this._inflateStream.on("end", () => this.push(null));
          this._inflateStream.on("error", (err) => this.destroy(err));
        }
        this._inflateStream.write(chunk, encoding, callback);
      }
      _final(callback) {
        if (this._inflateStream) {
          this._inflateStream.end();
          this._inflateStream = null;
        }
        callback();
      }
    };
    function createInflate(zlibOptions) {
      return new InflateStream(zlibOptions);
    }
    function extractMimeType(headers) {
      let charset = null;
      let essence = null;
      let mimeType = null;
      const values = getDecodeSplit("content-type", headers);
      if (values === null) {
        return "failure";
      }
      for (const value of values) {
        const temporaryMimeType = parseMIMEType(value);
        if (temporaryMimeType === "failure" || temporaryMimeType.essence === "*/*") {
          continue;
        }
        mimeType = temporaryMimeType;
        if (mimeType.essence !== essence) {
          charset = null;
          if (mimeType.parameters.has("charset")) {
            charset = mimeType.parameters.get("charset");
          }
          essence = mimeType.essence;
        } else if (!mimeType.parameters.has("charset") && charset !== null) {
          mimeType.parameters.set("charset", charset);
        }
      }
      if (mimeType == null) {
        return "failure";
      }
      return mimeType;
    }
    function gettingDecodingSplitting(value) {
      const input = value;
      const position = { position: 0 };
      const values = [];
      let temporaryValue = "";
      while (position.position < input.length) {
        temporaryValue += collectASequenceOfCodePoints(
          (char) => char !== '"' && char !== ",",
          input,
          position
        );
        if (position.position < input.length) {
          if (input.charCodeAt(position.position) === 34) {
            temporaryValue += collectAnHTTPQuotedString(
              input,
              position
            );
            if (position.position < input.length) {
              continue;
            }
          } else {
            assert(input.charCodeAt(position.position) === 44);
            position.position++;
          }
        }
        temporaryValue = removeChars(temporaryValue, true, true, (char) => char === 9 || char === 32);
        values.push(temporaryValue);
        temporaryValue = "";
      }
      return values;
    }
    function getDecodeSplit(name, list) {
      const value = list.get(name, true);
      if (value === null) {
        return null;
      }
      return gettingDecodingSplitting(value);
    }
    var textDecoder = new TextDecoder();
    function utf8DecodeBytes(buffer) {
      if (buffer.length === 0) {
        return "";
      }
      if (buffer[0] === 239 && buffer[1] === 187 && buffer[2] === 191) {
        buffer = buffer.subarray(3);
      }
      const output = textDecoder.decode(buffer);
      return output;
    }
    var EnvironmentSettingsObjectBase = class {
      get baseUrl() {
        return getGlobalOrigin();
      }
      get origin() {
        return this.baseUrl?.origin;
      }
      policyContainer = makePolicyContainer();
    };
    var EnvironmentSettingsObject = class {
      settingsObject = new EnvironmentSettingsObjectBase();
    };
    var environmentSettingsObject = new EnvironmentSettingsObject();
    module2.exports = {
      isAborted,
      isCancelled,
      isValidEncodedURL,
      ReadableStreamFrom,
      tryUpgradeRequestToAPotentiallyTrustworthyURL,
      clampAndCoarsenConnectionTimingInfo,
      coarsenedSharedCurrentTime,
      determineRequestsReferrer,
      makePolicyContainer,
      clonePolicyContainer,
      appendFetchMetadata,
      appendRequestOriginHeader,
      TAOCheck,
      corsCheck,
      crossOriginResourcePolicyCheck,
      createOpaqueTimingInfo,
      setRequestReferrerPolicyOnRedirect,
      isValidHTTPToken,
      requestBadPort,
      requestCurrentURL,
      responseURL,
      responseLocationURL,
      isURLPotentiallyTrustworthy,
      isValidReasonPhrase,
      sameOrigin,
      normalizeMethod,
      serializeJavascriptValueToJSONString,
      iteratorMixin,
      createIterator,
      isValidHeaderName,
      isValidHeaderValue,
      isErrorLike,
      fullyReadBody,
      bytesMatch,
      readableStreamClose,
      isomorphicEncode,
      urlIsLocal,
      urlHasHttpsScheme,
      urlIsHttpHttpsScheme,
      readAllBytes,
      simpleRangeHeaderValue,
      buildContentRange,
      parseMetadata,
      createInflate,
      extractMimeType,
      getDecodeSplit,
      utf8DecodeBytes,
      environmentSettingsObject,
      isOriginIPPotentiallyTrustworthy
    };
  }
});

// node_modules/undici/lib/web/fetch/formdata.js
var require_formdata = __commonJS({
  "node_modules/undici/lib/web/fetch/formdata.js"(exports2, module2) {
    "use strict";
    var { iteratorMixin } = require_util5();
    var { kEnumerableProperty } = require_util4();
    var { webidl } = require_webidl();
    var nodeUtil = require("node:util");
    var FormData2 = class _FormData {
      #state = [];
      constructor(form) {
        webidl.util.markAsUncloneable(this);
        if (form !== void 0) {
          throw webidl.errors.conversionFailed({
            prefix: "FormData constructor",
            argument: "Argument 1",
            types: ["undefined"]
          });
        }
      }
      append(name, value, filename = void 0) {
        webidl.brandCheck(this, _FormData);
        const prefix = "FormData.append";
        webidl.argumentLengthCheck(arguments, 2, prefix);
        name = webidl.converters.USVString(name);
        if (arguments.length === 3 || webidl.is.Blob(value)) {
          value = webidl.converters.Blob(value, prefix, "value");
          if (filename !== void 0) {
            filename = webidl.converters.USVString(filename);
          }
        } else {
          value = webidl.converters.USVString(value);
        }
        const entry = makeEntry(name, value, filename);
        this.#state.push(entry);
      }
      delete(name) {
        webidl.brandCheck(this, _FormData);
        const prefix = "FormData.delete";
        webidl.argumentLengthCheck(arguments, 1, prefix);
        name = webidl.converters.USVString(name);
        this.#state = this.#state.filter((entry) => entry.name !== name);
      }
      get(name) {
        webidl.brandCheck(this, _FormData);
        const prefix = "FormData.get";
        webidl.argumentLengthCheck(arguments, 1, prefix);
        name = webidl.converters.USVString(name);
        const idx = this.#state.findIndex((entry) => entry.name === name);
        if (idx === -1) {
          return null;
        }
        return this.#state[idx].value;
      }
      getAll(name) {
        webidl.brandCheck(this, _FormData);
        const prefix = "FormData.getAll";
        webidl.argumentLengthCheck(arguments, 1, prefix);
        name = webidl.converters.USVString(name);
        return this.#state.filter((entry) => entry.name === name).map((entry) => entry.value);
      }
      has(name) {
        webidl.brandCheck(this, _FormData);
        const prefix = "FormData.has";
        webidl.argumentLengthCheck(arguments, 1, prefix);
        name = webidl.converters.USVString(name);
        return this.#state.findIndex((entry) => entry.name === name) !== -1;
      }
      set(name, value, filename = void 0) {
        webidl.brandCheck(this, _FormData);
        const prefix = "FormData.set";
        webidl.argumentLengthCheck(arguments, 2, prefix);
        name = webidl.converters.USVString(name);
        if (arguments.length === 3 || webidl.is.Blob(value)) {
          value = webidl.converters.Blob(value, prefix, "value");
          if (filename !== void 0) {
            filename = webidl.converters.USVString(filename);
          }
        } else {
          value = webidl.converters.USVString(value);
        }
        const entry = makeEntry(name, value, filename);
        const idx = this.#state.findIndex((entry2) => entry2.name === name);
        if (idx !== -1) {
          this.#state = [
            ...this.#state.slice(0, idx),
            entry,
            ...this.#state.slice(idx + 1).filter((entry2) => entry2.name !== name)
          ];
        } else {
          this.#state.push(entry);
        }
      }
      [nodeUtil.inspect.custom](depth, options) {
        const state = this.#state.reduce((a, b) => {
          if (a[b.name]) {
            if (Array.isArray(a[b.name])) {
              a[b.name].push(b.value);
            } else {
              a[b.name] = [a[b.name], b.value];
            }
          } else {
            a[b.name] = b.value;
          }
          return a;
        }, { __proto__: null });
        options.depth ??= depth;
        options.colors ??= true;
        const output = nodeUtil.formatWithOptions(options, state);
        return `FormData ${output.slice(output.indexOf("]") + 2)}`;
      }
      /**
       * @param {FormData} formData
       */
      static getFormDataState(formData) {
        return formData.#state;
      }
      /**
       * @param {FormData} formData
       * @param {any[]} newState
       */
      static setFormDataState(formData, newState) {
        formData.#state = newState;
      }
    };
    var { getFormDataState, setFormDataState } = FormData2;
    Reflect.deleteProperty(FormData2, "getFormDataState");
    Reflect.deleteProperty(FormData2, "setFormDataState");
    iteratorMixin("FormData", FormData2, getFormDataState, "name", "value");
    Object.defineProperties(FormData2.prototype, {
      append: kEnumerableProperty,
      delete: kEnumerableProperty,
      get: kEnumerableProperty,
      getAll: kEnumerableProperty,
      has: kEnumerableProperty,
      set: kEnumerableProperty,
      [Symbol.toStringTag]: {
        value: "FormData",
        configurable: true
      }
    });
    function makeEntry(name, value, filename) {
      if (typeof value === "string") {
      } else {
        if (!webidl.is.File(value)) {
          value = new File([value], "blob", { type: value.type });
        }
        if (filename !== void 0) {
          const options = {
            type: value.type,
            lastModified: value.lastModified
          };
          value = new File([value], filename, options);
        }
      }
      return { name, value };
    }
    webidl.is.FormData = webidl.util.MakeTypeAssertion(FormData2);
    module2.exports = { FormData: FormData2, makeEntry, setFormDataState };
  }
});

// node_modules/undici/lib/web/fetch/formdata-parser.js
var require_formdata_parser = __commonJS({
  "node_modules/undici/lib/web/fetch/formdata-parser.js"(exports2, module2) {
    "use strict";
    var { bufferToLowerCasedHeaderName } = require_util4();
    var { utf8DecodeBytes } = require_util5();
    var { HTTP_TOKEN_CODEPOINTS, isomorphicDecode } = require_data_url();
    var { makeEntry } = require_formdata();
    var { webidl } = require_webidl();
    var assert = require("node:assert");
    var formDataNameBuffer = Buffer.from('form-data; name="');
    var filenameBuffer = Buffer.from("filename");
    var dd2 = Buffer.from("--");
    var ddcrlf = Buffer.from("--\r\n");
    function isAsciiString(chars) {
      for (let i = 0; i < chars.length; ++i) {
        if ((chars.charCodeAt(i) & ~127) !== 0) {
          return false;
        }
      }
      return true;
    }
    function validateBoundary(boundary) {
      const length = boundary.length;
      if (length < 27 || length > 70) {
        return false;
      }
      for (let i = 0; i < length; ++i) {
        const cp = boundary.charCodeAt(i);
        if (!(cp >= 48 && cp <= 57 || cp >= 65 && cp <= 90 || cp >= 97 && cp <= 122 || cp === 39 || cp === 45 || cp === 95)) {
          return false;
        }
      }
      return true;
    }
    function multipartFormDataParser(input, mimeType) {
      assert(mimeType !== "failure" && mimeType.essence === "multipart/form-data");
      const boundaryString = mimeType.parameters.get("boundary");
      if (boundaryString === void 0) {
        throw parsingError("missing boundary in content-type header");
      }
      const boundary = Buffer.from(`--${boundaryString}`, "utf8");
      const entryList = [];
      const position = { position: 0 };
      while (input[position.position] === 13 && input[position.position + 1] === 10) {
        position.position += 2;
      }
      let trailing = input.length;
      while (input[trailing - 1] === 10 && input[trailing - 2] === 13) {
        trailing -= 2;
      }
      if (trailing !== input.length) {
        input = input.subarray(0, trailing);
      }
      while (true) {
        if (input.subarray(position.position, position.position + boundary.length).equals(boundary)) {
          position.position += boundary.length;
        } else {
          throw parsingError("expected a value starting with -- and the boundary");
        }
        if (position.position === input.length - 2 && bufferStartsWith(input, dd2, position) || position.position === input.length - 4 && bufferStartsWith(input, ddcrlf, position)) {
          return entryList;
        }
        if (input[position.position] !== 13 || input[position.position + 1] !== 10) {
          throw parsingError("expected CRLF");
        }
        position.position += 2;
        const result = parseMultipartFormDataHeaders(input, position);
        let { name, filename, contentType, encoding } = result;
        position.position += 2;
        let body;
        {
          const boundaryIndex = input.indexOf(boundary.subarray(2), position.position);
          if (boundaryIndex === -1) {
            throw parsingError("expected boundary after body");
          }
          body = input.subarray(position.position, boundaryIndex - 4);
          position.position += body.length;
          if (encoding === "base64") {
            body = Buffer.from(body.toString(), "base64");
          }
        }
        if (input[position.position] !== 13 || input[position.position + 1] !== 10) {
          throw parsingError("expected CRLF");
        } else {
          position.position += 2;
        }
        let value;
        if (filename !== null) {
          contentType ??= "text/plain";
          if (!isAsciiString(contentType)) {
            contentType = "";
          }
          value = new File([body], filename, { type: contentType });
        } else {
          value = utf8DecodeBytes(Buffer.from(body));
        }
        assert(webidl.is.USVString(name));
        assert(typeof value === "string" && webidl.is.USVString(value) || webidl.is.File(value));
        entryList.push(makeEntry(name, value, filename));
      }
    }
    function parseMultipartFormDataHeaders(input, position) {
      let name = null;
      let filename = null;
      let contentType = null;
      let encoding = null;
      while (true) {
        if (input[position.position] === 13 && input[position.position + 1] === 10) {
          if (name === null) {
            throw parsingError("header name is null");
          }
          return { name, filename, contentType, encoding };
        }
        let headerName = collectASequenceOfBytes(
          (char) => char !== 10 && char !== 13 && char !== 58,
          input,
          position
        );
        headerName = removeChars(headerName, true, true, (char) => char === 9 || char === 32);
        if (!HTTP_TOKEN_CODEPOINTS.test(headerName.toString())) {
          throw parsingError("header name does not match the field-name token production");
        }
        if (input[position.position] !== 58) {
          throw parsingError("expected :");
        }
        position.position++;
        collectASequenceOfBytes(
          (char) => char === 32 || char === 9,
          input,
          position
        );
        switch (bufferToLowerCasedHeaderName(headerName)) {
          case "content-disposition": {
            name = filename = null;
            if (!bufferStartsWith(input, formDataNameBuffer, position)) {
              throw parsingError('expected form-data; name=" for content-disposition header');
            }
            position.position += 17;
            name = parseMultipartFormDataName(input, position);
            if (input[position.position] === 59 && input[position.position + 1] === 32) {
              const at2 = { position: position.position + 2 };
              if (bufferStartsWith(input, filenameBuffer, at2)) {
                if (input[at2.position + 8] === 42) {
                  at2.position += 10;
                  collectASequenceOfBytes(
                    (char) => char === 32 || char === 9,
                    input,
                    at2
                  );
                  const headerValue = collectASequenceOfBytes(
                    (char) => char !== 32 && char !== 13 && char !== 10,
                    // ' ' or CRLF
                    input,
                    at2
                  );
                  if (headerValue[0] !== 117 && headerValue[0] !== 85 || // u or U
                  headerValue[1] !== 116 && headerValue[1] !== 84 || // t or T
                  headerValue[2] !== 102 && headerValue[2] !== 70 || // f or F
                  headerValue[3] !== 45 || // -
                  headerValue[4] !== 56) {
                    throw parsingError("unknown encoding, expected utf-8''");
                  }
                  filename = decodeURIComponent(new TextDecoder().decode(headerValue.subarray(7)));
                  position.position = at2.position;
                } else {
                  position.position += 11;
                  collectASequenceOfBytes(
                    (char) => char === 32 || char === 9,
                    input,
                    position
                  );
                  position.position++;
                  filename = parseMultipartFormDataName(input, position);
                }
              }
            }
            break;
          }
          case "content-type": {
            let headerValue = collectASequenceOfBytes(
              (char) => char !== 10 && char !== 13,
              input,
              position
            );
            headerValue = removeChars(headerValue, false, true, (char) => char === 9 || char === 32);
            contentType = isomorphicDecode(headerValue);
            break;
          }
          case "content-transfer-encoding": {
            let headerValue = collectASequenceOfBytes(
              (char) => char !== 10 && char !== 13,
              input,
              position
            );
            headerValue = removeChars(headerValue, false, true, (char) => char === 9 || char === 32);
            encoding = isomorphicDecode(headerValue);
            break;
          }
          default: {
            collectASequenceOfBytes(
              (char) => char !== 10 && char !== 13,
              input,
              position
            );
          }
        }
        if (input[position.position] !== 13 && input[position.position + 1] !== 10) {
          throw parsingError("expected CRLF");
        } else {
          position.position += 2;
        }
      }
    }
    function parseMultipartFormDataName(input, position) {
      assert(input[position.position - 1] === 34);
      let name = collectASequenceOfBytes(
        (char) => char !== 10 && char !== 13 && char !== 34,
        input,
        position
      );
      if (input[position.position] !== 34) {
        throw parsingError('expected "');
      } else {
        position.position++;
      }
      name = new TextDecoder().decode(name).replace(/%0A/ig, "\n").replace(/%0D/ig, "\r").replace(/%22/g, '"');
      return name;
    }
    function collectASequenceOfBytes(condition, input, position) {
      let start = position.position;
      while (start < input.length && condition(input[start])) {
        ++start;
      }
      return input.subarray(position.position, position.position = start);
    }
    function removeChars(buf, leading, trailing, predicate) {
      let lead = 0;
      let trail = buf.length - 1;
      if (leading) {
        while (lead < buf.length && predicate(buf[lead])) lead++;
      }
      if (trailing) {
        while (trail > 0 && predicate(buf[trail])) trail--;
      }
      return lead === 0 && trail === buf.length - 1 ? buf : buf.subarray(lead, trail + 1);
    }
    function bufferStartsWith(buffer, start, position) {
      if (buffer.length < start.length) {
        return false;
      }
      for (let i = 0; i < start.length; i++) {
        if (start[i] !== buffer[position.position + i]) {
          return false;
        }
      }
      return true;
    }
    function parsingError(cause) {
      return new TypeError("Failed to parse body as FormData.", { cause: new TypeError(cause) });
    }
    module2.exports = {
      multipartFormDataParser,
      validateBoundary
    };
  }
});

// node_modules/undici/lib/util/promise.js
var require_promise = __commonJS({
  "node_modules/undici/lib/util/promise.js"(exports2, module2) {
    "use strict";
    function createDeferredPromise() {
      let res;
      let rej;
      const promise = new Promise((resolve, reject) => {
        res = resolve;
        rej = reject;
      });
      return { promise, resolve: res, reject: rej };
    }
    module2.exports = {
      createDeferredPromise
    };
  }
});

// node_modules/undici/lib/web/fetch/body.js
var require_body = __commonJS({
  "node_modules/undici/lib/web/fetch/body.js"(exports2, module2) {
    "use strict";
    var util = require_util4();
    var {
      ReadableStreamFrom,
      readableStreamClose,
      fullyReadBody,
      extractMimeType,
      utf8DecodeBytes
    } = require_util5();
    var { FormData: FormData2, setFormDataState } = require_formdata();
    var { webidl } = require_webidl();
    var assert = require("node:assert");
    var { isErrored, isDisturbed } = require("node:stream");
    var { isArrayBuffer } = require("node:util/types");
    var { serializeAMimeType } = require_data_url();
    var { multipartFormDataParser } = require_formdata_parser();
    var { createDeferredPromise } = require_promise();
    var random;
    try {
      const crypto2 = require("node:crypto");
      random = (max) => crypto2.randomInt(0, max);
    } catch {
      random = (max) => Math.floor(Math.random() * max);
    }
    var textEncoder = new TextEncoder();
    function noop() {
    }
    var streamRegistry = new FinalizationRegistry((weakRef) => {
      const stream = weakRef.deref();
      if (stream && !stream.locked && !isDisturbed(stream) && !isErrored(stream)) {
        stream.cancel("Response object has been garbage collected").catch(noop);
      }
    });
    function extractBody(object, keepalive = false) {
      let stream = null;
      if (webidl.is.ReadableStream(object)) {
        stream = object;
      } else if (webidl.is.Blob(object)) {
        stream = object.stream();
      } else {
        stream = new ReadableStream({
          async pull(controller) {
            const buffer = typeof source === "string" ? textEncoder.encode(source) : source;
            if (buffer.byteLength) {
              controller.enqueue(buffer);
            }
            queueMicrotask(() => readableStreamClose(controller));
          },
          start() {
          },
          type: "bytes"
        });
      }
      assert(webidl.is.ReadableStream(stream));
      let action = null;
      let source = null;
      let length = null;
      let type = null;
      if (typeof object === "string") {
        source = object;
        type = "text/plain;charset=UTF-8";
      } else if (webidl.is.URLSearchParams(object)) {
        source = object.toString();
        type = "application/x-www-form-urlencoded;charset=UTF-8";
      } else if (isArrayBuffer(object)) {
        source = new Uint8Array(object.slice());
      } else if (ArrayBuffer.isView(object)) {
        source = new Uint8Array(object.buffer.slice(object.byteOffset, object.byteOffset + object.byteLength));
      } else if (webidl.is.FormData(object)) {
        const boundary = `----formdata-undici-0${`${random(1e11)}`.padStart(11, "0")}`;
        const prefix = `--${boundary}\r
Content-Disposition: form-data`;
        const escape2 = (str) => str.replace(/\n/g, "%0A").replace(/\r/g, "%0D").replace(/"/g, "%22");
        const normalizeLinefeeds = (value) => value.replace(/\r?\n|\r/g, "\r\n");
        const blobParts = [];
        const rn = new Uint8Array([13, 10]);
        length = 0;
        let hasUnknownSizeValue = false;
        for (const [name, value] of object) {
          if (typeof value === "string") {
            const chunk2 = textEncoder.encode(prefix + `; name="${escape2(normalizeLinefeeds(name))}"\r
\r
${normalizeLinefeeds(value)}\r
`);
            blobParts.push(chunk2);
            length += chunk2.byteLength;
          } else {
            const chunk2 = textEncoder.encode(`${prefix}; name="${escape2(normalizeLinefeeds(name))}"` + (value.name ? `; filename="${escape2(value.name)}"` : "") + `\r
Content-Type: ${value.type || "application/octet-stream"}\r
\r
`);
            blobParts.push(chunk2, value, rn);
            if (typeof value.size === "number") {
              length += chunk2.byteLength + value.size + rn.byteLength;
            } else {
              hasUnknownSizeValue = true;
            }
          }
        }
        const chunk = textEncoder.encode(`--${boundary}--\r
`);
        blobParts.push(chunk);
        length += chunk.byteLength;
        if (hasUnknownSizeValue) {
          length = null;
        }
        source = object;
        action = async function* () {
          for (const part of blobParts) {
            if (part.stream) {
              yield* part.stream();
            } else {
              yield part;
            }
          }
        };
        type = `multipart/form-data; boundary=${boundary}`;
      } else if (webidl.is.Blob(object)) {
        source = object;
        length = object.size;
        if (object.type) {
          type = object.type;
        }
      } else if (typeof object[Symbol.asyncIterator] === "function") {
        if (keepalive) {
          throw new TypeError("keepalive");
        }
        if (util.isDisturbed(object) || object.locked) {
          throw new TypeError(
            "Response body object should not be disturbed or locked"
          );
        }
        stream = webidl.is.ReadableStream(object) ? object : ReadableStreamFrom(object);
      }
      if (typeof source === "string" || util.isBuffer(source)) {
        length = Buffer.byteLength(source);
      }
      if (action != null) {
        let iterator;
        stream = new ReadableStream({
          async start() {
            iterator = action(object)[Symbol.asyncIterator]();
          },
          async pull(controller) {
            const { value, done } = await iterator.next();
            if (done) {
              queueMicrotask(() => {
                controller.close();
                controller.byobRequest?.respond(0);
              });
            } else {
              if (!isErrored(stream)) {
                const buffer = new Uint8Array(value);
                if (buffer.byteLength) {
                  controller.enqueue(buffer);
                }
              }
            }
            return controller.desiredSize > 0;
          },
          async cancel(reason) {
            await iterator.return();
          },
          type: "bytes"
        });
      }
      const body = { stream, source, length };
      return [body, type];
    }
    function safelyExtractBody(object, keepalive = false) {
      if (webidl.is.ReadableStream(object)) {
        assert(!util.isDisturbed(object), "The body has already been consumed.");
        assert(!object.locked, "The stream is locked.");
      }
      return extractBody(object, keepalive);
    }
    function cloneBody(body) {
      const { 0: out1, 1: out2 } = body.stream.tee();
      body.stream = out1;
      return {
        stream: out2,
        length: body.length,
        source: body.source
      };
    }
    function throwIfAborted(state) {
      if (state.aborted) {
        throw new DOMException("The operation was aborted.", "AbortError");
      }
    }
    function bodyMixinMethods(instance, getInternalState) {
      const methods = {
        blob() {
          return consumeBody(this, (bytes) => {
            let mimeType = bodyMimeType(getInternalState(this));
            if (mimeType === null) {
              mimeType = "";
            } else if (mimeType) {
              mimeType = serializeAMimeType(mimeType);
            }
            return new Blob([bytes], { type: mimeType });
          }, instance, getInternalState);
        },
        arrayBuffer() {
          return consumeBody(this, (bytes) => {
            return new Uint8Array(bytes).buffer;
          }, instance, getInternalState);
        },
        text() {
          return consumeBody(this, utf8DecodeBytes, instance, getInternalState);
        },
        json() {
          return consumeBody(this, parseJSONFromBytes, instance, getInternalState);
        },
        formData() {
          return consumeBody(this, (value) => {
            const mimeType = bodyMimeType(getInternalState(this));
            if (mimeType !== null) {
              switch (mimeType.essence) {
                case "multipart/form-data": {
                  const parsed = multipartFormDataParser(value, mimeType);
                  const fd = new FormData2();
                  setFormDataState(fd, parsed);
                  return fd;
                }
                case "application/x-www-form-urlencoded": {
                  const entries = new URLSearchParams(value.toString());
                  const fd = new FormData2();
                  for (const [name, value2] of entries) {
                    fd.append(name, value2);
                  }
                  return fd;
                }
              }
            }
            throw new TypeError(
              'Content-Type was not one of "multipart/form-data" or "application/x-www-form-urlencoded".'
            );
          }, instance, getInternalState);
        },
        bytes() {
          return consumeBody(this, (bytes) => {
            return new Uint8Array(bytes);
          }, instance, getInternalState);
        }
      };
      return methods;
    }
    function mixinBody(prototype, getInternalState) {
      Object.assign(prototype.prototype, bodyMixinMethods(prototype, getInternalState));
    }
    async function consumeBody(object, convertBytesToJSValue, instance, getInternalState) {
      webidl.brandCheck(object, instance);
      const state = getInternalState(object);
      if (bodyUnusable(state)) {
        throw new TypeError("Body is unusable: Body has already been read");
      }
      throwIfAborted(state);
      const promise = createDeferredPromise();
      const errorSteps = (error) => promise.reject(error);
      const successSteps = (data) => {
        try {
          promise.resolve(convertBytesToJSValue(data));
        } catch (e) {
          errorSteps(e);
        }
      };
      if (state.body == null) {
        successSteps(Buffer.allocUnsafe(0));
        return promise.promise;
      }
      fullyReadBody(state.body, successSteps, errorSteps);
      return promise.promise;
    }
    function bodyUnusable(object) {
      const body = object.body;
      return body != null && (body.stream.locked || util.isDisturbed(body.stream));
    }
    function parseJSONFromBytes(bytes) {
      return JSON.parse(utf8DecodeBytes(bytes));
    }
    function bodyMimeType(requestOrResponse) {
      const headers = requestOrResponse.headersList;
      const mimeType = extractMimeType(headers);
      if (mimeType === "failure") {
        return null;
      }
      return mimeType;
    }
    module2.exports = {
      extractBody,
      safelyExtractBody,
      cloneBody,
      mixinBody,
      streamRegistry,
      bodyUnusable
    };
  }
});

// node_modules/undici/lib/dispatcher/client-h1.js
var require_client_h1 = __commonJS({
  "node_modules/undici/lib/dispatcher/client-h1.js"(exports2, module2) {
    "use strict";
    var assert = require("node:assert");
    var util = require_util4();
    var { channels } = require_diagnostics();
    var timers = require_timers();
    var {
      RequestContentLengthMismatchError,
      ResponseContentLengthMismatchError,
      RequestAbortedError,
      HeadersTimeoutError,
      HeadersOverflowError,
      SocketError,
      InformationalError,
      BodyTimeoutError,
      HTTPParserError,
      ResponseExceededMaxSizeError
    } = require_errors5();
    var {
      kUrl,
      kReset,
      kClient,
      kParser,
      kBlocking,
      kRunning,
      kPending,
      kSize,
      kWriting,
      kQueue,
      kNoRef,
      kKeepAliveDefaultTimeout,
      kHostHeader,
      kPendingIdx,
      kRunningIdx,
      kError,
      kPipelining,
      kSocket,
      kKeepAliveTimeoutValue,
      kMaxHeadersSize,
      kKeepAliveMaxTimeout,
      kKeepAliveTimeoutThreshold,
      kHeadersTimeout,
      kBodyTimeout,
      kStrictContentLength,
      kMaxRequests,
      kCounter,
      kMaxResponseSize,
      kOnError,
      kResume,
      kHTTPContext,
      kClosed
    } = require_symbols4();
    var constants = require_constants4();
    var EMPTY_BUF = Buffer.alloc(0);
    var FastBuffer = Buffer[Symbol.species];
    var removeAllListeners = util.removeAllListeners;
    var extractBody;
    function lazyllhttp() {
      const llhttpWasmData = process.env.JEST_WORKER_ID ? require_llhttp_wasm() : void 0;
      let mod;
      try {
        mod = new WebAssembly.Module(require_llhttp_simd_wasm());
      } catch (e) {
        mod = new WebAssembly.Module(llhttpWasmData || require_llhttp_wasm());
      }
      return new WebAssembly.Instance(mod, {
        env: {
          /**
           * @param {number} p
           * @param {number} at
           * @param {number} len
           * @returns {number}
           */
          wasm_on_url: (p, at2, len) => {
            return 0;
          },
          /**
           * @param {number} p
           * @param {number} at
           * @param {number} len
           * @returns {number}
           */
          wasm_on_status: (p, at2, len) => {
            assert(currentParser.ptr === p);
            const start = at2 - currentBufferPtr + currentBufferRef.byteOffset;
            return currentParser.onStatus(new FastBuffer(currentBufferRef.buffer, start, len));
          },
          /**
           * @param {number} p
           * @returns {number}
           */
          wasm_on_message_begin: (p) => {
            assert(currentParser.ptr === p);
            return currentParser.onMessageBegin();
          },
          /**
           * @param {number} p
           * @param {number} at
           * @param {number} len
           * @returns {number}
           */
          wasm_on_header_field: (p, at2, len) => {
            assert(currentParser.ptr === p);
            const start = at2 - currentBufferPtr + currentBufferRef.byteOffset;
            return currentParser.onHeaderField(new FastBuffer(currentBufferRef.buffer, start, len));
          },
          /**
           * @param {number} p
           * @param {number} at
           * @param {number} len
           * @returns {number}
           */
          wasm_on_header_value: (p, at2, len) => {
            assert(currentParser.ptr === p);
            const start = at2 - currentBufferPtr + currentBufferRef.byteOffset;
            return currentParser.onHeaderValue(new FastBuffer(currentBufferRef.buffer, start, len));
          },
          /**
           * @param {number} p
           * @param {number} statusCode
           * @param {0|1} upgrade
           * @param {0|1} shouldKeepAlive
           * @returns {number}
           */
          wasm_on_headers_complete: (p, statusCode, upgrade, shouldKeepAlive) => {
            assert(currentParser.ptr === p);
            return currentParser.onHeadersComplete(statusCode, upgrade === 1, shouldKeepAlive === 1);
          },
          /**
           * @param {number} p
           * @param {number} at
           * @param {number} len
           * @returns {number}
           */
          wasm_on_body: (p, at2, len) => {
            assert(currentParser.ptr === p);
            const start = at2 - currentBufferPtr + currentBufferRef.byteOffset;
            return currentParser.onBody(new FastBuffer(currentBufferRef.buffer, start, len));
          },
          /**
           * @param {number} p
           * @returns {number}
           */
          wasm_on_message_complete: (p) => {
            assert(currentParser.ptr === p);
            return currentParser.onMessageComplete();
          }
        }
      });
    }
    var llhttpInstance = null;
    var currentParser = null;
    var currentBufferRef = null;
    var currentBufferSize = 0;
    var currentBufferPtr = null;
    var USE_NATIVE_TIMER = 0;
    var USE_FAST_TIMER = 1;
    var TIMEOUT_HEADERS = 2 | USE_FAST_TIMER;
    var TIMEOUT_BODY = 4 | USE_FAST_TIMER;
    var TIMEOUT_KEEP_ALIVE = 8 | USE_NATIVE_TIMER;
    var Parser = class {
      /**
         * @param {import('./client.js')} client
         * @param {import('net').Socket} socket
         * @param {*} llhttp
         */
      constructor(client, socket, { exports: exports3 }) {
        this.llhttp = exports3;
        this.ptr = this.llhttp.llhttp_alloc(constants.TYPE.RESPONSE);
        this.client = client;
        this.socket = socket;
        this.timeout = null;
        this.timeoutValue = null;
        this.timeoutType = null;
        this.statusCode = 0;
        this.statusText = "";
        this.upgrade = false;
        this.headers = [];
        this.headersSize = 0;
        this.headersMaxSize = client[kMaxHeadersSize];
        this.shouldKeepAlive = false;
        this.paused = false;
        this.resume = this.resume.bind(this);
        this.bytesRead = 0;
        this.keepAlive = "";
        this.contentLength = "";
        this.connection = "";
        this.maxResponseSize = client[kMaxResponseSize];
      }
      setTimeout(delay, type) {
        if (delay !== this.timeoutValue || type & USE_FAST_TIMER ^ this.timeoutType & USE_FAST_TIMER) {
          if (this.timeout) {
            timers.clearTimeout(this.timeout);
            this.timeout = null;
          }
          if (delay) {
            if (type & USE_FAST_TIMER) {
              this.timeout = timers.setFastTimeout(onParserTimeout, delay, new WeakRef(this));
            } else {
              this.timeout = setTimeout(onParserTimeout, delay, new WeakRef(this));
              this.timeout?.unref();
            }
          }
          this.timeoutValue = delay;
        } else if (this.timeout) {
          if (this.timeout.refresh) {
            this.timeout.refresh();
          }
        }
        this.timeoutType = type;
      }
      resume() {
        if (this.socket.destroyed || !this.paused) {
          return;
        }
        assert(this.ptr != null);
        assert(currentParser === null);
        this.llhttp.llhttp_resume(this.ptr);
        assert(this.timeoutType === TIMEOUT_BODY);
        if (this.timeout) {
          if (this.timeout.refresh) {
            this.timeout.refresh();
          }
        }
        this.paused = false;
        this.execute(this.socket.read() || EMPTY_BUF);
        this.readMore();
      }
      readMore() {
        while (!this.paused && this.ptr) {
          const chunk = this.socket.read();
          if (chunk === null) {
            break;
          }
          this.execute(chunk);
        }
      }
      /**
       * @param {Buffer} chunk
       */
      execute(chunk) {
        assert(currentParser === null);
        assert(this.ptr != null);
        assert(!this.paused);
        const { socket, llhttp } = this;
        if (chunk.length > currentBufferSize) {
          if (currentBufferPtr) {
            llhttp.free(currentBufferPtr);
          }
          currentBufferSize = Math.ceil(chunk.length / 4096) * 4096;
          currentBufferPtr = llhttp.malloc(currentBufferSize);
        }
        new Uint8Array(llhttp.memory.buffer, currentBufferPtr, currentBufferSize).set(chunk);
        try {
          let ret;
          try {
            currentBufferRef = chunk;
            currentParser = this;
            ret = llhttp.llhttp_execute(this.ptr, currentBufferPtr, chunk.length);
          } catch (err) {
            throw err;
          } finally {
            currentParser = null;
            currentBufferRef = null;
          }
          if (ret !== constants.ERROR.OK) {
            const data = chunk.subarray(llhttp.llhttp_get_error_pos(this.ptr) - currentBufferPtr);
            if (ret === constants.ERROR.PAUSED_UPGRADE) {
              this.onUpgrade(data);
            } else if (ret === constants.ERROR.PAUSED) {
              this.paused = true;
              socket.unshift(data);
            } else {
              const ptr = llhttp.llhttp_get_error_reason(this.ptr);
              let message = "";
              if (ptr) {
                const len = new Uint8Array(llhttp.memory.buffer, ptr).indexOf(0);
                message = "Response does not match the HTTP/1.1 protocol (" + Buffer.from(llhttp.memory.buffer, ptr, len).toString() + ")";
              }
              throw new HTTPParserError(message, constants.ERROR[ret], data);
            }
          }
        } catch (err) {
          util.destroy(socket, err);
        }
      }
      destroy() {
        assert(currentParser === null);
        assert(this.ptr != null);
        this.llhttp.llhttp_free(this.ptr);
        this.ptr = null;
        this.timeout && timers.clearTimeout(this.timeout);
        this.timeout = null;
        this.timeoutValue = null;
        this.timeoutType = null;
        this.paused = false;
      }
      /**
       * @param {Buffer} buf
       * @returns {0}
       */
      onStatus(buf) {
        this.statusText = buf.toString();
        return 0;
      }
      /**
       * @returns {0|-1}
       */
      onMessageBegin() {
        const { socket, client } = this;
        if (socket.destroyed) {
          return -1;
        }
        const request = client[kQueue][client[kRunningIdx]];
        if (!request) {
          return -1;
        }
        request.onResponseStarted();
        return 0;
      }
      /**
       * @param {Buffer} buf
       * @returns {number}
       */
      onHeaderField(buf) {
        const len = this.headers.length;
        if ((len & 1) === 0) {
          this.headers.push(buf);
        } else {
          this.headers[len - 1] = Buffer.concat([this.headers[len - 1], buf]);
        }
        this.trackHeader(buf.length);
        return 0;
      }
      /**
       * @param {Buffer} buf
       * @returns {number}
       */
      onHeaderValue(buf) {
        let len = this.headers.length;
        if ((len & 1) === 1) {
          this.headers.push(buf);
          len += 1;
        } else {
          this.headers[len - 1] = Buffer.concat([this.headers[len - 1], buf]);
        }
        const key = this.headers[len - 2];
        if (key.length === 10) {
          const headerName = util.bufferToLowerCasedHeaderName(key);
          if (headerName === "keep-alive") {
            this.keepAlive += buf.toString();
          } else if (headerName === "connection") {
            this.connection += buf.toString();
          }
        } else if (key.length === 14 && util.bufferToLowerCasedHeaderName(key) === "content-length") {
          this.contentLength += buf.toString();
        }
        this.trackHeader(buf.length);
        return 0;
      }
      /**
       * @param {number} len
       */
      trackHeader(len) {
        this.headersSize += len;
        if (this.headersSize >= this.headersMaxSize) {
          util.destroy(this.socket, new HeadersOverflowError());
        }
      }
      /**
       * @param {Buffer} head
       */
      onUpgrade(head) {
        const { upgrade, client, socket, headers, statusCode } = this;
        assert(upgrade);
        assert(client[kSocket] === socket);
        assert(!socket.destroyed);
        assert(!this.paused);
        assert((headers.length & 1) === 0);
        const request = client[kQueue][client[kRunningIdx]];
        assert(request);
        assert(request.upgrade || request.method === "CONNECT");
        this.statusCode = 0;
        this.statusText = "";
        this.shouldKeepAlive = false;
        this.headers = [];
        this.headersSize = 0;
        socket.unshift(head);
        socket[kParser].destroy();
        socket[kParser] = null;
        socket[kClient] = null;
        socket[kError] = null;
        removeAllListeners(socket);
        client[kSocket] = null;
        client[kHTTPContext] = null;
        client[kQueue][client[kRunningIdx]++] = null;
        client.emit("disconnect", client[kUrl], [client], new InformationalError("upgrade"));
        try {
          request.onUpgrade(statusCode, headers, socket);
        } catch (err) {
          util.destroy(socket, err);
        }
        client[kResume]();
      }
      /**
       * @param {number} statusCode
       * @param {boolean} upgrade
       * @param {boolean} shouldKeepAlive
       * @returns {number}
       */
      onHeadersComplete(statusCode, upgrade, shouldKeepAlive) {
        const { client, socket, headers, statusText } = this;
        if (socket.destroyed) {
          return -1;
        }
        const request = client[kQueue][client[kRunningIdx]];
        if (!request) {
          return -1;
        }
        assert(!this.upgrade);
        assert(this.statusCode < 200);
        if (statusCode === 100) {
          util.destroy(socket, new SocketError("bad response", util.getSocketInfo(socket)));
          return -1;
        }
        if (upgrade && !request.upgrade) {
          util.destroy(socket, new SocketError("bad upgrade", util.getSocketInfo(socket)));
          return -1;
        }
        assert(this.timeoutType === TIMEOUT_HEADERS);
        this.statusCode = statusCode;
        this.shouldKeepAlive = shouldKeepAlive || // Override llhttp value which does not allow keepAlive for HEAD.
        request.method === "HEAD" && !socket[kReset] && this.connection.toLowerCase() === "keep-alive";
        if (this.statusCode >= 200) {
          const bodyTimeout = request.bodyTimeout != null ? request.bodyTimeout : client[kBodyTimeout];
          this.setTimeout(bodyTimeout, TIMEOUT_BODY);
        } else if (this.timeout) {
          if (this.timeout.refresh) {
            this.timeout.refresh();
          }
        }
        if (request.method === "CONNECT") {
          assert(client[kRunning] === 1);
          this.upgrade = true;
          return 2;
        }
        if (upgrade) {
          assert(client[kRunning] === 1);
          this.upgrade = true;
          return 2;
        }
        assert((this.headers.length & 1) === 0);
        this.headers = [];
        this.headersSize = 0;
        if (this.shouldKeepAlive && client[kPipelining]) {
          const keepAliveTimeout = this.keepAlive ? util.parseKeepAliveTimeout(this.keepAlive) : null;
          if (keepAliveTimeout != null) {
            const timeout = Math.min(
              keepAliveTimeout - client[kKeepAliveTimeoutThreshold],
              client[kKeepAliveMaxTimeout]
            );
            if (timeout <= 0) {
              socket[kReset] = true;
            } else {
              client[kKeepAliveTimeoutValue] = timeout;
            }
          } else {
            client[kKeepAliveTimeoutValue] = client[kKeepAliveDefaultTimeout];
          }
        } else {
          socket[kReset] = true;
        }
        const pause = request.onHeaders(statusCode, headers, this.resume, statusText) === false;
        if (request.aborted) {
          return -1;
        }
        if (request.method === "HEAD") {
          return 1;
        }
        if (statusCode < 200) {
          return 1;
        }
        if (socket[kBlocking]) {
          socket[kBlocking] = false;
          client[kResume]();
        }
        return pause ? constants.ERROR.PAUSED : 0;
      }
      /**
       * @param {Buffer} buf
       * @returns {number}
       */
      onBody(buf) {
        const { client, socket, statusCode, maxResponseSize } = this;
        if (socket.destroyed) {
          return -1;
        }
        const request = client[kQueue][client[kRunningIdx]];
        assert(request);
        assert(this.timeoutType === TIMEOUT_BODY);
        if (this.timeout) {
          if (this.timeout.refresh) {
            this.timeout.refresh();
          }
        }
        assert(statusCode >= 200);
        if (maxResponseSize > -1 && this.bytesRead + buf.length > maxResponseSize) {
          util.destroy(socket, new ResponseExceededMaxSizeError());
          return -1;
        }
        this.bytesRead += buf.length;
        if (request.onData(buf) === false) {
          return constants.ERROR.PAUSED;
        }
        return 0;
      }
      /**
       * @returns {number}
       */
      onMessageComplete() {
        const { client, socket, statusCode, upgrade, headers, contentLength, bytesRead, shouldKeepAlive } = this;
        if (socket.destroyed && (!statusCode || shouldKeepAlive)) {
          return -1;
        }
        if (upgrade) {
          return 0;
        }
        assert(statusCode >= 100);
        assert((this.headers.length & 1) === 0);
        const request = client[kQueue][client[kRunningIdx]];
        assert(request);
        this.statusCode = 0;
        this.statusText = "";
        this.bytesRead = 0;
        this.contentLength = "";
        this.keepAlive = "";
        this.connection = "";
        this.headers = [];
        this.headersSize = 0;
        if (statusCode < 200) {
          return 0;
        }
        if (request.method !== "HEAD" && contentLength && bytesRead !== parseInt(contentLength, 10)) {
          util.destroy(socket, new ResponseContentLengthMismatchError());
          return -1;
        }
        request.onComplete(headers);
        client[kQueue][client[kRunningIdx]++] = null;
        if (socket[kWriting]) {
          assert(client[kRunning] === 0);
          util.destroy(socket, new InformationalError("reset"));
          return constants.ERROR.PAUSED;
        } else if (!shouldKeepAlive) {
          util.destroy(socket, new InformationalError("reset"));
          return constants.ERROR.PAUSED;
        } else if (socket[kReset] && client[kRunning] === 0) {
          util.destroy(socket, new InformationalError("reset"));
          return constants.ERROR.PAUSED;
        } else if (client[kPipelining] == null || client[kPipelining] === 1) {
          setImmediate(client[kResume]);
        } else {
          client[kResume]();
        }
        return 0;
      }
    };
    function onParserTimeout(parser) {
      const { socket, timeoutType, client, paused } = parser.deref();
      if (timeoutType === TIMEOUT_HEADERS) {
        if (!socket[kWriting] || socket.writableNeedDrain || client[kRunning] > 1) {
          assert(!paused, "cannot be paused while waiting for headers");
          util.destroy(socket, new HeadersTimeoutError());
        }
      } else if (timeoutType === TIMEOUT_BODY) {
        if (!paused) {
          util.destroy(socket, new BodyTimeoutError());
        }
      } else if (timeoutType === TIMEOUT_KEEP_ALIVE) {
        assert(client[kRunning] === 0 && client[kKeepAliveTimeoutValue]);
        util.destroy(socket, new InformationalError("socket idle timeout"));
      }
    }
    async function connectH1(client, socket) {
      client[kSocket] = socket;
      if (!llhttpInstance) {
        llhttpInstance = lazyllhttp();
      }
      if (socket.errored) {
        throw socket.errored;
      }
      if (socket.destroyed) {
        throw new SocketError("destroyed");
      }
      socket[kNoRef] = false;
      socket[kWriting] = false;
      socket[kReset] = false;
      socket[kBlocking] = false;
      socket[kParser] = new Parser(client, socket, llhttpInstance);
      util.addListener(socket, "error", onHttpSocketError);
      util.addListener(socket, "readable", onHttpSocketReadable);
      util.addListener(socket, "end", onHttpSocketEnd);
      util.addListener(socket, "close", onHttpSocketClose);
      socket[kClosed] = false;
      socket.on("close", onSocketClose);
      return {
        version: "h1",
        defaultPipelining: 1,
        write(request) {
          return writeH1(client, request);
        },
        resume() {
          resumeH1(client);
        },
        /**
         * @param {Error|undefined} err
         * @param {() => void} callback
         */
        destroy(err, callback) {
          if (socket[kClosed]) {
            queueMicrotask(callback);
          } else {
            socket.on("close", callback);
            socket.destroy(err);
          }
        },
        /**
         * @returns {boolean}
         */
        get destroyed() {
          return socket.destroyed;
        },
        /**
         * @param {import('../core/request.js')} request
         * @returns {boolean}
         */
        busy(request) {
          if (socket[kWriting] || socket[kReset] || socket[kBlocking]) {
            return true;
          }
          if (request) {
            if (client[kRunning] > 0 && !request.idempotent) {
              return true;
            }
            if (client[kRunning] > 0 && (request.upgrade || request.method === "CONNECT")) {
              return true;
            }
            if (client[kRunning] > 0 && util.bodyLength(request.body) !== 0 && (util.isStream(request.body) || util.isAsyncIterable(request.body) || util.isFormDataLike(request.body))) {
              return true;
            }
          }
          return false;
        }
      };
    }
    function onHttpSocketError(err) {
      assert(err.code !== "ERR_TLS_CERT_ALTNAME_INVALID");
      const parser = this[kParser];
      if (err.code === "ECONNRESET" && parser.statusCode && !parser.shouldKeepAlive) {
        parser.onMessageComplete();
        return;
      }
      this[kError] = err;
      this[kClient][kOnError](err);
    }
    function onHttpSocketReadable() {
      this[kParser]?.readMore();
    }
    function onHttpSocketEnd() {
      const parser = this[kParser];
      if (parser.statusCode && !parser.shouldKeepAlive) {
        parser.onMessageComplete();
        return;
      }
      util.destroy(this, new SocketError("other side closed", util.getSocketInfo(this)));
    }
    function onHttpSocketClose() {
      const parser = this[kParser];
      if (parser) {
        if (!this[kError] && parser.statusCode && !parser.shouldKeepAlive) {
          parser.onMessageComplete();
        }
        this[kParser].destroy();
        this[kParser] = null;
      }
      const err = this[kError] || new SocketError("closed", util.getSocketInfo(this));
      const client = this[kClient];
      client[kSocket] = null;
      client[kHTTPContext] = null;
      if (client.destroyed) {
        assert(client[kPending] === 0);
        const requests = client[kQueue].splice(client[kRunningIdx]);
        for (let i = 0; i < requests.length; i++) {
          const request = requests[i];
          util.errorRequest(client, request, err);
        }
      } else if (client[kRunning] > 0 && err.code !== "UND_ERR_INFO") {
        const request = client[kQueue][client[kRunningIdx]];
        client[kQueue][client[kRunningIdx]++] = null;
        util.errorRequest(client, request, err);
      }
      client[kPendingIdx] = client[kRunningIdx];
      assert(client[kRunning] === 0);
      client.emit("disconnect", client[kUrl], [client], err);
      client[kResume]();
    }
    function onSocketClose() {
      this[kClosed] = true;
    }
    function resumeH1(client) {
      const socket = client[kSocket];
      if (socket && !socket.destroyed) {
        if (client[kSize] === 0) {
          if (!socket[kNoRef] && socket.unref) {
            socket.unref();
            socket[kNoRef] = true;
          }
        } else if (socket[kNoRef] && socket.ref) {
          socket.ref();
          socket[kNoRef] = false;
        }
        if (client[kSize] === 0) {
          if (socket[kParser].timeoutType !== TIMEOUT_KEEP_ALIVE) {
            socket[kParser].setTimeout(client[kKeepAliveTimeoutValue], TIMEOUT_KEEP_ALIVE);
          }
        } else if (client[kRunning] > 0 && socket[kParser].statusCode < 200) {
          if (socket[kParser].timeoutType !== TIMEOUT_HEADERS) {
            const request = client[kQueue][client[kRunningIdx]];
            const headersTimeout = request.headersTimeout != null ? request.headersTimeout : client[kHeadersTimeout];
            socket[kParser].setTimeout(headersTimeout, TIMEOUT_HEADERS);
          }
        }
      }
    }
    function shouldSendContentLength(method) {
      return method !== "GET" && method !== "HEAD" && method !== "OPTIONS" && method !== "TRACE" && method !== "CONNECT";
    }
    function writeH1(client, request) {
      const { method, path: path4, host, upgrade, blocking, reset } = request;
      let { body, headers, contentLength } = request;
      const expectsPayload = method === "PUT" || method === "POST" || method === "PATCH" || method === "QUERY" || method === "PROPFIND" || method === "PROPPATCH";
      if (util.isFormDataLike(body)) {
        if (!extractBody) {
          extractBody = require_body().extractBody;
        }
        const [bodyStream, contentType] = extractBody(body);
        if (request.contentType == null) {
          headers.push("content-type", contentType);
        }
        body = bodyStream.stream;
        contentLength = bodyStream.length;
      } else if (util.isBlobLike(body) && request.contentType == null && body.type) {
        headers.push("content-type", body.type);
      }
      if (body && typeof body.read === "function") {
        body.read(0);
      }
      const bodyLength = util.bodyLength(body);
      contentLength = bodyLength ?? contentLength;
      if (contentLength === null) {
        contentLength = request.contentLength;
      }
      if (contentLength === 0 && !expectsPayload) {
        contentLength = null;
      }
      if (shouldSendContentLength(method) && contentLength > 0 && request.contentLength !== null && request.contentLength !== contentLength) {
        if (client[kStrictContentLength]) {
          util.errorRequest(client, request, new RequestContentLengthMismatchError());
          return false;
        }
        process.emitWarning(new RequestContentLengthMismatchError());
      }
      const socket = client[kSocket];
      const abort = (err) => {
        if (request.aborted || request.completed) {
          return;
        }
        util.errorRequest(client, request, err || new RequestAbortedError());
        util.destroy(body);
        util.destroy(socket, new InformationalError("aborted"));
      };
      try {
        request.onConnect(abort);
      } catch (err) {
        util.errorRequest(client, request, err);
      }
      if (request.aborted) {
        return false;
      }
      if (method === "HEAD") {
        socket[kReset] = true;
      }
      if (upgrade || method === "CONNECT") {
        socket[kReset] = true;
      }
      if (reset != null) {
        socket[kReset] = reset;
      }
      if (client[kMaxRequests] && socket[kCounter]++ >= client[kMaxRequests]) {
        socket[kReset] = true;
      }
      if (blocking) {
        socket[kBlocking] = true;
      }
      let header = `${method} ${path4} HTTP/1.1\r
`;
      if (typeof host === "string") {
        header += `host: ${host}\r
`;
      } else {
        header += client[kHostHeader];
      }
      if (upgrade) {
        header += `connection: upgrade\r
upgrade: ${upgrade}\r
`;
      } else if (client[kPipelining] && !socket[kReset]) {
        header += "connection: keep-alive\r\n";
      } else {
        header += "connection: close\r\n";
      }
      if (Array.isArray(headers)) {
        for (let n = 0; n < headers.length; n += 2) {
          const key = headers[n + 0];
          const val = headers[n + 1];
          if (Array.isArray(val)) {
            for (let i = 0; i < val.length; i++) {
              header += `${key}: ${val[i]}\r
`;
            }
          } else {
            header += `${key}: ${val}\r
`;
          }
        }
      }
      if (channels.sendHeaders.hasSubscribers) {
        channels.sendHeaders.publish({ request, headers: header, socket });
      }
      if (!body || bodyLength === 0) {
        writeBuffer(abort, null, client, request, socket, contentLength, header, expectsPayload);
      } else if (util.isBuffer(body)) {
        writeBuffer(abort, body, client, request, socket, contentLength, header, expectsPayload);
      } else if (util.isBlobLike(body)) {
        if (typeof body.stream === "function") {
          writeIterable(abort, body.stream(), client, request, socket, contentLength, header, expectsPayload);
        } else {
          writeBlob(abort, body, client, request, socket, contentLength, header, expectsPayload);
        }
      } else if (util.isStream(body)) {
        writeStream(abort, body, client, request, socket, contentLength, header, expectsPayload);
      } else if (util.isIterable(body)) {
        writeIterable(abort, body, client, request, socket, contentLength, header, expectsPayload);
      } else {
        assert(false);
      }
      return true;
    }
    function writeStream(abort, body, client, request, socket, contentLength, header, expectsPayload) {
      assert(contentLength !== 0 || client[kRunning] === 0, "stream body cannot be pipelined");
      let finished = false;
      const writer = new AsyncWriter({ abort, socket, request, contentLength, client, expectsPayload, header });
      const onData = function(chunk) {
        if (finished) {
          return;
        }
        try {
          if (!writer.write(chunk) && this.pause) {
            this.pause();
          }
        } catch (err) {
          util.destroy(this, err);
        }
      };
      const onDrain = function() {
        if (finished) {
          return;
        }
        if (body.resume) {
          body.resume();
        }
      };
      const onClose = function() {
        queueMicrotask(() => {
          body.removeListener("error", onFinished);
        });
        if (!finished) {
          const err = new RequestAbortedError();
          queueMicrotask(() => onFinished(err));
        }
      };
      const onFinished = function(err) {
        if (finished) {
          return;
        }
        finished = true;
        assert(socket.destroyed || socket[kWriting] && client[kRunning] <= 1);
        socket.off("drain", onDrain).off("error", onFinished);
        body.removeListener("data", onData).removeListener("end", onFinished).removeListener("close", onClose);
        if (!err) {
          try {
            writer.end();
          } catch (er) {
            err = er;
          }
        }
        writer.destroy(err);
        if (err && (err.code !== "UND_ERR_INFO" || err.message !== "reset")) {
          util.destroy(body, err);
        } else {
          util.destroy(body);
        }
      };
      body.on("data", onData).on("end", onFinished).on("error", onFinished).on("close", onClose);
      if (body.resume) {
        body.resume();
      }
      socket.on("drain", onDrain).on("error", onFinished);
      if (body.errorEmitted ?? body.errored) {
        setImmediate(onFinished, body.errored);
      } else if (body.endEmitted ?? body.readableEnded) {
        setImmediate(onFinished, null);
      }
      if (body.closeEmitted ?? body.closed) {
        setImmediate(onClose);
      }
    }
    function writeBuffer(abort, body, client, request, socket, contentLength, header, expectsPayload) {
      try {
        if (!body) {
          if (contentLength === 0) {
            socket.write(`${header}content-length: 0\r
\r
`, "latin1");
          } else {
            assert(contentLength === null, "no body must not have content length");
            socket.write(`${header}\r
`, "latin1");
          }
        } else if (util.isBuffer(body)) {
          assert(contentLength === body.byteLength, "buffer body must have content length");
          socket.cork();
          socket.write(`${header}content-length: ${contentLength}\r
\r
`, "latin1");
          socket.write(body);
          socket.uncork();
          request.onBodySent(body);
          if (!expectsPayload && request.reset !== false) {
            socket[kReset] = true;
          }
        }
        request.onRequestSent();
        client[kResume]();
      } catch (err) {
        abort(err);
      }
    }
    async function writeBlob(abort, body, client, request, socket, contentLength, header, expectsPayload) {
      assert(contentLength === body.size, "blob body must have content length");
      try {
        if (contentLength != null && contentLength !== body.size) {
          throw new RequestContentLengthMismatchError();
        }
        const buffer = Buffer.from(await body.arrayBuffer());
        socket.cork();
        socket.write(`${header}content-length: ${contentLength}\r
\r
`, "latin1");
        socket.write(buffer);
        socket.uncork();
        request.onBodySent(buffer);
        request.onRequestSent();
        if (!expectsPayload && request.reset !== false) {
          socket[kReset] = true;
        }
        client[kResume]();
      } catch (err) {
        abort(err);
      }
    }
    async function writeIterable(abort, body, client, request, socket, contentLength, header, expectsPayload) {
      assert(contentLength !== 0 || client[kRunning] === 0, "iterator body cannot be pipelined");
      let callback = null;
      function onDrain() {
        if (callback) {
          const cb = callback;
          callback = null;
          cb();
        }
      }
      const waitForDrain = () => new Promise((resolve, reject) => {
        assert(callback === null);
        if (socket[kError]) {
          reject(socket[kError]);
        } else {
          callback = resolve;
        }
      });
      socket.on("close", onDrain).on("drain", onDrain);
      const writer = new AsyncWriter({ abort, socket, request, contentLength, client, expectsPayload, header });
      try {
        for await (const chunk of body) {
          if (socket[kError]) {
            throw socket[kError];
          }
          if (!writer.write(chunk)) {
            await waitForDrain();
          }
        }
        writer.end();
      } catch (err) {
        writer.destroy(err);
      } finally {
        socket.off("close", onDrain).off("drain", onDrain);
      }
    }
    var AsyncWriter = class {
      /**
       *
       * @param {object} arg
       * @param {AbortCallback} arg.abort
       * @param {import('net').Socket} arg.socket
       * @param {import('../core/request.js')} arg.request
       * @param {number} arg.contentLength
       * @param {import('./client.js')} arg.client
       * @param {boolean} arg.expectsPayload
       * @param {string} arg.header
       */
      constructor({ abort, socket, request, contentLength, client, expectsPayload, header }) {
        this.socket = socket;
        this.request = request;
        this.contentLength = contentLength;
        this.client = client;
        this.bytesWritten = 0;
        this.expectsPayload = expectsPayload;
        this.header = header;
        this.abort = abort;
        socket[kWriting] = true;
      }
      /**
       * @param {Buffer} chunk
       * @returns
       */
      write(chunk) {
        const { socket, request, contentLength, client, bytesWritten, expectsPayload, header } = this;
        if (socket[kError]) {
          throw socket[kError];
        }
        if (socket.destroyed) {
          return false;
        }
        const len = Buffer.byteLength(chunk);
        if (!len) {
          return true;
        }
        if (contentLength !== null && bytesWritten + len > contentLength) {
          if (client[kStrictContentLength]) {
            throw new RequestContentLengthMismatchError();
          }
          process.emitWarning(new RequestContentLengthMismatchError());
        }
        socket.cork();
        if (bytesWritten === 0) {
          if (!expectsPayload && request.reset !== false) {
            socket[kReset] = true;
          }
          if (contentLength === null) {
            socket.write(`${header}transfer-encoding: chunked\r
`, "latin1");
          } else {
            socket.write(`${header}content-length: ${contentLength}\r
\r
`, "latin1");
          }
        }
        if (contentLength === null) {
          socket.write(`\r
${len.toString(16)}\r
`, "latin1");
        }
        this.bytesWritten += len;
        const ret = socket.write(chunk);
        socket.uncork();
        request.onBodySent(chunk);
        if (!ret) {
          if (socket[kParser].timeout && socket[kParser].timeoutType === TIMEOUT_HEADERS) {
            if (socket[kParser].timeout.refresh) {
              socket[kParser].timeout.refresh();
            }
          }
        }
        return ret;
      }
      /**
       * @returns {void}
       */
      end() {
        const { socket, contentLength, client, bytesWritten, expectsPayload, header, request } = this;
        request.onRequestSent();
        socket[kWriting] = false;
        if (socket[kError]) {
          throw socket[kError];
        }
        if (socket.destroyed) {
          return;
        }
        if (bytesWritten === 0) {
          if (expectsPayload) {
            socket.write(`${header}content-length: 0\r
\r
`, "latin1");
          } else {
            socket.write(`${header}\r
`, "latin1");
          }
        } else if (contentLength === null) {
          socket.write("\r\n0\r\n\r\n", "latin1");
        }
        if (contentLength !== null && bytesWritten !== contentLength) {
          if (client[kStrictContentLength]) {
            throw new RequestContentLengthMismatchError();
          } else {
            process.emitWarning(new RequestContentLengthMismatchError());
          }
        }
        if (socket[kParser].timeout && socket[kParser].timeoutType === TIMEOUT_HEADERS) {
          if (socket[kParser].timeout.refresh) {
            socket[kParser].timeout.refresh();
          }
        }
        client[kResume]();
      }
      /**
       * @param {Error} [err]
       * @returns {void}
       */
      destroy(err) {
        const { socket, client, abort } = this;
        socket[kWriting] = false;
        if (err) {
          assert(client[kRunning] <= 1, "pipeline should only contain this request");
          abort(err);
        }
      }
    };
    module2.exports = connectH1;
  }
});

// node_modules/undici/lib/dispatcher/client-h2.js
var require_client_h2 = __commonJS({
  "node_modules/undici/lib/dispatcher/client-h2.js"(exports2, module2) {
    "use strict";
    var assert = require("node:assert");
    var { pipeline } = require("node:stream");
    var util = require_util4();
    var {
      RequestContentLengthMismatchError,
      RequestAbortedError,
      SocketError,
      InformationalError
    } = require_errors5();
    var {
      kUrl,
      kReset,
      kClient,
      kRunning,
      kPending,
      kQueue,
      kPendingIdx,
      kRunningIdx,
      kError,
      kSocket,
      kStrictContentLength,
      kOnError,
      kMaxConcurrentStreams,
      kHTTP2Session,
      kResume,
      kSize,
      kHTTPContext,
      kClosed,
      kBodyTimeout
    } = require_symbols4();
    var { channels } = require_diagnostics();
    var kOpenStreams = Symbol("open streams");
    var extractBody;
    var http2;
    try {
      http2 = require("node:http2");
    } catch {
      http2 = { constants: {} };
    }
    var {
      constants: {
        HTTP2_HEADER_AUTHORITY,
        HTTP2_HEADER_METHOD,
        HTTP2_HEADER_PATH,
        HTTP2_HEADER_SCHEME,
        HTTP2_HEADER_CONTENT_LENGTH,
        HTTP2_HEADER_EXPECT,
        HTTP2_HEADER_STATUS
      }
    } = http2;
    function parseH2Headers(headers) {
      const result = [];
      for (const [name, value] of Object.entries(headers)) {
        if (Array.isArray(value)) {
          for (const subvalue of value) {
            result.push(Buffer.from(name), Buffer.from(subvalue));
          }
        } else {
          result.push(Buffer.from(name), Buffer.from(value));
        }
      }
      return result;
    }
    async function connectH2(client, socket) {
      client[kSocket] = socket;
      const session = http2.connect(client[kUrl], {
        createConnection: () => socket,
        peerMaxConcurrentStreams: client[kMaxConcurrentStreams],
        settings: {
          // TODO(metcoder95): add support for PUSH
          enablePush: false
        }
      });
      session[kOpenStreams] = 0;
      session[kClient] = client;
      session[kSocket] = socket;
      session[kHTTP2Session] = null;
      util.addListener(session, "error", onHttp2SessionError);
      util.addListener(session, "frameError", onHttp2FrameError);
      util.addListener(session, "end", onHttp2SessionEnd);
      util.addListener(session, "goaway", onHttp2SessionGoAway);
      util.addListener(session, "close", onHttp2SessionClose);
      session.unref();
      client[kHTTP2Session] = session;
      socket[kHTTP2Session] = session;
      util.addListener(socket, "error", onHttp2SocketError);
      util.addListener(socket, "end", onHttp2SocketEnd);
      util.addListener(socket, "close", onHttp2SocketClose);
      socket[kClosed] = false;
      socket.on("close", onSocketClose);
      return {
        version: "h2",
        defaultPipelining: Infinity,
        write(request) {
          return writeH2(client, request);
        },
        resume() {
          resumeH2(client);
        },
        destroy(err, callback) {
          if (socket[kClosed]) {
            queueMicrotask(callback);
          } else {
            socket.destroy(err).on("close", callback);
          }
        },
        get destroyed() {
          return socket.destroyed;
        },
        busy() {
          return false;
        }
      };
    }
    function resumeH2(client) {
      const socket = client[kSocket];
      if (socket?.destroyed === false) {
        if (client[kSize] === 0 || client[kMaxConcurrentStreams] === 0) {
          socket.unref();
          client[kHTTP2Session].unref();
        } else {
          socket.ref();
          client[kHTTP2Session].ref();
        }
      }
    }
    function onHttp2SessionError(err) {
      assert(err.code !== "ERR_TLS_CERT_ALTNAME_INVALID");
      this[kSocket][kError] = err;
      this[kClient][kOnError](err);
    }
    function onHttp2FrameError(type, code, id2) {
      if (id2 === 0) {
        const err = new InformationalError(`HTTP/2: "frameError" received - type ${type}, code ${code}`);
        this[kSocket][kError] = err;
        this[kClient][kOnError](err);
      }
    }
    function onHttp2SessionEnd() {
      const err = new SocketError("other side closed", util.getSocketInfo(this[kSocket]));
      this.destroy(err);
      util.destroy(this[kSocket], err);
    }
    function onHttp2SessionGoAway(errorCode) {
      const err = this[kError] || new SocketError(`HTTP/2: "GOAWAY" frame received with code ${errorCode}`, util.getSocketInfo(this[kSocket]));
      const client = this[kClient];
      client[kSocket] = null;
      client[kHTTPContext] = null;
      this.close();
      this[kHTTP2Session] = null;
      util.destroy(this[kSocket], err);
      if (client[kRunningIdx] < client[kQueue].length) {
        const request = client[kQueue][client[kRunningIdx]];
        client[kQueue][client[kRunningIdx]++] = null;
        util.errorRequest(client, request, err);
        client[kPendingIdx] = client[kRunningIdx];
      }
      assert(client[kRunning] === 0);
      client.emit("disconnect", client[kUrl], [client], err);
      client.emit("connectionError", client[kUrl], [client], err);
      client[kResume]();
    }
    function onHttp2SessionClose() {
      const { [kClient]: client } = this;
      const { [kSocket]: socket } = client;
      const err = this[kSocket][kError] || this[kError] || new SocketError("closed", util.getSocketInfo(socket));
      client[kSocket] = null;
      client[kHTTPContext] = null;
      if (client.destroyed) {
        assert(client[kPending] === 0);
        const requests = client[kQueue].splice(client[kRunningIdx]);
        for (let i = 0; i < requests.length; i++) {
          const request = requests[i];
          util.errorRequest(client, request, err);
        }
      }
    }
    function onHttp2SocketClose() {
      const err = this[kError] || new SocketError("closed", util.getSocketInfo(this));
      const client = this[kHTTP2Session][kClient];
      client[kSocket] = null;
      client[kHTTPContext] = null;
      if (this[kHTTP2Session] !== null) {
        this[kHTTP2Session].destroy(err);
      }
      client[kPendingIdx] = client[kRunningIdx];
      assert(client[kRunning] === 0);
      client.emit("disconnect", client[kUrl], [client], err);
      client[kResume]();
    }
    function onHttp2SocketError(err) {
      assert(err.code !== "ERR_TLS_CERT_ALTNAME_INVALID");
      this[kError] = err;
      this[kClient][kOnError](err);
    }
    function onHttp2SocketEnd() {
      util.destroy(this, new SocketError("other side closed", util.getSocketInfo(this)));
    }
    function onSocketClose() {
      this[kClosed] = true;
    }
    function shouldSendContentLength(method) {
      return method !== "GET" && method !== "HEAD" && method !== "OPTIONS" && method !== "TRACE" && method !== "CONNECT";
    }
    function writeH2(client, request) {
      const requestTimeout = request.bodyTimeout ?? client[kBodyTimeout];
      const session = client[kHTTP2Session];
      const { method, path: path4, host, upgrade, expectContinue, signal, headers: reqHeaders } = request;
      let { body } = request;
      if (upgrade) {
        util.errorRequest(client, request, new Error("Upgrade not supported for H2"));
        return false;
      }
      const headers = {};
      for (let n = 0; n < reqHeaders.length; n += 2) {
        const key = reqHeaders[n + 0];
        const val = reqHeaders[n + 1];
        if (Array.isArray(val)) {
          for (let i = 0; i < val.length; i++) {
            if (headers[key]) {
              headers[key] += `, ${val[i]}`;
            } else {
              headers[key] = val[i];
            }
          }
        } else if (headers[key]) {
          headers[key] += `, ${val}`;
        } else {
          headers[key] = val;
        }
      }
      let stream = null;
      const { hostname, port } = client[kUrl];
      headers[HTTP2_HEADER_AUTHORITY] = host || `${hostname}${port ? `:${port}` : ""}`;
      headers[HTTP2_HEADER_METHOD] = method;
      const abort = (err) => {
        if (request.aborted || request.completed) {
          return;
        }
        err = err || new RequestAbortedError();
        util.errorRequest(client, request, err);
        if (stream != null) {
          stream.removeAllListeners("data");
          stream.close();
          client[kOnError](err);
          client[kResume]();
        }
        util.destroy(body, err);
      };
      try {
        request.onConnect(abort);
      } catch (err) {
        util.errorRequest(client, request, err);
      }
      if (request.aborted) {
        return false;
      }
      if (method === "CONNECT") {
        session.ref();
        stream = session.request(headers, { endStream: false, signal });
        if (!stream.pending) {
          request.onUpgrade(null, null, stream);
          ++session[kOpenStreams];
          client[kQueue][client[kRunningIdx]++] = null;
        } else {
          stream.once("ready", () => {
            request.onUpgrade(null, null, stream);
            ++session[kOpenStreams];
            client[kQueue][client[kRunningIdx]++] = null;
          });
        }
        stream.once("close", () => {
          session[kOpenStreams] -= 1;
          if (session[kOpenStreams] === 0) session.unref();
        });
        stream.setTimeout(requestTimeout);
        return true;
      }
      headers[HTTP2_HEADER_PATH] = path4;
      headers[HTTP2_HEADER_SCHEME] = "https";
      const expectsPayload = method === "PUT" || method === "POST" || method === "PATCH";
      if (body && typeof body.read === "function") {
        body.read(0);
      }
      let contentLength = util.bodyLength(body);
      if (util.isFormDataLike(body)) {
        extractBody ??= require_body().extractBody;
        const [bodyStream, contentType] = extractBody(body);
        headers["content-type"] = contentType;
        body = bodyStream.stream;
        contentLength = bodyStream.length;
      }
      if (contentLength == null) {
        contentLength = request.contentLength;
      }
      if (contentLength === 0 || !expectsPayload) {
        contentLength = null;
      }
      if (shouldSendContentLength(method) && contentLength > 0 && request.contentLength != null && request.contentLength !== contentLength) {
        if (client[kStrictContentLength]) {
          util.errorRequest(client, request, new RequestContentLengthMismatchError());
          return false;
        }
        process.emitWarning(new RequestContentLengthMismatchError());
      }
      if (contentLength != null) {
        assert(body, "no body must not have content length");
        headers[HTTP2_HEADER_CONTENT_LENGTH] = `${contentLength}`;
      }
      session.ref();
      if (channels.sendHeaders.hasSubscribers) {
        let header = "";
        for (const key in headers) {
          header += `${key}: ${headers[key]}\r
`;
        }
        channels.sendHeaders.publish({ request, headers: header, socket: session[kSocket] });
      }
      const shouldEndStream = method === "GET" || method === "HEAD" || body === null;
      if (expectContinue) {
        headers[HTTP2_HEADER_EXPECT] = "100-continue";
        stream = session.request(headers, { endStream: shouldEndStream, signal });
        stream.once("continue", writeBodyH2);
      } else {
        stream = session.request(headers, {
          endStream: shouldEndStream,
          signal
        });
        writeBodyH2();
      }
      ++session[kOpenStreams];
      stream.setTimeout(requestTimeout);
      stream.once("response", (headers2) => {
        const { [HTTP2_HEADER_STATUS]: statusCode, ...realHeaders } = headers2;
        request.onResponseStarted();
        if (request.aborted) {
          stream.removeAllListeners("data");
          return;
        }
        if (request.onHeaders(Number(statusCode), parseH2Headers(realHeaders), stream.resume.bind(stream), "") === false) {
          stream.pause();
        }
      });
      stream.on("data", (chunk) => {
        if (request.onData(chunk) === false) {
          stream.pause();
        }
      });
      stream.once("end", (err) => {
        stream.removeAllListeners("data");
        if (stream.state?.state == null || stream.state.state < 6) {
          if (!request.aborted && !request.completed) {
            request.onComplete({});
          }
          client[kQueue][client[kRunningIdx]++] = null;
          client[kResume]();
        } else {
          --session[kOpenStreams];
          if (session[kOpenStreams] === 0) {
            session.unref();
          }
          abort(err ?? new InformationalError("HTTP/2: stream half-closed (remote)"));
          client[kQueue][client[kRunningIdx]++] = null;
          client[kPendingIdx] = client[kRunningIdx];
          client[kResume]();
        }
      });
      stream.once("close", () => {
        stream.removeAllListeners("data");
        session[kOpenStreams] -= 1;
        if (session[kOpenStreams] === 0) {
          session.unref();
        }
      });
      stream.once("error", function(err) {
        stream.removeAllListeners("data");
        abort(err);
      });
      stream.once("frameError", (type, code) => {
        stream.removeAllListeners("data");
        abort(new InformationalError(`HTTP/2: "frameError" received - type ${type}, code ${code}`));
      });
      stream.on("aborted", () => {
        stream.removeAllListeners("data");
      });
      stream.on("timeout", () => {
        const err = new InformationalError(`HTTP/2: "stream timeout after ${requestTimeout}"`);
        stream.removeAllListeners("data");
        session[kOpenStreams] -= 1;
        if (session[kOpenStreams] === 0) {
          session.unref();
        }
        abort(err);
      });
      stream.once("trailers", (trailers) => {
        if (request.aborted || request.completed) {
          return;
        }
        request.onComplete(trailers);
      });
      return true;
      function writeBodyH2() {
        if (!body || contentLength === 0) {
          writeBuffer(
            abort,
            stream,
            null,
            client,
            request,
            client[kSocket],
            contentLength,
            expectsPayload
          );
        } else if (util.isBuffer(body)) {
          writeBuffer(
            abort,
            stream,
            body,
            client,
            request,
            client[kSocket],
            contentLength,
            expectsPayload
          );
        } else if (util.isBlobLike(body)) {
          if (typeof body.stream === "function") {
            writeIterable(
              abort,
              stream,
              body.stream(),
              client,
              request,
              client[kSocket],
              contentLength,
              expectsPayload
            );
          } else {
            writeBlob(
              abort,
              stream,
              body,
              client,
              request,
              client[kSocket],
              contentLength,
              expectsPayload
            );
          }
        } else if (util.isStream(body)) {
          writeStream(
            abort,
            client[kSocket],
            expectsPayload,
            stream,
            body,
            client,
            request,
            contentLength
          );
        } else if (util.isIterable(body)) {
          writeIterable(
            abort,
            stream,
            body,
            client,
            request,
            client[kSocket],
            contentLength,
            expectsPayload
          );
        } else {
          assert(false);
        }
      }
    }
    function writeBuffer(abort, h2stream, body, client, request, socket, contentLength, expectsPayload) {
      try {
        if (body != null && util.isBuffer(body)) {
          assert(contentLength === body.byteLength, "buffer body must have content length");
          h2stream.cork();
          h2stream.write(body);
          h2stream.uncork();
          h2stream.end();
          request.onBodySent(body);
        }
        if (!expectsPayload) {
          socket[kReset] = true;
        }
        request.onRequestSent();
        client[kResume]();
      } catch (error) {
        abort(error);
      }
    }
    function writeStream(abort, socket, expectsPayload, h2stream, body, client, request, contentLength) {
      assert(contentLength !== 0 || client[kRunning] === 0, "stream body cannot be pipelined");
      const pipe = pipeline(
        body,
        h2stream,
        (err) => {
          if (err) {
            util.destroy(pipe, err);
            abort(err);
          } else {
            util.removeAllListeners(pipe);
            request.onRequestSent();
            if (!expectsPayload) {
              socket[kReset] = true;
            }
            client[kResume]();
          }
        }
      );
      util.addListener(pipe, "data", onPipeData);
      function onPipeData(chunk) {
        request.onBodySent(chunk);
      }
    }
    async function writeBlob(abort, h2stream, body, client, request, socket, contentLength, expectsPayload) {
      assert(contentLength === body.size, "blob body must have content length");
      try {
        if (contentLength != null && contentLength !== body.size) {
          throw new RequestContentLengthMismatchError();
        }
        const buffer = Buffer.from(await body.arrayBuffer());
        h2stream.cork();
        h2stream.write(buffer);
        h2stream.uncork();
        h2stream.end();
        request.onBodySent(buffer);
        request.onRequestSent();
        if (!expectsPayload) {
          socket[kReset] = true;
        }
        client[kResume]();
      } catch (err) {
        abort(err);
      }
    }
    async function writeIterable(abort, h2stream, body, client, request, socket, contentLength, expectsPayload) {
      assert(contentLength !== 0 || client[kRunning] === 0, "iterator body cannot be pipelined");
      let callback = null;
      function onDrain() {
        if (callback) {
          const cb = callback;
          callback = null;
          cb();
        }
      }
      const waitForDrain = () => new Promise((resolve, reject) => {
        assert(callback === null);
        if (socket[kError]) {
          reject(socket[kError]);
        } else {
          callback = resolve;
        }
      });
      h2stream.on("close", onDrain).on("drain", onDrain);
      try {
        for await (const chunk of body) {
          if (socket[kError]) {
            throw socket[kError];
          }
          const res = h2stream.write(chunk);
          request.onBodySent(chunk);
          if (!res) {
            await waitForDrain();
          }
        }
        h2stream.end();
        request.onRequestSent();
        if (!expectsPayload) {
          socket[kReset] = true;
        }
        client[kResume]();
      } catch (err) {
        abort(err);
      } finally {
        h2stream.off("close", onDrain).off("drain", onDrain);
      }
    }
    module2.exports = connectH2;
  }
});

// node_modules/undici/lib/dispatcher/client.js
var require_client = __commonJS({
  "node_modules/undici/lib/dispatcher/client.js"(exports2, module2) {
    "use strict";
    var assert = require("node:assert");
    var net = require("node:net");
    var http = require("node:http");
    var util = require_util4();
    var { ClientStats } = require_stats();
    var { channels } = require_diagnostics();
    var Request = require_request3();
    var DispatcherBase = require_dispatcher_base();
    var {
      InvalidArgumentError,
      InformationalError,
      ClientDestroyedError
    } = require_errors5();
    var buildConnector = require_connect();
    var {
      kUrl,
      kServerName,
      kClient,
      kBusy,
      kConnect,
      kResuming,
      kRunning,
      kPending,
      kSize,
      kQueue,
      kConnected,
      kConnecting,
      kNeedDrain,
      kKeepAliveDefaultTimeout,
      kHostHeader,
      kPendingIdx,
      kRunningIdx,
      kError,
      kPipelining,
      kKeepAliveTimeoutValue,
      kMaxHeadersSize,
      kKeepAliveMaxTimeout,
      kKeepAliveTimeoutThreshold,
      kHeadersTimeout,
      kBodyTimeout,
      kStrictContentLength,
      kConnector,
      kMaxRequests,
      kCounter,
      kClose,
      kDestroy,
      kDispatch,
      kLocalAddress,
      kMaxResponseSize,
      kOnError,
      kHTTPContext,
      kMaxConcurrentStreams,
      kResume
    } = require_symbols4();
    var connectH1 = require_client_h1();
    var connectH2 = require_client_h2();
    var kClosedResolve = Symbol("kClosedResolve");
    var getDefaultNodeMaxHeaderSize = http && http.maxHeaderSize && Number.isInteger(http.maxHeaderSize) && http.maxHeaderSize > 0 ? () => http.maxHeaderSize : () => {
      throw new InvalidArgumentError("http module not available or http.maxHeaderSize invalid");
    };
    var noop = () => {
    };
    function getPipelining(client) {
      return client[kPipelining] ?? client[kHTTPContext]?.defaultPipelining ?? 1;
    }
    var Client = class extends DispatcherBase {
      /**
       *
       * @param {string|URL} url
       * @param {import('../../types/client.js').Client.Options} options
       */
      constructor(url, {
        maxHeaderSize,
        headersTimeout,
        socketTimeout,
        requestTimeout,
        connectTimeout,
        bodyTimeout,
        idleTimeout,
        keepAlive,
        keepAliveTimeout,
        maxKeepAliveTimeout,
        keepAliveMaxTimeout,
        keepAliveTimeoutThreshold,
        socketPath,
        pipelining,
        tls,
        strictContentLength,
        maxCachedSessions,
        connect: connect2,
        maxRequestsPerClient,
        localAddress,
        maxResponseSize,
        autoSelectFamily,
        autoSelectFamilyAttemptTimeout,
        // h2
        maxConcurrentStreams,
        allowH2
      } = {}) {
        if (keepAlive !== void 0) {
          throw new InvalidArgumentError("unsupported keepAlive, use pipelining=0 instead");
        }
        if (socketTimeout !== void 0) {
          throw new InvalidArgumentError("unsupported socketTimeout, use headersTimeout & bodyTimeout instead");
        }
        if (requestTimeout !== void 0) {
          throw new InvalidArgumentError("unsupported requestTimeout, use headersTimeout & bodyTimeout instead");
        }
        if (idleTimeout !== void 0) {
          throw new InvalidArgumentError("unsupported idleTimeout, use keepAliveTimeout instead");
        }
        if (maxKeepAliveTimeout !== void 0) {
          throw new InvalidArgumentError("unsupported maxKeepAliveTimeout, use keepAliveMaxTimeout instead");
        }
        if (maxHeaderSize != null) {
          if (!Number.isInteger(maxHeaderSize) || maxHeaderSize < 1) {
            throw new InvalidArgumentError("invalid maxHeaderSize");
          }
        } else {
          maxHeaderSize = getDefaultNodeMaxHeaderSize();
        }
        if (socketPath != null && typeof socketPath !== "string") {
          throw new InvalidArgumentError("invalid socketPath");
        }
        if (connectTimeout != null && (!Number.isFinite(connectTimeout) || connectTimeout < 0)) {
          throw new InvalidArgumentError("invalid connectTimeout");
        }
        if (keepAliveTimeout != null && (!Number.isFinite(keepAliveTimeout) || keepAliveTimeout <= 0)) {
          throw new InvalidArgumentError("invalid keepAliveTimeout");
        }
        if (keepAliveMaxTimeout != null && (!Number.isFinite(keepAliveMaxTimeout) || keepAliveMaxTimeout <= 0)) {
          throw new InvalidArgumentError("invalid keepAliveMaxTimeout");
        }
        if (keepAliveTimeoutThreshold != null && !Number.isFinite(keepAliveTimeoutThreshold)) {
          throw new InvalidArgumentError("invalid keepAliveTimeoutThreshold");
        }
        if (headersTimeout != null && (!Number.isInteger(headersTimeout) || headersTimeout < 0)) {
          throw new InvalidArgumentError("headersTimeout must be a positive integer or zero");
        }
        if (bodyTimeout != null && (!Number.isInteger(bodyTimeout) || bodyTimeout < 0)) {
          throw new InvalidArgumentError("bodyTimeout must be a positive integer or zero");
        }
        if (connect2 != null && typeof connect2 !== "function" && typeof connect2 !== "object") {
          throw new InvalidArgumentError("connect must be a function or an object");
        }
        if (maxRequestsPerClient != null && (!Number.isInteger(maxRequestsPerClient) || maxRequestsPerClient < 0)) {
          throw new InvalidArgumentError("maxRequestsPerClient must be a positive number");
        }
        if (localAddress != null && (typeof localAddress !== "string" || net.isIP(localAddress) === 0)) {
          throw new InvalidArgumentError("localAddress must be valid string IP address");
        }
        if (maxResponseSize != null && (!Number.isInteger(maxResponseSize) || maxResponseSize < -1)) {
          throw new InvalidArgumentError("maxResponseSize must be a positive number");
        }
        if (autoSelectFamilyAttemptTimeout != null && (!Number.isInteger(autoSelectFamilyAttemptTimeout) || autoSelectFamilyAttemptTimeout < -1)) {
          throw new InvalidArgumentError("autoSelectFamilyAttemptTimeout must be a positive number");
        }
        if (allowH2 != null && typeof allowH2 !== "boolean") {
          throw new InvalidArgumentError("allowH2 must be a valid boolean value");
        }
        if (maxConcurrentStreams != null && (typeof maxConcurrentStreams !== "number" || maxConcurrentStreams < 1)) {
          throw new InvalidArgumentError("maxConcurrentStreams must be a positive integer, greater than 0");
        }
        super();
        if (typeof connect2 !== "function") {
          connect2 = buildConnector({
            ...tls,
            maxCachedSessions,
            allowH2,
            socketPath,
            timeout: connectTimeout,
            ...typeof autoSelectFamily === "boolean" ? { autoSelectFamily, autoSelectFamilyAttemptTimeout } : void 0,
            ...connect2
          });
        }
        this[kUrl] = util.parseOrigin(url);
        this[kConnector] = connect2;
        this[kPipelining] = pipelining != null ? pipelining : 1;
        this[kMaxHeadersSize] = maxHeaderSize;
        this[kKeepAliveDefaultTimeout] = keepAliveTimeout == null ? 4e3 : keepAliveTimeout;
        this[kKeepAliveMaxTimeout] = keepAliveMaxTimeout == null ? 6e5 : keepAliveMaxTimeout;
        this[kKeepAliveTimeoutThreshold] = keepAliveTimeoutThreshold == null ? 2e3 : keepAliveTimeoutThreshold;
        this[kKeepAliveTimeoutValue] = this[kKeepAliveDefaultTimeout];
        this[kServerName] = null;
        this[kLocalAddress] = localAddress != null ? localAddress : null;
        this[kResuming] = 0;
        this[kNeedDrain] = 0;
        this[kHostHeader] = `host: ${this[kUrl].hostname}${this[kUrl].port ? `:${this[kUrl].port}` : ""}\r
`;
        this[kBodyTimeout] = bodyTimeout != null ? bodyTimeout : 3e5;
        this[kHeadersTimeout] = headersTimeout != null ? headersTimeout : 3e5;
        this[kStrictContentLength] = strictContentLength == null ? true : strictContentLength;
        this[kMaxRequests] = maxRequestsPerClient;
        this[kClosedResolve] = null;
        this[kMaxResponseSize] = maxResponseSize > -1 ? maxResponseSize : -1;
        this[kMaxConcurrentStreams] = maxConcurrentStreams != null ? maxConcurrentStreams : 100;
        this[kHTTPContext] = null;
        this[kQueue] = [];
        this[kRunningIdx] = 0;
        this[kPendingIdx] = 0;
        this[kResume] = (sync) => resume(this, sync);
        this[kOnError] = (err) => onError(this, err);
      }
      get pipelining() {
        return this[kPipelining];
      }
      set pipelining(value) {
        this[kPipelining] = value;
        this[kResume](true);
      }
      get stats() {
        return new ClientStats(this);
      }
      get [kPending]() {
        return this[kQueue].length - this[kPendingIdx];
      }
      get [kRunning]() {
        return this[kPendingIdx] - this[kRunningIdx];
      }
      get [kSize]() {
        return this[kQueue].length - this[kRunningIdx];
      }
      get [kConnected]() {
        return !!this[kHTTPContext] && !this[kConnecting] && !this[kHTTPContext].destroyed;
      }
      get [kBusy]() {
        return Boolean(
          this[kHTTPContext]?.busy(null) || this[kSize] >= (getPipelining(this) || 1) || this[kPending] > 0
        );
      }
      /* istanbul ignore: only used for test */
      [kConnect](cb) {
        connect(this);
        this.once("connect", cb);
      }
      [kDispatch](opts, handler) {
        const origin = opts.origin || this[kUrl].origin;
        const request = new Request(origin, opts, handler);
        this[kQueue].push(request);
        if (this[kResuming]) {
        } else if (util.bodyLength(request.body) == null && util.isIterable(request.body)) {
          this[kResuming] = 1;
          queueMicrotask(() => resume(this));
        } else {
          this[kResume](true);
        }
        if (this[kResuming] && this[kNeedDrain] !== 2 && this[kBusy]) {
          this[kNeedDrain] = 2;
        }
        return this[kNeedDrain] < 2;
      }
      async [kClose]() {
        return new Promise((resolve) => {
          if (this[kSize]) {
            this[kClosedResolve] = resolve;
          } else {
            resolve(null);
          }
        });
      }
      async [kDestroy](err) {
        return new Promise((resolve) => {
          const requests = this[kQueue].splice(this[kPendingIdx]);
          for (let i = 0; i < requests.length; i++) {
            const request = requests[i];
            util.errorRequest(this, request, err);
          }
          const callback = () => {
            if (this[kClosedResolve]) {
              this[kClosedResolve]();
              this[kClosedResolve] = null;
            }
            resolve(null);
          };
          if (this[kHTTPContext]) {
            this[kHTTPContext].destroy(err, callback);
            this[kHTTPContext] = null;
          } else {
            queueMicrotask(callback);
          }
          this[kResume]();
        });
      }
    };
    function onError(client, err) {
      if (client[kRunning] === 0 && err.code !== "UND_ERR_INFO" && err.code !== "UND_ERR_SOCKET") {
        assert(client[kPendingIdx] === client[kRunningIdx]);
        const requests = client[kQueue].splice(client[kRunningIdx]);
        for (let i = 0; i < requests.length; i++) {
          const request = requests[i];
          util.errorRequest(client, request, err);
        }
        assert(client[kSize] === 0);
      }
    }
    async function connect(client) {
      assert(!client[kConnecting]);
      assert(!client[kHTTPContext]);
      let { host, hostname, protocol, port } = client[kUrl];
      if (hostname[0] === "[") {
        const idx = hostname.indexOf("]");
        assert(idx !== -1);
        const ip = hostname.substring(1, idx);
        assert(net.isIPv6(ip));
        hostname = ip;
      }
      client[kConnecting] = true;
      if (channels.beforeConnect.hasSubscribers) {
        channels.beforeConnect.publish({
          connectParams: {
            host,
            hostname,
            protocol,
            port,
            version: client[kHTTPContext]?.version,
            servername: client[kServerName],
            localAddress: client[kLocalAddress]
          },
          connector: client[kConnector]
        });
      }
      try {
        const socket = await new Promise((resolve, reject) => {
          client[kConnector]({
            host,
            hostname,
            protocol,
            port,
            servername: client[kServerName],
            localAddress: client[kLocalAddress]
          }, (err, socket2) => {
            if (err) {
              reject(err);
            } else {
              resolve(socket2);
            }
          });
        });
        if (client.destroyed) {
          util.destroy(socket.on("error", noop), new ClientDestroyedError());
          return;
        }
        assert(socket);
        try {
          client[kHTTPContext] = socket.alpnProtocol === "h2" ? await connectH2(client, socket) : await connectH1(client, socket);
        } catch (err) {
          socket.destroy().on("error", noop);
          throw err;
        }
        client[kConnecting] = false;
        socket[kCounter] = 0;
        socket[kMaxRequests] = client[kMaxRequests];
        socket[kClient] = client;
        socket[kError] = null;
        if (channels.connected.hasSubscribers) {
          channels.connected.publish({
            connectParams: {
              host,
              hostname,
              protocol,
              port,
              version: client[kHTTPContext]?.version,
              servername: client[kServerName],
              localAddress: client[kLocalAddress]
            },
            connector: client[kConnector],
            socket
          });
        }
        client.emit("connect", client[kUrl], [client]);
      } catch (err) {
        if (client.destroyed) {
          return;
        }
        client[kConnecting] = false;
        if (channels.connectError.hasSubscribers) {
          channels.connectError.publish({
            connectParams: {
              host,
              hostname,
              protocol,
              port,
              version: client[kHTTPContext]?.version,
              servername: client[kServerName],
              localAddress: client[kLocalAddress]
            },
            connector: client[kConnector],
            error: err
          });
        }
        if (err.code === "ERR_TLS_CERT_ALTNAME_INVALID") {
          assert(client[kRunning] === 0);
          while (client[kPending] > 0 && client[kQueue][client[kPendingIdx]].servername === client[kServerName]) {
            const request = client[kQueue][client[kPendingIdx]++];
            util.errorRequest(client, request, err);
          }
        } else {
          onError(client, err);
        }
        client.emit("connectionError", client[kUrl], [client], err);
      }
      client[kResume]();
    }
    function emitDrain(client) {
      client[kNeedDrain] = 0;
      client.emit("drain", client[kUrl], [client]);
    }
    function resume(client, sync) {
      if (client[kResuming] === 2) {
        return;
      }
      client[kResuming] = 2;
      _resume(client, sync);
      client[kResuming] = 0;
      if (client[kRunningIdx] > 256) {
        client[kQueue].splice(0, client[kRunningIdx]);
        client[kPendingIdx] -= client[kRunningIdx];
        client[kRunningIdx] = 0;
      }
    }
    function _resume(client, sync) {
      while (true) {
        if (client.destroyed) {
          assert(client[kPending] === 0);
          return;
        }
        if (client[kClosedResolve] && !client[kSize]) {
          client[kClosedResolve]();
          client[kClosedResolve] = null;
          return;
        }
        if (client[kHTTPContext]) {
          client[kHTTPContext].resume();
        }
        if (client[kBusy]) {
          client[kNeedDrain] = 2;
        } else if (client[kNeedDrain] === 2) {
          if (sync) {
            client[kNeedDrain] = 1;
            queueMicrotask(() => emitDrain(client));
          } else {
            emitDrain(client);
          }
          continue;
        }
        if (client[kPending] === 0) {
          return;
        }
        if (client[kRunning] >= (getPipelining(client) || 1)) {
          return;
        }
        const request = client[kQueue][client[kPendingIdx]];
        if (client[kUrl].protocol === "https:" && client[kServerName] !== request.servername) {
          if (client[kRunning] > 0) {
            return;
          }
          client[kServerName] = request.servername;
          client[kHTTPContext]?.destroy(new InformationalError("servername changed"), () => {
            client[kHTTPContext] = null;
            resume(client);
          });
        }
        if (client[kConnecting]) {
          return;
        }
        if (!client[kHTTPContext]) {
          connect(client);
          return;
        }
        if (client[kHTTPContext].destroyed) {
          return;
        }
        if (client[kHTTPContext].busy(request)) {
          return;
        }
        if (!request.aborted && client[kHTTPContext].write(request)) {
          client[kPendingIdx]++;
        } else {
          client[kQueue].splice(client[kPendingIdx], 1);
        }
      }
    }
    module2.exports = Client;
  }
});

// node_modules/undici/lib/dispatcher/fixed-queue.js
var require_fixed_queue = __commonJS({
  "node_modules/undici/lib/dispatcher/fixed-queue.js"(exports2, module2) {
    "use strict";
    var kSize = 2048;
    var kMask = kSize - 1;
    var FixedCircularBuffer = class {
      constructor() {
        this.bottom = 0;
        this.top = 0;
        this.list = new Array(kSize).fill(void 0);
        this.next = null;
      }
      /**
       * @returns {boolean}
       */
      isEmpty() {
        return this.top === this.bottom;
      }
      /**
       * @returns {boolean}
       */
      isFull() {
        return (this.top + 1 & kMask) === this.bottom;
      }
      /**
       * @param {T} data
       * @returns {void}
       */
      push(data) {
        this.list[this.top] = data;
        this.top = this.top + 1 & kMask;
      }
      /**
       * @returns {T|null}
       */
      shift() {
        const nextItem = this.list[this.bottom];
        if (nextItem === void 0) {
          return null;
        }
        this.list[this.bottom] = void 0;
        this.bottom = this.bottom + 1 & kMask;
        return nextItem;
      }
    };
    module2.exports = class FixedQueue {
      constructor() {
        this.head = this.tail = new FixedCircularBuffer();
      }
      /**
       * @returns {boolean}
       */
      isEmpty() {
        return this.head.isEmpty();
      }
      /**
       * @param {T} data
       */
      push(data) {
        if (this.head.isFull()) {
          this.head = this.head.next = new FixedCircularBuffer();
        }
        this.head.push(data);
      }
      /**
       * @returns {T|null}
       */
      shift() {
        const tail = this.tail;
        const next = tail.shift();
        if (tail.isEmpty() && tail.next !== null) {
          this.tail = tail.next;
          tail.next = null;
        }
        return next;
      }
    };
  }
});

// node_modules/undici/lib/dispatcher/pool-base.js
var require_pool_base = __commonJS({
  "node_modules/undici/lib/dispatcher/pool-base.js"(exports2, module2) {
    "use strict";
    var { PoolStats } = require_stats();
    var DispatcherBase = require_dispatcher_base();
    var FixedQueue = require_fixed_queue();
    var { kConnected, kSize, kRunning, kPending, kQueued, kBusy, kFree, kUrl, kClose, kDestroy, kDispatch } = require_symbols4();
    var kClients = Symbol("clients");
    var kNeedDrain = Symbol("needDrain");
    var kQueue = Symbol("queue");
    var kClosedResolve = Symbol("closed resolve");
    var kOnDrain = Symbol("onDrain");
    var kOnConnect = Symbol("onConnect");
    var kOnDisconnect = Symbol("onDisconnect");
    var kOnConnectionError = Symbol("onConnectionError");
    var kGetDispatcher = Symbol("get dispatcher");
    var kAddClient = Symbol("add client");
    var kRemoveClient = Symbol("remove client");
    var PoolBase = class extends DispatcherBase {
      constructor() {
        super();
        this[kQueue] = new FixedQueue();
        this[kClients] = [];
        this[kQueued] = 0;
        const pool = this;
        this[kOnDrain] = function onDrain(origin, targets) {
          const queue = pool[kQueue];
          let needDrain = false;
          while (!needDrain) {
            const item = queue.shift();
            if (!item) {
              break;
            }
            pool[kQueued]--;
            needDrain = !this.dispatch(item.opts, item.handler);
          }
          this[kNeedDrain] = needDrain;
          if (!this[kNeedDrain] && pool[kNeedDrain]) {
            pool[kNeedDrain] = false;
            pool.emit("drain", origin, [pool, ...targets]);
          }
          if (pool[kClosedResolve] && queue.isEmpty()) {
            Promise.all(pool[kClients].map((c) => c.close())).then(pool[kClosedResolve]);
          }
        };
        this[kOnConnect] = (origin, targets) => {
          pool.emit("connect", origin, [pool, ...targets]);
        };
        this[kOnDisconnect] = (origin, targets, err) => {
          pool.emit("disconnect", origin, [pool, ...targets], err);
        };
        this[kOnConnectionError] = (origin, targets, err) => {
          pool.emit("connectionError", origin, [pool, ...targets], err);
        };
      }
      get [kBusy]() {
        return this[kNeedDrain];
      }
      get [kConnected]() {
        return this[kClients].filter((client) => client[kConnected]).length;
      }
      get [kFree]() {
        return this[kClients].filter((client) => client[kConnected] && !client[kNeedDrain]).length;
      }
      get [kPending]() {
        let ret = this[kQueued];
        for (const { [kPending]: pending } of this[kClients]) {
          ret += pending;
        }
        return ret;
      }
      get [kRunning]() {
        let ret = 0;
        for (const { [kRunning]: running } of this[kClients]) {
          ret += running;
        }
        return ret;
      }
      get [kSize]() {
        let ret = this[kQueued];
        for (const { [kSize]: size } of this[kClients]) {
          ret += size;
        }
        return ret;
      }
      get stats() {
        return new PoolStats(this);
      }
      async [kClose]() {
        if (this[kQueue].isEmpty()) {
          await Promise.all(this[kClients].map((c) => c.close()));
        } else {
          await new Promise((resolve) => {
            this[kClosedResolve] = resolve;
          });
        }
      }
      async [kDestroy](err) {
        while (true) {
          const item = this[kQueue].shift();
          if (!item) {
            break;
          }
          item.handler.onError(err);
        }
        await Promise.all(this[kClients].map((c) => c.destroy(err)));
      }
      [kDispatch](opts, handler) {
        const dispatcher = this[kGetDispatcher]();
        if (!dispatcher) {
          this[kNeedDrain] = true;
          this[kQueue].push({ opts, handler });
          this[kQueued]++;
        } else if (!dispatcher.dispatch(opts, handler)) {
          dispatcher[kNeedDrain] = true;
          this[kNeedDrain] = !this[kGetDispatcher]();
        }
        return !this[kNeedDrain];
      }
      [kAddClient](client) {
        client.on("drain", this[kOnDrain]).on("connect", this[kOnConnect]).on("disconnect", this[kOnDisconnect]).on("connectionError", this[kOnConnectionError]);
        this[kClients].push(client);
        if (this[kNeedDrain]) {
          queueMicrotask(() => {
            if (this[kNeedDrain]) {
              this[kOnDrain](client[kUrl], [this, client]);
            }
          });
        }
        return this;
      }
      [kRemoveClient](client) {
        client.close(() => {
          const idx = this[kClients].indexOf(client);
          if (idx !== -1) {
            this[kClients].splice(idx, 1);
          }
        });
        this[kNeedDrain] = this[kClients].some((dispatcher) => !dispatcher[kNeedDrain] && dispatcher.closed !== true && dispatcher.destroyed !== true);
      }
    };
    module2.exports = {
      PoolBase,
      kClients,
      kNeedDrain,
      kAddClient,
      kRemoveClient,
      kGetDispatcher
    };
  }
});

// node_modules/undici/lib/dispatcher/pool.js
var require_pool = __commonJS({
  "node_modules/undici/lib/dispatcher/pool.js"(exports2, module2) {
    "use strict";
    var {
      PoolBase,
      kClients,
      kNeedDrain,
      kAddClient,
      kGetDispatcher,
      kRemoveClient
    } = require_pool_base();
    var Client = require_client();
    var {
      InvalidArgumentError
    } = require_errors5();
    var util = require_util4();
    var { kUrl } = require_symbols4();
    var buildConnector = require_connect();
    var kOptions = Symbol("options");
    var kConnections = Symbol("connections");
    var kFactory = Symbol("factory");
    function defaultFactory(origin, opts) {
      return new Client(origin, opts);
    }
    var Pool = class extends PoolBase {
      constructor(origin, {
        connections,
        factory = defaultFactory,
        connect,
        connectTimeout,
        tls,
        maxCachedSessions,
        socketPath,
        autoSelectFamily,
        autoSelectFamilyAttemptTimeout,
        allowH2,
        clientTtl,
        ...options
      } = {}) {
        if (connections != null && (!Number.isFinite(connections) || connections < 0)) {
          throw new InvalidArgumentError("invalid connections");
        }
        if (typeof factory !== "function") {
          throw new InvalidArgumentError("factory must be a function.");
        }
        if (connect != null && typeof connect !== "function" && typeof connect !== "object") {
          throw new InvalidArgumentError("connect must be a function or an object");
        }
        super();
        if (typeof connect !== "function") {
          connect = buildConnector({
            ...tls,
            maxCachedSessions,
            allowH2,
            socketPath,
            timeout: connectTimeout,
            ...typeof autoSelectFamily === "boolean" ? { autoSelectFamily, autoSelectFamilyAttemptTimeout } : void 0,
            ...connect
          });
        }
        this[kConnections] = connections || null;
        this[kUrl] = util.parseOrigin(origin);
        this[kOptions] = { ...util.deepClone(options), connect, allowH2, clientTtl };
        this[kOptions].interceptors = options.interceptors ? { ...options.interceptors } : void 0;
        this[kFactory] = factory;
        this.on("connect", (origin2, targets) => {
          if (clientTtl != null && clientTtl > 0) {
            for (const target of targets) {
              Object.assign(target, { ttl: Date.now() });
            }
          }
        });
        this.on("connectionError", (origin2, targets, error) => {
          for (const target of targets) {
            const idx = this[kClients].indexOf(target);
            if (idx !== -1) {
              this[kClients].splice(idx, 1);
            }
          }
        });
      }
      [kGetDispatcher]() {
        const clientTtlOption = this[kOptions].clientTtl;
        for (const client of this[kClients]) {
          if (clientTtlOption != null && clientTtlOption > 0 && client.ttl && Date.now() - client.ttl > clientTtlOption) {
            this[kRemoveClient](client);
          } else if (!client[kNeedDrain]) {
            return client;
          }
        }
        if (!this[kConnections] || this[kClients].length < this[kConnections]) {
          const dispatcher = this[kFactory](this[kUrl], this[kOptions]);
          this[kAddClient](dispatcher);
          return dispatcher;
        }
      }
    };
    module2.exports = Pool;
  }
});

// node_modules/undici/lib/dispatcher/balanced-pool.js
var require_balanced_pool = __commonJS({
  "node_modules/undici/lib/dispatcher/balanced-pool.js"(exports2, module2) {
    "use strict";
    var {
      BalancedPoolMissingUpstreamError,
      InvalidArgumentError
    } = require_errors5();
    var {
      PoolBase,
      kClients,
      kNeedDrain,
      kAddClient,
      kRemoveClient,
      kGetDispatcher
    } = require_pool_base();
    var Pool = require_pool();
    var { kUrl } = require_symbols4();
    var { parseOrigin } = require_util4();
    var kFactory = Symbol("factory");
    var kOptions = Symbol("options");
    var kGreatestCommonDivisor = Symbol("kGreatestCommonDivisor");
    var kCurrentWeight = Symbol("kCurrentWeight");
    var kIndex = Symbol("kIndex");
    var kWeight = Symbol("kWeight");
    var kMaxWeightPerServer = Symbol("kMaxWeightPerServer");
    var kErrorPenalty = Symbol("kErrorPenalty");
    function getGreatestCommonDivisor(a, b) {
      if (a === 0) return b;
      while (b !== 0) {
        const t = b;
        b = a % b;
        a = t;
      }
      return a;
    }
    function defaultFactory(origin, opts) {
      return new Pool(origin, opts);
    }
    var BalancedPool = class extends PoolBase {
      constructor(upstreams = [], { factory = defaultFactory, ...opts } = {}) {
        if (typeof factory !== "function") {
          throw new InvalidArgumentError("factory must be a function.");
        }
        super();
        this[kOptions] = opts;
        this[kIndex] = -1;
        this[kCurrentWeight] = 0;
        this[kMaxWeightPerServer] = this[kOptions].maxWeightPerServer || 100;
        this[kErrorPenalty] = this[kOptions].errorPenalty || 15;
        if (!Array.isArray(upstreams)) {
          upstreams = [upstreams];
        }
        this[kFactory] = factory;
        for (const upstream of upstreams) {
          this.addUpstream(upstream);
        }
        this._updateBalancedPoolStats();
      }
      addUpstream(upstream) {
        const upstreamOrigin = parseOrigin(upstream).origin;
        if (this[kClients].find((pool2) => pool2[kUrl].origin === upstreamOrigin && pool2.closed !== true && pool2.destroyed !== true)) {
          return this;
        }
        const pool = this[kFactory](upstreamOrigin, Object.assign({}, this[kOptions]));
        this[kAddClient](pool);
        pool.on("connect", () => {
          pool[kWeight] = Math.min(this[kMaxWeightPerServer], pool[kWeight] + this[kErrorPenalty]);
        });
        pool.on("connectionError", () => {
          pool[kWeight] = Math.max(1, pool[kWeight] - this[kErrorPenalty]);
          this._updateBalancedPoolStats();
        });
        pool.on("disconnect", (...args) => {
          const err = args[2];
          if (err && err.code === "UND_ERR_SOCKET") {
            pool[kWeight] = Math.max(1, pool[kWeight] - this[kErrorPenalty]);
            this._updateBalancedPoolStats();
          }
        });
        for (const client of this[kClients]) {
          client[kWeight] = this[kMaxWeightPerServer];
        }
        this._updateBalancedPoolStats();
        return this;
      }
      _updateBalancedPoolStats() {
        let result = 0;
        for (let i = 0; i < this[kClients].length; i++) {
          result = getGreatestCommonDivisor(this[kClients][i][kWeight], result);
        }
        this[kGreatestCommonDivisor] = result;
      }
      removeUpstream(upstream) {
        const upstreamOrigin = parseOrigin(upstream).origin;
        const pool = this[kClients].find((pool2) => pool2[kUrl].origin === upstreamOrigin && pool2.closed !== true && pool2.destroyed !== true);
        if (pool) {
          this[kRemoveClient](pool);
        }
        return this;
      }
      get upstreams() {
        return this[kClients].filter((dispatcher) => dispatcher.closed !== true && dispatcher.destroyed !== true).map((p) => p[kUrl].origin);
      }
      [kGetDispatcher]() {
        if (this[kClients].length === 0) {
          throw new BalancedPoolMissingUpstreamError();
        }
        const dispatcher = this[kClients].find((dispatcher2) => !dispatcher2[kNeedDrain] && dispatcher2.closed !== true && dispatcher2.destroyed !== true);
        if (!dispatcher) {
          return;
        }
        const allClientsBusy = this[kClients].map((pool) => pool[kNeedDrain]).reduce((a, b) => a && b, true);
        if (allClientsBusy) {
          return;
        }
        let counter = 0;
        let maxWeightIndex = this[kClients].findIndex((pool) => !pool[kNeedDrain]);
        while (counter++ < this[kClients].length) {
          this[kIndex] = (this[kIndex] + 1) % this[kClients].length;
          const pool = this[kClients][this[kIndex]];
          if (pool[kWeight] > this[kClients][maxWeightIndex][kWeight] && !pool[kNeedDrain]) {
            maxWeightIndex = this[kIndex];
          }
          if (this[kIndex] === 0) {
            this[kCurrentWeight] = this[kCurrentWeight] - this[kGreatestCommonDivisor];
            if (this[kCurrentWeight] <= 0) {
              this[kCurrentWeight] = this[kMaxWeightPerServer];
            }
          }
          if (pool[kWeight] >= this[kCurrentWeight] && !pool[kNeedDrain]) {
            return pool;
          }
        }
        this[kCurrentWeight] = this[kClients][maxWeightIndex][kWeight];
        this[kIndex] = maxWeightIndex;
        return this[kClients][maxWeightIndex];
      }
    };
    module2.exports = BalancedPool;
  }
});

// node_modules/undici/lib/dispatcher/agent.js
var require_agent = __commonJS({
  "node_modules/undici/lib/dispatcher/agent.js"(exports2, module2) {
    "use strict";
    var { InvalidArgumentError } = require_errors5();
    var { kClients, kRunning, kClose, kDestroy, kDispatch, kUrl } = require_symbols4();
    var DispatcherBase = require_dispatcher_base();
    var Pool = require_pool();
    var Client = require_client();
    var util = require_util4();
    var kOnConnect = Symbol("onConnect");
    var kOnDisconnect = Symbol("onDisconnect");
    var kOnConnectionError = Symbol("onConnectionError");
    var kOnDrain = Symbol("onDrain");
    var kFactory = Symbol("factory");
    var kOptions = Symbol("options");
    function defaultFactory(origin, opts) {
      return opts && opts.connections === 1 ? new Client(origin, opts) : new Pool(origin, opts);
    }
    var Agent = class extends DispatcherBase {
      constructor({ factory = defaultFactory, connect, ...options } = {}) {
        if (typeof factory !== "function") {
          throw new InvalidArgumentError("factory must be a function.");
        }
        if (connect != null && typeof connect !== "function" && typeof connect !== "object") {
          throw new InvalidArgumentError("connect must be a function or an object");
        }
        super();
        if (connect && typeof connect !== "function") {
          connect = { ...connect };
        }
        this[kOptions] = { ...util.deepClone(options), connect };
        this[kFactory] = factory;
        this[kClients] = /* @__PURE__ */ new Map();
        this[kOnDrain] = (origin, targets) => {
          this.emit("drain", origin, [this, ...targets]);
        };
        this[kOnConnect] = (origin, targets) => {
          const result = this[kClients].get(origin);
          if (result) {
            result.count += 1;
          }
          this.emit("connect", origin, [this, ...targets]);
        };
        this[kOnDisconnect] = (origin, targets, err) => {
          const result = this[kClients].get(origin);
          if (result) {
            result.count -= 1;
            if (result.count <= 0) {
              this[kClients].delete(origin);
              result.dispatcher.destroy();
            }
          }
          this.emit("disconnect", origin, [this, ...targets], err);
        };
        this[kOnConnectionError] = (origin, targets, err) => {
          this.emit("connectionError", origin, [this, ...targets], err);
        };
      }
      get [kRunning]() {
        let ret = 0;
        for (const { dispatcher } of this[kClients].values()) {
          ret += dispatcher[kRunning];
        }
        return ret;
      }
      [kDispatch](opts, handler) {
        let key;
        if (opts.origin && (typeof opts.origin === "string" || opts.origin instanceof URL)) {
          key = String(opts.origin);
        } else {
          throw new InvalidArgumentError("opts.origin must be a non-empty string or URL.");
        }
        const result = this[kClients].get(key);
        let dispatcher = result && result.dispatcher;
        if (!dispatcher) {
          dispatcher = this[kFactory](opts.origin, this[kOptions]).on("drain", this[kOnDrain]).on("connect", this[kOnConnect]).on("disconnect", this[kOnDisconnect]).on("connectionError", this[kOnConnectionError]);
          this[kClients].set(key, { count: 0, dispatcher });
        }
        return dispatcher.dispatch(opts, handler);
      }
      async [kClose]() {
        const closePromises = [];
        for (const { dispatcher } of this[kClients].values()) {
          closePromises.push(dispatcher.close());
        }
        this[kClients].clear();
        await Promise.all(closePromises);
      }
      async [kDestroy](err) {
        const destroyPromises = [];
        for (const { dispatcher } of this[kClients].values()) {
          destroyPromises.push(dispatcher.destroy(err));
        }
        this[kClients].clear();
        await Promise.all(destroyPromises);
      }
      get stats() {
        const allClientStats = {};
        for (const { dispatcher } of this[kClients].values()) {
          if (dispatcher.stats) {
            allClientStats[dispatcher[kUrl].origin] = dispatcher.stats;
          }
        }
        return allClientStats;
      }
    };
    module2.exports = Agent;
  }
});

// node_modules/undici/lib/dispatcher/proxy-agent.js
var require_proxy_agent = __commonJS({
  "node_modules/undici/lib/dispatcher/proxy-agent.js"(exports2, module2) {
    "use strict";
    var { kProxy, kClose, kDestroy, kDispatch } = require_symbols4();
    var { URL: URL2 } = require("node:url");
    var Agent = require_agent();
    var Pool = require_pool();
    var DispatcherBase = require_dispatcher_base();
    var { InvalidArgumentError, RequestAbortedError, SecureProxyConnectionError } = require_errors5();
    var buildConnector = require_connect();
    var Client = require_client();
    var kAgent = Symbol("proxy agent");
    var kClient = Symbol("proxy client");
    var kProxyHeaders = Symbol("proxy headers");
    var kRequestTls = Symbol("request tls settings");
    var kProxyTls = Symbol("proxy tls settings");
    var kConnectEndpoint = Symbol("connect endpoint function");
    var kTunnelProxy = Symbol("tunnel proxy");
    function defaultProtocolPort(protocol) {
      return protocol === "https:" ? 443 : 80;
    }
    function defaultFactory(origin, opts) {
      return new Pool(origin, opts);
    }
    var noop = () => {
    };
    function defaultAgentFactory(origin, opts) {
      if (opts.connections === 1) {
        return new Client(origin, opts);
      }
      return new Pool(origin, opts);
    }
    var Http1ProxyWrapper = class extends DispatcherBase {
      #client;
      constructor(proxyUrl, { headers = {}, connect, factory }) {
        super();
        if (!proxyUrl) {
          throw new InvalidArgumentError("Proxy URL is mandatory");
        }
        this[kProxyHeaders] = headers;
        if (factory) {
          this.#client = factory(proxyUrl, { connect });
        } else {
          this.#client = new Client(proxyUrl, { connect });
        }
      }
      [kDispatch](opts, handler) {
        const onHeaders = handler.onHeaders;
        handler.onHeaders = function(statusCode, data, resume) {
          if (statusCode === 407) {
            if (typeof handler.onError === "function") {
              handler.onError(new InvalidArgumentError("Proxy Authentication Required (407)"));
            }
            return;
          }
          if (onHeaders) onHeaders.call(this, statusCode, data, resume);
        };
        const {
          origin,
          path: path4 = "/",
          headers = {}
        } = opts;
        opts.path = origin + path4;
        if (!("host" in headers) && !("Host" in headers)) {
          const { host } = new URL2(origin);
          headers.host = host;
        }
        opts.headers = { ...this[kProxyHeaders], ...headers };
        return this.#client[kDispatch](opts, handler);
      }
      async [kClose]() {
        return this.#client.close();
      }
      async [kDestroy](err) {
        return this.#client.destroy(err);
      }
    };
    var ProxyAgent = class extends DispatcherBase {
      constructor(opts) {
        if (!opts || typeof opts === "object" && !(opts instanceof URL2) && !opts.uri) {
          throw new InvalidArgumentError("Proxy uri is mandatory");
        }
        const { clientFactory = defaultFactory } = opts;
        if (typeof clientFactory !== "function") {
          throw new InvalidArgumentError("Proxy opts.clientFactory must be a function.");
        }
        const { proxyTunnel = true } = opts;
        super();
        const url = this.#getUrl(opts);
        const { href, origin, port, protocol, username, password, hostname: proxyHostname } = url;
        this[kProxy] = { uri: href, protocol };
        this[kRequestTls] = opts.requestTls;
        this[kProxyTls] = opts.proxyTls;
        this[kProxyHeaders] = opts.headers || {};
        this[kTunnelProxy] = proxyTunnel;
        if (opts.auth && opts.token) {
          throw new InvalidArgumentError("opts.auth cannot be used in combination with opts.token");
        } else if (opts.auth) {
          this[kProxyHeaders]["proxy-authorization"] = `Basic ${opts.auth}`;
        } else if (opts.token) {
          this[kProxyHeaders]["proxy-authorization"] = opts.token;
        } else if (username && password) {
          this[kProxyHeaders]["proxy-authorization"] = `Basic ${Buffer.from(`${decodeURIComponent(username)}:${decodeURIComponent(password)}`).toString("base64")}`;
        }
        const connect = buildConnector({ ...opts.proxyTls });
        this[kConnectEndpoint] = buildConnector({ ...opts.requestTls });
        const agentFactory = opts.factory || defaultAgentFactory;
        const factory = (origin2, options) => {
          const { protocol: protocol2 } = new URL2(origin2);
          if (!this[kTunnelProxy] && protocol2 === "http:" && this[kProxy].protocol === "http:") {
            return new Http1ProxyWrapper(this[kProxy].uri, {
              headers: this[kProxyHeaders],
              connect,
              factory: agentFactory
            });
          }
          return agentFactory(origin2, options);
        };
        this[kClient] = clientFactory(url, { connect });
        this[kAgent] = new Agent({
          ...opts,
          factory,
          connect: async (opts2, callback) => {
            let requestedPath = opts2.host;
            if (!opts2.port) {
              requestedPath += `:${defaultProtocolPort(opts2.protocol)}`;
            }
            try {
              const { socket, statusCode } = await this[kClient].connect({
                origin,
                port,
                path: requestedPath,
                signal: opts2.signal,
                headers: {
                  ...this[kProxyHeaders],
                  host: opts2.host,
                  ...opts2.connections == null || opts2.connections > 0 ? { "proxy-connection": "keep-alive" } : {}
                },
                servername: this[kProxyTls]?.servername || proxyHostname
              });
              if (statusCode !== 200) {
                socket.on("error", noop).destroy();
                callback(new RequestAbortedError(`Proxy response (${statusCode}) !== 200 when HTTP Tunneling`));
              }
              if (opts2.protocol !== "https:") {
                callback(null, socket);
                return;
              }
              let servername;
              if (this[kRequestTls]) {
                servername = this[kRequestTls].servername;
              } else {
                servername = opts2.servername;
              }
              this[kConnectEndpoint]({ ...opts2, servername, httpSocket: socket }, callback);
            } catch (err) {
              if (err.code === "ERR_TLS_CERT_ALTNAME_INVALID") {
                callback(new SecureProxyConnectionError(err));
              } else {
                callback(err);
              }
            }
          }
        });
      }
      dispatch(opts, handler) {
        const headers = buildHeaders(opts.headers);
        throwIfProxyAuthIsSent(headers);
        if (headers && !("host" in headers) && !("Host" in headers)) {
          const { host } = new URL2(opts.origin);
          headers.host = host;
        }
        return this[kAgent].dispatch(
          {
            ...opts,
            headers
          },
          handler
        );
      }
      /**
       * @param {import('../types/proxy-agent').ProxyAgent.Options | string | URL} opts
       * @returns {URL}
       */
      #getUrl(opts) {
        if (typeof opts === "string") {
          return new URL2(opts);
        } else if (opts instanceof URL2) {
          return opts;
        } else {
          return new URL2(opts.uri);
        }
      }
      async [kClose]() {
        await this[kAgent].close();
        await this[kClient].close();
      }
      async [kDestroy]() {
        await this[kAgent].destroy();
        await this[kClient].destroy();
      }
    };
    function buildHeaders(headers) {
      if (Array.isArray(headers)) {
        const headersPair = {};
        for (let i = 0; i < headers.length; i += 2) {
          headersPair[headers[i]] = headers[i + 1];
        }
        return headersPair;
      }
      return headers;
    }
    function throwIfProxyAuthIsSent(headers) {
      const existProxyAuth = headers && Object.keys(headers).find((key) => key.toLowerCase() === "proxy-authorization");
      if (existProxyAuth) {
        throw new InvalidArgumentError("Proxy-Authorization should be sent in ProxyAgent constructor");
      }
    }
    module2.exports = ProxyAgent;
  }
});

// node_modules/undici/lib/dispatcher/env-http-proxy-agent.js
var require_env_http_proxy_agent = __commonJS({
  "node_modules/undici/lib/dispatcher/env-http-proxy-agent.js"(exports2, module2) {
    "use strict";
    var DispatcherBase = require_dispatcher_base();
    var { kClose, kDestroy, kClosed, kDestroyed, kDispatch, kNoProxyAgent, kHttpProxyAgent, kHttpsProxyAgent } = require_symbols4();
    var ProxyAgent = require_proxy_agent();
    var Agent = require_agent();
    var DEFAULT_PORTS = {
      "http:": 80,
      "https:": 443
    };
    var EnvHttpProxyAgent = class extends DispatcherBase {
      #noProxyValue = null;
      #noProxyEntries = null;
      #opts = null;
      constructor(opts = {}) {
        super();
        this.#opts = opts;
        const { httpProxy, httpsProxy, noProxy, ...agentOpts } = opts;
        this[kNoProxyAgent] = new Agent(agentOpts);
        const HTTP_PROXY = httpProxy ?? process.env.http_proxy ?? process.env.HTTP_PROXY;
        if (HTTP_PROXY) {
          this[kHttpProxyAgent] = new ProxyAgent({ ...agentOpts, uri: HTTP_PROXY });
        } else {
          this[kHttpProxyAgent] = this[kNoProxyAgent];
        }
        const HTTPS_PROXY = httpsProxy ?? process.env.https_proxy ?? process.env.HTTPS_PROXY;
        if (HTTPS_PROXY) {
          this[kHttpsProxyAgent] = new ProxyAgent({ ...agentOpts, uri: HTTPS_PROXY });
        } else {
          this[kHttpsProxyAgent] = this[kHttpProxyAgent];
        }
        this.#parseNoProxy();
      }
      [kDispatch](opts, handler) {
        const url = new URL(opts.origin);
        const agent = this.#getProxyAgentForUrl(url);
        return agent.dispatch(opts, handler);
      }
      async [kClose]() {
        await this[kNoProxyAgent].close();
        if (!this[kHttpProxyAgent][kClosed]) {
          await this[kHttpProxyAgent].close();
        }
        if (!this[kHttpsProxyAgent][kClosed]) {
          await this[kHttpsProxyAgent].close();
        }
      }
      async [kDestroy](err) {
        await this[kNoProxyAgent].destroy(err);
        if (!this[kHttpProxyAgent][kDestroyed]) {
          await this[kHttpProxyAgent].destroy(err);
        }
        if (!this[kHttpsProxyAgent][kDestroyed]) {
          await this[kHttpsProxyAgent].destroy(err);
        }
      }
      #getProxyAgentForUrl(url) {
        let { protocol, host: hostname, port } = url;
        hostname = hostname.replace(/:\d*$/, "").toLowerCase();
        port = Number.parseInt(port, 10) || DEFAULT_PORTS[protocol] || 0;
        if (!this.#shouldProxy(hostname, port)) {
          return this[kNoProxyAgent];
        }
        if (protocol === "https:") {
          return this[kHttpsProxyAgent];
        }
        return this[kHttpProxyAgent];
      }
      #shouldProxy(hostname, port) {
        if (this.#noProxyChanged) {
          this.#parseNoProxy();
        }
        if (this.#noProxyEntries.length === 0) {
          return true;
        }
        if (this.#noProxyValue === "*") {
          return false;
        }
        for (let i = 0; i < this.#noProxyEntries.length; i++) {
          const entry = this.#noProxyEntries[i];
          if (entry.port && entry.port !== port) {
            continue;
          }
          if (!/^[.*]/.test(entry.hostname)) {
            if (hostname === entry.hostname) {
              return false;
            }
          } else {
            if (hostname.endsWith(entry.hostname.replace(/^\*/, ""))) {
              return false;
            }
          }
        }
        return true;
      }
      #parseNoProxy() {
        const noProxyValue = this.#opts.noProxy ?? this.#noProxyEnv;
        const noProxySplit = noProxyValue.split(/[,\s]/);
        const noProxyEntries = [];
        for (let i = 0; i < noProxySplit.length; i++) {
          const entry = noProxySplit[i];
          if (!entry) {
            continue;
          }
          const parsed = entry.match(/^(.+):(\d+)$/);
          noProxyEntries.push({
            hostname: (parsed ? parsed[1] : entry).toLowerCase(),
            port: parsed ? Number.parseInt(parsed[2], 10) : 0
          });
        }
        this.#noProxyValue = noProxyValue;
        this.#noProxyEntries = noProxyEntries;
      }
      get #noProxyChanged() {
        if (this.#opts.noProxy !== void 0) {
          return false;
        }
        return this.#noProxyValue !== this.#noProxyEnv;
      }
      get #noProxyEnv() {
        return process.env.no_proxy ?? process.env.NO_PROXY ?? "";
      }
    };
    module2.exports = EnvHttpProxyAgent;
  }
});

// node_modules/undici/lib/handler/retry-handler.js
var require_retry_handler = __commonJS({
  "node_modules/undici/lib/handler/retry-handler.js"(exports2, module2) {
    "use strict";
    var assert = require("node:assert");
    var { kRetryHandlerDefaultRetry } = require_symbols4();
    var { RequestRetryError } = require_errors5();
    var WrapHandler = require_wrap_handler();
    var {
      isDisturbed,
      parseRangeHeader,
      wrapRequestBody
    } = require_util4();
    function calculateRetryAfterHeader(retryAfter) {
      const retryTime = new Date(retryAfter).getTime();
      return isNaN(retryTime) ? 0 : retryTime - Date.now();
    }
    var RetryHandler = class _RetryHandler {
      constructor(opts, { dispatch, handler }) {
        const { retryOptions, ...dispatchOpts } = opts;
        const {
          // Retry scoped
          retry: retryFn,
          maxRetries,
          maxTimeout,
          minTimeout,
          timeoutFactor,
          // Response scoped
          methods,
          errorCodes,
          retryAfter,
          statusCodes,
          throwOnError
        } = retryOptions ?? {};
        this.error = null;
        this.dispatch = dispatch;
        this.handler = WrapHandler.wrap(handler);
        this.opts = { ...dispatchOpts, body: wrapRequestBody(opts.body) };
        this.retryOpts = {
          throwOnError: throwOnError ?? true,
          retry: retryFn ?? _RetryHandler[kRetryHandlerDefaultRetry],
          retryAfter: retryAfter ?? true,
          maxTimeout: maxTimeout ?? 30 * 1e3,
          // 30s,
          minTimeout: minTimeout ?? 500,
          // .5s
          timeoutFactor: timeoutFactor ?? 2,
          maxRetries: maxRetries ?? 5,
          // What errors we should retry
          methods: methods ?? ["GET", "HEAD", "OPTIONS", "PUT", "DELETE", "TRACE"],
          // Indicates which errors to retry
          statusCodes: statusCodes ?? [500, 502, 503, 504, 429],
          // List of errors to retry
          errorCodes: errorCodes ?? [
            "ECONNRESET",
            "ECONNREFUSED",
            "ENOTFOUND",
            "ENETDOWN",
            "ENETUNREACH",
            "EHOSTDOWN",
            "EHOSTUNREACH",
            "EPIPE",
            "UND_ERR_SOCKET"
          ]
        };
        this.retryCount = 0;
        this.retryCountCheckpoint = 0;
        this.headersSent = false;
        this.start = 0;
        this.end = null;
        this.etag = null;
      }
      onResponseStartWithRetry(controller, statusCode, headers, statusMessage, err) {
        if (this.retryOpts.throwOnError) {
          if (this.retryOpts.statusCodes.includes(statusCode) === false) {
            this.headersSent = true;
            this.handler.onResponseStart?.(controller, statusCode, headers, statusMessage);
          } else {
            this.error = err;
          }
          return;
        }
        if (isDisturbed(this.opts.body)) {
          this.headersSent = true;
          this.handler.onResponseStart?.(controller, statusCode, headers, statusMessage);
          return;
        }
        function shouldRetry(passedErr) {
          if (passedErr) {
            this.headersSent = true;
            this.headersSent = true;
            this.handler.onResponseStart?.(controller, statusCode, headers, statusMessage);
            controller.resume();
            return;
          }
          this.error = err;
          controller.resume();
        }
        controller.pause();
        this.retryOpts.retry(
          err,
          {
            state: { counter: this.retryCount },
            opts: { retryOptions: this.retryOpts, ...this.opts }
          },
          shouldRetry.bind(this)
        );
      }
      onRequestStart(controller, context) {
        if (!this.headersSent) {
          this.handler.onRequestStart?.(controller, context);
        }
      }
      onRequestUpgrade(controller, statusCode, headers, socket) {
        this.handler.onRequestUpgrade?.(controller, statusCode, headers, socket);
      }
      static [kRetryHandlerDefaultRetry](err, { state, opts }, cb) {
        const { statusCode, code, headers } = err;
        const { method, retryOptions } = opts;
        const {
          maxRetries,
          minTimeout,
          maxTimeout,
          timeoutFactor,
          statusCodes,
          errorCodes,
          methods
        } = retryOptions;
        const { counter } = state;
        if (code && code !== "UND_ERR_REQ_RETRY" && !errorCodes.includes(code)) {
          cb(err);
          return;
        }
        if (Array.isArray(methods) && !methods.includes(method)) {
          cb(err);
          return;
        }
        if (statusCode != null && Array.isArray(statusCodes) && !statusCodes.includes(statusCode)) {
          cb(err);
          return;
        }
        if (counter > maxRetries) {
          cb(err);
          return;
        }
        let retryAfterHeader = headers?.["retry-after"];
        if (retryAfterHeader) {
          retryAfterHeader = Number(retryAfterHeader);
          retryAfterHeader = Number.isNaN(retryAfterHeader) ? calculateRetryAfterHeader(headers["retry-after"]) : retryAfterHeader * 1e3;
        }
        const retryTimeout = retryAfterHeader > 0 ? Math.min(retryAfterHeader, maxTimeout) : Math.min(minTimeout * timeoutFactor ** (counter - 1), maxTimeout);
        setTimeout(() => cb(null), retryTimeout);
      }
      onResponseStart(controller, statusCode, headers, statusMessage) {
        this.error = null;
        this.retryCount += 1;
        if (statusCode >= 300) {
          const err = new RequestRetryError("Request failed", statusCode, {
            headers,
            data: {
              count: this.retryCount
            }
          });
          this.onResponseStartWithRetry(controller, statusCode, headers, statusMessage, err);
          return;
        }
        if (this.headersSent) {
          if (statusCode !== 206 && (this.start > 0 || statusCode !== 200)) {
            throw new RequestRetryError("server does not support the range header and the payload was partially consumed", statusCode, {
              headers,
              data: { count: this.retryCount }
            });
          }
          const contentRange = parseRangeHeader(headers["content-range"]);
          if (!contentRange) {
            throw new RequestRetryError("Content-Range mismatch", statusCode, {
              headers,
              data: { count: this.retryCount }
            });
          }
          if (this.etag != null && this.etag !== headers.etag) {
            throw new RequestRetryError("ETag mismatch", statusCode, {
              headers,
              data: { count: this.retryCount }
            });
          }
          const { start, size, end = size ? size - 1 : null } = contentRange;
          assert(this.start === start, "content-range mismatch");
          assert(this.end == null || this.end === end, "content-range mismatch");
          return;
        }
        if (this.end == null) {
          if (statusCode === 206) {
            const range = parseRangeHeader(headers["content-range"]);
            if (range == null) {
              this.headersSent = true;
              this.handler.onResponseStart?.(
                controller,
                statusCode,
                headers,
                statusMessage
              );
              return;
            }
            const { start, size, end = size ? size - 1 : null } = range;
            assert(
              start != null && Number.isFinite(start),
              "content-range mismatch"
            );
            assert(end != null && Number.isFinite(end), "invalid content-length");
            this.start = start;
            this.end = end;
          }
          if (this.end == null) {
            const contentLength = headers["content-length"];
            this.end = contentLength != null ? Number(contentLength) - 1 : null;
          }
          assert(Number.isFinite(this.start));
          assert(
            this.end == null || Number.isFinite(this.end),
            "invalid content-length"
          );
          this.resume = true;
          this.etag = headers.etag != null ? headers.etag : null;
          if (this.etag != null && this.etag[0] === "W" && this.etag[1] === "/") {
            this.etag = null;
          }
          this.headersSent = true;
          this.handler.onResponseStart?.(
            controller,
            statusCode,
            headers,
            statusMessage
          );
        } else {
          throw new RequestRetryError("Request failed", statusCode, {
            headers,
            data: { count: this.retryCount }
          });
        }
      }
      onResponseData(controller, chunk) {
        if (this.error) {
          return;
        }
        this.start += chunk.length;
        this.handler.onResponseData?.(controller, chunk);
      }
      onResponseEnd(controller, trailers) {
        if (this.error && this.retryOpts.throwOnError) {
          throw this.error;
        }
        if (!this.error) {
          this.retryCount = 0;
          return this.handler.onResponseEnd?.(controller, trailers);
        }
        this.retry(controller);
      }
      retry(controller) {
        if (this.start !== 0) {
          const headers = { range: `bytes=${this.start}-${this.end ?? ""}` };
          if (this.etag != null) {
            headers["if-match"] = this.etag;
          }
          this.opts = {
            ...this.opts,
            headers: {
              ...this.opts.headers,
              ...headers
            }
          };
        }
        try {
          this.retryCountCheckpoint = this.retryCount;
          this.dispatch(this.opts, this);
        } catch (err) {
          this.handler.onResponseError?.(controller, err);
        }
      }
      onResponseError(controller, err) {
        if (controller?.aborted || isDisturbed(this.opts.body)) {
          this.handler.onResponseError?.(controller, err);
          return;
        }
        function shouldRetry(returnedErr) {
          if (!returnedErr) {
            this.retry(controller);
            return;
          }
          this.handler?.onResponseError?.(controller, returnedErr);
        }
        if (this.retryCount - this.retryCountCheckpoint > 0) {
          this.retryCount = this.retryCountCheckpoint + (this.retryCount - this.retryCountCheckpoint);
        } else {
          this.retryCount += 1;
        }
        this.retryOpts.retry(
          err,
          {
            state: { counter: this.retryCount },
            opts: { retryOptions: this.retryOpts, ...this.opts }
          },
          shouldRetry.bind(this)
        );
      }
    };
    module2.exports = RetryHandler;
  }
});

// node_modules/undici/lib/dispatcher/retry-agent.js
var require_retry_agent = __commonJS({
  "node_modules/undici/lib/dispatcher/retry-agent.js"(exports2, module2) {
    "use strict";
    var Dispatcher = require_dispatcher();
    var RetryHandler = require_retry_handler();
    var RetryAgent = class extends Dispatcher {
      #agent = null;
      #options = null;
      constructor(agent, options = {}) {
        super(options);
        this.#agent = agent;
        this.#options = options;
      }
      dispatch(opts, handler) {
        const retry = new RetryHandler({
          ...opts,
          retryOptions: this.#options
        }, {
          dispatch: this.#agent.dispatch.bind(this.#agent),
          handler
        });
        return this.#agent.dispatch(opts, retry);
      }
      close() {
        return this.#agent.close();
      }
      destroy() {
        return this.#agent.destroy();
      }
    };
    module2.exports = RetryAgent;
  }
});

// node_modules/undici/lib/dispatcher/h2c-client.js
var require_h2c_client = __commonJS({
  "node_modules/undici/lib/dispatcher/h2c-client.js"(exports2, module2) {
    "use strict";
    var { connect } = require("node:net");
    var { kClose, kDestroy } = require_symbols4();
    var { InvalidArgumentError } = require_errors5();
    var util = require_util4();
    var Client = require_client();
    var DispatcherBase = require_dispatcher_base();
    var H2CClient = class extends DispatcherBase {
      #client = null;
      constructor(origin, clientOpts) {
        super();
        if (typeof origin === "string") {
          origin = new URL(origin);
        }
        if (origin.protocol !== "http:") {
          throw new InvalidArgumentError(
            "h2c-client: Only h2c protocol is supported"
          );
        }
        const { connect: connect2, maxConcurrentStreams, pipelining, ...opts } = clientOpts ?? {};
        let defaultMaxConcurrentStreams = 100;
        let defaultPipelining = 100;
        if (maxConcurrentStreams != null && Number.isInteger(maxConcurrentStreams) && maxConcurrentStreams > 0) {
          defaultMaxConcurrentStreams = maxConcurrentStreams;
        }
        if (pipelining != null && Number.isInteger(pipelining) && pipelining > 0) {
          defaultPipelining = pipelining;
        }
        if (defaultPipelining > defaultMaxConcurrentStreams) {
          throw new InvalidArgumentError(
            "h2c-client: pipelining cannot be greater than maxConcurrentStreams"
          );
        }
        this.#client = new Client(origin, {
          ...opts,
          connect: this.#buildConnector(connect2),
          maxConcurrentStreams: defaultMaxConcurrentStreams,
          pipelining: defaultPipelining,
          allowH2: true
        });
      }
      #buildConnector(connectOpts) {
        return (opts, callback) => {
          const timeout = connectOpts?.connectOpts ?? 1e4;
          const { hostname, port, pathname } = opts;
          const socket = connect({
            ...opts,
            host: hostname,
            port,
            pathname
          });
          if (opts.keepAlive == null || opts.keepAlive) {
            const keepAliveInitialDelay = opts.keepAliveInitialDelay == null ? 6e4 : opts.keepAliveInitialDelay;
            socket.setKeepAlive(true, keepAliveInitialDelay);
          }
          socket.alpnProtocol = "h2";
          const clearConnectTimeout = util.setupConnectTimeout(
            new WeakRef(socket),
            { timeout, hostname, port }
          );
          socket.setNoDelay(true).once("connect", function() {
            queueMicrotask(clearConnectTimeout);
            if (callback) {
              const cb = callback;
              callback = null;
              cb(null, this);
            }
          }).on("error", function(err) {
            queueMicrotask(clearConnectTimeout);
            if (callback) {
              const cb = callback;
              callback = null;
              cb(err);
            }
          });
          return socket;
        };
      }
      dispatch(opts, handler) {
        return this.#client.dispatch(opts, handler);
      }
      async [kClose]() {
        await this.#client.close();
      }
      async [kDestroy]() {
        await this.#client.destroy();
      }
    };
    module2.exports = H2CClient;
  }
});

// node_modules/undici/lib/api/readable.js
var require_readable = __commonJS({
  "node_modules/undici/lib/api/readable.js"(exports2, module2) {
    "use strict";
    var assert = require("node:assert");
    var { Readable } = require("node:stream");
    var { RequestAbortedError, NotSupportedError, InvalidArgumentError, AbortError } = require_errors5();
    var util = require_util4();
    var { ReadableStreamFrom } = require_util4();
    var kConsume = Symbol("kConsume");
    var kReading = Symbol("kReading");
    var kBody = Symbol("kBody");
    var kAbort = Symbol("kAbort");
    var kContentType = Symbol("kContentType");
    var kContentLength = Symbol("kContentLength");
    var kUsed = Symbol("kUsed");
    var kBytesRead = Symbol("kBytesRead");
    var noop = () => {
    };
    var BodyReadable = class extends Readable {
      /**
       * @param {object} opts
       * @param {(this: Readable, size: number) => void} opts.resume
       * @param {() => (void | null)} opts.abort
       * @param {string} [opts.contentType = '']
       * @param {number} [opts.contentLength]
       * @param {number} [opts.highWaterMark = 64 * 1024]
       */
      constructor({
        resume,
        abort,
        contentType = "",
        contentLength,
        highWaterMark = 64 * 1024
        // Same as nodejs fs streams.
      }) {
        super({
          autoDestroy: true,
          read: resume,
          highWaterMark
        });
        this._readableState.dataEmitted = false;
        this[kAbort] = abort;
        this[kConsume] = null;
        this[kBytesRead] = 0;
        this[kBody] = null;
        this[kUsed] = false;
        this[kContentType] = contentType;
        this[kContentLength] = Number.isFinite(contentLength) ? contentLength : null;
        this[kReading] = false;
      }
      /**
       * @param {Error|null} err
       * @param {(error:(Error|null)) => void} callback
       * @returns {void}
       */
      _destroy(err, callback) {
        if (!err && !this._readableState.endEmitted) {
          err = new RequestAbortedError();
        }
        if (err) {
          this[kAbort]();
        }
        if (!this[kUsed]) {
          setImmediate(callback, err);
        } else {
          callback(err);
        }
      }
      /**
       * @param {string|symbol} event
       * @param {(...args: any[]) => void} listener
       * @returns {this}
       */
      on(event, listener) {
        if (event === "data" || event === "readable") {
          this[kReading] = true;
          this[kUsed] = true;
        }
        return super.on(event, listener);
      }
      /**
       * @param {string|symbol} event
       * @param {(...args: any[]) => void} listener
       * @returns {this}
       */
      addListener(event, listener) {
        return this.on(event, listener);
      }
      /**
       * @param {string|symbol} event
       * @param {(...args: any[]) => void} listener
       * @returns {this}
       */
      off(event, listener) {
        const ret = super.off(event, listener);
        if (event === "data" || event === "readable") {
          this[kReading] = this.listenerCount("data") > 0 || this.listenerCount("readable") > 0;
        }
        return ret;
      }
      /**
       * @param {string|symbol} event
       * @param {(...args: any[]) => void} listener
       * @returns {this}
       */
      removeListener(event, listener) {
        return this.off(event, listener);
      }
      /**
       * @param {Buffer|null} chunk
       * @returns {boolean}
       */
      push(chunk) {
        if (chunk) {
          this[kBytesRead] += chunk.length;
          if (this[kConsume]) {
            consumePush(this[kConsume], chunk);
            return this[kReading] ? super.push(chunk) : true;
          }
        }
        return super.push(chunk);
      }
      /**
       * Consumes and returns the body as a string.
       *
       * @see https://fetch.spec.whatwg.org/#dom-body-text
       * @returns {Promise<string>}
       */
      text() {
        return consume(this, "text");
      }
      /**
       * Consumes and returns the body as a JavaScript Object.
       *
       * @see https://fetch.spec.whatwg.org/#dom-body-json
       * @returns {Promise<unknown>}
       */
      json() {
        return consume(this, "json");
      }
      /**
       * Consumes and returns the body as a Blob
       *
       * @see https://fetch.spec.whatwg.org/#dom-body-blob
       * @returns {Promise<Blob>}
       */
      blob() {
        return consume(this, "blob");
      }
      /**
       * Consumes and returns the body as an Uint8Array.
       *
       * @see https://fetch.spec.whatwg.org/#dom-body-bytes
       * @returns {Promise<Uint8Array>}
       */
      bytes() {
        return consume(this, "bytes");
      }
      /**
       * Consumes and returns the body as an ArrayBuffer.
       *
       * @see https://fetch.spec.whatwg.org/#dom-body-arraybuffer
       * @returns {Promise<ArrayBuffer>}
       */
      arrayBuffer() {
        return consume(this, "arrayBuffer");
      }
      /**
       * Not implemented
       *
       * @see https://fetch.spec.whatwg.org/#dom-body-formdata
       * @throws {NotSupportedError}
       */
      async formData() {
        throw new NotSupportedError();
      }
      /**
       * Returns true if the body is not null and the body has been consumed.
       * Otherwise, returns false.
       *
       * @see https://fetch.spec.whatwg.org/#dom-body-bodyused
       * @readonly
       * @returns {boolean}
       */
      get bodyUsed() {
        return util.isDisturbed(this);
      }
      /**
       * @see https://fetch.spec.whatwg.org/#dom-body-body
       * @readonly
       * @returns {ReadableStream}
       */
      get body() {
        if (!this[kBody]) {
          this[kBody] = ReadableStreamFrom(this);
          if (this[kConsume]) {
            this[kBody].getReader();
            assert(this[kBody].locked);
          }
        }
        return this[kBody];
      }
      /**
       * Dumps the response body by reading `limit` number of bytes.
       * @param {object} opts
       * @param {number} [opts.limit = 131072] Number of bytes to read.
       * @param {AbortSignal} [opts.signal] An AbortSignal to cancel the dump.
       * @returns {Promise<null>}
       */
      async dump(opts) {
        const signal = opts?.signal;
        if (signal != null && (typeof signal !== "object" || !("aborted" in signal))) {
          throw new InvalidArgumentError("signal must be an AbortSignal");
        }
        const limit = opts?.limit && Number.isFinite(opts.limit) ? opts.limit : 128 * 1024;
        signal?.throwIfAborted();
        if (this._readableState.closeEmitted) {
          return null;
        }
        return await new Promise((resolve, reject) => {
          if (this[kContentLength] && this[kContentLength] > limit || this[kBytesRead] > limit) {
            this.destroy(new AbortError());
          }
          if (signal) {
            const onAbort = () => {
              this.destroy(signal.reason ?? new AbortError());
            };
            signal.addEventListener("abort", onAbort);
            this.on("close", function() {
              signal.removeEventListener("abort", onAbort);
              if (signal.aborted) {
                reject(signal.reason ?? new AbortError());
              } else {
                resolve(null);
              }
            });
          } else {
            this.on("close", resolve);
          }
          this.on("error", noop).on("data", () => {
            if (this[kBytesRead] > limit) {
              this.destroy();
            }
          }).resume();
        });
      }
      /**
       * @param {BufferEncoding} encoding
       * @returns {this}
       */
      setEncoding(encoding) {
        if (Buffer.isEncoding(encoding)) {
          this._readableState.encoding = encoding;
        }
        return this;
      }
    };
    function isLocked(bodyReadable) {
      return bodyReadable[kBody]?.locked === true || bodyReadable[kConsume] !== null;
    }
    function isUnusable(bodyReadable) {
      return util.isDisturbed(bodyReadable) || isLocked(bodyReadable);
    }
    function consume(stream, type) {
      assert(!stream[kConsume]);
      return new Promise((resolve, reject) => {
        if (isUnusable(stream)) {
          const rState = stream._readableState;
          if (rState.destroyed && rState.closeEmitted === false) {
            stream.on("error", reject).on("close", () => {
              reject(new TypeError("unusable"));
            });
          } else {
            reject(rState.errored ?? new TypeError("unusable"));
          }
        } else {
          queueMicrotask(() => {
            stream[kConsume] = {
              type,
              stream,
              resolve,
              reject,
              length: 0,
              body: []
            };
            stream.on("error", function(err) {
              consumeFinish(this[kConsume], err);
            }).on("close", function() {
              if (this[kConsume].body !== null) {
                consumeFinish(this[kConsume], new RequestAbortedError());
              }
            });
            consumeStart(stream[kConsume]);
          });
        }
      });
    }
    function consumeStart(consume2) {
      if (consume2.body === null) {
        return;
      }
      const { _readableState: state } = consume2.stream;
      if (state.bufferIndex) {
        const start = state.bufferIndex;
        const end = state.buffer.length;
        for (let n = start; n < end; n++) {
          consumePush(consume2, state.buffer[n]);
        }
      } else {
        for (const chunk of state.buffer) {
          consumePush(consume2, chunk);
        }
      }
      if (state.endEmitted) {
        consumeEnd(this[kConsume], this._readableState.encoding);
      } else {
        consume2.stream.on("end", function() {
          consumeEnd(this[kConsume], this._readableState.encoding);
        });
      }
      consume2.stream.resume();
      while (consume2.stream.read() != null) {
      }
    }
    function chunksDecode(chunks, length, encoding) {
      if (chunks.length === 0 || length === 0) {
        return "";
      }
      const buffer = chunks.length === 1 ? chunks[0] : Buffer.concat(chunks, length);
      const bufferLength = buffer.length;
      const start = bufferLength > 2 && buffer[0] === 239 && buffer[1] === 187 && buffer[2] === 191 ? 3 : 0;
      if (!encoding || encoding === "utf8" || encoding === "utf-8") {
        return buffer.utf8Slice(start, bufferLength);
      } else {
        return buffer.subarray(start, bufferLength).toString(encoding);
      }
    }
    function chunksConcat(chunks, length) {
      if (chunks.length === 0 || length === 0) {
        return new Uint8Array(0);
      }
      if (chunks.length === 1) {
        return new Uint8Array(chunks[0]);
      }
      const buffer = new Uint8Array(Buffer.allocUnsafeSlow(length).buffer);
      let offset = 0;
      for (let i = 0; i < chunks.length; ++i) {
        const chunk = chunks[i];
        buffer.set(chunk, offset);
        offset += chunk.length;
      }
      return buffer;
    }
    function consumeEnd(consume2, encoding) {
      const { type, body, resolve, stream, length } = consume2;
      try {
        if (type === "text") {
          resolve(chunksDecode(body, length, encoding));
        } else if (type === "json") {
          resolve(JSON.parse(chunksDecode(body, length, encoding)));
        } else if (type === "arrayBuffer") {
          resolve(chunksConcat(body, length).buffer);
        } else if (type === "blob") {
          resolve(new Blob(body, { type: stream[kContentType] }));
        } else if (type === "bytes") {
          resolve(chunksConcat(body, length));
        }
        consumeFinish(consume2);
      } catch (err) {
        stream.destroy(err);
      }
    }
    function consumePush(consume2, chunk) {
      consume2.length += chunk.length;
      consume2.body.push(chunk);
    }
    function consumeFinish(consume2, err) {
      if (consume2.body === null) {
        return;
      }
      if (err) {
        consume2.reject(err);
      } else {
        consume2.resolve();
      }
      consume2.type = null;
      consume2.stream = null;
      consume2.resolve = null;
      consume2.reject = null;
      consume2.length = 0;
      consume2.body = null;
    }
    module2.exports = {
      Readable: BodyReadable,
      chunksDecode
    };
  }
});

// node_modules/undici/lib/api/api-request.js
var require_api_request = __commonJS({
  "node_modules/undici/lib/api/api-request.js"(exports2, module2) {
    "use strict";
    var assert = require("node:assert");
    var { AsyncResource } = require("node:async_hooks");
    var { Readable } = require_readable();
    var { InvalidArgumentError, RequestAbortedError } = require_errors5();
    var util = require_util4();
    function noop() {
    }
    var RequestHandler = class extends AsyncResource {
      constructor(opts, callback) {
        if (!opts || typeof opts !== "object") {
          throw new InvalidArgumentError("invalid opts");
        }
        const { signal, method, opaque, body, onInfo, responseHeaders, highWaterMark } = opts;
        try {
          if (typeof callback !== "function") {
            throw new InvalidArgumentError("invalid callback");
          }
          if (highWaterMark && (typeof highWaterMark !== "number" || highWaterMark < 0)) {
            throw new InvalidArgumentError("invalid highWaterMark");
          }
          if (signal && typeof signal.on !== "function" && typeof signal.addEventListener !== "function") {
            throw new InvalidArgumentError("signal must be an EventEmitter or EventTarget");
          }
          if (method === "CONNECT") {
            throw new InvalidArgumentError("invalid method");
          }
          if (onInfo && typeof onInfo !== "function") {
            throw new InvalidArgumentError("invalid onInfo callback");
          }
          super("UNDICI_REQUEST");
        } catch (err) {
          if (util.isStream(body)) {
            util.destroy(body.on("error", noop), err);
          }
          throw err;
        }
        this.method = method;
        this.responseHeaders = responseHeaders || null;
        this.opaque = opaque || null;
        this.callback = callback;
        this.res = null;
        this.abort = null;
        this.body = body;
        this.trailers = {};
        this.context = null;
        this.onInfo = onInfo || null;
        this.highWaterMark = highWaterMark;
        this.reason = null;
        this.removeAbortListener = null;
        if (signal?.aborted) {
          this.reason = signal.reason ?? new RequestAbortedError();
        } else if (signal) {
          this.removeAbortListener = util.addAbortListener(signal, () => {
            this.reason = signal.reason ?? new RequestAbortedError();
            if (this.res) {
              util.destroy(this.res.on("error", noop), this.reason);
            } else if (this.abort) {
              this.abort(this.reason);
            }
          });
        }
      }
      onConnect(abort, context) {
        if (this.reason) {
          abort(this.reason);
          return;
        }
        assert(this.callback);
        this.abort = abort;
        this.context = context;
      }
      onHeaders(statusCode, rawHeaders, resume, statusMessage) {
        const { callback, opaque, abort, context, responseHeaders, highWaterMark } = this;
        const headers = responseHeaders === "raw" ? util.parseRawHeaders(rawHeaders) : util.parseHeaders(rawHeaders);
        if (statusCode < 200) {
          if (this.onInfo) {
            this.onInfo({ statusCode, headers });
          }
          return;
        }
        const parsedHeaders = responseHeaders === "raw" ? util.parseHeaders(rawHeaders) : headers;
        const contentType = parsedHeaders["content-type"];
        const contentLength = parsedHeaders["content-length"];
        const res = new Readable({
          resume,
          abort,
          contentType,
          contentLength: this.method !== "HEAD" && contentLength ? Number(contentLength) : null,
          highWaterMark
        });
        if (this.removeAbortListener) {
          res.on("close", this.removeAbortListener);
          this.removeAbortListener = null;
        }
        this.callback = null;
        this.res = res;
        if (callback !== null) {
          this.runInAsyncScope(callback, null, null, {
            statusCode,
            headers,
            trailers: this.trailers,
            opaque,
            body: res,
            context
          });
        }
      }
      onData(chunk) {
        return this.res.push(chunk);
      }
      onComplete(trailers) {
        util.parseHeaders(trailers, this.trailers);
        this.res.push(null);
      }
      onError(err) {
        const { res, callback, body, opaque } = this;
        if (callback) {
          this.callback = null;
          queueMicrotask(() => {
            this.runInAsyncScope(callback, null, err, { opaque });
          });
        }
        if (res) {
          this.res = null;
          queueMicrotask(() => {
            util.destroy(res.on("error", noop), err);
          });
        }
        if (body) {
          this.body = null;
          if (util.isStream(body)) {
            body.on("error", noop);
            util.destroy(body, err);
          }
        }
        if (this.removeAbortListener) {
          this.removeAbortListener();
          this.removeAbortListener = null;
        }
      }
    };
    function request(opts, callback) {
      if (callback === void 0) {
        return new Promise((resolve, reject) => {
          request.call(this, opts, (err, data) => {
            return err ? reject(err) : resolve(data);
          });
        });
      }
      try {
        const handler = new RequestHandler(opts, callback);
        this.dispatch(opts, handler);
      } catch (err) {
        if (typeof callback !== "function") {
          throw err;
        }
        const opaque = opts?.opaque;
        queueMicrotask(() => callback(err, { opaque }));
      }
    }
    module2.exports = request;
    module2.exports.RequestHandler = RequestHandler;
  }
});

// node_modules/undici/lib/api/abort-signal.js
var require_abort_signal = __commonJS({
  "node_modules/undici/lib/api/abort-signal.js"(exports2, module2) {
    "use strict";
    var { addAbortListener } = require_util4();
    var { RequestAbortedError } = require_errors5();
    var kListener = Symbol("kListener");
    var kSignal = Symbol("kSignal");
    function abort(self2) {
      if (self2.abort) {
        self2.abort(self2[kSignal]?.reason);
      } else {
        self2.reason = self2[kSignal]?.reason ?? new RequestAbortedError();
      }
      removeSignal(self2);
    }
    function addSignal(self2, signal) {
      self2.reason = null;
      self2[kSignal] = null;
      self2[kListener] = null;
      if (!signal) {
        return;
      }
      if (signal.aborted) {
        abort(self2);
        return;
      }
      self2[kSignal] = signal;
      self2[kListener] = () => {
        abort(self2);
      };
      addAbortListener(self2[kSignal], self2[kListener]);
    }
    function removeSignal(self2) {
      if (!self2[kSignal]) {
        return;
      }
      if ("removeEventListener" in self2[kSignal]) {
        self2[kSignal].removeEventListener("abort", self2[kListener]);
      } else {
        self2[kSignal].removeListener("abort", self2[kListener]);
      }
      self2[kSignal] = null;
      self2[kListener] = null;
    }
    module2.exports = {
      addSignal,
      removeSignal
    };
  }
});

// node_modules/undici/lib/api/api-stream.js
var require_api_stream = __commonJS({
  "node_modules/undici/lib/api/api-stream.js"(exports2, module2) {
    "use strict";
    var assert = require("node:assert");
    var { finished } = require("node:stream");
    var { AsyncResource } = require("node:async_hooks");
    var { InvalidArgumentError, InvalidReturnValueError } = require_errors5();
    var util = require_util4();
    var { addSignal, removeSignal } = require_abort_signal();
    function noop() {
    }
    var StreamHandler = class extends AsyncResource {
      constructor(opts, factory, callback) {
        if (!opts || typeof opts !== "object") {
          throw new InvalidArgumentError("invalid opts");
        }
        const { signal, method, opaque, body, onInfo, responseHeaders } = opts;
        try {
          if (typeof callback !== "function") {
            throw new InvalidArgumentError("invalid callback");
          }
          if (typeof factory !== "function") {
            throw new InvalidArgumentError("invalid factory");
          }
          if (signal && typeof signal.on !== "function" && typeof signal.addEventListener !== "function") {
            throw new InvalidArgumentError("signal must be an EventEmitter or EventTarget");
          }
          if (method === "CONNECT") {
            throw new InvalidArgumentError("invalid method");
          }
          if (onInfo && typeof onInfo !== "function") {
            throw new InvalidArgumentError("invalid onInfo callback");
          }
          super("UNDICI_STREAM");
        } catch (err) {
          if (util.isStream(body)) {
            util.destroy(body.on("error", noop), err);
          }
          throw err;
        }
        this.responseHeaders = responseHeaders || null;
        this.opaque = opaque || null;
        this.factory = factory;
        this.callback = callback;
        this.res = null;
        this.abort = null;
        this.context = null;
        this.trailers = null;
        this.body = body;
        this.onInfo = onInfo || null;
        if (util.isStream(body)) {
          body.on("error", (err) => {
            this.onError(err);
          });
        }
        addSignal(this, signal);
      }
      onConnect(abort, context) {
        if (this.reason) {
          abort(this.reason);
          return;
        }
        assert(this.callback);
        this.abort = abort;
        this.context = context;
      }
      onHeaders(statusCode, rawHeaders, resume, statusMessage) {
        const { factory, opaque, context, responseHeaders } = this;
        const headers = responseHeaders === "raw" ? util.parseRawHeaders(rawHeaders) : util.parseHeaders(rawHeaders);
        if (statusCode < 200) {
          if (this.onInfo) {
            this.onInfo({ statusCode, headers });
          }
          return;
        }
        this.factory = null;
        if (factory === null) {
          return;
        }
        const res = this.runInAsyncScope(factory, null, {
          statusCode,
          headers,
          opaque,
          context
        });
        if (!res || typeof res.write !== "function" || typeof res.end !== "function" || typeof res.on !== "function") {
          throw new InvalidReturnValueError("expected Writable");
        }
        finished(res, { readable: false }, (err) => {
          const { callback, res: res2, opaque: opaque2, trailers, abort } = this;
          this.res = null;
          if (err || !res2?.readable) {
            util.destroy(res2, err);
          }
          this.callback = null;
          this.runInAsyncScope(callback, null, err || null, { opaque: opaque2, trailers });
          if (err) {
            abort();
          }
        });
        res.on("drain", resume);
        this.res = res;
        const needDrain = res.writableNeedDrain !== void 0 ? res.writableNeedDrain : res._writableState?.needDrain;
        return needDrain !== true;
      }
      onData(chunk) {
        const { res } = this;
        return res ? res.write(chunk) : true;
      }
      onComplete(trailers) {
        const { res } = this;
        removeSignal(this);
        if (!res) {
          return;
        }
        this.trailers = util.parseHeaders(trailers);
        res.end();
      }
      onError(err) {
        const { res, callback, opaque, body } = this;
        removeSignal(this);
        this.factory = null;
        if (res) {
          this.res = null;
          util.destroy(res, err);
        } else if (callback) {
          this.callback = null;
          queueMicrotask(() => {
            this.runInAsyncScope(callback, null, err, { opaque });
          });
        }
        if (body) {
          this.body = null;
          util.destroy(body, err);
        }
      }
    };
    function stream(opts, factory, callback) {
      if (callback === void 0) {
        return new Promise((resolve, reject) => {
          stream.call(this, opts, factory, (err, data) => {
            return err ? reject(err) : resolve(data);
          });
        });
      }
      try {
        const handler = new StreamHandler(opts, factory, callback);
        this.dispatch(opts, handler);
      } catch (err) {
        if (typeof callback !== "function") {
          throw err;
        }
        const opaque = opts?.opaque;
        queueMicrotask(() => callback(err, { opaque }));
      }
    }
    module2.exports = stream;
  }
});

// node_modules/undici/lib/api/api-pipeline.js
var require_api_pipeline = __commonJS({
  "node_modules/undici/lib/api/api-pipeline.js"(exports2, module2) {
    "use strict";
    var {
      Readable,
      Duplex,
      PassThrough
    } = require("node:stream");
    var assert = require("node:assert");
    var { AsyncResource } = require("node:async_hooks");
    var {
      InvalidArgumentError,
      InvalidReturnValueError,
      RequestAbortedError
    } = require_errors5();
    var util = require_util4();
    var { addSignal, removeSignal } = require_abort_signal();
    function noop() {
    }
    var kResume = Symbol("resume");
    var PipelineRequest = class extends Readable {
      constructor() {
        super({ autoDestroy: true });
        this[kResume] = null;
      }
      _read() {
        const { [kResume]: resume } = this;
        if (resume) {
          this[kResume] = null;
          resume();
        }
      }
      _destroy(err, callback) {
        this._read();
        callback(err);
      }
    };
    var PipelineResponse = class extends Readable {
      constructor(resume) {
        super({ autoDestroy: true });
        this[kResume] = resume;
      }
      _read() {
        this[kResume]();
      }
      _destroy(err, callback) {
        if (!err && !this._readableState.endEmitted) {
          err = new RequestAbortedError();
        }
        callback(err);
      }
    };
    var PipelineHandler = class extends AsyncResource {
      constructor(opts, handler) {
        if (!opts || typeof opts !== "object") {
          throw new InvalidArgumentError("invalid opts");
        }
        if (typeof handler !== "function") {
          throw new InvalidArgumentError("invalid handler");
        }
        const { signal, method, opaque, onInfo, responseHeaders } = opts;
        if (signal && typeof signal.on !== "function" && typeof signal.addEventListener !== "function") {
          throw new InvalidArgumentError("signal must be an EventEmitter or EventTarget");
        }
        if (method === "CONNECT") {
          throw new InvalidArgumentError("invalid method");
        }
        if (onInfo && typeof onInfo !== "function") {
          throw new InvalidArgumentError("invalid onInfo callback");
        }
        super("UNDICI_PIPELINE");
        this.opaque = opaque || null;
        this.responseHeaders = responseHeaders || null;
        this.handler = handler;
        this.abort = null;
        this.context = null;
        this.onInfo = onInfo || null;
        this.req = new PipelineRequest().on("error", noop);
        this.ret = new Duplex({
          readableObjectMode: opts.objectMode,
          autoDestroy: true,
          read: () => {
            const { body } = this;
            if (body?.resume) {
              body.resume();
            }
          },
          write: (chunk, encoding, callback) => {
            const { req } = this;
            if (req.push(chunk, encoding) || req._readableState.destroyed) {
              callback();
            } else {
              req[kResume] = callback;
            }
          },
          destroy: (err, callback) => {
            const { body, req, res, ret, abort } = this;
            if (!err && !ret._readableState.endEmitted) {
              err = new RequestAbortedError();
            }
            if (abort && err) {
              abort();
            }
            util.destroy(body, err);
            util.destroy(req, err);
            util.destroy(res, err);
            removeSignal(this);
            callback(err);
          }
        }).on("prefinish", () => {
          const { req } = this;
          req.push(null);
        });
        this.res = null;
        addSignal(this, signal);
      }
      onConnect(abort, context) {
        const { res } = this;
        if (this.reason) {
          abort(this.reason);
          return;
        }
        assert(!res, "pipeline cannot be retried");
        this.abort = abort;
        this.context = context;
      }
      onHeaders(statusCode, rawHeaders, resume) {
        const { opaque, handler, context } = this;
        if (statusCode < 200) {
          if (this.onInfo) {
            const headers = this.responseHeaders === "raw" ? util.parseRawHeaders(rawHeaders) : util.parseHeaders(rawHeaders);
            this.onInfo({ statusCode, headers });
          }
          return;
        }
        this.res = new PipelineResponse(resume);
        let body;
        try {
          this.handler = null;
          const headers = this.responseHeaders === "raw" ? util.parseRawHeaders(rawHeaders) : util.parseHeaders(rawHeaders);
          body = this.runInAsyncScope(handler, null, {
            statusCode,
            headers,
            opaque,
            body: this.res,
            context
          });
        } catch (err) {
          this.res.on("error", noop);
          throw err;
        }
        if (!body || typeof body.on !== "function") {
          throw new InvalidReturnValueError("expected Readable");
        }
        body.on("data", (chunk) => {
          const { ret, body: body2 } = this;
          if (!ret.push(chunk) && body2.pause) {
            body2.pause();
          }
        }).on("error", (err) => {
          const { ret } = this;
          util.destroy(ret, err);
        }).on("end", () => {
          const { ret } = this;
          ret.push(null);
        }).on("close", () => {
          const { ret } = this;
          if (!ret._readableState.ended) {
            util.destroy(ret, new RequestAbortedError());
          }
        });
        this.body = body;
      }
      onData(chunk) {
        const { res } = this;
        return res.push(chunk);
      }
      onComplete(trailers) {
        const { res } = this;
        res.push(null);
      }
      onError(err) {
        const { ret } = this;
        this.handler = null;
        util.destroy(ret, err);
      }
    };
    function pipeline(opts, handler) {
      try {
        const pipelineHandler = new PipelineHandler(opts, handler);
        this.dispatch({ ...opts, body: pipelineHandler.req }, pipelineHandler);
        return pipelineHandler.ret;
      } catch (err) {
        return new PassThrough().destroy(err);
      }
    }
    module2.exports = pipeline;
  }
});

// node_modules/undici/lib/api/api-upgrade.js
var require_api_upgrade = __commonJS({
  "node_modules/undici/lib/api/api-upgrade.js"(exports2, module2) {
    "use strict";
    var { InvalidArgumentError, SocketError } = require_errors5();
    var { AsyncResource } = require("node:async_hooks");
    var assert = require("node:assert");
    var util = require_util4();
    var { addSignal, removeSignal } = require_abort_signal();
    var UpgradeHandler = class extends AsyncResource {
      constructor(opts, callback) {
        if (!opts || typeof opts !== "object") {
          throw new InvalidArgumentError("invalid opts");
        }
        if (typeof callback !== "function") {
          throw new InvalidArgumentError("invalid callback");
        }
        const { signal, opaque, responseHeaders } = opts;
        if (signal && typeof signal.on !== "function" && typeof signal.addEventListener !== "function") {
          throw new InvalidArgumentError("signal must be an EventEmitter or EventTarget");
        }
        super("UNDICI_UPGRADE");
        this.responseHeaders = responseHeaders || null;
        this.opaque = opaque || null;
        this.callback = callback;
        this.abort = null;
        this.context = null;
        addSignal(this, signal);
      }
      onConnect(abort, context) {
        if (this.reason) {
          abort(this.reason);
          return;
        }
        assert(this.callback);
        this.abort = abort;
        this.context = null;
      }
      onHeaders() {
        throw new SocketError("bad upgrade", null);
      }
      onUpgrade(statusCode, rawHeaders, socket) {
        assert(statusCode === 101);
        const { callback, opaque, context } = this;
        removeSignal(this);
        this.callback = null;
        const headers = this.responseHeaders === "raw" ? util.parseRawHeaders(rawHeaders) : util.parseHeaders(rawHeaders);
        this.runInAsyncScope(callback, null, null, {
          headers,
          socket,
          opaque,
          context
        });
      }
      onError(err) {
        const { callback, opaque } = this;
        removeSignal(this);
        if (callback) {
          this.callback = null;
          queueMicrotask(() => {
            this.runInAsyncScope(callback, null, err, { opaque });
          });
        }
      }
    };
    function upgrade(opts, callback) {
      if (callback === void 0) {
        return new Promise((resolve, reject) => {
          upgrade.call(this, opts, (err, data) => {
            return err ? reject(err) : resolve(data);
          });
        });
      }
      try {
        const upgradeHandler = new UpgradeHandler(opts, callback);
        const upgradeOpts = {
          ...opts,
          method: opts.method || "GET",
          upgrade: opts.protocol || "Websocket"
        };
        this.dispatch(upgradeOpts, upgradeHandler);
      } catch (err) {
        if (typeof callback !== "function") {
          throw err;
        }
        const opaque = opts?.opaque;
        queueMicrotask(() => callback(err, { opaque }));
      }
    }
    module2.exports = upgrade;
  }
});

// node_modules/undici/lib/api/api-connect.js
var require_api_connect = __commonJS({
  "node_modules/undici/lib/api/api-connect.js"(exports2, module2) {
    "use strict";
    var assert = require("node:assert");
    var { AsyncResource } = require("node:async_hooks");
    var { InvalidArgumentError, SocketError } = require_errors5();
    var util = require_util4();
    var { addSignal, removeSignal } = require_abort_signal();
    var ConnectHandler = class extends AsyncResource {
      constructor(opts, callback) {
        if (!opts || typeof opts !== "object") {
          throw new InvalidArgumentError("invalid opts");
        }
        if (typeof callback !== "function") {
          throw new InvalidArgumentError("invalid callback");
        }
        const { signal, opaque, responseHeaders } = opts;
        if (signal && typeof signal.on !== "function" && typeof signal.addEventListener !== "function") {
          throw new InvalidArgumentError("signal must be an EventEmitter or EventTarget");
        }
        super("UNDICI_CONNECT");
        this.opaque = opaque || null;
        this.responseHeaders = responseHeaders || null;
        this.callback = callback;
        this.abort = null;
        addSignal(this, signal);
      }
      onConnect(abort, context) {
        if (this.reason) {
          abort(this.reason);
          return;
        }
        assert(this.callback);
        this.abort = abort;
        this.context = context;
      }
      onHeaders() {
        throw new SocketError("bad connect", null);
      }
      onUpgrade(statusCode, rawHeaders, socket) {
        const { callback, opaque, context } = this;
        removeSignal(this);
        this.callback = null;
        let headers = rawHeaders;
        if (headers != null) {
          headers = this.responseHeaders === "raw" ? util.parseRawHeaders(rawHeaders) : util.parseHeaders(rawHeaders);
        }
        this.runInAsyncScope(callback, null, null, {
          statusCode,
          headers,
          socket,
          opaque,
          context
        });
      }
      onError(err) {
        const { callback, opaque } = this;
        removeSignal(this);
        if (callback) {
          this.callback = null;
          queueMicrotask(() => {
            this.runInAsyncScope(callback, null, err, { opaque });
          });
        }
      }
    };
    function connect(opts, callback) {
      if (callback === void 0) {
        return new Promise((resolve, reject) => {
          connect.call(this, opts, (err, data) => {
            return err ? reject(err) : resolve(data);
          });
        });
      }
      try {
        const connectHandler = new ConnectHandler(opts, callback);
        const connectOptions = { ...opts, method: "CONNECT" };
        this.dispatch(connectOptions, connectHandler);
      } catch (err) {
        if (typeof callback !== "function") {
          throw err;
        }
        const opaque = opts?.opaque;
        queueMicrotask(() => callback(err, { opaque }));
      }
    }
    module2.exports = connect;
  }
});

// node_modules/undici/lib/api/index.js
var require_api = __commonJS({
  "node_modules/undici/lib/api/index.js"(exports2, module2) {
    "use strict";
    module2.exports.request = require_api_request();
    module2.exports.stream = require_api_stream();
    module2.exports.pipeline = require_api_pipeline();
    module2.exports.upgrade = require_api_upgrade();
    module2.exports.connect = require_api_connect();
  }
});

// node_modules/undici/lib/mock/mock-errors.js
var require_mock_errors = __commonJS({
  "node_modules/undici/lib/mock/mock-errors.js"(exports2, module2) {
    "use strict";
    var { UndiciError } = require_errors5();
    var MockNotMatchedError = class extends UndiciError {
      constructor(message) {
        super(message);
        this.name = "MockNotMatchedError";
        this.message = message || "The request does not match any registered mock dispatches";
        this.code = "UND_MOCK_ERR_MOCK_NOT_MATCHED";
      }
    };
    module2.exports = {
      MockNotMatchedError
    };
  }
});

// node_modules/undici/lib/mock/mock-symbols.js
var require_mock_symbols = __commonJS({
  "node_modules/undici/lib/mock/mock-symbols.js"(exports2, module2) {
    "use strict";
    module2.exports = {
      kAgent: Symbol("agent"),
      kOptions: Symbol("options"),
      kFactory: Symbol("factory"),
      kDispatches: Symbol("dispatches"),
      kDispatchKey: Symbol("dispatch key"),
      kDefaultHeaders: Symbol("default headers"),
      kDefaultTrailers: Symbol("default trailers"),
      kContentLength: Symbol("content length"),
      kMockAgent: Symbol("mock agent"),
      kMockAgentSet: Symbol("mock agent set"),
      kMockAgentGet: Symbol("mock agent get"),
      kMockDispatch: Symbol("mock dispatch"),
      kClose: Symbol("close"),
      kOriginalClose: Symbol("original agent close"),
      kOriginalDispatch: Symbol("original dispatch"),
      kOrigin: Symbol("origin"),
      kIsMockActive: Symbol("is mock active"),
      kNetConnect: Symbol("net connect"),
      kGetNetConnect: Symbol("get net connect"),
      kConnected: Symbol("connected"),
      kIgnoreTrailingSlash: Symbol("ignore trailing slash"),
      kMockAgentMockCallHistoryInstance: Symbol("mock agent mock call history name"),
      kMockAgentRegisterCallHistory: Symbol("mock agent register mock call history"),
      kMockAgentAddCallHistoryLog: Symbol("mock agent add call history log"),
      kMockAgentIsCallHistoryEnabled: Symbol("mock agent is call history enabled"),
      kMockAgentAcceptsNonStandardSearchParameters: Symbol("mock agent accepts non standard search parameters"),
      kMockCallHistoryAddLog: Symbol("mock call history add log")
    };
  }
});

// node_modules/undici/lib/mock/mock-utils.js
var require_mock_utils = __commonJS({
  "node_modules/undici/lib/mock/mock-utils.js"(exports2, module2) {
    "use strict";
    var { MockNotMatchedError } = require_mock_errors();
    var {
      kDispatches,
      kMockAgent,
      kOriginalDispatch,
      kOrigin,
      kGetNetConnect
    } = require_mock_symbols();
    var { serializePathWithQuery } = require_util4();
    var { STATUS_CODES } = require("node:http");
    var {
      types: {
        isPromise
      }
    } = require("node:util");
    var { InvalidArgumentError } = require_errors5();
    function matchValue(match, value) {
      if (typeof match === "string") {
        return match === value;
      }
      if (match instanceof RegExp) {
        return match.test(value);
      }
      if (typeof match === "function") {
        return match(value) === true;
      }
      return false;
    }
    function lowerCaseEntries(headers) {
      return Object.fromEntries(
        Object.entries(headers).map(([headerName, headerValue]) => {
          return [headerName.toLocaleLowerCase(), headerValue];
        })
      );
    }
    function getHeaderByName(headers, key) {
      if (Array.isArray(headers)) {
        for (let i = 0; i < headers.length; i += 2) {
          if (headers[i].toLocaleLowerCase() === key.toLocaleLowerCase()) {
            return headers[i + 1];
          }
        }
        return void 0;
      } else if (typeof headers.get === "function") {
        return headers.get(key);
      } else {
        return lowerCaseEntries(headers)[key.toLocaleLowerCase()];
      }
    }
    function buildHeadersFromArray(headers) {
      const clone = headers.slice();
      const entries = [];
      for (let index = 0; index < clone.length; index += 2) {
        entries.push([clone[index], clone[index + 1]]);
      }
      return Object.fromEntries(entries);
    }
    function matchHeaders(mockDispatch2, headers) {
      if (typeof mockDispatch2.headers === "function") {
        if (Array.isArray(headers)) {
          headers = buildHeadersFromArray(headers);
        }
        return mockDispatch2.headers(headers ? lowerCaseEntries(headers) : {});
      }
      if (typeof mockDispatch2.headers === "undefined") {
        return true;
      }
      if (typeof headers !== "object" || typeof mockDispatch2.headers !== "object") {
        return false;
      }
      for (const [matchHeaderName, matchHeaderValue] of Object.entries(mockDispatch2.headers)) {
        const headerValue = getHeaderByName(headers, matchHeaderName);
        if (!matchValue(matchHeaderValue, headerValue)) {
          return false;
        }
      }
      return true;
    }
    function normalizeSearchParams(query) {
      if (typeof query !== "string") {
        return query;
      }
      const originalQp = new URLSearchParams(query);
      const normalizedQp = new URLSearchParams();
      for (let [key, value] of originalQp.entries()) {
        key = key.replace("[]", "");
        const valueRepresentsString = /^(['"]).*\1$/.test(value);
        if (valueRepresentsString) {
          normalizedQp.append(key, value);
          continue;
        }
        if (value.includes(",")) {
          const values = value.split(",");
          for (const v of values) {
            normalizedQp.append(key, v);
          }
          continue;
        }
        normalizedQp.append(key, value);
      }
      return normalizedQp;
    }
    function safeUrl(path4) {
      if (typeof path4 !== "string") {
        return path4;
      }
      const pathSegments = path4.split("?", 3);
      if (pathSegments.length !== 2) {
        return path4;
      }
      const qp = new URLSearchParams(pathSegments.pop());
      qp.sort();
      return [...pathSegments, qp.toString()].join("?");
    }
    function matchKey(mockDispatch2, { path: path4, method, body, headers }) {
      const pathMatch = matchValue(mockDispatch2.path, path4);
      const methodMatch = matchValue(mockDispatch2.method, method);
      const bodyMatch = typeof mockDispatch2.body !== "undefined" ? matchValue(mockDispatch2.body, body) : true;
      const headersMatch = matchHeaders(mockDispatch2, headers);
      return pathMatch && methodMatch && bodyMatch && headersMatch;
    }
    function getResponseData(data) {
      if (Buffer.isBuffer(data)) {
        return data;
      } else if (data instanceof Uint8Array) {
        return data;
      } else if (data instanceof ArrayBuffer) {
        return data;
      } else if (typeof data === "object") {
        return JSON.stringify(data);
      } else if (data) {
        return data.toString();
      } else {
        return "";
      }
    }
    function getMockDispatch(mockDispatches, key) {
      const basePath = key.query ? serializePathWithQuery(key.path, key.query) : key.path;
      const resolvedPath = typeof basePath === "string" ? safeUrl(basePath) : basePath;
      const resolvedPathWithoutTrailingSlash = removeTrailingSlash(resolvedPath);
      let matchedMockDispatches = mockDispatches.filter(({ consumed }) => !consumed).filter(({ path: path4, ignoreTrailingSlash }) => {
        return ignoreTrailingSlash ? matchValue(removeTrailingSlash(safeUrl(path4)), resolvedPathWithoutTrailingSlash) : matchValue(safeUrl(path4), resolvedPath);
      });
      if (matchedMockDispatches.length === 0) {
        throw new MockNotMatchedError(`Mock dispatch not matched for path '${resolvedPath}'`);
      }
      matchedMockDispatches = matchedMockDispatches.filter(({ method }) => matchValue(method, key.method));
      if (matchedMockDispatches.length === 0) {
        throw new MockNotMatchedError(`Mock dispatch not matched for method '${key.method}' on path '${resolvedPath}'`);
      }
      matchedMockDispatches = matchedMockDispatches.filter(({ body }) => typeof body !== "undefined" ? matchValue(body, key.body) : true);
      if (matchedMockDispatches.length === 0) {
        throw new MockNotMatchedError(`Mock dispatch not matched for body '${key.body}' on path '${resolvedPath}'`);
      }
      matchedMockDispatches = matchedMockDispatches.filter((mockDispatch2) => matchHeaders(mockDispatch2, key.headers));
      if (matchedMockDispatches.length === 0) {
        const headers = typeof key.headers === "object" ? JSON.stringify(key.headers) : key.headers;
        throw new MockNotMatchedError(`Mock dispatch not matched for headers '${headers}' on path '${resolvedPath}'`);
      }
      return matchedMockDispatches[0];
    }
    function addMockDispatch(mockDispatches, key, data, opts) {
      const baseData = { timesInvoked: 0, times: 1, persist: false, consumed: false, ...opts };
      const replyData = typeof data === "function" ? { callback: data } : { ...data };
      const newMockDispatch = { ...baseData, ...key, pending: true, data: { error: null, ...replyData } };
      mockDispatches.push(newMockDispatch);
      return newMockDispatch;
    }
    function deleteMockDispatch(mockDispatches, key) {
      const index = mockDispatches.findIndex((dispatch) => {
        if (!dispatch.consumed) {
          return false;
        }
        return matchKey(dispatch, key);
      });
      if (index !== -1) {
        mockDispatches.splice(index, 1);
      }
    }
    function removeTrailingSlash(path4) {
      while (path4.endsWith("/")) {
        path4 = path4.slice(0, -1);
      }
      if (path4.length === 0) {
        path4 = "/";
      }
      return path4;
    }
    function buildKey(opts) {
      const { path: path4, method, body, headers, query } = opts;
      return {
        path: path4,
        method,
        body,
        headers,
        query
      };
    }
    function generateKeyValues(data) {
      const keys = Object.keys(data);
      const result = [];
      for (let i = 0; i < keys.length; ++i) {
        const key = keys[i];
        const value = data[key];
        const name = Buffer.from(`${key}`);
        if (Array.isArray(value)) {
          for (let j = 0; j < value.length; ++j) {
            result.push(name, Buffer.from(`${value[j]}`));
          }
        } else {
          result.push(name, Buffer.from(`${value}`));
        }
      }
      return result;
    }
    function getStatusText(statusCode) {
      return STATUS_CODES[statusCode] || "unknown";
    }
    async function getResponse(body) {
      const buffers = [];
      for await (const data of body) {
        buffers.push(data);
      }
      return Buffer.concat(buffers).toString("utf8");
    }
    function mockDispatch(opts, handler) {
      const key = buildKey(opts);
      const mockDispatch2 = getMockDispatch(this[kDispatches], key);
      mockDispatch2.timesInvoked++;
      if (mockDispatch2.data.callback) {
        mockDispatch2.data = { ...mockDispatch2.data, ...mockDispatch2.data.callback(opts) };
      }
      const { data: { statusCode, data, headers, trailers, error }, delay, persist } = mockDispatch2;
      const { timesInvoked, times } = mockDispatch2;
      mockDispatch2.consumed = !persist && timesInvoked >= times;
      mockDispatch2.pending = timesInvoked < times;
      if (error !== null) {
        deleteMockDispatch(this[kDispatches], key);
        handler.onError(error);
        return true;
      }
      if (typeof delay === "number" && delay > 0) {
        setTimeout(() => {
          handleReply(this[kDispatches]);
        }, delay);
      } else {
        handleReply(this[kDispatches]);
      }
      function handleReply(mockDispatches, _data = data) {
        const optsHeaders = Array.isArray(opts.headers) ? buildHeadersFromArray(opts.headers) : opts.headers;
        const body = typeof _data === "function" ? _data({ ...opts, headers: optsHeaders }) : _data;
        if (isPromise(body)) {
          body.then((newData) => handleReply(mockDispatches, newData));
          return;
        }
        const responseData = getResponseData(body);
        const responseHeaders = generateKeyValues(headers);
        const responseTrailers = generateKeyValues(trailers);
        handler.onConnect?.((err) => handler.onError(err), null);
        handler.onHeaders?.(statusCode, responseHeaders, resume, getStatusText(statusCode));
        handler.onData?.(Buffer.from(responseData));
        handler.onComplete?.(responseTrailers);
        deleteMockDispatch(mockDispatches, key);
      }
      function resume() {
      }
      return true;
    }
    function buildMockDispatch() {
      const agent = this[kMockAgent];
      const origin = this[kOrigin];
      const originalDispatch = this[kOriginalDispatch];
      return function dispatch(opts, handler) {
        if (agent.isMockActive) {
          try {
            mockDispatch.call(this, opts, handler);
          } catch (error) {
            if (error instanceof MockNotMatchedError) {
              const netConnect = agent[kGetNetConnect]();
              if (netConnect === false) {
                throw new MockNotMatchedError(`${error.message}: subsequent request to origin ${origin} was not allowed (net.connect disabled)`);
              }
              if (checkNetConnect(netConnect, origin)) {
                originalDispatch.call(this, opts, handler);
              } else {
                throw new MockNotMatchedError(`${error.message}: subsequent request to origin ${origin} was not allowed (net.connect is not enabled for this origin)`);
              }
            } else {
              throw error;
            }
          }
        } else {
          originalDispatch.call(this, opts, handler);
        }
      };
    }
    function checkNetConnect(netConnect, origin) {
      const url = new URL(origin);
      if (netConnect === true) {
        return true;
      } else if (Array.isArray(netConnect) && netConnect.some((matcher) => matchValue(matcher, url.host))) {
        return true;
      }
      return false;
    }
    function buildAndValidateMockOptions(opts) {
      if (opts) {
        const { agent, ...mockOptions } = opts;
        if ("enableCallHistory" in mockOptions && typeof mockOptions.enableCallHistory !== "boolean") {
          throw new InvalidArgumentError("options.enableCallHistory must to be a boolean");
        }
        if ("acceptNonStandardSearchParameters" in mockOptions && typeof mockOptions.acceptNonStandardSearchParameters !== "boolean") {
          throw new InvalidArgumentError("options.acceptNonStandardSearchParameters must to be a boolean");
        }
        return mockOptions;
      }
    }
    module2.exports = {
      getResponseData,
      getMockDispatch,
      addMockDispatch,
      deleteMockDispatch,
      buildKey,
      generateKeyValues,
      matchValue,
      getResponse,
      getStatusText,
      mockDispatch,
      buildMockDispatch,
      checkNetConnect,
      buildAndValidateMockOptions,
      getHeaderByName,
      buildHeadersFromArray,
      normalizeSearchParams
    };
  }
});

// node_modules/undici/lib/mock/mock-interceptor.js
var require_mock_interceptor = __commonJS({
  "node_modules/undici/lib/mock/mock-interceptor.js"(exports2, module2) {
    "use strict";
    var { getResponseData, buildKey, addMockDispatch } = require_mock_utils();
    var {
      kDispatches,
      kDispatchKey,
      kDefaultHeaders,
      kDefaultTrailers,
      kContentLength,
      kMockDispatch,
      kIgnoreTrailingSlash
    } = require_mock_symbols();
    var { InvalidArgumentError } = require_errors5();
    var { serializePathWithQuery } = require_util4();
    var MockScope = class {
      constructor(mockDispatch) {
        this[kMockDispatch] = mockDispatch;
      }
      /**
       * Delay a reply by a set amount in ms.
       */
      delay(waitInMs) {
        if (typeof waitInMs !== "number" || !Number.isInteger(waitInMs) || waitInMs <= 0) {
          throw new InvalidArgumentError("waitInMs must be a valid integer > 0");
        }
        this[kMockDispatch].delay = waitInMs;
        return this;
      }
      /**
       * For a defined reply, never mark as consumed.
       */
      persist() {
        this[kMockDispatch].persist = true;
        return this;
      }
      /**
       * Allow one to define a reply for a set amount of matching requests.
       */
      times(repeatTimes) {
        if (typeof repeatTimes !== "number" || !Number.isInteger(repeatTimes) || repeatTimes <= 0) {
          throw new InvalidArgumentError("repeatTimes must be a valid integer > 0");
        }
        this[kMockDispatch].times = repeatTimes;
        return this;
      }
    };
    var MockInterceptor = class {
      constructor(opts, mockDispatches) {
        if (typeof opts !== "object") {
          throw new InvalidArgumentError("opts must be an object");
        }
        if (typeof opts.path === "undefined") {
          throw new InvalidArgumentError("opts.path must be defined");
        }
        if (typeof opts.method === "undefined") {
          opts.method = "GET";
        }
        if (typeof opts.path === "string") {
          if (opts.query) {
            opts.path = serializePathWithQuery(opts.path, opts.query);
          } else {
            const parsedURL = new URL(opts.path, "data://");
            opts.path = parsedURL.pathname + parsedURL.search;
          }
        }
        if (typeof opts.method === "string") {
          opts.method = opts.method.toUpperCase();
        }
        this[kDispatchKey] = buildKey(opts);
        this[kDispatches] = mockDispatches;
        this[kIgnoreTrailingSlash] = opts.ignoreTrailingSlash ?? false;
        this[kDefaultHeaders] = {};
        this[kDefaultTrailers] = {};
        this[kContentLength] = false;
      }
      createMockScopeDispatchData({ statusCode, data, responseOptions }) {
        const responseData = getResponseData(data);
        const contentLength = this[kContentLength] ? { "content-length": responseData.length } : {};
        const headers = { ...this[kDefaultHeaders], ...contentLength, ...responseOptions.headers };
        const trailers = { ...this[kDefaultTrailers], ...responseOptions.trailers };
        return { statusCode, data, headers, trailers };
      }
      validateReplyParameters(replyParameters) {
        if (typeof replyParameters.statusCode === "undefined") {
          throw new InvalidArgumentError("statusCode must be defined");
        }
        if (typeof replyParameters.responseOptions !== "object" || replyParameters.responseOptions === null) {
          throw new InvalidArgumentError("responseOptions must be an object");
        }
      }
      /**
       * Mock an undici request with a defined reply.
       */
      reply(replyOptionsCallbackOrStatusCode) {
        if (typeof replyOptionsCallbackOrStatusCode === "function") {
          const wrappedDefaultsCallback = (opts) => {
            const resolvedData = replyOptionsCallbackOrStatusCode(opts);
            if (typeof resolvedData !== "object" || resolvedData === null) {
              throw new InvalidArgumentError("reply options callback must return an object");
            }
            const replyParameters2 = { data: "", responseOptions: {}, ...resolvedData };
            this.validateReplyParameters(replyParameters2);
            return {
              ...this.createMockScopeDispatchData(replyParameters2)
            };
          };
          const newMockDispatch2 = addMockDispatch(this[kDispatches], this[kDispatchKey], wrappedDefaultsCallback, { ignoreTrailingSlash: this[kIgnoreTrailingSlash] });
          return new MockScope(newMockDispatch2);
        }
        const replyParameters = {
          statusCode: replyOptionsCallbackOrStatusCode,
          data: arguments[1] === void 0 ? "" : arguments[1],
          responseOptions: arguments[2] === void 0 ? {} : arguments[2]
        };
        this.validateReplyParameters(replyParameters);
        const dispatchData = this.createMockScopeDispatchData(replyParameters);
        const newMockDispatch = addMockDispatch(this[kDispatches], this[kDispatchKey], dispatchData, { ignoreTrailingSlash: this[kIgnoreTrailingSlash] });
        return new MockScope(newMockDispatch);
      }
      /**
       * Mock an undici request with a defined error.
       */
      replyWithError(error) {
        if (typeof error === "undefined") {
          throw new InvalidArgumentError("error must be defined");
        }
        const newMockDispatch = addMockDispatch(this[kDispatches], this[kDispatchKey], { error }, { ignoreTrailingSlash: this[kIgnoreTrailingSlash] });
        return new MockScope(newMockDispatch);
      }
      /**
       * Set default reply headers on the interceptor for subsequent replies
       */
      defaultReplyHeaders(headers) {
        if (typeof headers === "undefined") {
          throw new InvalidArgumentError("headers must be defined");
        }
        this[kDefaultHeaders] = headers;
        return this;
      }
      /**
       * Set default reply trailers on the interceptor for subsequent replies
       */
      defaultReplyTrailers(trailers) {
        if (typeof trailers === "undefined") {
          throw new InvalidArgumentError("trailers must be defined");
        }
        this[kDefaultTrailers] = trailers;
        return this;
      }
      /**
       * Set reply content length header for replies on the interceptor
       */
      replyContentLength() {
        this[kContentLength] = true;
        return this;
      }
    };
    module2.exports.MockInterceptor = MockInterceptor;
    module2.exports.MockScope = MockScope;
  }
});

// node_modules/undici/lib/mock/mock-client.js
var require_mock_client = __commonJS({
  "node_modules/undici/lib/mock/mock-client.js"(exports2, module2) {
    "use strict";
    var { promisify } = require("node:util");
    var Client = require_client();
    var { buildMockDispatch } = require_mock_utils();
    var {
      kDispatches,
      kMockAgent,
      kClose,
      kOriginalClose,
      kOrigin,
      kOriginalDispatch,
      kConnected,
      kIgnoreTrailingSlash
    } = require_mock_symbols();
    var { MockInterceptor } = require_mock_interceptor();
    var Symbols = require_symbols4();
    var { InvalidArgumentError } = require_errors5();
    var MockClient = class extends Client {
      constructor(origin, opts) {
        if (!opts || !opts.agent || typeof opts.agent.dispatch !== "function") {
          throw new InvalidArgumentError("Argument opts.agent must implement Agent");
        }
        super(origin, opts);
        this[kMockAgent] = opts.agent;
        this[kOrigin] = origin;
        this[kIgnoreTrailingSlash] = opts.ignoreTrailingSlash ?? false;
        this[kDispatches] = [];
        this[kConnected] = 1;
        this[kOriginalDispatch] = this.dispatch;
        this[kOriginalClose] = this.close.bind(this);
        this.dispatch = buildMockDispatch.call(this);
        this.close = this[kClose];
      }
      get [Symbols.kConnected]() {
        return this[kConnected];
      }
      /**
       * Sets up the base interceptor for mocking replies from undici.
       */
      intercept(opts) {
        return new MockInterceptor(
          opts && { ignoreTrailingSlash: this[kIgnoreTrailingSlash], ...opts },
          this[kDispatches]
        );
      }
      cleanMocks() {
        this[kDispatches] = [];
      }
      async [kClose]() {
        await promisify(this[kOriginalClose])();
        this[kConnected] = 0;
        this[kMockAgent][Symbols.kClients].delete(this[kOrigin]);
      }
    };
    module2.exports = MockClient;
  }
});

// node_modules/undici/lib/mock/mock-call-history.js
var require_mock_call_history = __commonJS({
  "node_modules/undici/lib/mock/mock-call-history.js"(exports2, module2) {
    "use strict";
    var { kMockCallHistoryAddLog } = require_mock_symbols();
    var { InvalidArgumentError } = require_errors5();
    function handleFilterCallsWithOptions(criteria, options, handler, store) {
      switch (options.operator) {
        case "OR":
          store.push(...handler(criteria));
          return store;
        case "AND":
          return handler.call({ logs: store }, criteria);
        default:
          throw new InvalidArgumentError("options.operator must to be a case insensitive string equal to 'OR' or 'AND'");
      }
    }
    function buildAndValidateFilterCallsOptions(options = {}) {
      const finalOptions = {};
      if ("operator" in options) {
        if (typeof options.operator !== "string" || options.operator.toUpperCase() !== "OR" && options.operator.toUpperCase() !== "AND") {
          throw new InvalidArgumentError("options.operator must to be a case insensitive string equal to 'OR' or 'AND'");
        }
        return {
          ...finalOptions,
          operator: options.operator.toUpperCase()
        };
      }
      return finalOptions;
    }
    function makeFilterCalls(parameterName) {
      return (parameterValue) => {
        if (typeof parameterValue === "string" || parameterValue == null) {
          return this.logs.filter((log2) => {
            return log2[parameterName] === parameterValue;
          });
        }
        if (parameterValue instanceof RegExp) {
          return this.logs.filter((log2) => {
            return parameterValue.test(log2[parameterName]);
          });
        }
        throw new InvalidArgumentError(`${parameterName} parameter should be one of string, regexp, undefined or null`);
      };
    }
    function computeUrlWithMaybeSearchParameters(requestInit) {
      try {
        const url = new URL(requestInit.path, requestInit.origin);
        if (url.search.length !== 0) {
          return url;
        }
        url.search = new URLSearchParams(requestInit.query).toString();
        return url;
      } catch (error) {
        throw new InvalidArgumentError("An error occurred when computing MockCallHistoryLog.url", { cause: error });
      }
    }
    var MockCallHistoryLog = class {
      constructor(requestInit = {}) {
        this.body = requestInit.body;
        this.headers = requestInit.headers;
        this.method = requestInit.method;
        const url = computeUrlWithMaybeSearchParameters(requestInit);
        this.fullUrl = url.toString();
        this.origin = url.origin;
        this.path = url.pathname;
        this.searchParams = Object.fromEntries(url.searchParams);
        this.protocol = url.protocol;
        this.host = url.host;
        this.port = url.port;
        this.hash = url.hash;
      }
      toMap() {
        return /* @__PURE__ */ new Map(
          [
            ["protocol", this.protocol],
            ["host", this.host],
            ["port", this.port],
            ["origin", this.origin],
            ["path", this.path],
            ["hash", this.hash],
            ["searchParams", this.searchParams],
            ["fullUrl", this.fullUrl],
            ["method", this.method],
            ["body", this.body],
            ["headers", this.headers]
          ]
        );
      }
      toString() {
        const options = { betweenKeyValueSeparator: "->", betweenPairSeparator: "|" };
        let result = "";
        this.toMap().forEach((value, key) => {
          if (typeof value === "string" || value === void 0 || value === null) {
            result = `${result}${key}${options.betweenKeyValueSeparator}${value}${options.betweenPairSeparator}`;
          }
          if (typeof value === "object" && value !== null || Array.isArray(value)) {
            result = `${result}${key}${options.betweenKeyValueSeparator}${JSON.stringify(value)}${options.betweenPairSeparator}`;
          }
        });
        return result.slice(0, -1);
      }
    };
    var MockCallHistory = class {
      logs = [];
      calls() {
        return this.logs;
      }
      firstCall() {
        return this.logs.at(0);
      }
      lastCall() {
        return this.logs.at(-1);
      }
      nthCall(number) {
        if (typeof number !== "number") {
          throw new InvalidArgumentError("nthCall must be called with a number");
        }
        if (!Number.isInteger(number)) {
          throw new InvalidArgumentError("nthCall must be called with an integer");
        }
        if (Math.sign(number) !== 1) {
          throw new InvalidArgumentError("nthCall must be called with a positive value. use firstCall or lastCall instead");
        }
        return this.logs.at(number - 1);
      }
      filterCalls(criteria, options) {
        if (this.logs.length === 0) {
          return this.logs;
        }
        if (typeof criteria === "function") {
          return this.logs.filter(criteria);
        }
        if (criteria instanceof RegExp) {
          return this.logs.filter((log2) => {
            return criteria.test(log2.toString());
          });
        }
        if (typeof criteria === "object" && criteria !== null) {
          if (Object.keys(criteria).length === 0) {
            return this.logs;
          }
          const finalOptions = { operator: "OR", ...buildAndValidateFilterCallsOptions(options) };
          let maybeDuplicatedLogsFiltered = [];
          if ("protocol" in criteria) {
            maybeDuplicatedLogsFiltered = handleFilterCallsWithOptions(criteria.protocol, finalOptions, this.filterCallsByProtocol, maybeDuplicatedLogsFiltered);
          }
          if ("host" in criteria) {
            maybeDuplicatedLogsFiltered = handleFilterCallsWithOptions(criteria.host, finalOptions, this.filterCallsByHost, maybeDuplicatedLogsFiltered);
          }
          if ("port" in criteria) {
            maybeDuplicatedLogsFiltered = handleFilterCallsWithOptions(criteria.port, finalOptions, this.filterCallsByPort, maybeDuplicatedLogsFiltered);
          }
          if ("origin" in criteria) {
            maybeDuplicatedLogsFiltered = handleFilterCallsWithOptions(criteria.origin, finalOptions, this.filterCallsByOrigin, maybeDuplicatedLogsFiltered);
          }
          if ("path" in criteria) {
            maybeDuplicatedLogsFiltered = handleFilterCallsWithOptions(criteria.path, finalOptions, this.filterCallsByPath, maybeDuplicatedLogsFiltered);
          }
          if ("hash" in criteria) {
            maybeDuplicatedLogsFiltered = handleFilterCallsWithOptions(criteria.hash, finalOptions, this.filterCallsByHash, maybeDuplicatedLogsFiltered);
          }
          if ("fullUrl" in criteria) {
            maybeDuplicatedLogsFiltered = handleFilterCallsWithOptions(criteria.fullUrl, finalOptions, this.filterCallsByFullUrl, maybeDuplicatedLogsFiltered);
          }
          if ("method" in criteria) {
            maybeDuplicatedLogsFiltered = handleFilterCallsWithOptions(criteria.method, finalOptions, this.filterCallsByMethod, maybeDuplicatedLogsFiltered);
          }
          const uniqLogsFiltered = [...new Set(maybeDuplicatedLogsFiltered)];
          return uniqLogsFiltered;
        }
        throw new InvalidArgumentError("criteria parameter should be one of function, regexp, or object");
      }
      filterCallsByProtocol = makeFilterCalls.call(this, "protocol");
      filterCallsByHost = makeFilterCalls.call(this, "host");
      filterCallsByPort = makeFilterCalls.call(this, "port");
      filterCallsByOrigin = makeFilterCalls.call(this, "origin");
      filterCallsByPath = makeFilterCalls.call(this, "path");
      filterCallsByHash = makeFilterCalls.call(this, "hash");
      filterCallsByFullUrl = makeFilterCalls.call(this, "fullUrl");
      filterCallsByMethod = makeFilterCalls.call(this, "method");
      clear() {
        this.logs = [];
      }
      [kMockCallHistoryAddLog](requestInit) {
        const log2 = new MockCallHistoryLog(requestInit);
        this.logs.push(log2);
        return log2;
      }
      *[Symbol.iterator]() {
        for (const log2 of this.calls()) {
          yield log2;
        }
      }
    };
    module2.exports.MockCallHistory = MockCallHistory;
    module2.exports.MockCallHistoryLog = MockCallHistoryLog;
  }
});

// node_modules/undici/lib/mock/mock-pool.js
var require_mock_pool = __commonJS({
  "node_modules/undici/lib/mock/mock-pool.js"(exports2, module2) {
    "use strict";
    var { promisify } = require("node:util");
    var Pool = require_pool();
    var { buildMockDispatch } = require_mock_utils();
    var {
      kDispatches,
      kMockAgent,
      kClose,
      kOriginalClose,
      kOrigin,
      kOriginalDispatch,
      kConnected,
      kIgnoreTrailingSlash
    } = require_mock_symbols();
    var { MockInterceptor } = require_mock_interceptor();
    var Symbols = require_symbols4();
    var { InvalidArgumentError } = require_errors5();
    var MockPool = class extends Pool {
      constructor(origin, opts) {
        if (!opts || !opts.agent || typeof opts.agent.dispatch !== "function") {
          throw new InvalidArgumentError("Argument opts.agent must implement Agent");
        }
        super(origin, opts);
        this[kMockAgent] = opts.agent;
        this[kOrigin] = origin;
        this[kIgnoreTrailingSlash] = opts.ignoreTrailingSlash ?? false;
        this[kDispatches] = [];
        this[kConnected] = 1;
        this[kOriginalDispatch] = this.dispatch;
        this[kOriginalClose] = this.close.bind(this);
        this.dispatch = buildMockDispatch.call(this);
        this.close = this[kClose];
      }
      get [Symbols.kConnected]() {
        return this[kConnected];
      }
      /**
       * Sets up the base interceptor for mocking replies from undici.
       */
      intercept(opts) {
        return new MockInterceptor(
          opts && { ignoreTrailingSlash: this[kIgnoreTrailingSlash], ...opts },
          this[kDispatches]
        );
      }
      cleanMocks() {
        this[kDispatches] = [];
      }
      async [kClose]() {
        await promisify(this[kOriginalClose])();
        this[kConnected] = 0;
        this[kMockAgent][Symbols.kClients].delete(this[kOrigin]);
      }
    };
    module2.exports = MockPool;
  }
});

// node_modules/undici/lib/mock/pending-interceptors-formatter.js
var require_pending_interceptors_formatter = __commonJS({
  "node_modules/undici/lib/mock/pending-interceptors-formatter.js"(exports2, module2) {
    "use strict";
    var { Transform } = require("node:stream");
    var { Console } = require("node:console");
    var PERSISTENT = process.versions.icu ? "\u2705" : "Y ";
    var NOT_PERSISTENT = process.versions.icu ? "\u274C" : "N ";
    module2.exports = class PendingInterceptorsFormatter {
      constructor({ disableColors } = {}) {
        this.transform = new Transform({
          transform(chunk, _enc, cb) {
            cb(null, chunk);
          }
        });
        this.logger = new Console({
          stdout: this.transform,
          inspectOptions: {
            colors: !disableColors && !process.env.CI
          }
        });
      }
      format(pendingInterceptors) {
        const withPrettyHeaders = pendingInterceptors.map(
          ({ method, path: path4, data: { statusCode }, persist, times, timesInvoked, origin }) => ({
            Method: method,
            Origin: origin,
            Path: path4,
            "Status code": statusCode,
            Persistent: persist ? PERSISTENT : NOT_PERSISTENT,
            Invocations: timesInvoked,
            Remaining: persist ? Infinity : times - timesInvoked
          })
        );
        this.logger.table(withPrettyHeaders);
        return this.transform.read().toString();
      }
    };
  }
});

// node_modules/undici/lib/mock/mock-agent.js
var require_mock_agent = __commonJS({
  "node_modules/undici/lib/mock/mock-agent.js"(exports2, module2) {
    "use strict";
    var { kClients } = require_symbols4();
    var Agent = require_agent();
    var {
      kAgent,
      kMockAgentSet,
      kMockAgentGet,
      kDispatches,
      kIsMockActive,
      kNetConnect,
      kGetNetConnect,
      kOptions,
      kFactory,
      kMockAgentRegisterCallHistory,
      kMockAgentIsCallHistoryEnabled,
      kMockAgentAddCallHistoryLog,
      kMockAgentMockCallHistoryInstance,
      kMockAgentAcceptsNonStandardSearchParameters,
      kMockCallHistoryAddLog,
      kIgnoreTrailingSlash
    } = require_mock_symbols();
    var MockClient = require_mock_client();
    var MockPool = require_mock_pool();
    var { matchValue, normalizeSearchParams, buildAndValidateMockOptions } = require_mock_utils();
    var { InvalidArgumentError, UndiciError } = require_errors5();
    var Dispatcher = require_dispatcher();
    var PendingInterceptorsFormatter = require_pending_interceptors_formatter();
    var { MockCallHistory } = require_mock_call_history();
    var MockAgent = class extends Dispatcher {
      constructor(opts) {
        super(opts);
        const mockOptions = buildAndValidateMockOptions(opts);
        this[kNetConnect] = true;
        this[kIsMockActive] = true;
        this[kMockAgentIsCallHistoryEnabled] = mockOptions?.enableCallHistory ?? false;
        this[kMockAgentAcceptsNonStandardSearchParameters] = mockOptions?.acceptNonStandardSearchParameters ?? false;
        this[kIgnoreTrailingSlash] = mockOptions?.ignoreTrailingSlash ?? false;
        if (opts?.agent && typeof opts.agent.dispatch !== "function") {
          throw new InvalidArgumentError("Argument opts.agent must implement Agent");
        }
        const agent = opts?.agent ? opts.agent : new Agent(opts);
        this[kAgent] = agent;
        this[kClients] = agent[kClients];
        this[kOptions] = mockOptions;
        if (this[kMockAgentIsCallHistoryEnabled]) {
          this[kMockAgentRegisterCallHistory]();
        }
      }
      get(origin) {
        const originKey = this[kIgnoreTrailingSlash] ? origin.replace(/\/$/, "") : origin;
        let dispatcher = this[kMockAgentGet](originKey);
        if (!dispatcher) {
          dispatcher = this[kFactory](originKey);
          this[kMockAgentSet](originKey, dispatcher);
        }
        return dispatcher;
      }
      dispatch(opts, handler) {
        this.get(opts.origin);
        this[kMockAgentAddCallHistoryLog](opts);
        const acceptNonStandardSearchParameters = this[kMockAgentAcceptsNonStandardSearchParameters];
        const dispatchOpts = { ...opts };
        if (acceptNonStandardSearchParameters && dispatchOpts.path) {
          const [path4, searchParams] = dispatchOpts.path.split("?");
          const normalizedSearchParams = normalizeSearchParams(searchParams, acceptNonStandardSearchParameters);
          dispatchOpts.path = `${path4}?${normalizedSearchParams}`;
        }
        return this[kAgent].dispatch(dispatchOpts, handler);
      }
      async close() {
        this.clearCallHistory();
        await this[kAgent].close();
        this[kClients].clear();
      }
      deactivate() {
        this[kIsMockActive] = false;
      }
      activate() {
        this[kIsMockActive] = true;
      }
      enableNetConnect(matcher) {
        if (typeof matcher === "string" || typeof matcher === "function" || matcher instanceof RegExp) {
          if (Array.isArray(this[kNetConnect])) {
            this[kNetConnect].push(matcher);
          } else {
            this[kNetConnect] = [matcher];
          }
        } else if (typeof matcher === "undefined") {
          this[kNetConnect] = true;
        } else {
          throw new InvalidArgumentError("Unsupported matcher. Must be one of String|Function|RegExp.");
        }
      }
      disableNetConnect() {
        this[kNetConnect] = false;
      }
      enableCallHistory() {
        this[kMockAgentIsCallHistoryEnabled] = true;
        return this;
      }
      disableCallHistory() {
        this[kMockAgentIsCallHistoryEnabled] = false;
        return this;
      }
      getCallHistory() {
        return this[kMockAgentMockCallHistoryInstance];
      }
      clearCallHistory() {
        if (this[kMockAgentMockCallHistoryInstance] !== void 0) {
          this[kMockAgentMockCallHistoryInstance].clear();
        }
      }
      // This is required to bypass issues caused by using global symbols - see:
      // https://github.com/nodejs/undici/issues/1447
      get isMockActive() {
        return this[kIsMockActive];
      }
      [kMockAgentRegisterCallHistory]() {
        if (this[kMockAgentMockCallHistoryInstance] === void 0) {
          this[kMockAgentMockCallHistoryInstance] = new MockCallHistory();
        }
      }
      [kMockAgentAddCallHistoryLog](opts) {
        if (this[kMockAgentIsCallHistoryEnabled]) {
          this[kMockAgentRegisterCallHistory]();
          this[kMockAgentMockCallHistoryInstance][kMockCallHistoryAddLog](opts);
        }
      }
      [kMockAgentSet](origin, dispatcher) {
        this[kClients].set(origin, { count: 0, dispatcher });
      }
      [kFactory](origin) {
        const mockOptions = Object.assign({ agent: this }, this[kOptions]);
        return this[kOptions] && this[kOptions].connections === 1 ? new MockClient(origin, mockOptions) : new MockPool(origin, mockOptions);
      }
      [kMockAgentGet](origin) {
        const result = this[kClients].get(origin);
        if (result?.dispatcher) {
          return result.dispatcher;
        }
        if (typeof origin !== "string") {
          const dispatcher = this[kFactory]("http://localhost:9999");
          this[kMockAgentSet](origin, dispatcher);
          return dispatcher;
        }
        for (const [keyMatcher, result2] of Array.from(this[kClients])) {
          if (result2 && typeof keyMatcher !== "string" && matchValue(keyMatcher, origin)) {
            const dispatcher = this[kFactory](origin);
            this[kMockAgentSet](origin, dispatcher);
            dispatcher[kDispatches] = result2.dispatcher[kDispatches];
            return dispatcher;
          }
        }
      }
      [kGetNetConnect]() {
        return this[kNetConnect];
      }
      pendingInterceptors() {
        const mockAgentClients = this[kClients];
        return Array.from(mockAgentClients.entries()).flatMap(([origin, result]) => result.dispatcher[kDispatches].map((dispatch) => ({ ...dispatch, origin }))).filter(({ pending }) => pending);
      }
      assertNoPendingInterceptors({ pendingInterceptorsFormatter = new PendingInterceptorsFormatter() } = {}) {
        const pending = this.pendingInterceptors();
        if (pending.length === 0) {
          return;
        }
        throw new UndiciError(
          pending.length === 1 ? `1 interceptor is pending:

${pendingInterceptorsFormatter.format(pending)}`.trim() : `${pending.length} interceptors are pending:

${pendingInterceptorsFormatter.format(pending)}`.trim()
        );
      }
    };
    module2.exports = MockAgent;
  }
});

// node_modules/undici/lib/mock/snapshot-recorder.js
var require_snapshot_recorder = __commonJS({
  "node_modules/undici/lib/mock/snapshot-recorder.js"(exports2, module2) {
    "use strict";
    var { writeFile: writeFile2, readFile, mkdir } = require("node:fs/promises");
    var { dirname, resolve } = require("node:path");
    var { InvalidArgumentError, UndiciError } = require_errors5();
    function formatRequestKey(opts, cachedSets, matchOptions = {}) {
      const url = new URL(opts.path, opts.origin);
      const normalized = opts._normalizedHeaders || normalizeHeaders(opts.headers);
      if (!opts._normalizedHeaders) {
        opts._normalizedHeaders = normalized;
      }
      return {
        method: opts.method || "GET",
        url: matchOptions.matchQuery !== false ? url.toString() : `${url.origin}${url.pathname}`,
        headers: filterHeadersForMatching(normalized, cachedSets, matchOptions),
        body: matchOptions.matchBody !== false && opts.body ? String(opts.body) : void 0
      };
    }
    function filterHeadersForMatching(headers, cachedSets, matchOptions = {}) {
      if (!headers || typeof headers !== "object") return {};
      const {
        matchHeaders = null,
        caseSensitive = false
      } = matchOptions;
      const filtered = {};
      const { ignoreSet, excludeSet, matchSet } = cachedSets;
      for (const [key, value] of Object.entries(headers)) {
        const headerKey = caseSensitive ? key : key.toLowerCase();
        if (excludeSet.has(headerKey)) continue;
        if (ignoreSet.has(headerKey)) continue;
        if (matchHeaders && Array.isArray(matchHeaders)) {
          if (!matchSet.has(headerKey)) continue;
        }
        filtered[headerKey] = value;
      }
      return filtered;
    }
    function filterHeadersForStorage(headers, matchOptions = {}) {
      if (!headers || typeof headers !== "object") return {};
      const {
        excludeHeaders = [],
        caseSensitive = false
      } = matchOptions;
      const filtered = {};
      const excludeSet = new Set(excludeHeaders.map((h) => caseSensitive ? h : h.toLowerCase()));
      for (const [key, value] of Object.entries(headers)) {
        const headerKey = caseSensitive ? key : key.toLowerCase();
        if (excludeSet.has(headerKey)) continue;
        filtered[headerKey] = value;
      }
      return filtered;
    }
    function createHeaderSetsCache(matchOptions = {}) {
      const { ignoreHeaders = [], excludeHeaders = [], matchHeaders = null, caseSensitive = false } = matchOptions;
      return {
        ignoreSet: new Set(ignoreHeaders.map((h) => caseSensitive ? h : h.toLowerCase())),
        excludeSet: new Set(excludeHeaders.map((h) => caseSensitive ? h : h.toLowerCase())),
        matchSet: matchHeaders && Array.isArray(matchHeaders) ? new Set(matchHeaders.map((h) => caseSensitive ? h : h.toLowerCase())) : null
      };
    }
    function normalizeHeaders(headers) {
      if (!headers) return {};
      const normalized = {};
      if (Array.isArray(headers)) {
        for (let i = 0; i < headers.length; i += 2) {
          const key = headers[i];
          const value = headers[i + 1];
          if (key && value !== void 0) {
            const keyStr = Buffer.isBuffer(key) ? key.toString() : String(key);
            const valueStr = Buffer.isBuffer(value) ? value.toString() : String(value);
            normalized[keyStr.toLowerCase()] = valueStr;
          }
        }
        return normalized;
      }
      if (headers && typeof headers === "object") {
        for (const [key, value] of Object.entries(headers)) {
          if (key && typeof key === "string") {
            normalized[key.toLowerCase()] = Array.isArray(value) ? value.join(", ") : String(value);
          }
        }
      }
      return normalized;
    }
    function createRequestHash(request) {
      const parts = [
        request.method,
        request.url,
        JSON.stringify(request.headers, Object.keys(request.headers).sort()),
        request.body || ""
      ];
      return Buffer.from(parts.join("|")).toString("base64url");
    }
    function isUrlExcluded(url, excludePatterns = []) {
      if (!excludePatterns.length) return false;
      for (const pattern of excludePatterns) {
        if (typeof pattern === "string") {
          if (url.toLowerCase().includes(pattern.toLowerCase())) {
            return true;
          }
        } else if (pattern instanceof RegExp) {
          if (pattern.test(url)) {
            return true;
          }
        }
      }
      return false;
    }
    var SnapshotRecorder = class {
      constructor(options = {}) {
        this.snapshots = /* @__PURE__ */ new Map();
        this.snapshotPath = options.snapshotPath;
        this.mode = options.mode || "record";
        this.loaded = false;
        this.maxSnapshots = options.maxSnapshots || Infinity;
        this.autoFlush = options.autoFlush || false;
        this.flushInterval = options.flushInterval || 3e4;
        this._flushTimer = null;
        this._flushTimeout = null;
        this.matchOptions = {
          matchHeaders: options.matchHeaders || null,
          // null means match all headers
          ignoreHeaders: options.ignoreHeaders || [],
          excludeHeaders: options.excludeHeaders || [],
          matchBody: options.matchBody !== false,
          // default: true
          matchQuery: options.matchQuery !== false,
          // default: true
          caseSensitive: options.caseSensitive || false
        };
        this._headerSetsCache = createHeaderSetsCache(this.matchOptions);
        this.shouldRecord = options.shouldRecord || null;
        this.shouldPlayback = options.shouldPlayback || null;
        this.excludeUrls = options.excludeUrls || [];
        if (this.autoFlush && this.snapshotPath) {
          this._startAutoFlush();
        }
      }
      /**
       * Records a request-response interaction
       */
      async record(requestOpts, response) {
        if (this.shouldRecord && typeof this.shouldRecord === "function") {
          if (!this.shouldRecord(requestOpts)) {
            return;
          }
        }
        const url = new URL(requestOpts.path, requestOpts.origin).toString();
        if (isUrlExcluded(url, this.excludeUrls)) {
          return;
        }
        const request = formatRequestKey(requestOpts, this._headerSetsCache, this.matchOptions);
        const hash = createRequestHash(request);
        const normalizedHeaders = normalizeHeaders(response.headers);
        const responseData = {
          statusCode: response.statusCode,
          headers: filterHeadersForStorage(normalizedHeaders, this.matchOptions),
          body: Buffer.isBuffer(response.body) ? response.body.toString("base64") : Buffer.from(String(response.body || "")).toString("base64"),
          trailers: response.trailers
        };
        if (this.snapshots.size >= this.maxSnapshots && !this.snapshots.has(hash)) {
          const oldestKey = this.snapshots.keys().next().value;
          this.snapshots.delete(oldestKey);
        }
        const existingSnapshot = this.snapshots.get(hash);
        if (existingSnapshot && existingSnapshot.responses) {
          existingSnapshot.responses.push(responseData);
          existingSnapshot.timestamp = (/* @__PURE__ */ new Date()).toISOString();
        } else {
          this.snapshots.set(hash, {
            request,
            responses: [responseData],
            // Always store as array for consistency
            callCount: 0,
            timestamp: (/* @__PURE__ */ new Date()).toISOString()
          });
        }
        if (this.autoFlush && this.snapshotPath) {
          this._scheduleFlush();
        }
      }
      /**
       * Finds a matching snapshot for the given request
       * Returns the appropriate response based on call count for sequential responses
       */
      findSnapshot(requestOpts) {
        if (this.shouldPlayback && typeof this.shouldPlayback === "function") {
          if (!this.shouldPlayback(requestOpts)) {
            return void 0;
          }
        }
        const url = new URL(requestOpts.path, requestOpts.origin).toString();
        if (isUrlExcluded(url, this.excludeUrls)) {
          return void 0;
        }
        const request = formatRequestKey(requestOpts, this._headerSetsCache, this.matchOptions);
        const hash = createRequestHash(request);
        const snapshot = this.snapshots.get(hash);
        if (!snapshot) return void 0;
        if (snapshot.responses && Array.isArray(snapshot.responses)) {
          const currentCallCount = snapshot.callCount || 0;
          const responseIndex = Math.min(currentCallCount, snapshot.responses.length - 1);
          snapshot.callCount = currentCallCount + 1;
          return {
            ...snapshot,
            response: snapshot.responses[responseIndex]
          };
        }
        if (snapshot.response && !snapshot.responses) {
          snapshot.responses = [snapshot.response];
          snapshot.callCount = 1;
          delete snapshot.response;
          return {
            ...snapshot,
            response: snapshot.responses[0]
          };
        }
        return snapshot;
      }
      /**
       * Loads snapshots from file
       */
      async loadSnapshots(filePath) {
        const path4 = filePath || this.snapshotPath;
        if (!path4) {
          throw new InvalidArgumentError("Snapshot path is required");
        }
        try {
          const data = await readFile(resolve(path4), "utf8");
          const parsed = JSON.parse(data);
          if (Array.isArray(parsed)) {
            this.snapshots.clear();
            for (const { hash, snapshot } of parsed) {
              this.snapshots.set(hash, snapshot);
            }
          } else {
            this.snapshots = new Map(Object.entries(parsed));
          }
          this.loaded = true;
        } catch (error) {
          if (error.code === "ENOENT") {
            this.snapshots.clear();
            this.loaded = true;
          } else {
            throw new UndiciError(`Failed to load snapshots from ${path4}`, { cause: error });
          }
        }
      }
      /**
       * Saves snapshots to file
       */
      async saveSnapshots(filePath) {
        const path4 = filePath || this.snapshotPath;
        if (!path4) {
          throw new InvalidArgumentError("Snapshot path is required");
        }
        const resolvedPath = resolve(path4);
        await mkdir(dirname(resolvedPath), { recursive: true });
        const data = Array.from(this.snapshots.entries()).map(([hash, snapshot]) => ({
          hash,
          snapshot
        }));
        await writeFile2(resolvedPath, JSON.stringify(data, null, 2), "utf8", { flush: true });
      }
      /**
       * Clears all recorded snapshots
       */
      clear() {
        this.snapshots.clear();
      }
      /**
       * Gets all recorded snapshots
       */
      getSnapshots() {
        return Array.from(this.snapshots.values());
      }
      /**
       * Gets snapshot count
       */
      size() {
        return this.snapshots.size;
      }
      /**
       * Resets call counts for all snapshots (useful for test cleanup)
       */
      resetCallCounts() {
        for (const snapshot of this.snapshots.values()) {
          snapshot.callCount = 0;
        }
      }
      /**
       * Deletes a specific snapshot by request options
       */
      deleteSnapshot(requestOpts) {
        const request = formatRequestKey(requestOpts, this._headerSetsCache, this.matchOptions);
        const hash = createRequestHash(request);
        return this.snapshots.delete(hash);
      }
      /**
       * Gets information about a specific snapshot
       */
      getSnapshotInfo(requestOpts) {
        const request = formatRequestKey(requestOpts, this._headerSetsCache, this.matchOptions);
        const hash = createRequestHash(request);
        const snapshot = this.snapshots.get(hash);
        if (!snapshot) return null;
        return {
          hash,
          request: snapshot.request,
          responseCount: snapshot.responses ? snapshot.responses.length : snapshot.response ? 1 : 0,
          callCount: snapshot.callCount || 0,
          timestamp: snapshot.timestamp
        };
      }
      /**
       * Replaces all snapshots with new data (full replacement)
       */
      replaceSnapshots(snapshotData) {
        this.snapshots.clear();
        if (Array.isArray(snapshotData)) {
          for (const { hash, snapshot } of snapshotData) {
            this.snapshots.set(hash, snapshot);
          }
        } else if (snapshotData && typeof snapshotData === "object") {
          this.snapshots = new Map(Object.entries(snapshotData));
        }
      }
      /**
       * Starts the auto-flush timer
       */
      _startAutoFlush() {
        if (!this._flushTimer) {
          this._flushTimer = setInterval(() => {
            this.saveSnapshots().catch(() => {
            });
          }, this.flushInterval);
        }
      }
      /**
       * Stops the auto-flush timer
       */
      _stopAutoFlush() {
        if (this._flushTimer) {
          clearInterval(this._flushTimer);
          this._flushTimer = null;
        }
      }
      /**
       * Schedules a flush (debounced to avoid excessive writes)
       */
      _scheduleFlush() {
        if (this._flushTimeout) {
          clearTimeout(this._flushTimeout);
        }
        this._flushTimeout = setTimeout(() => {
          this.saveSnapshots().catch(() => {
          });
          this._flushTimeout = null;
        }, 1e3);
      }
      /**
       * Cleanup method to stop timers
       */
      destroy() {
        this._stopAutoFlush();
        if (this._flushTimeout) {
          clearTimeout(this._flushTimeout);
          this._flushTimeout = null;
        }
      }
      /**
       * Async close method that saves all recordings and performs cleanup
       */
      async close() {
        if (this.snapshotPath && this.snapshots.size > 0) {
          await this.saveSnapshots();
        }
        this.destroy();
      }
    };
    module2.exports = { SnapshotRecorder, formatRequestKey, createRequestHash, filterHeadersForMatching, filterHeadersForStorage, isUrlExcluded, createHeaderSetsCache };
  }
});

// node_modules/undici/lib/mock/snapshot-agent.js
var require_snapshot_agent = __commonJS({
  "node_modules/undici/lib/mock/snapshot-agent.js"(exports2, module2) {
    "use strict";
    var Agent = require_agent();
    var MockAgent = require_mock_agent();
    var { SnapshotRecorder } = require_snapshot_recorder();
    var WrapHandler = require_wrap_handler();
    var { InvalidArgumentError, UndiciError } = require_errors5();
    var kSnapshotRecorder = Symbol("kSnapshotRecorder");
    var kSnapshotMode = Symbol("kSnapshotMode");
    var kSnapshotPath = Symbol("kSnapshotPath");
    var kSnapshotLoaded = Symbol("kSnapshotLoaded");
    var kRealAgent = Symbol("kRealAgent");
    var warningEmitted = false;
    var SnapshotAgent = class extends MockAgent {
      constructor(opts = {}) {
        if (!warningEmitted) {
          process.emitWarning(
            "SnapshotAgent is experimental and subject to change",
            "ExperimentalWarning"
          );
          warningEmitted = true;
        }
        const mockOptions = { ...opts };
        delete mockOptions.mode;
        delete mockOptions.snapshotPath;
        super(mockOptions);
        const validModes = ["record", "playback", "update"];
        const mode = opts.mode || "record";
        if (!validModes.includes(mode)) {
          throw new InvalidArgumentError(`Invalid snapshot mode: ${mode}. Must be one of: ${validModes.join(", ")}`);
        }
        if ((mode === "playback" || mode === "update") && !opts.snapshotPath) {
          throw new InvalidArgumentError(`snapshotPath is required when mode is '${mode}'`);
        }
        this[kSnapshotMode] = mode;
        this[kSnapshotPath] = opts.snapshotPath;
        this[kSnapshotRecorder] = new SnapshotRecorder({
          snapshotPath: this[kSnapshotPath],
          mode: this[kSnapshotMode],
          maxSnapshots: opts.maxSnapshots,
          autoFlush: opts.autoFlush,
          flushInterval: opts.flushInterval,
          matchHeaders: opts.matchHeaders,
          ignoreHeaders: opts.ignoreHeaders,
          excludeHeaders: opts.excludeHeaders,
          matchBody: opts.matchBody,
          matchQuery: opts.matchQuery,
          caseSensitive: opts.caseSensitive,
          shouldRecord: opts.shouldRecord,
          shouldPlayback: opts.shouldPlayback,
          excludeUrls: opts.excludeUrls
        });
        this[kSnapshotLoaded] = false;
        if (this[kSnapshotMode] === "record" || this[kSnapshotMode] === "update") {
          this[kRealAgent] = new Agent(opts);
        }
        if ((this[kSnapshotMode] === "playback" || this[kSnapshotMode] === "update") && this[kSnapshotPath]) {
          this.loadSnapshots().catch(() => {
          });
        }
      }
      dispatch(opts, handler) {
        handler = WrapHandler.wrap(handler);
        const mode = this[kSnapshotMode];
        if (mode === "playback" || mode === "update") {
          if (!this[kSnapshotLoaded]) {
            return this._asyncDispatch(opts, handler);
          }
          const snapshot = this[kSnapshotRecorder].findSnapshot(opts);
          if (snapshot) {
            return this._replaySnapshot(snapshot, handler);
          } else if (mode === "update") {
            return this._recordAndReplay(opts, handler);
          } else {
            const error = new UndiciError(`No snapshot found for ${opts.method || "GET"} ${opts.path}`);
            if (handler.onError) {
              handler.onError(error);
              return;
            }
            throw error;
          }
        } else if (mode === "record") {
          return this._recordAndReplay(opts, handler);
        } else {
          throw new InvalidArgumentError(`Invalid snapshot mode: ${mode}. Must be 'record', 'playback', or 'update'`);
        }
      }
      /**
       * Async version of dispatch for when we need to load snapshots first
       */
      async _asyncDispatch(opts, handler) {
        await this.loadSnapshots();
        return this.dispatch(opts, handler);
      }
      /**
       * Records a real request and replays the response
       */
      _recordAndReplay(opts, handler) {
        const responseData = {
          statusCode: null,
          headers: {},
          trailers: {},
          body: []
        };
        const self2 = this;
        const recordingHandler = {
          onRequestStart(controller, context) {
            return handler.onRequestStart(controller, { ...context, history: this.history });
          },
          onRequestUpgrade(controller, statusCode, headers, socket) {
            return handler.onRequestUpgrade(controller, statusCode, headers, socket);
          },
          onResponseStart(controller, statusCode, headers, statusMessage) {
            responseData.statusCode = statusCode;
            responseData.headers = headers;
            return handler.onResponseStart(controller, statusCode, headers, statusMessage);
          },
          onResponseData(controller, chunk) {
            responseData.body.push(chunk);
            return handler.onResponseData(controller, chunk);
          },
          onResponseEnd(controller, trailers) {
            responseData.trailers = trailers;
            const responseBody = Buffer.concat(responseData.body);
            self2[kSnapshotRecorder].record(opts, {
              statusCode: responseData.statusCode,
              headers: responseData.headers,
              body: responseBody,
              trailers: responseData.trailers
            }).then(() => {
              handler.onResponseEnd(controller, trailers);
            }).catch((error) => {
              handler.onResponseError(controller, error);
            });
          }
        };
        const agent = this[kRealAgent];
        return agent.dispatch(opts, recordingHandler);
      }
      /**
       * Replays a recorded response
       */
      _replaySnapshot(snapshot, handler) {
        return new Promise((resolve) => {
          setImmediate(() => {
            try {
              const { response } = snapshot;
              const controller = {
                pause() {
                },
                resume() {
                },
                abort(reason) {
                  this.aborted = true;
                  this.reason = reason;
                },
                aborted: false,
                paused: false
              };
              handler.onRequestStart(controller);
              handler.onResponseStart(controller, response.statusCode, response.headers);
              const body = Buffer.from(response.body, "base64");
              handler.onResponseData(controller, body);
              handler.onResponseEnd(controller, response.trailers);
              resolve();
            } catch (error) {
              handler.onError?.(error);
            }
          });
        });
      }
      /**
       * Loads snapshots from file
       */
      async loadSnapshots(filePath) {
        await this[kSnapshotRecorder].loadSnapshots(filePath || this[kSnapshotPath]);
        this[kSnapshotLoaded] = true;
        if (this[kSnapshotMode] === "playback") {
          this._setupMockInterceptors();
        }
      }
      /**
       * Saves snapshots to file
       */
      async saveSnapshots(filePath) {
        return this[kSnapshotRecorder].saveSnapshots(filePath || this[kSnapshotPath]);
      }
      /**
       * Sets up MockAgent interceptors based on recorded snapshots.
       *
       * This method creates MockAgent interceptors for each recorded snapshot,
       * allowing the SnapshotAgent to fall back to MockAgent's standard intercept
       * mechanism in playback mode. Each interceptor is configured to persist
       * (remain active for multiple requests) and responds with the recorded
       * response data.
       *
       * Called automatically when loading snapshots in playback mode.
       *
       * @private
       */
      _setupMockInterceptors() {
        for (const snapshot of this[kSnapshotRecorder].getSnapshots()) {
          const { request, responses, response } = snapshot;
          const url = new URL(request.url);
          const mockPool = this.get(url.origin);
          const responseData = responses ? responses[0] : response;
          if (!responseData) continue;
          mockPool.intercept({
            path: url.pathname + url.search,
            method: request.method,
            headers: request.headers,
            body: request.body
          }).reply(responseData.statusCode, responseData.body, {
            headers: responseData.headers,
            trailers: responseData.trailers
          }).persist();
        }
      }
      /**
       * Gets the snapshot recorder
       */
      getRecorder() {
        return this[kSnapshotRecorder];
      }
      /**
       * Gets the current mode
       */
      getMode() {
        return this[kSnapshotMode];
      }
      /**
       * Clears all snapshots
       */
      clearSnapshots() {
        this[kSnapshotRecorder].clear();
      }
      /**
       * Resets call counts for all snapshots (useful for test cleanup)
       */
      resetCallCounts() {
        this[kSnapshotRecorder].resetCallCounts();
      }
      /**
       * Deletes a specific snapshot by request options
       */
      deleteSnapshot(requestOpts) {
        return this[kSnapshotRecorder].deleteSnapshot(requestOpts);
      }
      /**
       * Gets information about a specific snapshot
       */
      getSnapshotInfo(requestOpts) {
        return this[kSnapshotRecorder].getSnapshotInfo(requestOpts);
      }
      /**
       * Replaces all snapshots with new data (full replacement)
       */
      replaceSnapshots(snapshotData) {
        this[kSnapshotRecorder].replaceSnapshots(snapshotData);
      }
      async close() {
        await this[kSnapshotRecorder].close();
        await this[kRealAgent]?.close();
        await super.close();
      }
    };
    module2.exports = SnapshotAgent;
  }
});

// node_modules/undici/lib/global.js
var require_global2 = __commonJS({
  "node_modules/undici/lib/global.js"(exports2, module2) {
    "use strict";
    var globalDispatcher = Symbol.for("undici.globalDispatcher.1");
    var { InvalidArgumentError } = require_errors5();
    var Agent = require_agent();
    if (getGlobalDispatcher() === void 0) {
      setGlobalDispatcher(new Agent());
    }
    function setGlobalDispatcher(agent) {
      if (!agent || typeof agent.dispatch !== "function") {
        throw new InvalidArgumentError("Argument agent must implement Agent");
      }
      Object.defineProperty(globalThis, globalDispatcher, {
        value: agent,
        writable: true,
        enumerable: false,
        configurable: false
      });
    }
    function getGlobalDispatcher() {
      return globalThis[globalDispatcher];
    }
    module2.exports = {
      setGlobalDispatcher,
      getGlobalDispatcher
    };
  }
});

// node_modules/undici/lib/handler/decorator-handler.js
var require_decorator_handler = __commonJS({
  "node_modules/undici/lib/handler/decorator-handler.js"(exports2, module2) {
    "use strict";
    var assert = require("node:assert");
    var WrapHandler = require_wrap_handler();
    module2.exports = class DecoratorHandler {
      #handler;
      #onCompleteCalled = false;
      #onErrorCalled = false;
      #onResponseStartCalled = false;
      constructor(handler) {
        if (typeof handler !== "object" || handler === null) {
          throw new TypeError("handler must be an object");
        }
        this.#handler = WrapHandler.wrap(handler);
      }
      onRequestStart(...args) {
        this.#handler.onRequestStart?.(...args);
      }
      onRequestUpgrade(...args) {
        assert(!this.#onCompleteCalled);
        assert(!this.#onErrorCalled);
        return this.#handler.onRequestUpgrade?.(...args);
      }
      onResponseStart(...args) {
        assert(!this.#onCompleteCalled);
        assert(!this.#onErrorCalled);
        assert(!this.#onResponseStartCalled);
        this.#onResponseStartCalled = true;
        return this.#handler.onResponseStart?.(...args);
      }
      onResponseData(...args) {
        assert(!this.#onCompleteCalled);
        assert(!this.#onErrorCalled);
        return this.#handler.onResponseData?.(...args);
      }
      onResponseEnd(...args) {
        assert(!this.#onCompleteCalled);
        assert(!this.#onErrorCalled);
        this.#onCompleteCalled = true;
        return this.#handler.onResponseEnd?.(...args);
      }
      onResponseError(...args) {
        this.#onErrorCalled = true;
        return this.#handler.onResponseError?.(...args);
      }
      /**
       * @deprecated
       */
      onBodySent() {
      }
    };
  }
});

// node_modules/undici/lib/handler/redirect-handler.js
var require_redirect_handler = __commonJS({
  "node_modules/undici/lib/handler/redirect-handler.js"(exports2, module2) {
    "use strict";
    var util = require_util4();
    var { kBodyUsed } = require_symbols4();
    var assert = require("node:assert");
    var { InvalidArgumentError } = require_errors5();
    var EE = require("node:events");
    var redirectableStatusCodes = [300, 301, 302, 303, 307, 308];
    var kBody = Symbol("body");
    var noop = () => {
    };
    var BodyAsyncIterable = class {
      constructor(body) {
        this[kBody] = body;
        this[kBodyUsed] = false;
      }
      async *[Symbol.asyncIterator]() {
        assert(!this[kBodyUsed], "disturbed");
        this[kBodyUsed] = true;
        yield* this[kBody];
      }
    };
    var RedirectHandler = class _RedirectHandler {
      static buildDispatch(dispatcher, maxRedirections) {
        if (maxRedirections != null && (!Number.isInteger(maxRedirections) || maxRedirections < 0)) {
          throw new InvalidArgumentError("maxRedirections must be a positive number");
        }
        const dispatch = dispatcher.dispatch.bind(dispatcher);
        return (opts, originalHandler) => dispatch(opts, new _RedirectHandler(dispatch, maxRedirections, opts, originalHandler));
      }
      constructor(dispatch, maxRedirections, opts, handler) {
        if (maxRedirections != null && (!Number.isInteger(maxRedirections) || maxRedirections < 0)) {
          throw new InvalidArgumentError("maxRedirections must be a positive number");
        }
        this.dispatch = dispatch;
        this.location = null;
        const { maxRedirections: _, ...cleanOpts } = opts;
        this.opts = cleanOpts;
        this.maxRedirections = maxRedirections;
        this.handler = handler;
        this.history = [];
        if (util.isStream(this.opts.body)) {
          if (util.bodyLength(this.opts.body) === 0) {
            this.opts.body.on("data", function() {
              assert(false);
            });
          }
          if (typeof this.opts.body.readableDidRead !== "boolean") {
            this.opts.body[kBodyUsed] = false;
            EE.prototype.on.call(this.opts.body, "data", function() {
              this[kBodyUsed] = true;
            });
          }
        } else if (this.opts.body && typeof this.opts.body.pipeTo === "function") {
          this.opts.body = new BodyAsyncIterable(this.opts.body);
        } else if (this.opts.body && typeof this.opts.body !== "string" && !ArrayBuffer.isView(this.opts.body) && util.isIterable(this.opts.body) && !util.isFormDataLike(this.opts.body)) {
          this.opts.body = new BodyAsyncIterable(this.opts.body);
        }
      }
      onRequestStart(controller, context) {
        this.handler.onRequestStart?.(controller, { ...context, history: this.history });
      }
      onRequestUpgrade(controller, statusCode, headers, socket) {
        this.handler.onRequestUpgrade?.(controller, statusCode, headers, socket);
      }
      onResponseStart(controller, statusCode, headers, statusMessage) {
        if (this.opts.throwOnMaxRedirect && this.history.length >= this.maxRedirections) {
          throw new Error("max redirects");
        }
        if ((statusCode === 301 || statusCode === 302) && this.opts.method === "POST") {
          this.opts.method = "GET";
          if (util.isStream(this.opts.body)) {
            util.destroy(this.opts.body.on("error", noop));
          }
          this.opts.body = null;
        }
        if (statusCode === 303 && this.opts.method !== "HEAD") {
          this.opts.method = "GET";
          if (util.isStream(this.opts.body)) {
            util.destroy(this.opts.body.on("error", noop));
          }
          this.opts.body = null;
        }
        this.location = this.history.length >= this.maxRedirections || util.isDisturbed(this.opts.body) || redirectableStatusCodes.indexOf(statusCode) === -1 ? null : headers.location;
        if (this.opts.origin) {
          this.history.push(new URL(this.opts.path, this.opts.origin));
        }
        if (!this.location) {
          this.handler.onResponseStart?.(controller, statusCode, headers, statusMessage);
          return;
        }
        const { origin, pathname, search } = util.parseURL(new URL(this.location, this.opts.origin && new URL(this.opts.path, this.opts.origin)));
        const path4 = search ? `${pathname}${search}` : pathname;
        const redirectUrlString = `${origin}${path4}`;
        for (const historyUrl of this.history) {
          if (historyUrl.toString() === redirectUrlString) {
            throw new InvalidArgumentError(`Redirect loop detected. Cannot redirect to ${origin}. This typically happens when using a Client or Pool with cross-origin redirects. Use an Agent for cross-origin redirects.`);
          }
        }
        this.opts.headers = cleanRequestHeaders(this.opts.headers, statusCode === 303, this.opts.origin !== origin);
        this.opts.path = path4;
        this.opts.origin = origin;
        this.opts.query = null;
      }
      onResponseData(controller, chunk) {
        if (this.location) {
        } else {
          this.handler.onResponseData?.(controller, chunk);
        }
      }
      onResponseEnd(controller, trailers) {
        if (this.location) {
          this.dispatch(this.opts, this);
        } else {
          this.handler.onResponseEnd(controller, trailers);
        }
      }
      onResponseError(controller, error) {
        this.handler.onResponseError?.(controller, error);
      }
    };
    function shouldRemoveHeader(header, removeContent, unknownOrigin) {
      if (header.length === 4) {
        return util.headerNameToString(header) === "host";
      }
      if (removeContent && util.headerNameToString(header).startsWith("content-")) {
        return true;
      }
      if (unknownOrigin && (header.length === 13 || header.length === 6 || header.length === 19)) {
        const name = util.headerNameToString(header);
        return name === "authorization" || name === "cookie" || name === "proxy-authorization";
      }
      return false;
    }
    function cleanRequestHeaders(headers, removeContent, unknownOrigin) {
      const ret = [];
      if (Array.isArray(headers)) {
        for (let i = 0; i < headers.length; i += 2) {
          if (!shouldRemoveHeader(headers[i], removeContent, unknownOrigin)) {
            ret.push(headers[i], headers[i + 1]);
          }
        }
      } else if (headers && typeof headers === "object") {
        const entries = typeof headers[Symbol.iterator] === "function" ? headers : Object.entries(headers);
        for (const [key, value] of entries) {
          if (!shouldRemoveHeader(key, removeContent, unknownOrigin)) {
            ret.push(key, value);
          }
        }
      } else {
        assert(headers == null, "headers must be an object or an array");
      }
      return ret;
    }
    module2.exports = RedirectHandler;
  }
});

// node_modules/undici/lib/interceptor/redirect.js
var require_redirect = __commonJS({
  "node_modules/undici/lib/interceptor/redirect.js"(exports2, module2) {
    "use strict";
    var RedirectHandler = require_redirect_handler();
    function createRedirectInterceptor({ maxRedirections: defaultMaxRedirections } = {}) {
      return (dispatch) => {
        return function Intercept(opts, handler) {
          const { maxRedirections = defaultMaxRedirections, ...rest } = opts;
          if (maxRedirections == null || maxRedirections === 0) {
            return dispatch(opts, handler);
          }
          const dispatchOpts = { ...rest };
          const redirectHandler = new RedirectHandler(dispatch, maxRedirections, dispatchOpts, handler);
          return dispatch(dispatchOpts, redirectHandler);
        };
      };
    }
    module2.exports = createRedirectInterceptor;
  }
});

// node_modules/undici/lib/interceptor/response-error.js
var require_response_error = __commonJS({
  "node_modules/undici/lib/interceptor/response-error.js"(exports2, module2) {
    "use strict";
    var DecoratorHandler = require_decorator_handler();
    var { ResponseError } = require_errors5();
    var ResponseErrorHandler = class extends DecoratorHandler {
      #statusCode;
      #contentType;
      #decoder;
      #headers;
      #body;
      constructor(_opts, { handler }) {
        super(handler);
      }
      #checkContentType(contentType) {
        return (this.#contentType ?? "").indexOf(contentType) === 0;
      }
      onRequestStart(controller, context) {
        this.#statusCode = 0;
        this.#contentType = null;
        this.#decoder = null;
        this.#headers = null;
        this.#body = "";
        return super.onRequestStart(controller, context);
      }
      onResponseStart(controller, statusCode, headers, statusMessage) {
        this.#statusCode = statusCode;
        this.#headers = headers;
        this.#contentType = headers["content-type"];
        if (this.#statusCode < 400) {
          return super.onResponseStart(controller, statusCode, headers, statusMessage);
        }
        if (this.#checkContentType("application/json") || this.#checkContentType("text/plain")) {
          this.#decoder = new TextDecoder("utf-8");
        }
      }
      onResponseData(controller, chunk) {
        if (this.#statusCode < 400) {
          return super.onResponseData(controller, chunk);
        }
        this.#body += this.#decoder?.decode(chunk, { stream: true }) ?? "";
      }
      onResponseEnd(controller, trailers) {
        if (this.#statusCode >= 400) {
          this.#body += this.#decoder?.decode(void 0, { stream: false }) ?? "";
          if (this.#checkContentType("application/json")) {
            try {
              this.#body = JSON.parse(this.#body);
            } catch {
            }
          }
          let err;
          const stackTraceLimit = Error.stackTraceLimit;
          Error.stackTraceLimit = 0;
          try {
            err = new ResponseError("Response Error", this.#statusCode, {
              body: this.#body,
              headers: this.#headers
            });
          } finally {
            Error.stackTraceLimit = stackTraceLimit;
          }
          super.onResponseError(controller, err);
        } else {
          super.onResponseEnd(controller, trailers);
        }
      }
      onResponseError(controller, err) {
        super.onResponseError(controller, err);
      }
    };
    module2.exports = () => {
      return (dispatch) => {
        return function Intercept(opts, handler) {
          return dispatch(opts, new ResponseErrorHandler(opts, { handler }));
        };
      };
    };
  }
});

// node_modules/undici/lib/interceptor/retry.js
var require_retry = __commonJS({
  "node_modules/undici/lib/interceptor/retry.js"(exports2, module2) {
    "use strict";
    var RetryHandler = require_retry_handler();
    module2.exports = (globalOpts) => {
      return (dispatch) => {
        return function retryInterceptor(opts, handler) {
          return dispatch(
            opts,
            new RetryHandler(
              { ...opts, retryOptions: { ...globalOpts, ...opts.retryOptions } },
              {
                handler,
                dispatch
              }
            )
          );
        };
      };
    };
  }
});

// node_modules/undici/lib/interceptor/dump.js
var require_dump = __commonJS({
  "node_modules/undici/lib/interceptor/dump.js"(exports2, module2) {
    "use strict";
    var { InvalidArgumentError, RequestAbortedError } = require_errors5();
    var DecoratorHandler = require_decorator_handler();
    var DumpHandler = class extends DecoratorHandler {
      #maxSize = 1024 * 1024;
      #dumped = false;
      #size = 0;
      #controller = null;
      aborted = false;
      reason = false;
      constructor({ maxSize, signal }, handler) {
        if (maxSize != null && (!Number.isFinite(maxSize) || maxSize < 1)) {
          throw new InvalidArgumentError("maxSize must be a number greater than 0");
        }
        super(handler);
        this.#maxSize = maxSize ?? this.#maxSize;
      }
      #abort(reason) {
        this.aborted = true;
        this.reason = reason;
      }
      onRequestStart(controller, context) {
        controller.abort = this.#abort.bind(this);
        this.#controller = controller;
        return super.onRequestStart(controller, context);
      }
      onResponseStart(controller, statusCode, headers, statusMessage) {
        const contentLength = headers["content-length"];
        if (contentLength != null && contentLength > this.#maxSize) {
          throw new RequestAbortedError(
            `Response size (${contentLength}) larger than maxSize (${this.#maxSize})`
          );
        }
        if (this.aborted === true) {
          return true;
        }
        return super.onResponseStart(controller, statusCode, headers, statusMessage);
      }
      onResponseError(controller, err) {
        if (this.#dumped) {
          return;
        }
        err = this.#controller?.reason ?? err;
        super.onResponseError(controller, err);
      }
      onResponseData(controller, chunk) {
        this.#size = this.#size + chunk.length;
        if (this.#size >= this.#maxSize) {
          this.#dumped = true;
          if (this.aborted === true) {
            super.onResponseError(controller, this.reason);
          } else {
            super.onResponseEnd(controller, {});
          }
        }
        return true;
      }
      onResponseEnd(controller, trailers) {
        if (this.#dumped) {
          return;
        }
        if (this.#controller.aborted === true) {
          super.onResponseError(controller, this.reason);
          return;
        }
        super.onResponseEnd(controller, trailers);
      }
    };
    function createDumpInterceptor({ maxSize: defaultMaxSize } = {
      maxSize: 1024 * 1024
    }) {
      return (dispatch) => {
        return function Intercept(opts, handler) {
          const { dumpMaxSize = defaultMaxSize } = opts;
          const dumpHandler = new DumpHandler({ maxSize: dumpMaxSize, signal: opts.signal }, handler);
          return dispatch(opts, dumpHandler);
        };
      };
    }
    module2.exports = createDumpInterceptor;
  }
});

// node_modules/undici/lib/interceptor/dns.js
var require_dns = __commonJS({
  "node_modules/undici/lib/interceptor/dns.js"(exports2, module2) {
    "use strict";
    var { isIP } = require("node:net");
    var { lookup } = require("node:dns");
    var DecoratorHandler = require_decorator_handler();
    var { InvalidArgumentError, InformationalError } = require_errors5();
    var maxInt = Math.pow(2, 31) - 1;
    var DNSInstance = class {
      #maxTTL = 0;
      #maxItems = 0;
      #records = /* @__PURE__ */ new Map();
      dualStack = true;
      affinity = null;
      lookup = null;
      pick = null;
      constructor(opts) {
        this.#maxTTL = opts.maxTTL;
        this.#maxItems = opts.maxItems;
        this.dualStack = opts.dualStack;
        this.affinity = opts.affinity;
        this.lookup = opts.lookup ?? this.#defaultLookup;
        this.pick = opts.pick ?? this.#defaultPick;
      }
      get full() {
        return this.#records.size === this.#maxItems;
      }
      runLookup(origin, opts, cb) {
        const ips = this.#records.get(origin.hostname);
        if (ips == null && this.full) {
          cb(null, origin);
          return;
        }
        const newOpts = {
          affinity: this.affinity,
          dualStack: this.dualStack,
          lookup: this.lookup,
          pick: this.pick,
          ...opts.dns,
          maxTTL: this.#maxTTL,
          maxItems: this.#maxItems
        };
        if (ips == null) {
          this.lookup(origin, newOpts, (err, addresses) => {
            if (err || addresses == null || addresses.length === 0) {
              cb(err ?? new InformationalError("No DNS entries found"));
              return;
            }
            this.setRecords(origin, addresses);
            const records = this.#records.get(origin.hostname);
            const ip = this.pick(
              origin,
              records,
              newOpts.affinity
            );
            let port;
            if (typeof ip.port === "number") {
              port = `:${ip.port}`;
            } else if (origin.port !== "") {
              port = `:${origin.port}`;
            } else {
              port = "";
            }
            cb(
              null,
              new URL(`${origin.protocol}//${ip.family === 6 ? `[${ip.address}]` : ip.address}${port}`)
            );
          });
        } else {
          const ip = this.pick(
            origin,
            ips,
            newOpts.affinity
          );
          if (ip == null) {
            this.#records.delete(origin.hostname);
            this.runLookup(origin, opts, cb);
            return;
          }
          let port;
          if (typeof ip.port === "number") {
            port = `:${ip.port}`;
          } else if (origin.port !== "") {
            port = `:${origin.port}`;
          } else {
            port = "";
          }
          cb(
            null,
            new URL(`${origin.protocol}//${ip.family === 6 ? `[${ip.address}]` : ip.address}${port}`)
          );
        }
      }
      #defaultLookup(origin, opts, cb) {
        lookup(
          origin.hostname,
          {
            all: true,
            family: this.dualStack === false ? this.affinity : 0,
            order: "ipv4first"
          },
          (err, addresses) => {
            if (err) {
              return cb(err);
            }
            const results = /* @__PURE__ */ new Map();
            for (const addr of addresses) {
              results.set(`${addr.address}:${addr.family}`, addr);
            }
            cb(null, results.values());
          }
        );
      }
      #defaultPick(origin, hostnameRecords, affinity) {
        let ip = null;
        const { records, offset } = hostnameRecords;
        let family;
        if (this.dualStack) {
          if (affinity == null) {
            if (offset == null || offset === maxInt) {
              hostnameRecords.offset = 0;
              affinity = 4;
            } else {
              hostnameRecords.offset++;
              affinity = (hostnameRecords.offset & 1) === 1 ? 6 : 4;
            }
          }
          if (records[affinity] != null && records[affinity].ips.length > 0) {
            family = records[affinity];
          } else {
            family = records[affinity === 4 ? 6 : 4];
          }
        } else {
          family = records[affinity];
        }
        if (family == null || family.ips.length === 0) {
          return ip;
        }
        if (family.offset == null || family.offset === maxInt) {
          family.offset = 0;
        } else {
          family.offset++;
        }
        const position = family.offset % family.ips.length;
        ip = family.ips[position] ?? null;
        if (ip == null) {
          return ip;
        }
        if (Date.now() - ip.timestamp > ip.ttl) {
          family.ips.splice(position, 1);
          return this.pick(origin, hostnameRecords, affinity);
        }
        return ip;
      }
      pickFamily(origin, ipFamily) {
        const records = this.#records.get(origin.hostname)?.records;
        if (!records) {
          return null;
        }
        const family = records[ipFamily];
        if (!family) {
          return null;
        }
        if (family.offset == null || family.offset === maxInt) {
          family.offset = 0;
        } else {
          family.offset++;
        }
        const position = family.offset % family.ips.length;
        const ip = family.ips[position] ?? null;
        if (ip == null) {
          return ip;
        }
        if (Date.now() - ip.timestamp > ip.ttl) {
          family.ips.splice(position, 1);
        }
        return ip;
      }
      setRecords(origin, addresses) {
        const timestamp = Date.now();
        const records = { records: { 4: null, 6: null } };
        for (const record of addresses) {
          record.timestamp = timestamp;
          if (typeof record.ttl === "number") {
            record.ttl = Math.min(record.ttl, this.#maxTTL);
          } else {
            record.ttl = this.#maxTTL;
          }
          const familyRecords = records.records[record.family] ?? { ips: [] };
          familyRecords.ips.push(record);
          records.records[record.family] = familyRecords;
        }
        this.#records.set(origin.hostname, records);
      }
      deleteRecords(origin) {
        this.#records.delete(origin.hostname);
      }
      getHandler(meta, opts) {
        return new DNSDispatchHandler(this, meta, opts);
      }
    };
    var DNSDispatchHandler = class extends DecoratorHandler {
      #state = null;
      #opts = null;
      #dispatch = null;
      #origin = null;
      #controller = null;
      #newOrigin = null;
      #firstTry = true;
      constructor(state, { origin, handler, dispatch, newOrigin }, opts) {
        super(handler);
        this.#origin = origin;
        this.#newOrigin = newOrigin;
        this.#opts = { ...opts };
        this.#state = state;
        this.#dispatch = dispatch;
      }
      onResponseError(controller, err) {
        switch (err.code) {
          case "ETIMEDOUT":
          case "ECONNREFUSED": {
            if (this.#state.dualStack) {
              if (!this.#firstTry) {
                super.onResponseError(controller, err);
                return;
              }
              this.#firstTry = false;
              const otherFamily = this.#newOrigin.hostname[0] === "[" ? 4 : 6;
              const ip = this.#state.pickFamily(this.#origin, otherFamily);
              if (ip == null) {
                super.onResponseError(controller, err);
                return;
              }
              let port;
              if (typeof ip.port === "number") {
                port = `:${ip.port}`;
              } else if (this.#origin.port !== "") {
                port = `:${this.#origin.port}`;
              } else {
                port = "";
              }
              const dispatchOpts = {
                ...this.#opts,
                origin: `${this.#origin.protocol}//${ip.family === 6 ? `[${ip.address}]` : ip.address}${port}`
              };
              this.#dispatch(dispatchOpts, this);
              return;
            }
            super.onResponseError(controller, err);
            break;
          }
          case "ENOTFOUND":
            this.#state.deleteRecords(this.#origin);
            super.onResponseError(controller, err);
            break;
          default:
            super.onResponseError(controller, err);
            break;
        }
      }
    };
    module2.exports = (interceptorOpts) => {
      if (interceptorOpts?.maxTTL != null && (typeof interceptorOpts?.maxTTL !== "number" || interceptorOpts?.maxTTL < 0)) {
        throw new InvalidArgumentError("Invalid maxTTL. Must be a positive number");
      }
      if (interceptorOpts?.maxItems != null && (typeof interceptorOpts?.maxItems !== "number" || interceptorOpts?.maxItems < 1)) {
        throw new InvalidArgumentError(
          "Invalid maxItems. Must be a positive number and greater than zero"
        );
      }
      if (interceptorOpts?.affinity != null && interceptorOpts?.affinity !== 4 && interceptorOpts?.affinity !== 6) {
        throw new InvalidArgumentError("Invalid affinity. Must be either 4 or 6");
      }
      if (interceptorOpts?.dualStack != null && typeof interceptorOpts?.dualStack !== "boolean") {
        throw new InvalidArgumentError("Invalid dualStack. Must be a boolean");
      }
      if (interceptorOpts?.lookup != null && typeof interceptorOpts?.lookup !== "function") {
        throw new InvalidArgumentError("Invalid lookup. Must be a function");
      }
      if (interceptorOpts?.pick != null && typeof interceptorOpts?.pick !== "function") {
        throw new InvalidArgumentError("Invalid pick. Must be a function");
      }
      const dualStack = interceptorOpts?.dualStack ?? true;
      let affinity;
      if (dualStack) {
        affinity = interceptorOpts?.affinity ?? null;
      } else {
        affinity = interceptorOpts?.affinity ?? 4;
      }
      const opts = {
        maxTTL: interceptorOpts?.maxTTL ?? 1e4,
        // Expressed in ms
        lookup: interceptorOpts?.lookup ?? null,
        pick: interceptorOpts?.pick ?? null,
        dualStack,
        affinity,
        maxItems: interceptorOpts?.maxItems ?? Infinity
      };
      const instance = new DNSInstance(opts);
      return (dispatch) => {
        return function dnsInterceptor(origDispatchOpts, handler) {
          const origin = origDispatchOpts.origin.constructor === URL ? origDispatchOpts.origin : new URL(origDispatchOpts.origin);
          if (isIP(origin.hostname) !== 0) {
            return dispatch(origDispatchOpts, handler);
          }
          instance.runLookup(origin, origDispatchOpts, (err, newOrigin) => {
            if (err) {
              return handler.onResponseError(null, err);
            }
            const dispatchOpts = {
              ...origDispatchOpts,
              servername: origin.hostname,
              // For SNI on TLS
              origin: newOrigin.origin,
              headers: {
                host: origin.host,
                ...origDispatchOpts.headers
              }
            };
            dispatch(
              dispatchOpts,
              instance.getHandler(
                { origin, dispatch, handler, newOrigin },
                origDispatchOpts
              )
            );
          });
          return true;
        };
      };
    };
  }
});

// node_modules/undici/lib/util/cache.js
var require_cache = __commonJS({
  "node_modules/undici/lib/util/cache.js"(exports2, module2) {
    "use strict";
    var {
      safeHTTPMethods
    } = require_util4();
    var { serializePathWithQuery } = require_util4();
    function makeCacheKey(opts) {
      if (!opts.origin) {
        throw new Error("opts.origin is undefined");
      }
      let fullPath;
      try {
        fullPath = serializePathWithQuery(opts.path || "/", opts.query);
      } catch (error) {
        fullPath = opts.path || "/";
      }
      return {
        origin: opts.origin.toString(),
        method: opts.method,
        path: fullPath,
        headers: opts.headers
      };
    }
    function normaliseHeaders(opts) {
      let headers;
      if (opts.headers == null) {
        headers = {};
      } else if (typeof opts.headers[Symbol.iterator] === "function") {
        headers = {};
        for (const x of opts.headers) {
          if (!Array.isArray(x)) {
            throw new Error("opts.headers is not a valid header map");
          }
          const [key, val] = x;
          if (typeof key !== "string" || typeof val !== "string") {
            throw new Error("opts.headers is not a valid header map");
          }
          headers[key.toLowerCase()] = val;
        }
      } else if (typeof opts.headers === "object") {
        headers = {};
        for (const key of Object.keys(opts.headers)) {
          headers[key.toLowerCase()] = opts.headers[key];
        }
      } else {
        throw new Error("opts.headers is not an object");
      }
      return headers;
    }
    function assertCacheKey(key) {
      if (typeof key !== "object") {
        throw new TypeError(`expected key to be object, got ${typeof key}`);
      }
      for (const property of ["origin", "method", "path"]) {
        if (typeof key[property] !== "string") {
          throw new TypeError(`expected key.${property} to be string, got ${typeof key[property]}`);
        }
      }
      if (key.headers !== void 0 && typeof key.headers !== "object") {
        throw new TypeError(`expected headers to be object, got ${typeof key}`);
      }
    }
    function assertCacheValue(value) {
      if (typeof value !== "object") {
        throw new TypeError(`expected value to be object, got ${typeof value}`);
      }
      for (const property of ["statusCode", "cachedAt", "staleAt", "deleteAt"]) {
        if (typeof value[property] !== "number") {
          throw new TypeError(`expected value.${property} to be number, got ${typeof value[property]}`);
        }
      }
      if (typeof value.statusMessage !== "string") {
        throw new TypeError(`expected value.statusMessage to be string, got ${typeof value.statusMessage}`);
      }
      if (value.headers != null && typeof value.headers !== "object") {
        throw new TypeError(`expected value.rawHeaders to be object, got ${typeof value.headers}`);
      }
      if (value.vary !== void 0 && typeof value.vary !== "object") {
        throw new TypeError(`expected value.vary to be object, got ${typeof value.vary}`);
      }
      if (value.etag !== void 0 && typeof value.etag !== "string") {
        throw new TypeError(`expected value.etag to be string, got ${typeof value.etag}`);
      }
    }
    function parseCacheControlHeader(header) {
      const output = {};
      let directives;
      if (Array.isArray(header)) {
        directives = [];
        for (const directive of header) {
          directives.push(...directive.split(","));
        }
      } else {
        directives = header.split(",");
      }
      for (let i = 0; i < directives.length; i++) {
        const directive = directives[i].toLowerCase();
        const keyValueDelimiter = directive.indexOf("=");
        let key;
        let value;
        if (keyValueDelimiter !== -1) {
          key = directive.substring(0, keyValueDelimiter).trimStart();
          value = directive.substring(keyValueDelimiter + 1);
        } else {
          key = directive.trim();
        }
        switch (key) {
          case "min-fresh":
          case "max-stale":
          case "max-age":
          case "s-maxage":
          case "stale-while-revalidate":
          case "stale-if-error": {
            if (value === void 0 || value[0] === " ") {
              continue;
            }
            if (value.length >= 2 && value[0] === '"' && value[value.length - 1] === '"') {
              value = value.substring(1, value.length - 1);
            }
            const parsedValue = parseInt(value, 10);
            if (parsedValue !== parsedValue) {
              continue;
            }
            if (key === "max-age" && key in output && output[key] >= parsedValue) {
              continue;
            }
            output[key] = parsedValue;
            break;
          }
          case "private":
          case "no-cache": {
            if (value) {
              if (value[0] === '"') {
                const headers = [value.substring(1)];
                let foundEndingQuote = value[value.length - 1] === '"';
                if (!foundEndingQuote) {
                  for (let j = i + 1; j < directives.length; j++) {
                    const nextPart = directives[j];
                    const nextPartLength = nextPart.length;
                    headers.push(nextPart.trim());
                    if (nextPartLength !== 0 && nextPart[nextPartLength - 1] === '"') {
                      foundEndingQuote = true;
                      break;
                    }
                  }
                }
                if (foundEndingQuote) {
                  let lastHeader = headers[headers.length - 1];
                  if (lastHeader[lastHeader.length - 1] === '"') {
                    lastHeader = lastHeader.substring(0, lastHeader.length - 1);
                    headers[headers.length - 1] = lastHeader;
                  }
                  if (key in output) {
                    output[key] = output[key].concat(headers);
                  } else {
                    output[key] = headers;
                  }
                }
              } else {
                if (key in output) {
                  output[key] = output[key].concat(value);
                } else {
                  output[key] = [value];
                }
              }
              break;
            }
          }
          // eslint-disable-next-line no-fallthrough
          case "public":
          case "no-store":
          case "must-revalidate":
          case "proxy-revalidate":
          case "immutable":
          case "no-transform":
          case "must-understand":
          case "only-if-cached":
            if (value) {
              continue;
            }
            output[key] = true;
            break;
          default:
            continue;
        }
      }
      return output;
    }
    function parseVaryHeader(varyHeader, headers) {
      if (typeof varyHeader === "string" && varyHeader.includes("*")) {
        return headers;
      }
      const output = (
        /** @type {Record<string, string | string[] | null>} */
        {}
      );
      const varyingHeaders = typeof varyHeader === "string" ? varyHeader.split(",") : varyHeader;
      for (const header of varyingHeaders) {
        const trimmedHeader = header.trim().toLowerCase();
        output[trimmedHeader] = headers[trimmedHeader] ?? null;
      }
      return output;
    }
    function isEtagUsable(etag) {
      if (etag.length <= 2) {
        return false;
      }
      if (etag[0] === '"' && etag[etag.length - 1] === '"') {
        return !(etag[1] === '"' || etag.startsWith('"W/'));
      }
      if (etag.startsWith('W/"') && etag[etag.length - 1] === '"') {
        return etag.length !== 4;
      }
      return false;
    }
    function assertCacheStore(store, name = "CacheStore") {
      if (typeof store !== "object" || store === null) {
        throw new TypeError(`expected type of ${name} to be a CacheStore, got ${store === null ? "null" : typeof store}`);
      }
      for (const fn of ["get", "createWriteStream", "delete"]) {
        if (typeof store[fn] !== "function") {
          throw new TypeError(`${name} needs to have a \`${fn}()\` function`);
        }
      }
    }
    function assertCacheMethods(methods, name = "CacheMethods") {
      if (!Array.isArray(methods)) {
        throw new TypeError(`expected type of ${name} needs to be an array, got ${methods === null ? "null" : typeof methods}`);
      }
      if (methods.length === 0) {
        throw new TypeError(`${name} needs to have at least one method`);
      }
      for (const method of methods) {
        if (!safeHTTPMethods.includes(method)) {
          throw new TypeError(`element of ${name}-array needs to be one of following values: ${safeHTTPMethods.join(", ")}, got ${method}`);
        }
      }
    }
    module2.exports = {
      makeCacheKey,
      normaliseHeaders,
      assertCacheKey,
      assertCacheValue,
      parseCacheControlHeader,
      parseVaryHeader,
      isEtagUsable,
      assertCacheMethods,
      assertCacheStore
    };
  }
});

// node_modules/undici/lib/util/date.js
var require_date = __commonJS({
  "node_modules/undici/lib/util/date.js"(exports2, module2) {
    "use strict";
    var IMF_DAYS = ["mon", "tue", "wed", "thu", "fri", "sat", "sun"];
    var IMF_SPACES = [4, 7, 11, 16, 25];
    var IMF_MONTHS = ["jan", "feb", "mar", "apr", "may", "jun", "jul", "aug", "sep", "oct", "nov", "dec"];
    var IMF_COLONS = [19, 22];
    var ASCTIME_SPACES = [3, 7, 10, 19];
    var RFC850_DAYS = ["monday", "tuesday", "wednesday", "thursday", "friday", "saturday", "sunday"];
    function parseHttpDate(date, now) {
      date = date.toLowerCase();
      switch (date[3]) {
        case ",":
          return parseImfDate(date);
        case " ":
          return parseAscTimeDate(date);
        default:
          return parseRfc850Date(date, now);
      }
    }
    function parseImfDate(date) {
      if (date.length !== 29) {
        return void 0;
      }
      if (!date.endsWith("gmt")) {
        return void 0;
      }
      for (const spaceInx of IMF_SPACES) {
        if (date[spaceInx] !== " ") {
          return void 0;
        }
      }
      for (const colonIdx of IMF_COLONS) {
        if (date[colonIdx] !== ":") {
          return void 0;
        }
      }
      const dayName = date.substring(0, 3);
      if (!IMF_DAYS.includes(dayName)) {
        return void 0;
      }
      const dayString = date.substring(5, 7);
      const day = Number.parseInt(dayString);
      if (isNaN(day) || day < 10 && dayString[0] !== "0") {
        return void 0;
      }
      const month = date.substring(8, 11);
      const monthIdx = IMF_MONTHS.indexOf(month);
      if (monthIdx === -1) {
        return void 0;
      }
      const year = Number.parseInt(date.substring(12, 16));
      if (isNaN(year)) {
        return void 0;
      }
      const hourString = date.substring(17, 19);
      const hour = Number.parseInt(hourString);
      if (isNaN(hour) || hour < 10 && hourString[0] !== "0") {
        return void 0;
      }
      const minuteString = date.substring(20, 22);
      const minute = Number.parseInt(minuteString);
      if (isNaN(minute) || minute < 10 && minuteString[0] !== "0") {
        return void 0;
      }
      const secondString = date.substring(23, 25);
      const second = Number.parseInt(secondString);
      if (isNaN(second) || second < 10 && secondString[0] !== "0") {
        return void 0;
      }
      return new Date(Date.UTC(year, monthIdx, day, hour, minute, second));
    }
    function parseAscTimeDate(date) {
      if (date.length !== 24) {
        return void 0;
      }
      for (const spaceIdx of ASCTIME_SPACES) {
        if (date[spaceIdx] !== " ") {
          return void 0;
        }
      }
      const dayName = date.substring(0, 3);
      if (!IMF_DAYS.includes(dayName)) {
        return void 0;
      }
      const month = date.substring(4, 7);
      const monthIdx = IMF_MONTHS.indexOf(month);
      if (monthIdx === -1) {
        return void 0;
      }
      const dayString = date.substring(8, 10);
      const day = Number.parseInt(dayString);
      if (isNaN(day) || day < 10 && dayString[0] !== " ") {
        return void 0;
      }
      const hourString = date.substring(11, 13);
      const hour = Number.parseInt(hourString);
      if (isNaN(hour) || hour < 10 && hourString[0] !== "0") {
        return void 0;
      }
      const minuteString = date.substring(14, 16);
      const minute = Number.parseInt(minuteString);
      if (isNaN(minute) || minute < 10 && minuteString[0] !== "0") {
        return void 0;
      }
      const secondString = date.substring(17, 19);
      const second = Number.parseInt(secondString);
      if (isNaN(second) || second < 10 && secondString[0] !== "0") {
        return void 0;
      }
      const year = Number.parseInt(date.substring(20, 24));
      if (isNaN(year)) {
        return void 0;
      }
      return new Date(Date.UTC(year, monthIdx, day, hour, minute, second));
    }
    function parseRfc850Date(date, now = /* @__PURE__ */ new Date()) {
      if (!date.endsWith("gmt")) {
        return void 0;
      }
      const commaIndex = date.indexOf(",");
      if (commaIndex === -1) {
        return void 0;
      }
      if (date.length - commaIndex - 1 !== 23) {
        return void 0;
      }
      const dayName = date.substring(0, commaIndex);
      if (!RFC850_DAYS.includes(dayName)) {
        return void 0;
      }
      if (date[commaIndex + 1] !== " " || date[commaIndex + 4] !== "-" || date[commaIndex + 8] !== "-" || date[commaIndex + 11] !== " " || date[commaIndex + 14] !== ":" || date[commaIndex + 17] !== ":" || date[commaIndex + 20] !== " ") {
        return void 0;
      }
      const dayString = date.substring(commaIndex + 2, commaIndex + 4);
      const day = Number.parseInt(dayString);
      if (isNaN(day) || day < 10 && dayString[0] !== "0") {
        return void 0;
      }
      const month = date.substring(commaIndex + 5, commaIndex + 8);
      const monthIdx = IMF_MONTHS.indexOf(month);
      if (monthIdx === -1) {
        return void 0;
      }
      let year = Number.parseInt(date.substring(commaIndex + 9, commaIndex + 11));
      if (isNaN(year)) {
        return void 0;
      }
      const currentYear = now.getUTCFullYear();
      const currentDecade = currentYear % 100;
      const currentCentury = Math.floor(currentYear / 100);
      if (year > currentDecade && year - currentDecade >= 50) {
        year += (currentCentury - 1) * 100;
      } else {
        year += currentCentury * 100;
      }
      const hourString = date.substring(commaIndex + 12, commaIndex + 14);
      const hour = Number.parseInt(hourString);
      if (isNaN(hour) || hour < 10 && hourString[0] !== "0") {
        return void 0;
      }
      const minuteString = date.substring(commaIndex + 15, commaIndex + 17);
      const minute = Number.parseInt(minuteString);
      if (isNaN(minute) || minute < 10 && minuteString[0] !== "0") {
        return void 0;
      }
      const secondString = date.substring(commaIndex + 18, commaIndex + 20);
      const second = Number.parseInt(secondString);
      if (isNaN(second) || second < 10 && secondString[0] !== "0") {
        return void 0;
      }
      return new Date(Date.UTC(year, monthIdx, day, hour, minute, second));
    }
    module2.exports = {
      parseHttpDate
    };
  }
});

// node_modules/undici/lib/handler/cache-handler.js
var require_cache_handler = __commonJS({
  "node_modules/undici/lib/handler/cache-handler.js"(exports2, module2) {
    "use strict";
    var util = require_util4();
    var {
      parseCacheControlHeader,
      parseVaryHeader,
      isEtagUsable
    } = require_cache();
    var { parseHttpDate } = require_date();
    function noop() {
    }
    var HEURISTICALLY_CACHEABLE_STATUS_CODES = [
      200,
      203,
      204,
      206,
      300,
      301,
      308,
      404,
      405,
      410,
      414,
      501
    ];
    var MAX_RESPONSE_AGE = 2147483647e3;
    var CacheHandler = class {
      /**
       * @type {import('../../types/cache-interceptor.d.ts').default.CacheKey}
       */
      #cacheKey;
      /**
       * @type {import('../../types/cache-interceptor.d.ts').default.CacheHandlerOptions['type']}
       */
      #cacheType;
      /**
       * @type {number | undefined}
       */
      #cacheByDefault;
      /**
       * @type {import('../../types/cache-interceptor.d.ts').default.CacheStore}
       */
      #store;
      /**
       * @type {import('../../types/dispatcher.d.ts').default.DispatchHandler}
       */
      #handler;
      /**
       * @type {import('node:stream').Writable | undefined}
       */
      #writeStream;
      /**
       * @param {import('../../types/cache-interceptor.d.ts').default.CacheHandlerOptions} opts
       * @param {import('../../types/cache-interceptor.d.ts').default.CacheKey} cacheKey
       * @param {import('../../types/dispatcher.d.ts').default.DispatchHandler} handler
       */
      constructor({ store, type, cacheByDefault }, cacheKey, handler) {
        this.#store = store;
        this.#cacheType = type;
        this.#cacheByDefault = cacheByDefault;
        this.#cacheKey = cacheKey;
        this.#handler = handler;
      }
      onRequestStart(controller, context) {
        this.#writeStream?.destroy();
        this.#writeStream = void 0;
        this.#handler.onRequestStart?.(controller, context);
      }
      onRequestUpgrade(controller, statusCode, headers, socket) {
        this.#handler.onRequestUpgrade?.(controller, statusCode, headers, socket);
      }
      /**
       * @param {import('../../types/dispatcher.d.ts').default.DispatchController} controller
       * @param {number} statusCode
       * @param {import('../../types/header.d.ts').IncomingHttpHeaders} resHeaders
       * @param {string} statusMessage
       */
      onResponseStart(controller, statusCode, resHeaders, statusMessage) {
        const downstreamOnHeaders = () => this.#handler.onResponseStart?.(
          controller,
          statusCode,
          resHeaders,
          statusMessage
        );
        if (!util.safeHTTPMethods.includes(this.#cacheKey.method) && statusCode >= 200 && statusCode <= 399) {
          try {
            this.#store.delete(this.#cacheKey)?.catch?.(noop);
          } catch {
          }
          return downstreamOnHeaders();
        }
        const cacheControlHeader = resHeaders["cache-control"];
        const heuristicallyCacheable = resHeaders["last-modified"] && HEURISTICALLY_CACHEABLE_STATUS_CODES.includes(statusCode);
        if (!cacheControlHeader && !resHeaders["expires"] && !heuristicallyCacheable && !this.#cacheByDefault) {
          return downstreamOnHeaders();
        }
        const cacheControlDirectives = cacheControlHeader ? parseCacheControlHeader(cacheControlHeader) : {};
        if (!canCacheResponse(this.#cacheType, statusCode, resHeaders, cacheControlDirectives)) {
          return downstreamOnHeaders();
        }
        const now = Date.now();
        const resAge = resHeaders.age ? getAge(resHeaders.age) : void 0;
        if (resAge && resAge >= MAX_RESPONSE_AGE) {
          return downstreamOnHeaders();
        }
        const resDate = typeof resHeaders.date === "string" ? parseHttpDate(resHeaders.date) : void 0;
        const staleAt = determineStaleAt(this.#cacheType, now, resAge, resHeaders, resDate, cacheControlDirectives) ?? this.#cacheByDefault;
        if (staleAt === void 0 || resAge && resAge > staleAt) {
          return downstreamOnHeaders();
        }
        const baseTime = resDate ? resDate.getTime() : now;
        const absoluteStaleAt = staleAt + baseTime;
        if (now >= absoluteStaleAt) {
          return downstreamOnHeaders();
        }
        let varyDirectives;
        if (this.#cacheKey.headers && resHeaders.vary) {
          varyDirectives = parseVaryHeader(resHeaders.vary, this.#cacheKey.headers);
          if (!varyDirectives) {
            return downstreamOnHeaders();
          }
        }
        const deleteAt = determineDeleteAt(baseTime, cacheControlDirectives, absoluteStaleAt);
        const strippedHeaders = stripNecessaryHeaders(resHeaders, cacheControlDirectives);
        const value = {
          statusCode,
          statusMessage,
          headers: strippedHeaders,
          vary: varyDirectives,
          cacheControlDirectives,
          cachedAt: resAge ? now - resAge : now,
          staleAt: absoluteStaleAt,
          deleteAt
        };
        if (typeof resHeaders.etag === "string" && isEtagUsable(resHeaders.etag)) {
          value.etag = resHeaders.etag;
        }
        this.#writeStream = this.#store.createWriteStream(this.#cacheKey, value);
        if (!this.#writeStream) {
          return downstreamOnHeaders();
        }
        const handler = this;
        this.#writeStream.on("drain", () => controller.resume()).on("error", function() {
          handler.#writeStream = void 0;
          handler.#store.delete(handler.#cacheKey);
        }).on("close", function() {
          if (handler.#writeStream === this) {
            handler.#writeStream = void 0;
          }
          controller.resume();
        });
        return downstreamOnHeaders();
      }
      onResponseData(controller, chunk) {
        if (this.#writeStream?.write(chunk) === false) {
          controller.pause();
        }
        this.#handler.onResponseData?.(controller, chunk);
      }
      onResponseEnd(controller, trailers) {
        this.#writeStream?.end();
        this.#handler.onResponseEnd?.(controller, trailers);
      }
      onResponseError(controller, err) {
        this.#writeStream?.destroy(err);
        this.#writeStream = void 0;
        this.#handler.onResponseError?.(controller, err);
      }
    };
    function canCacheResponse(cacheType, statusCode, resHeaders, cacheControlDirectives) {
      if (statusCode !== 200 && statusCode !== 307 && !HEURISTICALLY_CACHEABLE_STATUS_CODES.includes(statusCode)) {
        return false;
      }
      if (cacheControlDirectives["no-store"]) {
        return false;
      }
      if (cacheType === "shared" && cacheControlDirectives.private === true) {
        return false;
      }
      if (resHeaders.vary?.includes("*")) {
        return false;
      }
      if (resHeaders.authorization) {
        if (!cacheControlDirectives.public || typeof resHeaders.authorization !== "string") {
          return false;
        }
        if (Array.isArray(cacheControlDirectives["no-cache"]) && cacheControlDirectives["no-cache"].includes("authorization")) {
          return false;
        }
        if (Array.isArray(cacheControlDirectives["private"]) && cacheControlDirectives["private"].includes("authorization")) {
          return false;
        }
      }
      return true;
    }
    function getAge(ageHeader) {
      const age = parseInt(Array.isArray(ageHeader) ? ageHeader[0] : ageHeader);
      return isNaN(age) ? void 0 : age * 1e3;
    }
    function determineStaleAt(cacheType, now, age, resHeaders, responseDate, cacheControlDirectives) {
      if (cacheType === "shared") {
        const sMaxAge = cacheControlDirectives["s-maxage"];
        if (sMaxAge !== void 0) {
          return sMaxAge > 0 ? sMaxAge * 1e3 : void 0;
        }
      }
      const maxAge = cacheControlDirectives["max-age"];
      if (maxAge !== void 0) {
        return maxAge > 0 ? maxAge * 1e3 : void 0;
      }
      if (typeof resHeaders.expires === "string") {
        const expiresDate = parseHttpDate(resHeaders.expires);
        if (expiresDate) {
          if (now >= expiresDate.getTime()) {
            return void 0;
          }
          if (responseDate) {
            if (responseDate >= expiresDate) {
              return void 0;
            }
            if (age !== void 0 && age > expiresDate - responseDate) {
              return void 0;
            }
          }
          return expiresDate.getTime() - now;
        }
      }
      if (typeof resHeaders["last-modified"] === "string") {
        const lastModified = new Date(resHeaders["last-modified"]);
        if (isValidDate(lastModified)) {
          if (lastModified.getTime() >= now) {
            return void 0;
          }
          const responseAge = now - lastModified.getTime();
          return responseAge * 0.1;
        }
      }
      if (cacheControlDirectives.immutable) {
        return 31536e3;
      }
      return void 0;
    }
    function determineDeleteAt(now, cacheControlDirectives, staleAt) {
      let staleWhileRevalidate = -Infinity;
      let staleIfError = -Infinity;
      let immutable = -Infinity;
      if (cacheControlDirectives["stale-while-revalidate"]) {
        staleWhileRevalidate = staleAt + cacheControlDirectives["stale-while-revalidate"] * 1e3;
      }
      if (cacheControlDirectives["stale-if-error"]) {
        staleIfError = staleAt + cacheControlDirectives["stale-if-error"] * 1e3;
      }
      if (staleWhileRevalidate === -Infinity && staleIfError === -Infinity) {
        immutable = now + 31536e6;
      }
      return Math.max(staleAt, staleWhileRevalidate, staleIfError, immutable);
    }
    function stripNecessaryHeaders(resHeaders, cacheControlDirectives) {
      const headersToRemove = [
        "connection",
        "proxy-authenticate",
        "proxy-authentication-info",
        "proxy-authorization",
        "proxy-connection",
        "te",
        "transfer-encoding",
        "upgrade",
        // We'll add age back when serving it
        "age"
      ];
      if (resHeaders["connection"]) {
        if (Array.isArray(resHeaders["connection"])) {
          headersToRemove.push(...resHeaders["connection"].map((header) => header.trim()));
        } else {
          headersToRemove.push(...resHeaders["connection"].split(",").map((header) => header.trim()));
        }
      }
      if (Array.isArray(cacheControlDirectives["no-cache"])) {
        headersToRemove.push(...cacheControlDirectives["no-cache"]);
      }
      if (Array.isArray(cacheControlDirectives["private"])) {
        headersToRemove.push(...cacheControlDirectives["private"]);
      }
      let strippedHeaders;
      for (const headerName of headersToRemove) {
        if (resHeaders[headerName]) {
          strippedHeaders ??= { ...resHeaders };
          delete strippedHeaders[headerName];
        }
      }
      return strippedHeaders ?? resHeaders;
    }
    function isValidDate(date) {
      return date instanceof Date && Number.isFinite(date.valueOf());
    }
    module2.exports = CacheHandler;
  }
});

// node_modules/undici/lib/cache/memory-cache-store.js
var require_memory_cache_store = __commonJS({
  "node_modules/undici/lib/cache/memory-cache-store.js"(exports2, module2) {
    "use strict";
    var { Writable } = require("node:stream");
    var { EventEmitter } = require("node:events");
    var { assertCacheKey, assertCacheValue } = require_cache();
    var MemoryCacheStore = class extends EventEmitter {
      #maxCount = 1024;
      #maxSize = 104857600;
      // 100MB
      #maxEntrySize = 5242880;
      // 5MB
      #size = 0;
      #count = 0;
      #entries = /* @__PURE__ */ new Map();
      #hasEmittedMaxSizeEvent = false;
      /**
       * @param {import('../../types/cache-interceptor.d.ts').default.MemoryCacheStoreOpts | undefined} [opts]
       */
      constructor(opts) {
        super();
        if (opts) {
          if (typeof opts !== "object") {
            throw new TypeError("MemoryCacheStore options must be an object");
          }
          if (opts.maxCount !== void 0) {
            if (typeof opts.maxCount !== "number" || !Number.isInteger(opts.maxCount) || opts.maxCount < 0) {
              throw new TypeError("MemoryCacheStore options.maxCount must be a non-negative integer");
            }
            this.#maxCount = opts.maxCount;
          }
          if (opts.maxSize !== void 0) {
            if (typeof opts.maxSize !== "number" || !Number.isInteger(opts.maxSize) || opts.maxSize < 0) {
              throw new TypeError("MemoryCacheStore options.maxSize must be a non-negative integer");
            }
            this.#maxSize = opts.maxSize;
          }
          if (opts.maxEntrySize !== void 0) {
            if (typeof opts.maxEntrySize !== "number" || !Number.isInteger(opts.maxEntrySize) || opts.maxEntrySize < 0) {
              throw new TypeError("MemoryCacheStore options.maxEntrySize must be a non-negative integer");
            }
            this.#maxEntrySize = opts.maxEntrySize;
          }
        }
      }
      /**
       * Get the current size of the cache in bytes
       * @returns {number} The current size of the cache in bytes
       */
      get size() {
        return this.#size;
      }
      /**
       * Check if the cache is full (either max size or max count reached)
       * @returns {boolean} True if the cache is full, false otherwise
       */
      isFull() {
        return this.#size >= this.#maxSize || this.#count >= this.#maxCount;
      }
      /**
       * @param {import('../../types/cache-interceptor.d.ts').default.CacheKey} req
       * @returns {import('../../types/cache-interceptor.d.ts').default.GetResult | undefined}
       */
      get(key) {
        assertCacheKey(key);
        const topLevelKey = `${key.origin}:${key.path}`;
        const now = Date.now();
        const entries = this.#entries.get(topLevelKey);
        const entry = entries ? findEntry(key, entries, now) : null;
        return entry == null ? void 0 : {
          statusMessage: entry.statusMessage,
          statusCode: entry.statusCode,
          headers: entry.headers,
          body: entry.body,
          vary: entry.vary ? entry.vary : void 0,
          etag: entry.etag,
          cacheControlDirectives: entry.cacheControlDirectives,
          cachedAt: entry.cachedAt,
          staleAt: entry.staleAt,
          deleteAt: entry.deleteAt
        };
      }
      /**
       * @param {import('../../types/cache-interceptor.d.ts').default.CacheKey} key
       * @param {import('../../types/cache-interceptor.d.ts').default.CacheValue} val
       * @returns {Writable | undefined}
       */
      createWriteStream(key, val) {
        assertCacheKey(key);
        assertCacheValue(val);
        const topLevelKey = `${key.origin}:${key.path}`;
        const store = this;
        const entry = { ...key, ...val, body: [], size: 0 };
        return new Writable({
          write(chunk, encoding, callback) {
            if (typeof chunk === "string") {
              chunk = Buffer.from(chunk, encoding);
            }
            entry.size += chunk.byteLength;
            if (entry.size >= store.#maxEntrySize) {
              this.destroy();
            } else {
              entry.body.push(chunk);
            }
            callback(null);
          },
          final(callback) {
            let entries = store.#entries.get(topLevelKey);
            if (!entries) {
              entries = [];
              store.#entries.set(topLevelKey, entries);
            }
            const previousEntry = findEntry(key, entries, Date.now());
            if (previousEntry) {
              const index = entries.indexOf(previousEntry);
              entries.splice(index, 1, entry);
              store.#size -= previousEntry.size;
            } else {
              entries.push(entry);
              store.#count += 1;
            }
            store.#size += entry.size;
            if (store.#size > store.#maxSize || store.#count > store.#maxCount) {
              if (!store.#hasEmittedMaxSizeEvent) {
                store.emit("maxSizeExceeded", {
                  size: store.#size,
                  maxSize: store.#maxSize,
                  count: store.#count,
                  maxCount: store.#maxCount
                });
                store.#hasEmittedMaxSizeEvent = true;
              }
              for (const [key2, entries2] of store.#entries) {
                for (const entry2 of entries2.splice(0, entries2.length / 2)) {
                  store.#size -= entry2.size;
                  store.#count -= 1;
                }
                if (entries2.length === 0) {
                  store.#entries.delete(key2);
                }
              }
              if (store.#size < store.#maxSize && store.#count < store.#maxCount) {
                store.#hasEmittedMaxSizeEvent = false;
              }
            }
            callback(null);
          }
        });
      }
      /**
       * @param {CacheKey} key
       */
      delete(key) {
        if (typeof key !== "object") {
          throw new TypeError(`expected key to be object, got ${typeof key}`);
        }
        const topLevelKey = `${key.origin}:${key.path}`;
        for (const entry of this.#entries.get(topLevelKey) ?? []) {
          this.#size -= entry.size;
          this.#count -= 1;
        }
        this.#entries.delete(topLevelKey);
      }
    };
    function findEntry(key, entries, now) {
      return entries.find((entry) => entry.deleteAt > now && entry.method === key.method && (entry.vary == null || Object.keys(entry.vary).every((headerName) => {
        if (entry.vary[headerName] === null) {
          return key.headers[headerName] === void 0;
        }
        return entry.vary[headerName] === key.headers[headerName];
      })));
    }
    module2.exports = MemoryCacheStore;
  }
});

// node_modules/undici/lib/handler/cache-revalidation-handler.js
var require_cache_revalidation_handler = __commonJS({
  "node_modules/undici/lib/handler/cache-revalidation-handler.js"(exports2, module2) {
    "use strict";
    var assert = require("node:assert");
    var CacheRevalidationHandler = class {
      #successful = false;
      /**
       * @type {((boolean, any) => void) | null}
       */
      #callback;
      /**
       * @type {(import('../../types/dispatcher.d.ts').default.DispatchHandler)}
       */
      #handler;
      #context;
      /**
       * @type {boolean}
       */
      #allowErrorStatusCodes;
      /**
       * @param {(boolean) => void} callback Function to call if the cached value is valid
       * @param {import('../../types/dispatcher.d.ts').default.DispatchHandlers} handler
       * @param {boolean} allowErrorStatusCodes
       */
      constructor(callback, handler, allowErrorStatusCodes) {
        if (typeof callback !== "function") {
          throw new TypeError("callback must be a function");
        }
        this.#callback = callback;
        this.#handler = handler;
        this.#allowErrorStatusCodes = allowErrorStatusCodes;
      }
      onRequestStart(_, context) {
        this.#successful = false;
        this.#context = context;
      }
      onRequestUpgrade(controller, statusCode, headers, socket) {
        this.#handler.onRequestUpgrade?.(controller, statusCode, headers, socket);
      }
      onResponseStart(controller, statusCode, headers, statusMessage) {
        assert(this.#callback != null);
        this.#successful = statusCode === 304 || this.#allowErrorStatusCodes && statusCode >= 500 && statusCode <= 504;
        this.#callback(this.#successful, this.#context);
        this.#callback = null;
        if (this.#successful) {
          return true;
        }
        this.#handler.onRequestStart?.(controller, this.#context);
        this.#handler.onResponseStart?.(
          controller,
          statusCode,
          headers,
          statusMessage
        );
      }
      onResponseData(controller, chunk) {
        if (this.#successful) {
          return;
        }
        return this.#handler.onResponseData?.(controller, chunk);
      }
      onResponseEnd(controller, trailers) {
        if (this.#successful) {
          return;
        }
        this.#handler.onResponseEnd?.(controller, trailers);
      }
      onResponseError(controller, err) {
        if (this.#successful) {
          return;
        }
        if (this.#callback) {
          this.#callback(false);
          this.#callback = null;
        }
        if (typeof this.#handler.onResponseError === "function") {
          this.#handler.onResponseError(controller, err);
        } else {
          throw err;
        }
      }
    };
    module2.exports = CacheRevalidationHandler;
  }
});

// node_modules/undici/lib/interceptor/cache.js
var require_cache2 = __commonJS({
  "node_modules/undici/lib/interceptor/cache.js"(exports2, module2) {
    "use strict";
    var assert = require("node:assert");
    var { Readable } = require("node:stream");
    var util = require_util4();
    var CacheHandler = require_cache_handler();
    var MemoryCacheStore = require_memory_cache_store();
    var CacheRevalidationHandler = require_cache_revalidation_handler();
    var { assertCacheStore, assertCacheMethods, makeCacheKey, normaliseHeaders, parseCacheControlHeader } = require_cache();
    var { AbortError } = require_errors5();
    function needsRevalidation(result, cacheControlDirectives) {
      if (cacheControlDirectives?.["no-cache"]) {
        return true;
      }
      if (result.cacheControlDirectives?.["no-cache"] && !Array.isArray(result.cacheControlDirectives["no-cache"])) {
        return true;
      }
      const now = Date.now();
      if (now > result.staleAt) {
        if (cacheControlDirectives?.["max-stale"]) {
          const gracePeriod = result.staleAt + cacheControlDirectives["max-stale"] * 1e3;
          return now > gracePeriod;
        }
        return true;
      }
      if (cacheControlDirectives?.["min-fresh"]) {
        const timeLeftTillStale = result.staleAt - now;
        const threshold = cacheControlDirectives["min-fresh"] * 1e3;
        return timeLeftTillStale <= threshold;
      }
      return false;
    }
    function handleUncachedResponse(dispatch, globalOpts, cacheKey, handler, opts, reqCacheControl) {
      if (reqCacheControl?.["only-if-cached"]) {
        let aborted = false;
        try {
          if (typeof handler.onConnect === "function") {
            handler.onConnect(() => {
              aborted = true;
            });
            if (aborted) {
              return;
            }
          }
          if (typeof handler.onHeaders === "function") {
            handler.onHeaders(504, [], () => {
            }, "Gateway Timeout");
            if (aborted) {
              return;
            }
          }
          if (typeof handler.onComplete === "function") {
            handler.onComplete([]);
          }
        } catch (err) {
          if (typeof handler.onError === "function") {
            handler.onError(err);
          }
        }
        return true;
      }
      return dispatch(opts, new CacheHandler(globalOpts, cacheKey, handler));
    }
    function sendCachedValue(handler, opts, result, age, context, isStale) {
      const stream = util.isStream(result.body) ? result.body : Readable.from(result.body ?? []);
      assert(!stream.destroyed, "stream should not be destroyed");
      assert(!stream.readableDidRead, "stream should not be readableDidRead");
      const controller = {
        resume() {
          stream.resume();
        },
        pause() {
          stream.pause();
        },
        get paused() {
          return stream.isPaused();
        },
        get aborted() {
          return stream.destroyed;
        },
        get reason() {
          return stream.errored;
        },
        abort(reason) {
          stream.destroy(reason ?? new AbortError());
        }
      };
      stream.on("error", function(err) {
        if (!this.readableEnded) {
          if (typeof handler.onResponseError === "function") {
            handler.onResponseError(controller, err);
          } else {
            throw err;
          }
        }
      }).on("close", function() {
        if (!this.errored) {
          handler.onResponseEnd?.(controller, {});
        }
      });
      handler.onRequestStart?.(controller, context);
      if (stream.destroyed) {
        return;
      }
      const headers = { ...result.headers, age: String(age) };
      if (isStale) {
        headers.warning = '110 - "response is stale"';
      }
      handler.onResponseStart?.(controller, result.statusCode, headers, result.statusMessage);
      if (opts.method === "HEAD") {
        stream.destroy();
      } else {
        stream.on("data", function(chunk) {
          handler.onResponseData?.(controller, chunk);
        });
      }
    }
    function handleResult(dispatch, globalOpts, cacheKey, handler, opts, reqCacheControl, result) {
      if (!result) {
        return handleUncachedResponse(dispatch, globalOpts, cacheKey, handler, opts, reqCacheControl);
      }
      const now = Date.now();
      if (now > result.deleteAt) {
        return dispatch(opts, new CacheHandler(globalOpts, cacheKey, handler));
      }
      const age = Math.round((now - result.cachedAt) / 1e3);
      if (reqCacheControl?.["max-age"] && age >= reqCacheControl["max-age"]) {
        return dispatch(opts, handler);
      }
      if (needsRevalidation(result, reqCacheControl)) {
        if (util.isStream(opts.body) && util.bodyLength(opts.body) !== 0) {
          return dispatch(opts, new CacheHandler(globalOpts, cacheKey, handler));
        }
        let withinStaleIfErrorThreshold = false;
        const staleIfErrorExpiry = result.cacheControlDirectives["stale-if-error"] ?? reqCacheControl?.["stale-if-error"];
        if (staleIfErrorExpiry) {
          withinStaleIfErrorThreshold = now < result.staleAt + staleIfErrorExpiry * 1e3;
        }
        let headers = {
          ...opts.headers,
          "if-modified-since": new Date(result.cachedAt).toUTCString()
        };
        if (result.etag) {
          headers["if-none-match"] = result.etag;
        }
        if (result.vary) {
          headers = {
            ...headers,
            ...result.vary
          };
        }
        return dispatch(
          {
            ...opts,
            headers
          },
          new CacheRevalidationHandler(
            (success, context) => {
              if (success) {
                sendCachedValue(handler, opts, result, age, context, true);
              } else if (util.isStream(result.body)) {
                result.body.on("error", () => {
                }).destroy();
              }
            },
            new CacheHandler(globalOpts, cacheKey, handler),
            withinStaleIfErrorThreshold
          )
        );
      }
      if (util.isStream(opts.body)) {
        opts.body.on("error", () => {
        }).destroy();
      }
      sendCachedValue(handler, opts, result, age, null, false);
    }
    module2.exports = (opts = {}) => {
      const {
        store = new MemoryCacheStore(),
        methods = ["GET"],
        cacheByDefault = void 0,
        type = "shared"
      } = opts;
      if (typeof opts !== "object" || opts === null) {
        throw new TypeError(`expected type of opts to be an Object, got ${opts === null ? "null" : typeof opts}`);
      }
      assertCacheStore(store, "opts.store");
      assertCacheMethods(methods, "opts.methods");
      if (typeof cacheByDefault !== "undefined" && typeof cacheByDefault !== "number") {
        throw new TypeError(`expected opts.cacheByDefault to be number or undefined, got ${typeof cacheByDefault}`);
      }
      if (typeof type !== "undefined" && type !== "shared" && type !== "private") {
        throw new TypeError(`expected opts.type to be shared, private, or undefined, got ${typeof type}`);
      }
      const globalOpts = {
        store,
        methods,
        cacheByDefault,
        type
      };
      const safeMethodsToNotCache = util.safeHTTPMethods.filter((method) => methods.includes(method) === false);
      return (dispatch) => {
        return (opts2, handler) => {
          if (!opts2.origin || safeMethodsToNotCache.includes(opts2.method)) {
            return dispatch(opts2, handler);
          }
          opts2 = {
            ...opts2,
            headers: normaliseHeaders(opts2)
          };
          const reqCacheControl = opts2.headers?.["cache-control"] ? parseCacheControlHeader(opts2.headers["cache-control"]) : void 0;
          if (reqCacheControl?.["no-store"]) {
            return dispatch(opts2, handler);
          }
          const cacheKey = makeCacheKey(opts2);
          const result = store.get(cacheKey);
          if (result && typeof result.then === "function") {
            result.then((result2) => {
              handleResult(
                dispatch,
                globalOpts,
                cacheKey,
                handler,
                opts2,
                reqCacheControl,
                result2
              );
            });
          } else {
            handleResult(
              dispatch,
              globalOpts,
              cacheKey,
              handler,
              opts2,
              reqCacheControl,
              result
            );
          }
          return true;
        };
      };
    };
  }
});

// node_modules/undici/lib/cache/sqlite-cache-store.js
var require_sqlite_cache_store = __commonJS({
  "node_modules/undici/lib/cache/sqlite-cache-store.js"(exports2, module2) {
    "use strict";
    var { Writable } = require("node:stream");
    var { assertCacheKey, assertCacheValue } = require_cache();
    var DatabaseSync;
    var VERSION = 3;
    var MAX_ENTRY_SIZE = 2 * 1e3 * 1e3 * 1e3;
    module2.exports = class SqliteCacheStore {
      #maxEntrySize = MAX_ENTRY_SIZE;
      #maxCount = Infinity;
      /**
       * @type {import('node:sqlite').DatabaseSync}
       */
      #db;
      /**
       * @type {import('node:sqlite').StatementSync}
       */
      #getValuesQuery;
      /**
       * @type {import('node:sqlite').StatementSync}
       */
      #updateValueQuery;
      /**
       * @type {import('node:sqlite').StatementSync}
       */
      #insertValueQuery;
      /**
       * @type {import('node:sqlite').StatementSync}
       */
      #deleteExpiredValuesQuery;
      /**
       * @type {import('node:sqlite').StatementSync}
       */
      #deleteByUrlQuery;
      /**
       * @type {import('node:sqlite').StatementSync}
       */
      #countEntriesQuery;
      /**
       * @type {import('node:sqlite').StatementSync | null}
       */
      #deleteOldValuesQuery;
      /**
       * @param {import('../../types/cache-interceptor.d.ts').default.SqliteCacheStoreOpts | undefined} opts
       */
      constructor(opts) {
        if (opts) {
          if (typeof opts !== "object") {
            throw new TypeError("SqliteCacheStore options must be an object");
          }
          if (opts.maxEntrySize !== void 0) {
            if (typeof opts.maxEntrySize !== "number" || !Number.isInteger(opts.maxEntrySize) || opts.maxEntrySize < 0) {
              throw new TypeError("SqliteCacheStore options.maxEntrySize must be a non-negative integer");
            }
            if (opts.maxEntrySize > MAX_ENTRY_SIZE) {
              throw new TypeError("SqliteCacheStore options.maxEntrySize must be less than 2gb");
            }
            this.#maxEntrySize = opts.maxEntrySize;
          }
          if (opts.maxCount !== void 0) {
            if (typeof opts.maxCount !== "number" || !Number.isInteger(opts.maxCount) || opts.maxCount < 0) {
              throw new TypeError("SqliteCacheStore options.maxCount must be a non-negative integer");
            }
            this.#maxCount = opts.maxCount;
          }
        }
        if (!DatabaseSync) {
          DatabaseSync = require("node:sqlite").DatabaseSync;
        }
        this.#db = new DatabaseSync(opts?.location ?? ":memory:");
        this.#db.exec(`
      PRAGMA journal_mode = WAL;
      PRAGMA synchronous = NORMAL;
      PRAGMA temp_store = memory;
      PRAGMA optimize;

      CREATE TABLE IF NOT EXISTS cacheInterceptorV${VERSION} (
        -- Data specific to us
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        url TEXT NOT NULL,
        method TEXT NOT NULL,

        -- Data returned to the interceptor
        body BUF NULL,
        deleteAt INTEGER NOT NULL,
        statusCode INTEGER NOT NULL,
        statusMessage TEXT NOT NULL,
        headers TEXT NULL,
        cacheControlDirectives TEXT NULL,
        etag TEXT NULL,
        vary TEXT NULL,
        cachedAt INTEGER NOT NULL,
        staleAt INTEGER NOT NULL
      );

      CREATE INDEX IF NOT EXISTS idx_cacheInterceptorV${VERSION}_getValuesQuery ON cacheInterceptorV${VERSION}(url, method, deleteAt);
      CREATE INDEX IF NOT EXISTS idx_cacheInterceptorV${VERSION}_deleteByUrlQuery ON cacheInterceptorV${VERSION}(deleteAt);
    `);
        this.#getValuesQuery = this.#db.prepare(`
      SELECT
        id,
        body,
        deleteAt,
        statusCode,
        statusMessage,
        headers,
        etag,
        cacheControlDirectives,
        vary,
        cachedAt,
        staleAt
      FROM cacheInterceptorV${VERSION}
      WHERE
        url = ?
        AND method = ?
      ORDER BY
        deleteAt ASC
    `);
        this.#updateValueQuery = this.#db.prepare(`
      UPDATE cacheInterceptorV${VERSION} SET
        body = ?,
        deleteAt = ?,
        statusCode = ?,
        statusMessage = ?,
        headers = ?,
        etag = ?,
        cacheControlDirectives = ?,
        cachedAt = ?,
        staleAt = ?
      WHERE
        id = ?
    `);
        this.#insertValueQuery = this.#db.prepare(`
      INSERT INTO cacheInterceptorV${VERSION} (
        url,
        method,
        body,
        deleteAt,
        statusCode,
        statusMessage,
        headers,
        etag,
        cacheControlDirectives,
        vary,
        cachedAt,
        staleAt
      ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
    `);
        this.#deleteByUrlQuery = this.#db.prepare(
          `DELETE FROM cacheInterceptorV${VERSION} WHERE url = ?`
        );
        this.#countEntriesQuery = this.#db.prepare(
          `SELECT COUNT(*) AS total FROM cacheInterceptorV${VERSION}`
        );
        this.#deleteExpiredValuesQuery = this.#db.prepare(
          `DELETE FROM cacheInterceptorV${VERSION} WHERE deleteAt <= ?`
        );
        this.#deleteOldValuesQuery = this.#maxCount === Infinity ? null : this.#db.prepare(`
        DELETE FROM cacheInterceptorV${VERSION}
        WHERE id IN (
          SELECT
            id
          FROM cacheInterceptorV${VERSION}
          ORDER BY cachedAt DESC
          LIMIT ?
        )
      `);
      }
      close() {
        this.#db.close();
      }
      /**
       * @param {import('../../types/cache-interceptor.d.ts').default.CacheKey} key
       * @returns {(import('../../types/cache-interceptor.d.ts').default.GetResult & { body?: Buffer }) | undefined}
       */
      get(key) {
        assertCacheKey(key);
        const value = this.#findValue(key);
        return value ? {
          body: value.body ? Buffer.from(value.body.buffer, value.body.byteOffset, value.body.byteLength) : void 0,
          statusCode: value.statusCode,
          statusMessage: value.statusMessage,
          headers: value.headers ? JSON.parse(value.headers) : void 0,
          etag: value.etag ? value.etag : void 0,
          vary: value.vary ? JSON.parse(value.vary) : void 0,
          cacheControlDirectives: value.cacheControlDirectives ? JSON.parse(value.cacheControlDirectives) : void 0,
          cachedAt: value.cachedAt,
          staleAt: value.staleAt,
          deleteAt: value.deleteAt
        } : void 0;
      }
      /**
       * @param {import('../../types/cache-interceptor.d.ts').default.CacheKey} key
       * @param {import('../../types/cache-interceptor.d.ts').default.CacheValue & { body: null | Buffer | Array<Buffer>}} value
       */
      set(key, value) {
        assertCacheKey(key);
        const url = this.#makeValueUrl(key);
        const body = Array.isArray(value.body) ? Buffer.concat(value.body) : value.body;
        const size = body?.byteLength;
        if (size && size > this.#maxEntrySize) {
          return;
        }
        const existingValue = this.#findValue(key, true);
        if (existingValue) {
          this.#updateValueQuery.run(
            body,
            value.deleteAt,
            value.statusCode,
            value.statusMessage,
            value.headers ? JSON.stringify(value.headers) : null,
            value.etag ? value.etag : null,
            value.cacheControlDirectives ? JSON.stringify(value.cacheControlDirectives) : null,
            value.cachedAt,
            value.staleAt,
            existingValue.id
          );
        } else {
          this.#prune();
          this.#insertValueQuery.run(
            url,
            key.method,
            body,
            value.deleteAt,
            value.statusCode,
            value.statusMessage,
            value.headers ? JSON.stringify(value.headers) : null,
            value.etag ? value.etag : null,
            value.cacheControlDirectives ? JSON.stringify(value.cacheControlDirectives) : null,
            value.vary ? JSON.stringify(value.vary) : null,
            value.cachedAt,
            value.staleAt
          );
        }
      }
      /**
       * @param {import('../../types/cache-interceptor.d.ts').default.CacheKey} key
       * @param {import('../../types/cache-interceptor.d.ts').default.CacheValue} value
       * @returns {Writable | undefined}
       */
      createWriteStream(key, value) {
        assertCacheKey(key);
        assertCacheValue(value);
        let size = 0;
        const body = [];
        const store = this;
        return new Writable({
          decodeStrings: true,
          write(chunk, encoding, callback) {
            size += chunk.byteLength;
            if (size < store.#maxEntrySize) {
              body.push(chunk);
            } else {
              this.destroy();
            }
            callback();
          },
          final(callback) {
            store.set(key, { ...value, body });
            callback();
          }
        });
      }
      /**
       * @param {import('../../types/cache-interceptor.d.ts').default.CacheKey} key
       */
      delete(key) {
        if (typeof key !== "object") {
          throw new TypeError(`expected key to be object, got ${typeof key}`);
        }
        this.#deleteByUrlQuery.run(this.#makeValueUrl(key));
      }
      #prune() {
        if (Number.isFinite(this.#maxCount) && this.size <= this.#maxCount) {
          return 0;
        }
        {
          const removed = this.#deleteExpiredValuesQuery.run(Date.now()).changes;
          if (removed) {
            return removed;
          }
        }
        {
          const removed = this.#deleteOldValuesQuery?.run(Math.max(Math.floor(this.#maxCount * 0.1), 1)).changes;
          if (removed) {
            return removed;
          }
        }
        return 0;
      }
      /**
       * Counts the number of rows in the cache
       * @returns {Number}
       */
      get size() {
        const { total } = this.#countEntriesQuery.get();
        return total;
      }
      /**
       * @param {import('../../types/cache-interceptor.d.ts').default.CacheKey} key
       * @returns {string}
       */
      #makeValueUrl(key) {
        return `${key.origin}/${key.path}`;
      }
      /**
       * @param {import('../../types/cache-interceptor.d.ts').default.CacheKey} key
       * @param {boolean} [canBeExpired=false]
       * @returns {SqliteStoreValue | undefined}
       */
      #findValue(key, canBeExpired = false) {
        const url = this.#makeValueUrl(key);
        const { headers, method } = key;
        const values = this.#getValuesQuery.all(url, method);
        if (values.length === 0) {
          return void 0;
        }
        const now = Date.now();
        for (const value of values) {
          if (now >= value.deleteAt && !canBeExpired) {
            return void 0;
          }
          let matches = true;
          if (value.vary) {
            const vary = JSON.parse(value.vary);
            for (const header in vary) {
              if (!headerValueEquals(headers[header], vary[header])) {
                matches = false;
                break;
              }
            }
          }
          if (matches) {
            return value;
          }
        }
        return void 0;
      }
    };
    function headerValueEquals(lhs, rhs) {
      if (lhs == null && rhs == null) {
        return true;
      }
      if (lhs == null && rhs != null || lhs != null && rhs == null) {
        return false;
      }
      if (Array.isArray(lhs) && Array.isArray(rhs)) {
        if (lhs.length !== rhs.length) {
          return false;
        }
        return lhs.every((x, i) => x === rhs[i]);
      }
      return lhs === rhs;
    }
  }
});

// node_modules/undici/lib/web/fetch/headers.js
var require_headers = __commonJS({
  "node_modules/undici/lib/web/fetch/headers.js"(exports2, module2) {
    "use strict";
    var { kConstruct } = require_symbols4();
    var { kEnumerableProperty } = require_util4();
    var {
      iteratorMixin,
      isValidHeaderName,
      isValidHeaderValue
    } = require_util5();
    var { webidl } = require_webidl();
    var assert = require("node:assert");
    var util = require("node:util");
    function isHTTPWhiteSpaceCharCode(code) {
      return code === 10 || code === 13 || code === 9 || code === 32;
    }
    function headerValueNormalize(potentialValue) {
      let i = 0;
      let j = potentialValue.length;
      while (j > i && isHTTPWhiteSpaceCharCode(potentialValue.charCodeAt(j - 1))) --j;
      while (j > i && isHTTPWhiteSpaceCharCode(potentialValue.charCodeAt(i))) ++i;
      return i === 0 && j === potentialValue.length ? potentialValue : potentialValue.substring(i, j);
    }
    function fill(headers, object) {
      if (Array.isArray(object)) {
        for (let i = 0; i < object.length; ++i) {
          const header = object[i];
          if (header.length !== 2) {
            throw webidl.errors.exception({
              header: "Headers constructor",
              message: `expected name/value pair to be length 2, found ${header.length}.`
            });
          }
          appendHeader(headers, header[0], header[1]);
        }
      } else if (typeof object === "object" && object !== null) {
        const keys = Object.keys(object);
        for (let i = 0; i < keys.length; ++i) {
          appendHeader(headers, keys[i], object[keys[i]]);
        }
      } else {
        throw webidl.errors.conversionFailed({
          prefix: "Headers constructor",
          argument: "Argument 1",
          types: ["sequence<sequence<ByteString>>", "record<ByteString, ByteString>"]
        });
      }
    }
    function appendHeader(headers, name, value) {
      value = headerValueNormalize(value);
      if (!isValidHeaderName(name)) {
        throw webidl.errors.invalidArgument({
          prefix: "Headers.append",
          value: name,
          type: "header name"
        });
      } else if (!isValidHeaderValue(value)) {
        throw webidl.errors.invalidArgument({
          prefix: "Headers.append",
          value,
          type: "header value"
        });
      }
      if (getHeadersGuard(headers) === "immutable") {
        throw new TypeError("immutable");
      }
      return getHeadersList(headers).append(name, value, false);
    }
    function headersListSortAndCombine(target) {
      const headersList = getHeadersList(target);
      if (!headersList) {
        return [];
      }
      if (headersList.sortedMap) {
        return headersList.sortedMap;
      }
      const headers = [];
      const names = headersList.toSortedArray();
      const cookies = headersList.cookies;
      if (cookies === null || cookies.length === 1) {
        return headersList.sortedMap = names;
      }
      for (let i = 0; i < names.length; ++i) {
        const { 0: name, 1: value } = names[i];
        if (name === "set-cookie") {
          for (let j = 0; j < cookies.length; ++j) {
            headers.push([name, cookies[j]]);
          }
        } else {
          headers.push([name, value]);
        }
      }
      return headersList.sortedMap = headers;
    }
    function compareHeaderName(a, b) {
      return a[0] < b[0] ? -1 : 1;
    }
    var HeadersList = class _HeadersList {
      /** @type {[string, string][]|null} */
      cookies = null;
      sortedMap;
      headersMap;
      constructor(init) {
        if (init instanceof _HeadersList) {
          this.headersMap = new Map(init.headersMap);
          this.sortedMap = init.sortedMap;
          this.cookies = init.cookies === null ? null : [...init.cookies];
        } else {
          this.headersMap = new Map(init);
          this.sortedMap = null;
        }
      }
      /**
       * @see https://fetch.spec.whatwg.org/#header-list-contains
       * @param {string} name
       * @param {boolean} isLowerCase
       */
      contains(name, isLowerCase) {
        return this.headersMap.has(isLowerCase ? name : name.toLowerCase());
      }
      clear() {
        this.headersMap.clear();
        this.sortedMap = null;
        this.cookies = null;
      }
      /**
       * @see https://fetch.spec.whatwg.org/#concept-header-list-append
       * @param {string} name
       * @param {string} value
       * @param {boolean} isLowerCase
       */
      append(name, value, isLowerCase) {
        this.sortedMap = null;
        const lowercaseName = isLowerCase ? name : name.toLowerCase();
        const exists = this.headersMap.get(lowercaseName);
        if (exists) {
          const delimiter = lowercaseName === "cookie" ? "; " : ", ";
          this.headersMap.set(lowercaseName, {
            name: exists.name,
            value: `${exists.value}${delimiter}${value}`
          });
        } else {
          this.headersMap.set(lowercaseName, { name, value });
        }
        if (lowercaseName === "set-cookie") {
          (this.cookies ??= []).push(value);
        }
      }
      /**
       * @see https://fetch.spec.whatwg.org/#concept-header-list-set
       * @param {string} name
       * @param {string} value
       * @param {boolean} isLowerCase
       */
      set(name, value, isLowerCase) {
        this.sortedMap = null;
        const lowercaseName = isLowerCase ? name : name.toLowerCase();
        if (lowercaseName === "set-cookie") {
          this.cookies = [value];
        }
        this.headersMap.set(lowercaseName, { name, value });
      }
      /**
       * @see https://fetch.spec.whatwg.org/#concept-header-list-delete
       * @param {string} name
       * @param {boolean} isLowerCase
       */
      delete(name, isLowerCase) {
        this.sortedMap = null;
        if (!isLowerCase) name = name.toLowerCase();
        if (name === "set-cookie") {
          this.cookies = null;
        }
        this.headersMap.delete(name);
      }
      /**
       * @see https://fetch.spec.whatwg.org/#concept-header-list-get
       * @param {string} name
       * @param {boolean} isLowerCase
       * @returns {string | null}
       */
      get(name, isLowerCase) {
        return this.headersMap.get(isLowerCase ? name : name.toLowerCase())?.value ?? null;
      }
      *[Symbol.iterator]() {
        for (const { 0: name, 1: { value } } of this.headersMap) {
          yield [name, value];
        }
      }
      get entries() {
        const headers = {};
        if (this.headersMap.size !== 0) {
          for (const { name, value } of this.headersMap.values()) {
            headers[name] = value;
          }
        }
        return headers;
      }
      rawValues() {
        return this.headersMap.values();
      }
      get entriesList() {
        const headers = [];
        if (this.headersMap.size !== 0) {
          for (const { 0: lowerName, 1: { name, value } } of this.headersMap) {
            if (lowerName === "set-cookie") {
              for (const cookie of this.cookies) {
                headers.push([name, cookie]);
              }
            } else {
              headers.push([name, value]);
            }
          }
        }
        return headers;
      }
      // https://fetch.spec.whatwg.org/#convert-header-names-to-a-sorted-lowercase-set
      toSortedArray() {
        const size = this.headersMap.size;
        const array = new Array(size);
        if (size <= 32) {
          if (size === 0) {
            return array;
          }
          const iterator = this.headersMap[Symbol.iterator]();
          const firstValue = iterator.next().value;
          array[0] = [firstValue[0], firstValue[1].value];
          assert(firstValue[1].value !== null);
          for (let i = 1, j = 0, right = 0, left = 0, pivot = 0, x, value; i < size; ++i) {
            value = iterator.next().value;
            x = array[i] = [value[0], value[1].value];
            assert(x[1] !== null);
            left = 0;
            right = i;
            while (left < right) {
              pivot = left + (right - left >> 1);
              if (array[pivot][0] <= x[0]) {
                left = pivot + 1;
              } else {
                right = pivot;
              }
            }
            if (i !== pivot) {
              j = i;
              while (j > left) {
                array[j] = array[--j];
              }
              array[left] = x;
            }
          }
          if (!iterator.next().done) {
            throw new TypeError("Unreachable");
          }
          return array;
        } else {
          let i = 0;
          for (const { 0: name, 1: { value } } of this.headersMap) {
            array[i++] = [name, value];
            assert(value !== null);
          }
          return array.sort(compareHeaderName);
        }
      }
    };
    var Headers2 = class _Headers {
      #guard;
      /**
       * @type {HeadersList}
       */
      #headersList;
      /**
       * @param {HeadersInit|Symbol} [init]
       * @returns
       */
      constructor(init = void 0) {
        webidl.util.markAsUncloneable(this);
        if (init === kConstruct) {
          return;
        }
        this.#headersList = new HeadersList();
        this.#guard = "none";
        if (init !== void 0) {
          init = webidl.converters.HeadersInit(init, "Headers constructor", "init");
          fill(this, init);
        }
      }
      // https://fetch.spec.whatwg.org/#dom-headers-append
      append(name, value) {
        webidl.brandCheck(this, _Headers);
        webidl.argumentLengthCheck(arguments, 2, "Headers.append");
        const prefix = "Headers.append";
        name = webidl.converters.ByteString(name, prefix, "name");
        value = webidl.converters.ByteString(value, prefix, "value");
        return appendHeader(this, name, value);
      }
      // https://fetch.spec.whatwg.org/#dom-headers-delete
      delete(name) {
        webidl.brandCheck(this, _Headers);
        webidl.argumentLengthCheck(arguments, 1, "Headers.delete");
        const prefix = "Headers.delete";
        name = webidl.converters.ByteString(name, prefix, "name");
        if (!isValidHeaderName(name)) {
          throw webidl.errors.invalidArgument({
            prefix: "Headers.delete",
            value: name,
            type: "header name"
          });
        }
        if (this.#guard === "immutable") {
          throw new TypeError("immutable");
        }
        if (!this.#headersList.contains(name, false)) {
          return;
        }
        this.#headersList.delete(name, false);
      }
      // https://fetch.spec.whatwg.org/#dom-headers-get
      get(name) {
        webidl.brandCheck(this, _Headers);
        webidl.argumentLengthCheck(arguments, 1, "Headers.get");
        const prefix = "Headers.get";
        name = webidl.converters.ByteString(name, prefix, "name");
        if (!isValidHeaderName(name)) {
          throw webidl.errors.invalidArgument({
            prefix,
            value: name,
            type: "header name"
          });
        }
        return this.#headersList.get(name, false);
      }
      // https://fetch.spec.whatwg.org/#dom-headers-has
      has(name) {
        webidl.brandCheck(this, _Headers);
        webidl.argumentLengthCheck(arguments, 1, "Headers.has");
        const prefix = "Headers.has";
        name = webidl.converters.ByteString(name, prefix, "name");
        if (!isValidHeaderName(name)) {
          throw webidl.errors.invalidArgument({
            prefix,
            value: name,
            type: "header name"
          });
        }
        return this.#headersList.contains(name, false);
      }
      // https://fetch.spec.whatwg.org/#dom-headers-set
      set(name, value) {
        webidl.brandCheck(this, _Headers);
        webidl.argumentLengthCheck(arguments, 2, "Headers.set");
        const prefix = "Headers.set";
        name = webidl.converters.ByteString(name, prefix, "name");
        value = webidl.converters.ByteString(value, prefix, "value");
        value = headerValueNormalize(value);
        if (!isValidHeaderName(name)) {
          throw webidl.errors.invalidArgument({
            prefix,
            value: name,
            type: "header name"
          });
        } else if (!isValidHeaderValue(value)) {
          throw webidl.errors.invalidArgument({
            prefix,
            value,
            type: "header value"
          });
        }
        if (this.#guard === "immutable") {
          throw new TypeError("immutable");
        }
        this.#headersList.set(name, value, false);
      }
      // https://fetch.spec.whatwg.org/#dom-headers-getsetcookie
      getSetCookie() {
        webidl.brandCheck(this, _Headers);
        const list = this.#headersList.cookies;
        if (list) {
          return [...list];
        }
        return [];
      }
      [util.inspect.custom](depth, options) {
        options.depth ??= depth;
        return `Headers ${util.formatWithOptions(options, this.#headersList.entries)}`;
      }
      static getHeadersGuard(o) {
        return o.#guard;
      }
      static setHeadersGuard(o, guard) {
        o.#guard = guard;
      }
      /**
       * @param {Headers} o
       */
      static getHeadersList(o) {
        return o.#headersList;
      }
      /**
       * @param {Headers} target
       * @param {HeadersList} list
       */
      static setHeadersList(target, list) {
        target.#headersList = list;
      }
    };
    var { getHeadersGuard, setHeadersGuard, getHeadersList, setHeadersList } = Headers2;
    Reflect.deleteProperty(Headers2, "getHeadersGuard");
    Reflect.deleteProperty(Headers2, "setHeadersGuard");
    Reflect.deleteProperty(Headers2, "getHeadersList");
    Reflect.deleteProperty(Headers2, "setHeadersList");
    iteratorMixin("Headers", Headers2, headersListSortAndCombine, 0, 1);
    Object.defineProperties(Headers2.prototype, {
      append: kEnumerableProperty,
      delete: kEnumerableProperty,
      get: kEnumerableProperty,
      has: kEnumerableProperty,
      set: kEnumerableProperty,
      getSetCookie: kEnumerableProperty,
      [Symbol.toStringTag]: {
        value: "Headers",
        configurable: true
      },
      [util.inspect.custom]: {
        enumerable: false
      }
    });
    webidl.converters.HeadersInit = function(V, prefix, argument) {
      if (webidl.util.Type(V) === webidl.util.Types.OBJECT) {
        const iterator = Reflect.get(V, Symbol.iterator);
        if (!util.types.isProxy(V) && iterator === Headers2.prototype.entries) {
          try {
            return getHeadersList(V).entriesList;
          } catch {
          }
        }
        if (typeof iterator === "function") {
          return webidl.converters["sequence<sequence<ByteString>>"](V, prefix, argument, iterator.bind(V));
        }
        return webidl.converters["record<ByteString, ByteString>"](V, prefix, argument);
      }
      throw webidl.errors.conversionFailed({
        prefix: "Headers constructor",
        argument: "Argument 1",
        types: ["sequence<sequence<ByteString>>", "record<ByteString, ByteString>"]
      });
    };
    module2.exports = {
      fill,
      // for test.
      compareHeaderName,
      Headers: Headers2,
      HeadersList,
      getHeadersGuard,
      setHeadersGuard,
      setHeadersList,
      getHeadersList
    };
  }
});

// node_modules/undici/lib/web/fetch/response.js
var require_response2 = __commonJS({
  "node_modules/undici/lib/web/fetch/response.js"(exports2, module2) {
    "use strict";
    var { Headers: Headers2, HeadersList, fill, getHeadersGuard, setHeadersGuard, setHeadersList } = require_headers();
    var { extractBody, cloneBody, mixinBody, streamRegistry, bodyUnusable } = require_body();
    var util = require_util4();
    var nodeUtil = require("node:util");
    var { kEnumerableProperty } = util;
    var {
      isValidReasonPhrase,
      isCancelled,
      isAborted,
      serializeJavascriptValueToJSONString,
      isErrorLike,
      isomorphicEncode,
      environmentSettingsObject: relevantRealm
    } = require_util5();
    var {
      redirectStatusSet,
      nullBodyStatus
    } = require_constants5();
    var { webidl } = require_webidl();
    var { URLSerializer } = require_data_url();
    var { kConstruct } = require_symbols4();
    var assert = require("node:assert");
    var { types } = require("node:util");
    var textEncoder = new TextEncoder("utf-8");
    var Response2 = class _Response {
      /** @type {Headers} */
      #headers;
      #state;
      // Creates network error Response.
      static error() {
        const responseObject = fromInnerResponse(makeNetworkError(), "immutable");
        return responseObject;
      }
      // https://fetch.spec.whatwg.org/#dom-response-json
      static json(data, init = void 0) {
        webidl.argumentLengthCheck(arguments, 1, "Response.json");
        if (init !== null) {
          init = webidl.converters.ResponseInit(init);
        }
        const bytes = textEncoder.encode(
          serializeJavascriptValueToJSONString(data)
        );
        const body = extractBody(bytes);
        const responseObject = fromInnerResponse(makeResponse({}), "response");
        initializeResponse(responseObject, init, { body: body[0], type: "application/json" });
        return responseObject;
      }
      // Creates a redirect Response that redirects to url with status status.
      static redirect(url, status = 302) {
        webidl.argumentLengthCheck(arguments, 1, "Response.redirect");
        url = webidl.converters.USVString(url);
        status = webidl.converters["unsigned short"](status);
        let parsedURL;
        try {
          parsedURL = new URL(url, relevantRealm.settingsObject.baseUrl);
        } catch (err) {
          throw new TypeError(`Failed to parse URL from ${url}`, { cause: err });
        }
        if (!redirectStatusSet.has(status)) {
          throw new RangeError(`Invalid status code ${status}`);
        }
        const responseObject = fromInnerResponse(makeResponse({}), "immutable");
        responseObject.#state.status = status;
        const value = isomorphicEncode(URLSerializer(parsedURL));
        responseObject.#state.headersList.append("location", value, true);
        return responseObject;
      }
      // https://fetch.spec.whatwg.org/#dom-response
      constructor(body = null, init = void 0) {
        webidl.util.markAsUncloneable(this);
        if (body === kConstruct) {
          return;
        }
        if (body !== null) {
          body = webidl.converters.BodyInit(body);
        }
        init = webidl.converters.ResponseInit(init);
        this.#state = makeResponse({});
        this.#headers = new Headers2(kConstruct);
        setHeadersGuard(this.#headers, "response");
        setHeadersList(this.#headers, this.#state.headersList);
        let bodyWithType = null;
        if (body != null) {
          const [extractedBody, type] = extractBody(body);
          bodyWithType = { body: extractedBody, type };
        }
        initializeResponse(this, init, bodyWithType);
      }
      // Returns responses type, e.g., "cors".
      get type() {
        webidl.brandCheck(this, _Response);
        return this.#state.type;
      }
      // Returns responses URL, if it has one; otherwise the empty string.
      get url() {
        webidl.brandCheck(this, _Response);
        const urlList = this.#state.urlList;
        const url = urlList[urlList.length - 1] ?? null;
        if (url === null) {
          return "";
        }
        return URLSerializer(url, true);
      }
      // Returns whether response was obtained through a redirect.
      get redirected() {
        webidl.brandCheck(this, _Response);
        return this.#state.urlList.length > 1;
      }
      // Returns responses status.
      get status() {
        webidl.brandCheck(this, _Response);
        return this.#state.status;
      }
      // Returns whether responses status is an ok status.
      get ok() {
        webidl.brandCheck(this, _Response);
        return this.#state.status >= 200 && this.#state.status <= 299;
      }
      // Returns responses status message.
      get statusText() {
        webidl.brandCheck(this, _Response);
        return this.#state.statusText;
      }
      // Returns responses headers as Headers.
      get headers() {
        webidl.brandCheck(this, _Response);
        return this.#headers;
      }
      get body() {
        webidl.brandCheck(this, _Response);
        return this.#state.body ? this.#state.body.stream : null;
      }
      get bodyUsed() {
        webidl.brandCheck(this, _Response);
        return !!this.#state.body && util.isDisturbed(this.#state.body.stream);
      }
      // Returns a clone of response.
      clone() {
        webidl.brandCheck(this, _Response);
        if (bodyUnusable(this.#state)) {
          throw webidl.errors.exception({
            header: "Response.clone",
            message: "Body has already been consumed."
          });
        }
        const clonedResponse = cloneResponse(this.#state);
        return fromInnerResponse(clonedResponse, getHeadersGuard(this.#headers));
      }
      [nodeUtil.inspect.custom](depth, options) {
        if (options.depth === null) {
          options.depth = 2;
        }
        options.colors ??= true;
        const properties = {
          status: this.status,
          statusText: this.statusText,
          headers: this.headers,
          body: this.body,
          bodyUsed: this.bodyUsed,
          ok: this.ok,
          redirected: this.redirected,
          type: this.type,
          url: this.url
        };
        return `Response ${nodeUtil.formatWithOptions(options, properties)}`;
      }
      /**
       * @param {Response} response
       */
      static getResponseHeaders(response) {
        return response.#headers;
      }
      /**
       * @param {Response} response
       * @param {Headers} newHeaders
       */
      static setResponseHeaders(response, newHeaders) {
        response.#headers = newHeaders;
      }
      /**
       * @param {Response} response
       */
      static getResponseState(response) {
        return response.#state;
      }
      /**
       * @param {Response} response
       * @param {any} newState
       */
      static setResponseState(response, newState) {
        response.#state = newState;
      }
    };
    var { getResponseHeaders, setResponseHeaders, getResponseState, setResponseState } = Response2;
    Reflect.deleteProperty(Response2, "getResponseHeaders");
    Reflect.deleteProperty(Response2, "setResponseHeaders");
    Reflect.deleteProperty(Response2, "getResponseState");
    Reflect.deleteProperty(Response2, "setResponseState");
    mixinBody(Response2, getResponseState);
    Object.defineProperties(Response2.prototype, {
      type: kEnumerableProperty,
      url: kEnumerableProperty,
      status: kEnumerableProperty,
      ok: kEnumerableProperty,
      redirected: kEnumerableProperty,
      statusText: kEnumerableProperty,
      headers: kEnumerableProperty,
      clone: kEnumerableProperty,
      body: kEnumerableProperty,
      bodyUsed: kEnumerableProperty,
      [Symbol.toStringTag]: {
        value: "Response",
        configurable: true
      }
    });
    Object.defineProperties(Response2, {
      json: kEnumerableProperty,
      redirect: kEnumerableProperty,
      error: kEnumerableProperty
    });
    function cloneResponse(response) {
      if (response.internalResponse) {
        return filterResponse(
          cloneResponse(response.internalResponse),
          response.type
        );
      }
      const newResponse = makeResponse({ ...response, body: null });
      if (response.body != null) {
        newResponse.body = cloneBody(response.body);
        streamRegistry.register(newResponse, new WeakRef(response.body.stream));
      }
      return newResponse;
    }
    function makeResponse(init) {
      return {
        aborted: false,
        rangeRequested: false,
        timingAllowPassed: false,
        requestIncludesCredentials: false,
        type: "default",
        status: 200,
        timingInfo: null,
        cacheState: "",
        statusText: "",
        ...init,
        headersList: init?.headersList ? new HeadersList(init?.headersList) : new HeadersList(),
        urlList: init?.urlList ? [...init.urlList] : []
      };
    }
    function makeNetworkError(reason) {
      const isError = isErrorLike(reason);
      return makeResponse({
        type: "error",
        status: 0,
        error: isError ? reason : new Error(reason ? String(reason) : reason),
        aborted: reason && reason.name === "AbortError"
      });
    }
    function isNetworkError(response) {
      return (
        // A network error is a response whose type is "error",
        response.type === "error" && // status is 0
        response.status === 0
      );
    }
    function makeFilteredResponse(response, state) {
      state = {
        internalResponse: response,
        ...state
      };
      return new Proxy(response, {
        get(target, p) {
          return p in state ? state[p] : target[p];
        },
        set(target, p, value) {
          assert(!(p in state));
          target[p] = value;
          return true;
        }
      });
    }
    function filterResponse(response, type) {
      if (type === "basic") {
        return makeFilteredResponse(response, {
          type: "basic",
          headersList: response.headersList
        });
      } else if (type === "cors") {
        return makeFilteredResponse(response, {
          type: "cors",
          headersList: response.headersList
        });
      } else if (type === "opaque") {
        return makeFilteredResponse(response, {
          type: "opaque",
          urlList: Object.freeze([]),
          status: 0,
          statusText: "",
          body: null
        });
      } else if (type === "opaqueredirect") {
        return makeFilteredResponse(response, {
          type: "opaqueredirect",
          status: 0,
          statusText: "",
          headersList: [],
          body: null
        });
      } else {
        assert(false);
      }
    }
    function makeAppropriateNetworkError(fetchParams, err = null) {
      assert(isCancelled(fetchParams));
      return isAborted(fetchParams) ? makeNetworkError(Object.assign(new DOMException("The operation was aborted.", "AbortError"), { cause: err })) : makeNetworkError(Object.assign(new DOMException("Request was cancelled."), { cause: err }));
    }
    function initializeResponse(response, init, body) {
      if (init.status !== null && (init.status < 200 || init.status > 599)) {
        throw new RangeError('init["status"] must be in the range of 200 to 599, inclusive.');
      }
      if ("statusText" in init && init.statusText != null) {
        if (!isValidReasonPhrase(String(init.statusText))) {
          throw new TypeError("Invalid statusText");
        }
      }
      if ("status" in init && init.status != null) {
        getResponseState(response).status = init.status;
      }
      if ("statusText" in init && init.statusText != null) {
        getResponseState(response).statusText = init.statusText;
      }
      if ("headers" in init && init.headers != null) {
        fill(getResponseHeaders(response), init.headers);
      }
      if (body) {
        if (nullBodyStatus.includes(response.status)) {
          throw webidl.errors.exception({
            header: "Response constructor",
            message: `Invalid response status code ${response.status}`
          });
        }
        getResponseState(response).body = body.body;
        if (body.type != null && !getResponseState(response).headersList.contains("content-type", true)) {
          getResponseState(response).headersList.append("content-type", body.type, true);
        }
      }
    }
    function fromInnerResponse(innerResponse, guard) {
      const response = new Response2(kConstruct);
      setResponseState(response, innerResponse);
      const headers = new Headers2(kConstruct);
      setResponseHeaders(response, headers);
      setHeadersList(headers, innerResponse.headersList);
      setHeadersGuard(headers, guard);
      if (innerResponse.body?.stream) {
        streamRegistry.register(response, new WeakRef(innerResponse.body.stream));
      }
      return response;
    }
    webidl.converters.XMLHttpRequestBodyInit = function(V, prefix, name) {
      if (typeof V === "string") {
        return webidl.converters.USVString(V, prefix, name);
      }
      if (webidl.is.Blob(V)) {
        return V;
      }
      if (ArrayBuffer.isView(V) || types.isArrayBuffer(V)) {
        return V;
      }
      if (webidl.is.FormData(V)) {
        return V;
      }
      if (webidl.is.URLSearchParams(V)) {
        return V;
      }
      return webidl.converters.DOMString(V, prefix, name);
    };
    webidl.converters.BodyInit = function(V, prefix, argument) {
      if (webidl.is.ReadableStream(V)) {
        return V;
      }
      if (V?.[Symbol.asyncIterator]) {
        return V;
      }
      return webidl.converters.XMLHttpRequestBodyInit(V, prefix, argument);
    };
    webidl.converters.ResponseInit = webidl.dictionaryConverter([
      {
        key: "status",
        converter: webidl.converters["unsigned short"],
        defaultValue: () => 200
      },
      {
        key: "statusText",
        converter: webidl.converters.ByteString,
        defaultValue: () => ""
      },
      {
        key: "headers",
        converter: webidl.converters.HeadersInit
      }
    ]);
    webidl.is.Response = webidl.util.MakeTypeAssertion(Response2);
    module2.exports = {
      isNetworkError,
      makeNetworkError,
      makeResponse,
      makeAppropriateNetworkError,
      filterResponse,
      Response: Response2,
      cloneResponse,
      fromInnerResponse,
      getResponseState
    };
  }
});

// node_modules/undici/lib/web/fetch/request.js
var require_request4 = __commonJS({
  "node_modules/undici/lib/web/fetch/request.js"(exports2, module2) {
    "use strict";
    var { extractBody, mixinBody, cloneBody, bodyUnusable } = require_body();
    var { Headers: Headers2, fill: fillHeaders, HeadersList, setHeadersGuard, getHeadersGuard, setHeadersList, getHeadersList } = require_headers();
    var util = require_util4();
    var nodeUtil = require("node:util");
    var {
      isValidHTTPToken,
      sameOrigin,
      environmentSettingsObject
    } = require_util5();
    var {
      forbiddenMethodsSet,
      corsSafeListedMethodsSet,
      referrerPolicy,
      requestRedirect,
      requestMode,
      requestCredentials,
      requestCache,
      requestDuplex
    } = require_constants5();
    var { kEnumerableProperty, normalizedMethodRecordsBase, normalizedMethodRecords } = util;
    var { webidl } = require_webidl();
    var { URLSerializer } = require_data_url();
    var { kConstruct } = require_symbols4();
    var assert = require("node:assert");
    var { getMaxListeners, setMaxListeners, defaultMaxListeners } = require("node:events");
    var kAbortController = Symbol("abortController");
    var requestFinalizer = new FinalizationRegistry(({ signal, abort }) => {
      signal.removeEventListener("abort", abort);
    });
    var dependentControllerMap = /* @__PURE__ */ new WeakMap();
    var abortSignalHasEventHandlerLeakWarning;
    try {
      abortSignalHasEventHandlerLeakWarning = getMaxListeners(new AbortController().signal) > 0;
    } catch {
      abortSignalHasEventHandlerLeakWarning = false;
    }
    function buildAbort(acRef) {
      return abort;
      function abort() {
        const ac = acRef.deref();
        if (ac !== void 0) {
          requestFinalizer.unregister(abort);
          this.removeEventListener("abort", abort);
          ac.abort(this.reason);
          const controllerList = dependentControllerMap.get(ac.signal);
          if (controllerList !== void 0) {
            if (controllerList.size !== 0) {
              for (const ref of controllerList) {
                const ctrl = ref.deref();
                if (ctrl !== void 0) {
                  ctrl.abort(this.reason);
                }
              }
              controllerList.clear();
            }
            dependentControllerMap.delete(ac.signal);
          }
        }
      }
    }
    var patchMethodWarning = false;
    var Request = class _Request {
      /** @type {AbortSignal} */
      #signal;
      /** @type {import('../../dispatcher/dispatcher')} */
      #dispatcher;
      /** @type {Headers} */
      #headers;
      #state;
      // https://fetch.spec.whatwg.org/#dom-request
      constructor(input, init = void 0) {
        webidl.util.markAsUncloneable(this);
        if (input === kConstruct) {
          return;
        }
        const prefix = "Request constructor";
        webidl.argumentLengthCheck(arguments, 1, prefix);
        input = webidl.converters.RequestInfo(input);
        init = webidl.converters.RequestInit(init);
        let request = null;
        let fallbackMode = null;
        const baseUrl = environmentSettingsObject.settingsObject.baseUrl;
        let signal = null;
        if (typeof input === "string") {
          this.#dispatcher = init.dispatcher;
          let parsedURL;
          try {
            parsedURL = new URL(input, baseUrl);
          } catch (err) {
            throw new TypeError("Failed to parse URL from " + input, { cause: err });
          }
          if (parsedURL.username || parsedURL.password) {
            throw new TypeError(
              "Request cannot be constructed from a URL that includes credentials: " + input
            );
          }
          request = makeRequest({ urlList: [parsedURL] });
          fallbackMode = "cors";
        } else {
          assert(webidl.is.Request(input));
          request = input.#state;
          signal = input.#signal;
          this.#dispatcher = init.dispatcher || input.#dispatcher;
        }
        const origin = environmentSettingsObject.settingsObject.origin;
        let window2 = "client";
        if (request.window?.constructor?.name === "EnvironmentSettingsObject" && sameOrigin(request.window, origin)) {
          window2 = request.window;
        }
        if (init.window != null) {
          throw new TypeError(`'window' option '${window2}' must be null`);
        }
        if ("window" in init) {
          window2 = "no-window";
        }
        request = makeRequest({
          // URL requests URL.
          // undici implementation note: this is set as the first item in request's urlList in makeRequest
          // method requests method.
          method: request.method,
          // header list A copy of requests header list.
          // undici implementation note: headersList is cloned in makeRequest
          headersList: request.headersList,
          // unsafe-request flag Set.
          unsafeRequest: request.unsafeRequest,
          // client Thiss relevant settings object.
          client: environmentSettingsObject.settingsObject,
          // window window.
          window: window2,
          // priority requests priority.
          priority: request.priority,
          // origin requests origin. The propagation of the origin is only significant for navigation requests
          // being handled by a service worker. In this scenario a request can have an origin that is different
          // from the current client.
          origin: request.origin,
          // referrer requests referrer.
          referrer: request.referrer,
          // referrer policy requests referrer policy.
          referrerPolicy: request.referrerPolicy,
          // mode requests mode.
          mode: request.mode,
          // credentials mode requests credentials mode.
          credentials: request.credentials,
          // cache mode requests cache mode.
          cache: request.cache,
          // redirect mode requests redirect mode.
          redirect: request.redirect,
          // integrity metadata requests integrity metadata.
          integrity: request.integrity,
          // keepalive requests keepalive.
          keepalive: request.keepalive,
          // reload-navigation flag requests reload-navigation flag.
          reloadNavigation: request.reloadNavigation,
          // history-navigation flag requests history-navigation flag.
          historyNavigation: request.historyNavigation,
          // URL list A clone of requests URL list.
          urlList: [...request.urlList]
        });
        const initHasKey = Object.keys(init).length !== 0;
        if (initHasKey) {
          if (request.mode === "navigate") {
            request.mode = "same-origin";
          }
          request.reloadNavigation = false;
          request.historyNavigation = false;
          request.origin = "client";
          request.referrer = "client";
          request.referrerPolicy = "";
          request.url = request.urlList[request.urlList.length - 1];
          request.urlList = [request.url];
        }
        if (init.referrer !== void 0) {
          const referrer = init.referrer;
          if (referrer === "") {
            request.referrer = "no-referrer";
          } else {
            let parsedReferrer;
            try {
              parsedReferrer = new URL(referrer, baseUrl);
            } catch (err) {
              throw new TypeError(`Referrer "${referrer}" is not a valid URL.`, { cause: err });
            }
            if (parsedReferrer.protocol === "about:" && parsedReferrer.hostname === "client" || origin && !sameOrigin(parsedReferrer, environmentSettingsObject.settingsObject.baseUrl)) {
              request.referrer = "client";
            } else {
              request.referrer = parsedReferrer;
            }
          }
        }
        if (init.referrerPolicy !== void 0) {
          request.referrerPolicy = init.referrerPolicy;
        }
        let mode;
        if (init.mode !== void 0) {
          mode = init.mode;
        } else {
          mode = fallbackMode;
        }
        if (mode === "navigate") {
          throw webidl.errors.exception({
            header: "Request constructor",
            message: "invalid request mode navigate."
          });
        }
        if (mode != null) {
          request.mode = mode;
        }
        if (init.credentials !== void 0) {
          request.credentials = init.credentials;
        }
        if (init.cache !== void 0) {
          request.cache = init.cache;
        }
        if (request.cache === "only-if-cached" && request.mode !== "same-origin") {
          throw new TypeError(
            "'only-if-cached' can be set only with 'same-origin' mode"
          );
        }
        if (init.redirect !== void 0) {
          request.redirect = init.redirect;
        }
        if (init.integrity != null) {
          request.integrity = String(init.integrity);
        }
        if (init.keepalive !== void 0) {
          request.keepalive = Boolean(init.keepalive);
        }
        if (init.method !== void 0) {
          let method = init.method;
          const mayBeNormalized = normalizedMethodRecords[method];
          if (mayBeNormalized !== void 0) {
            request.method = mayBeNormalized;
          } else {
            if (!isValidHTTPToken(method)) {
              throw new TypeError(`'${method}' is not a valid HTTP method.`);
            }
            const upperCase = method.toUpperCase();
            if (forbiddenMethodsSet.has(upperCase)) {
              throw new TypeError(`'${method}' HTTP method is unsupported.`);
            }
            method = normalizedMethodRecordsBase[upperCase] ?? method;
            request.method = method;
          }
          if (!patchMethodWarning && request.method === "patch") {
            process.emitWarning("Using `patch` is highly likely to result in a `405 Method Not Allowed`. `PATCH` is much more likely to succeed.", {
              code: "UNDICI-FETCH-patch"
            });
            patchMethodWarning = true;
          }
        }
        if (init.signal !== void 0) {
          signal = init.signal;
        }
        this.#state = request;
        const ac = new AbortController();
        this.#signal = ac.signal;
        if (signal != null) {
          if (signal.aborted) {
            ac.abort(signal.reason);
          } else {
            this[kAbortController] = ac;
            const acRef = new WeakRef(ac);
            const abort = buildAbort(acRef);
            if (abortSignalHasEventHandlerLeakWarning && getMaxListeners(signal) === defaultMaxListeners) {
              setMaxListeners(1500, signal);
            }
            util.addAbortListener(signal, abort);
            requestFinalizer.register(ac, { signal, abort }, abort);
          }
        }
        this.#headers = new Headers2(kConstruct);
        setHeadersList(this.#headers, request.headersList);
        setHeadersGuard(this.#headers, "request");
        if (mode === "no-cors") {
          if (!corsSafeListedMethodsSet.has(request.method)) {
            throw new TypeError(
              `'${request.method} is unsupported in no-cors mode.`
            );
          }
          setHeadersGuard(this.#headers, "request-no-cors");
        }
        if (initHasKey) {
          const headersList = getHeadersList(this.#headers);
          const headers = init.headers !== void 0 ? init.headers : new HeadersList(headersList);
          headersList.clear();
          if (headers instanceof HeadersList) {
            for (const { name, value } of headers.rawValues()) {
              headersList.append(name, value, false);
            }
            headersList.cookies = headers.cookies;
          } else {
            fillHeaders(this.#headers, headers);
          }
        }
        const inputBody = webidl.is.Request(input) ? input.#state.body : null;
        if ((init.body != null || inputBody != null) && (request.method === "GET" || request.method === "HEAD")) {
          throw new TypeError("Request with GET/HEAD method cannot have body.");
        }
        let initBody = null;
        if (init.body != null) {
          const [extractedBody, contentType] = extractBody(
            init.body,
            request.keepalive
          );
          initBody = extractedBody;
          if (contentType && !getHeadersList(this.#headers).contains("content-type", true)) {
            this.#headers.append("content-type", contentType, true);
          }
        }
        const inputOrInitBody = initBody ?? inputBody;
        if (inputOrInitBody != null && inputOrInitBody.source == null) {
          if (initBody != null && init.duplex == null) {
            throw new TypeError("RequestInit: duplex option is required when sending a body.");
          }
          if (request.mode !== "same-origin" && request.mode !== "cors") {
            throw new TypeError(
              'If request is made from ReadableStream, mode should be "same-origin" or "cors"'
            );
          }
          request.useCORSPreflightFlag = true;
        }
        let finalBody = inputOrInitBody;
        if (initBody == null && inputBody != null) {
          if (bodyUnusable(input.#state)) {
            throw new TypeError(
              "Cannot construct a Request with a Request object that has already been used."
            );
          }
          const identityTransform = new TransformStream();
          inputBody.stream.pipeThrough(identityTransform);
          finalBody = {
            source: inputBody.source,
            length: inputBody.length,
            stream: identityTransform.readable
          };
        }
        this.#state.body = finalBody;
      }
      // Returns requests HTTP method, which is "GET" by default.
      get method() {
        webidl.brandCheck(this, _Request);
        return this.#state.method;
      }
      // Returns the URL of request as a string.
      get url() {
        webidl.brandCheck(this, _Request);
        return URLSerializer(this.#state.url);
      }
      // Returns a Headers object consisting of the headers associated with request.
      // Note that headers added in the network layer by the user agent will not
      // be accounted for in this object, e.g., the "Host" header.
      get headers() {
        webidl.brandCheck(this, _Request);
        return this.#headers;
      }
      // Returns the kind of resource requested by request, e.g., "document"
      // or "script".
      get destination() {
        webidl.brandCheck(this, _Request);
        return this.#state.destination;
      }
      // Returns the referrer of request. Its value can be a same-origin URL if
      // explicitly set in init, the empty string to indicate no referrer, and
      // "about:client" when defaulting to the globals default. This is used
      // during fetching to determine the value of the `Referer` header of the
      // request being made.
      get referrer() {
        webidl.brandCheck(this, _Request);
        if (this.#state.referrer === "no-referrer") {
          return "";
        }
        if (this.#state.referrer === "client") {
          return "about:client";
        }
        return this.#state.referrer.toString();
      }
      // Returns the referrer policy associated with request.
      // This is used during fetching to compute the value of the requests
      // referrer.
      get referrerPolicy() {
        webidl.brandCheck(this, _Request);
        return this.#state.referrerPolicy;
      }
      // Returns the mode associated with request, which is a string indicating
      // whether the request will use CORS, or will be restricted to same-origin
      // URLs.
      get mode() {
        webidl.brandCheck(this, _Request);
        return this.#state.mode;
      }
      // Returns the credentials mode associated with request,
      // which is a string indicating whether credentials will be sent with the
      // request always, never, or only when sent to a same-origin URL.
      get credentials() {
        webidl.brandCheck(this, _Request);
        return this.#state.credentials;
      }
      // Returns the cache mode associated with request,
      // which is a string indicating how the request will
      // interact with the browsers cache when fetching.
      get cache() {
        webidl.brandCheck(this, _Request);
        return this.#state.cache;
      }
      // Returns the redirect mode associated with request,
      // which is a string indicating how redirects for the
      // request will be handled during fetching. A request
      // will follow redirects by default.
      get redirect() {
        webidl.brandCheck(this, _Request);
        return this.#state.redirect;
      }
      // Returns requests subresource integrity metadata, which is a
      // cryptographic hash of the resource being fetched. Its value
      // consists of multiple hashes separated by whitespace. [SRI]
      get integrity() {
        webidl.brandCheck(this, _Request);
        return this.#state.integrity;
      }
      // Returns a boolean indicating whether or not request can outlive the
      // global in which it was created.
      get keepalive() {
        webidl.brandCheck(this, _Request);
        return this.#state.keepalive;
      }
      // Returns a boolean indicating whether or not request is for a reload
      // navigation.
      get isReloadNavigation() {
        webidl.brandCheck(this, _Request);
        return this.#state.reloadNavigation;
      }
      // Returns a boolean indicating whether or not request is for a history
      // navigation (a.k.a. back-forward navigation).
      get isHistoryNavigation() {
        webidl.brandCheck(this, _Request);
        return this.#state.historyNavigation;
      }
      // Returns the signal associated with request, which is an AbortSignal
      // object indicating whether or not request has been aborted, and its
      // abort event handler.
      get signal() {
        webidl.brandCheck(this, _Request);
        return this.#signal;
      }
      get body() {
        webidl.brandCheck(this, _Request);
        return this.#state.body ? this.#state.body.stream : null;
      }
      get bodyUsed() {
        webidl.brandCheck(this, _Request);
        return !!this.#state.body && util.isDisturbed(this.#state.body.stream);
      }
      get duplex() {
        webidl.brandCheck(this, _Request);
        return "half";
      }
      // Returns a clone of request.
      clone() {
        webidl.brandCheck(this, _Request);
        if (bodyUnusable(this.#state)) {
          throw new TypeError("unusable");
        }
        const clonedRequest = cloneRequest(this.#state);
        const ac = new AbortController();
        if (this.signal.aborted) {
          ac.abort(this.signal.reason);
        } else {
          let list = dependentControllerMap.get(this.signal);
          if (list === void 0) {
            list = /* @__PURE__ */ new Set();
            dependentControllerMap.set(this.signal, list);
          }
          const acRef = new WeakRef(ac);
          list.add(acRef);
          util.addAbortListener(
            ac.signal,
            buildAbort(acRef)
          );
        }
        return fromInnerRequest(clonedRequest, this.#dispatcher, ac.signal, getHeadersGuard(this.#headers));
      }
      [nodeUtil.inspect.custom](depth, options) {
        if (options.depth === null) {
          options.depth = 2;
        }
        options.colors ??= true;
        const properties = {
          method: this.method,
          url: this.url,
          headers: this.headers,
          destination: this.destination,
          referrer: this.referrer,
          referrerPolicy: this.referrerPolicy,
          mode: this.mode,
          credentials: this.credentials,
          cache: this.cache,
          redirect: this.redirect,
          integrity: this.integrity,
          keepalive: this.keepalive,
          isReloadNavigation: this.isReloadNavigation,
          isHistoryNavigation: this.isHistoryNavigation,
          signal: this.signal
        };
        return `Request ${nodeUtil.formatWithOptions(options, properties)}`;
      }
      /**
       * @param {Request} request
       * @param {AbortSignal} newSignal
       */
      static setRequestSignal(request, newSignal) {
        request.#signal = newSignal;
        return request;
      }
      /**
       * @param {Request} request
       */
      static getRequestDispatcher(request) {
        return request.#dispatcher;
      }
      /**
       * @param {Request} request
       * @param {import('../../dispatcher/dispatcher')} newDispatcher
       */
      static setRequestDispatcher(request, newDispatcher) {
        request.#dispatcher = newDispatcher;
      }
      /**
       * @param {Request} request
       * @param {Headers} newHeaders
       */
      static setRequestHeaders(request, newHeaders) {
        request.#headers = newHeaders;
      }
      /**
       * @param {Request} request
       */
      static getRequestState(request) {
        return request.#state;
      }
      /**
       * @param {Request} request
       * @param {any} newState
       */
      static setRequestState(request, newState) {
        request.#state = newState;
      }
    };
    var { setRequestSignal, getRequestDispatcher, setRequestDispatcher, setRequestHeaders, getRequestState, setRequestState } = Request;
    Reflect.deleteProperty(Request, "setRequestSignal");
    Reflect.deleteProperty(Request, "getRequestDispatcher");
    Reflect.deleteProperty(Request, "setRequestDispatcher");
    Reflect.deleteProperty(Request, "setRequestHeaders");
    Reflect.deleteProperty(Request, "getRequestState");
    Reflect.deleteProperty(Request, "setRequestState");
    mixinBody(Request, getRequestState);
    function makeRequest(init) {
      return {
        method: init.method ?? "GET",
        localURLsOnly: init.localURLsOnly ?? false,
        unsafeRequest: init.unsafeRequest ?? false,
        body: init.body ?? null,
        client: init.client ?? null,
        reservedClient: init.reservedClient ?? null,
        replacesClientId: init.replacesClientId ?? "",
        window: init.window ?? "client",
        keepalive: init.keepalive ?? false,
        serviceWorkers: init.serviceWorkers ?? "all",
        initiator: init.initiator ?? "",
        destination: init.destination ?? "",
        priority: init.priority ?? null,
        origin: init.origin ?? "client",
        policyContainer: init.policyContainer ?? "client",
        referrer: init.referrer ?? "client",
        referrerPolicy: init.referrerPolicy ?? "",
        mode: init.mode ?? "no-cors",
        useCORSPreflightFlag: init.useCORSPreflightFlag ?? false,
        credentials: init.credentials ?? "same-origin",
        useCredentials: init.useCredentials ?? false,
        cache: init.cache ?? "default",
        redirect: init.redirect ?? "follow",
        integrity: init.integrity ?? "",
        cryptoGraphicsNonceMetadata: init.cryptoGraphicsNonceMetadata ?? "",
        parserMetadata: init.parserMetadata ?? "",
        reloadNavigation: init.reloadNavigation ?? false,
        historyNavigation: init.historyNavigation ?? false,
        userActivation: init.userActivation ?? false,
        taintedOrigin: init.taintedOrigin ?? false,
        redirectCount: init.redirectCount ?? 0,
        responseTainting: init.responseTainting ?? "basic",
        preventNoCacheCacheControlHeaderModification: init.preventNoCacheCacheControlHeaderModification ?? false,
        done: init.done ?? false,
        timingAllowFailed: init.timingAllowFailed ?? false,
        urlList: init.urlList,
        url: init.urlList[0],
        headersList: init.headersList ? new HeadersList(init.headersList) : new HeadersList()
      };
    }
    function cloneRequest(request) {
      const newRequest = makeRequest({ ...request, body: null });
      if (request.body != null) {
        newRequest.body = cloneBody(request.body);
      }
      return newRequest;
    }
    function fromInnerRequest(innerRequest, dispatcher, signal, guard) {
      const request = new Request(kConstruct);
      setRequestState(request, innerRequest);
      setRequestDispatcher(request, dispatcher);
      setRequestSignal(request, signal);
      const headers = new Headers2(kConstruct);
      setRequestHeaders(request, headers);
      setHeadersList(headers, innerRequest.headersList);
      setHeadersGuard(headers, guard);
      return request;
    }
    Object.defineProperties(Request.prototype, {
      method: kEnumerableProperty,
      url: kEnumerableProperty,
      headers: kEnumerableProperty,
      redirect: kEnumerableProperty,
      clone: kEnumerableProperty,
      signal: kEnumerableProperty,
      duplex: kEnumerableProperty,
      destination: kEnumerableProperty,
      body: kEnumerableProperty,
      bodyUsed: kEnumerableProperty,
      isHistoryNavigation: kEnumerableProperty,
      isReloadNavigation: kEnumerableProperty,
      keepalive: kEnumerableProperty,
      integrity: kEnumerableProperty,
      cache: kEnumerableProperty,
      credentials: kEnumerableProperty,
      attribute: kEnumerableProperty,
      referrerPolicy: kEnumerableProperty,
      referrer: kEnumerableProperty,
      mode: kEnumerableProperty,
      [Symbol.toStringTag]: {
        value: "Request",
        configurable: true
      }
    });
    webidl.is.Request = webidl.util.MakeTypeAssertion(Request);
    webidl.converters.RequestInfo = function(V) {
      if (typeof V === "string") {
        return webidl.converters.USVString(V);
      }
      if (webidl.is.Request(V)) {
        return V;
      }
      return webidl.converters.USVString(V);
    };
    webidl.converters.RequestInit = webidl.dictionaryConverter([
      {
        key: "method",
        converter: webidl.converters.ByteString
      },
      {
        key: "headers",
        converter: webidl.converters.HeadersInit
      },
      {
        key: "body",
        converter: webidl.nullableConverter(
          webidl.converters.BodyInit
        )
      },
      {
        key: "referrer",
        converter: webidl.converters.USVString
      },
      {
        key: "referrerPolicy",
        converter: webidl.converters.DOMString,
        // https://w3c.github.io/webappsec-referrer-policy/#referrer-policy
        allowedValues: referrerPolicy
      },
      {
        key: "mode",
        converter: webidl.converters.DOMString,
        // https://fetch.spec.whatwg.org/#concept-request-mode
        allowedValues: requestMode
      },
      {
        key: "credentials",
        converter: webidl.converters.DOMString,
        // https://fetch.spec.whatwg.org/#requestcredentials
        allowedValues: requestCredentials
      },
      {
        key: "cache",
        converter: webidl.converters.DOMString,
        // https://fetch.spec.whatwg.org/#requestcache
        allowedValues: requestCache
      },
      {
        key: "redirect",
        converter: webidl.converters.DOMString,
        // https://fetch.spec.whatwg.org/#requestredirect
        allowedValues: requestRedirect
      },
      {
        key: "integrity",
        converter: webidl.converters.DOMString
      },
      {
        key: "keepalive",
        converter: webidl.converters.boolean
      },
      {
        key: "signal",
        converter: webidl.nullableConverter(
          (signal) => webidl.converters.AbortSignal(
            signal,
            "RequestInit",
            "signal"
          )
        )
      },
      {
        key: "window",
        converter: webidl.converters.any
      },
      {
        key: "duplex",
        converter: webidl.converters.DOMString,
        allowedValues: requestDuplex
      },
      {
        key: "dispatcher",
        // undici specific option
        converter: webidl.converters.any
      }
    ]);
    module2.exports = {
      Request,
      makeRequest,
      fromInnerRequest,
      cloneRequest,
      getRequestDispatcher,
      getRequestState
    };
  }
});

// node_modules/undici/lib/web/fetch/index.js
var require_fetch = __commonJS({
  "node_modules/undici/lib/web/fetch/index.js"(exports2, module2) {
    "use strict";
    var {
      makeNetworkError,
      makeAppropriateNetworkError,
      filterResponse,
      makeResponse,
      fromInnerResponse,
      getResponseState
    } = require_response2();
    var { HeadersList } = require_headers();
    var { Request, cloneRequest, getRequestDispatcher, getRequestState } = require_request4();
    var zlib = require("node:zlib");
    var {
      bytesMatch,
      makePolicyContainer,
      clonePolicyContainer,
      requestBadPort,
      TAOCheck,
      appendRequestOriginHeader,
      responseLocationURL,
      requestCurrentURL,
      setRequestReferrerPolicyOnRedirect,
      tryUpgradeRequestToAPotentiallyTrustworthyURL,
      createOpaqueTimingInfo,
      appendFetchMetadata,
      corsCheck,
      crossOriginResourcePolicyCheck,
      determineRequestsReferrer,
      coarsenedSharedCurrentTime,
      sameOrigin,
      isCancelled,
      isAborted,
      isErrorLike,
      fullyReadBody,
      readableStreamClose,
      isomorphicEncode,
      urlIsLocal,
      urlIsHttpHttpsScheme,
      urlHasHttpsScheme,
      clampAndCoarsenConnectionTimingInfo,
      simpleRangeHeaderValue,
      buildContentRange,
      createInflate,
      extractMimeType
    } = require_util5();
    var assert = require("node:assert");
    var { safelyExtractBody, extractBody } = require_body();
    var {
      redirectStatusSet,
      nullBodyStatus,
      safeMethodsSet,
      requestBodyHeader,
      subresourceSet
    } = require_constants5();
    var EE = require("node:events");
    var { Readable, pipeline, finished, isErrored, isReadable } = require("node:stream");
    var { addAbortListener, bufferToLowerCasedHeaderName } = require_util4();
    var { dataURLProcessor, serializeAMimeType, minimizeSupportedMimeType } = require_data_url();
    var { getGlobalDispatcher } = require_global2();
    var { webidl } = require_webidl();
    var { STATUS_CODES } = require("node:http");
    var { createDeferredPromise } = require_promise();
    var GET_OR_HEAD = ["GET", "HEAD"];
    var defaultUserAgent = typeof __UNDICI_IS_NODE__ !== "undefined" || typeof esbuildDetection !== "undefined" ? "node" : "undici";
    var resolveObjectURL;
    var Fetch = class extends EE {
      constructor(dispatcher) {
        super();
        this.dispatcher = dispatcher;
        this.connection = null;
        this.dump = false;
        this.state = "ongoing";
      }
      terminate(reason) {
        if (this.state !== "ongoing") {
          return;
        }
        this.state = "terminated";
        this.connection?.destroy(reason);
        this.emit("terminated", reason);
      }
      // https://fetch.spec.whatwg.org/#fetch-controller-abort
      abort(error) {
        if (this.state !== "ongoing") {
          return;
        }
        this.state = "aborted";
        if (!error) {
          error = new DOMException("The operation was aborted.", "AbortError");
        }
        this.serializedAbortReason = error;
        this.connection?.destroy(error);
        this.emit("terminated", error);
      }
    };
    function handleFetchDone(response) {
      finalizeAndReportTiming(response, "fetch");
    }
    function fetch2(input, init = void 0) {
      webidl.argumentLengthCheck(arguments, 1, "globalThis.fetch");
      let p = createDeferredPromise();
      let requestObject;
      try {
        requestObject = new Request(input, init);
      } catch (e) {
        p.reject(e);
        return p.promise;
      }
      const request = getRequestState(requestObject);
      if (requestObject.signal.aborted) {
        abortFetch(p, request, null, requestObject.signal.reason);
        return p.promise;
      }
      const globalObject = request.client.globalObject;
      if (globalObject?.constructor?.name === "ServiceWorkerGlobalScope") {
        request.serviceWorkers = "none";
      }
      let responseObject = null;
      let locallyAborted = false;
      let controller = null;
      addAbortListener(
        requestObject.signal,
        () => {
          locallyAborted = true;
          assert(controller != null);
          controller.abort(requestObject.signal.reason);
          const realResponse = responseObject?.deref();
          abortFetch(p, request, realResponse, requestObject.signal.reason);
        }
      );
      const processResponse = (response) => {
        if (locallyAborted) {
          return;
        }
        if (response.aborted) {
          abortFetch(p, request, responseObject, controller.serializedAbortReason);
          return;
        }
        if (response.type === "error") {
          p.reject(new TypeError("fetch failed", { cause: response.error }));
          return;
        }
        responseObject = new WeakRef(fromInnerResponse(response, "immutable"));
        p.resolve(responseObject.deref());
        p = null;
      };
      controller = fetching({
        request,
        processResponseEndOfBody: handleFetchDone,
        processResponse,
        dispatcher: getRequestDispatcher(requestObject)
        // undici
      });
      return p.promise;
    }
    function finalizeAndReportTiming(response, initiatorType = "other") {
      if (response.type === "error" && response.aborted) {
        return;
      }
      if (!response.urlList?.length) {
        return;
      }
      const originalURL = response.urlList[0];
      let timingInfo = response.timingInfo;
      let cacheState = response.cacheState;
      if (!urlIsHttpHttpsScheme(originalURL)) {
        return;
      }
      if (timingInfo === null) {
        return;
      }
      if (!response.timingAllowPassed) {
        timingInfo = createOpaqueTimingInfo({
          startTime: timingInfo.startTime
        });
        cacheState = "";
      }
      timingInfo.endTime = coarsenedSharedCurrentTime();
      response.timingInfo = timingInfo;
      markResourceTiming(
        timingInfo,
        originalURL.href,
        initiatorType,
        globalThis,
        cacheState,
        "",
        // bodyType
        response.status
      );
    }
    var markResourceTiming = performance.markResourceTiming;
    function abortFetch(p, request, responseObject, error) {
      if (p) {
        p.reject(error);
      }
      if (request.body?.stream != null && isReadable(request.body.stream)) {
        request.body.stream.cancel(error).catch((err) => {
          if (err.code === "ERR_INVALID_STATE") {
            return;
          }
          throw err;
        });
      }
      if (responseObject == null) {
        return;
      }
      const response = getResponseState(responseObject);
      if (response.body?.stream != null && isReadable(response.body.stream)) {
        response.body.stream.cancel(error).catch((err) => {
          if (err.code === "ERR_INVALID_STATE") {
            return;
          }
          throw err;
        });
      }
    }
    function fetching({
      request,
      processRequestBodyChunkLength,
      processRequestEndOfBody,
      processResponse,
      processResponseEndOfBody,
      processResponseConsumeBody,
      useParallelQueue = false,
      dispatcher = getGlobalDispatcher()
      // undici
    }) {
      assert(dispatcher);
      let taskDestination = null;
      let crossOriginIsolatedCapability = false;
      if (request.client != null) {
        taskDestination = request.client.globalObject;
        crossOriginIsolatedCapability = request.client.crossOriginIsolatedCapability;
      }
      const currentTime = coarsenedSharedCurrentTime(crossOriginIsolatedCapability);
      const timingInfo = createOpaqueTimingInfo({
        startTime: currentTime
      });
      const fetchParams = {
        controller: new Fetch(dispatcher),
        request,
        timingInfo,
        processRequestBodyChunkLength,
        processRequestEndOfBody,
        processResponse,
        processResponseConsumeBody,
        processResponseEndOfBody,
        taskDestination,
        crossOriginIsolatedCapability
      };
      assert(!request.body || request.body.stream);
      if (request.window === "client") {
        request.window = request.client?.globalObject?.constructor?.name === "Window" ? request.client : "no-window";
      }
      if (request.origin === "client") {
        request.origin = request.client.origin;
      }
      if (request.policyContainer === "client") {
        if (request.client != null) {
          request.policyContainer = clonePolicyContainer(
            request.client.policyContainer
          );
        } else {
          request.policyContainer = makePolicyContainer();
        }
      }
      if (!request.headersList.contains("accept", true)) {
        const value = "*/*";
        request.headersList.append("accept", value, true);
      }
      if (!request.headersList.contains("accept-language", true)) {
        request.headersList.append("accept-language", "*", true);
      }
      if (request.priority === null) {
      }
      if (subresourceSet.has(request.destination)) {
      }
      mainFetch(fetchParams, false);
      return fetchParams.controller;
    }
    async function mainFetch(fetchParams, recursive) {
      try {
        const request = fetchParams.request;
        let response = null;
        if (request.localURLsOnly && !urlIsLocal(requestCurrentURL(request))) {
          response = makeNetworkError("local URLs only");
        }
        tryUpgradeRequestToAPotentiallyTrustworthyURL(request);
        if (requestBadPort(request) === "blocked") {
          response = makeNetworkError("bad port");
        }
        if (request.referrerPolicy === "") {
          request.referrerPolicy = request.policyContainer.referrerPolicy;
        }
        if (request.referrer !== "no-referrer") {
          request.referrer = determineRequestsReferrer(request);
        }
        if (response === null) {
          const currentURL = requestCurrentURL(request);
          if (
            // - requests current URLs origin is same origin with requests origin,
            //   and requests response tainting is "basic"
            sameOrigin(currentURL, request.url) && request.responseTainting === "basic" || // requests current URLs scheme is "data"
            currentURL.protocol === "data:" || // - requests mode is "navigate" or "websocket"
            (request.mode === "navigate" || request.mode === "websocket")
          ) {
            request.responseTainting = "basic";
            response = await schemeFetch(fetchParams);
          } else if (request.mode === "same-origin") {
            response = makeNetworkError('request mode cannot be "same-origin"');
          } else if (request.mode === "no-cors") {
            if (request.redirect !== "follow") {
              response = makeNetworkError(
                'redirect mode cannot be "follow" for "no-cors" request'
              );
            } else {
              request.responseTainting = "opaque";
              response = await schemeFetch(fetchParams);
            }
          } else if (!urlIsHttpHttpsScheme(requestCurrentURL(request))) {
            response = makeNetworkError("URL scheme must be a HTTP(S) scheme");
          } else {
            request.responseTainting = "cors";
            response = await httpFetch(fetchParams);
          }
        }
        if (recursive) {
          return response;
        }
        if (response.status !== 0 && !response.internalResponse) {
          if (request.responseTainting === "cors") {
          }
          if (request.responseTainting === "basic") {
            response = filterResponse(response, "basic");
          } else if (request.responseTainting === "cors") {
            response = filterResponse(response, "cors");
          } else if (request.responseTainting === "opaque") {
            response = filterResponse(response, "opaque");
          } else {
            assert(false);
          }
        }
        let internalResponse = response.status === 0 ? response : response.internalResponse;
        if (internalResponse.urlList.length === 0) {
          internalResponse.urlList.push(...request.urlList);
        }
        if (!request.timingAllowFailed) {
          response.timingAllowPassed = true;
        }
        if (response.type === "opaque" && internalResponse.status === 206 && internalResponse.rangeRequested && !request.headers.contains("range", true)) {
          response = internalResponse = makeNetworkError();
        }
        if (response.status !== 0 && (request.method === "HEAD" || request.method === "CONNECT" || nullBodyStatus.includes(internalResponse.status))) {
          internalResponse.body = null;
          fetchParams.controller.dump = true;
        }
        if (request.integrity) {
          const processBodyError = (reason) => fetchFinale(fetchParams, makeNetworkError(reason));
          if (request.responseTainting === "opaque" || response.body == null) {
            processBodyError(response.error);
            return;
          }
          const processBody = (bytes) => {
            if (!bytesMatch(bytes, request.integrity)) {
              processBodyError("integrity mismatch");
              return;
            }
            response.body = safelyExtractBody(bytes)[0];
            fetchFinale(fetchParams, response);
          };
          fullyReadBody(response.body, processBody, processBodyError);
        } else {
          fetchFinale(fetchParams, response);
        }
      } catch (err) {
        fetchParams.controller.terminate(err);
      }
    }
    function schemeFetch(fetchParams) {
      if (isCancelled(fetchParams) && fetchParams.request.redirectCount === 0) {
        return Promise.resolve(makeAppropriateNetworkError(fetchParams));
      }
      const { request } = fetchParams;
      const { protocol: scheme } = requestCurrentURL(request);
      switch (scheme) {
        case "about:": {
          return Promise.resolve(makeNetworkError("about scheme is not supported"));
        }
        case "blob:": {
          if (!resolveObjectURL) {
            resolveObjectURL = require("node:buffer").resolveObjectURL;
          }
          const blobURLEntry = requestCurrentURL(request);
          if (blobURLEntry.search.length !== 0) {
            return Promise.resolve(makeNetworkError("NetworkError when attempting to fetch resource."));
          }
          const blob = resolveObjectURL(blobURLEntry.toString());
          if (request.method !== "GET" || !webidl.is.Blob(blob)) {
            return Promise.resolve(makeNetworkError("invalid method"));
          }
          const response = makeResponse();
          const fullLength = blob.size;
          const serializedFullLength = isomorphicEncode(`${fullLength}`);
          const type = blob.type;
          if (!request.headersList.contains("range", true)) {
            const bodyWithType = extractBody(blob);
            response.statusText = "OK";
            response.body = bodyWithType[0];
            response.headersList.set("content-length", serializedFullLength, true);
            response.headersList.set("content-type", type, true);
          } else {
            response.rangeRequested = true;
            const rangeHeader = request.headersList.get("range", true);
            const rangeValue = simpleRangeHeaderValue(rangeHeader, true);
            if (rangeValue === "failure") {
              return Promise.resolve(makeNetworkError("failed to fetch the data URL"));
            }
            let { rangeStartValue: rangeStart, rangeEndValue: rangeEnd } = rangeValue;
            if (rangeStart === null) {
              rangeStart = fullLength - rangeEnd;
              rangeEnd = rangeStart + rangeEnd - 1;
            } else {
              if (rangeStart >= fullLength) {
                return Promise.resolve(makeNetworkError("Range start is greater than the blob's size."));
              }
              if (rangeEnd === null || rangeEnd >= fullLength) {
                rangeEnd = fullLength - 1;
              }
            }
            const slicedBlob = blob.slice(rangeStart, rangeEnd, type);
            const slicedBodyWithType = extractBody(slicedBlob);
            response.body = slicedBodyWithType[0];
            const serializedSlicedLength = isomorphicEncode(`${slicedBlob.size}`);
            const contentRange = buildContentRange(rangeStart, rangeEnd, fullLength);
            response.status = 206;
            response.statusText = "Partial Content";
            response.headersList.set("content-length", serializedSlicedLength, true);
            response.headersList.set("content-type", type, true);
            response.headersList.set("content-range", contentRange, true);
          }
          return Promise.resolve(response);
        }
        case "data:": {
          const currentURL = requestCurrentURL(request);
          const dataURLStruct = dataURLProcessor(currentURL);
          if (dataURLStruct === "failure") {
            return Promise.resolve(makeNetworkError("failed to fetch the data URL"));
          }
          const mimeType = serializeAMimeType(dataURLStruct.mimeType);
          return Promise.resolve(makeResponse({
            statusText: "OK",
            headersList: [
              ["content-type", { name: "Content-Type", value: mimeType }]
            ],
            body: safelyExtractBody(dataURLStruct.body)[0]
          }));
        }
        case "file:": {
          return Promise.resolve(makeNetworkError("not implemented... yet..."));
        }
        case "http:":
        case "https:": {
          return httpFetch(fetchParams).catch((err) => makeNetworkError(err));
        }
        default: {
          return Promise.resolve(makeNetworkError("unknown scheme"));
        }
      }
    }
    function finalizeResponse(fetchParams, response) {
      fetchParams.request.done = true;
      if (fetchParams.processResponseDone != null) {
        queueMicrotask(() => fetchParams.processResponseDone(response));
      }
    }
    function fetchFinale(fetchParams, response) {
      let timingInfo = fetchParams.timingInfo;
      const processResponseEndOfBody = () => {
        const unsafeEndTime = Date.now();
        if (fetchParams.request.destination === "document") {
          fetchParams.controller.fullTimingInfo = timingInfo;
        }
        fetchParams.controller.reportTimingSteps = () => {
          if (!urlIsHttpHttpsScheme(fetchParams.request.url)) {
            return;
          }
          timingInfo.endTime = unsafeEndTime;
          let cacheState = response.cacheState;
          const bodyInfo = response.bodyInfo;
          if (!response.timingAllowPassed) {
            timingInfo = createOpaqueTimingInfo(timingInfo);
            cacheState = "";
          }
          let responseStatus = 0;
          if (fetchParams.request.mode !== "navigator" || !response.hasCrossOriginRedirects) {
            responseStatus = response.status;
            const mimeType = extractMimeType(response.headersList);
            if (mimeType !== "failure") {
              bodyInfo.contentType = minimizeSupportedMimeType(mimeType);
            }
          }
          if (fetchParams.request.initiatorType != null) {
            markResourceTiming(timingInfo, fetchParams.request.url.href, fetchParams.request.initiatorType, globalThis, cacheState, bodyInfo, responseStatus);
          }
        };
        const processResponseEndOfBodyTask = () => {
          fetchParams.request.done = true;
          if (fetchParams.processResponseEndOfBody != null) {
            queueMicrotask(() => fetchParams.processResponseEndOfBody(response));
          }
          if (fetchParams.request.initiatorType != null) {
            fetchParams.controller.reportTimingSteps();
          }
        };
        queueMicrotask(() => processResponseEndOfBodyTask());
      };
      if (fetchParams.processResponse != null) {
        queueMicrotask(() => {
          fetchParams.processResponse(response);
          fetchParams.processResponse = null;
        });
      }
      const internalResponse = response.type === "error" ? response : response.internalResponse ?? response;
      if (internalResponse.body == null) {
        processResponseEndOfBody();
      } else {
        finished(internalResponse.body.stream, () => {
          processResponseEndOfBody();
        });
      }
    }
    async function httpFetch(fetchParams) {
      const request = fetchParams.request;
      let response = null;
      let actualResponse = null;
      const timingInfo = fetchParams.timingInfo;
      if (request.serviceWorkers === "all") {
      }
      if (response === null) {
        if (request.redirect === "follow") {
          request.serviceWorkers = "none";
        }
        actualResponse = response = await httpNetworkOrCacheFetch(fetchParams);
        if (request.responseTainting === "cors" && corsCheck(request, response) === "failure") {
          return makeNetworkError("cors failure");
        }
        if (TAOCheck(request, response) === "failure") {
          request.timingAllowFailed = true;
        }
      }
      if ((request.responseTainting === "opaque" || response.type === "opaque") && crossOriginResourcePolicyCheck(
        request.origin,
        request.client,
        request.destination,
        actualResponse
      ) === "blocked") {
        return makeNetworkError("blocked");
      }
      if (redirectStatusSet.has(actualResponse.status)) {
        if (request.redirect !== "manual") {
          fetchParams.controller.connection.destroy(void 0, false);
        }
        if (request.redirect === "error") {
          response = makeNetworkError("unexpected redirect");
        } else if (request.redirect === "manual") {
          response = actualResponse;
        } else if (request.redirect === "follow") {
          response = await httpRedirectFetch(fetchParams, response);
        } else {
          assert(false);
        }
      }
      response.timingInfo = timingInfo;
      return response;
    }
    function httpRedirectFetch(fetchParams, response) {
      const request = fetchParams.request;
      const actualResponse = response.internalResponse ? response.internalResponse : response;
      let locationURL;
      try {
        locationURL = responseLocationURL(
          actualResponse,
          requestCurrentURL(request).hash
        );
        if (locationURL == null) {
          return response;
        }
      } catch (err) {
        return Promise.resolve(makeNetworkError(err));
      }
      if (!urlIsHttpHttpsScheme(locationURL)) {
        return Promise.resolve(makeNetworkError("URL scheme must be a HTTP(S) scheme"));
      }
      if (request.redirectCount === 20) {
        return Promise.resolve(makeNetworkError("redirect count exceeded"));
      }
      request.redirectCount += 1;
      if (request.mode === "cors" && (locationURL.username || locationURL.password) && !sameOrigin(request, locationURL)) {
        return Promise.resolve(makeNetworkError('cross origin not allowed for request mode "cors"'));
      }
      if (request.responseTainting === "cors" && (locationURL.username || locationURL.password)) {
        return Promise.resolve(makeNetworkError(
          'URL cannot contain credentials for request mode "cors"'
        ));
      }
      if (actualResponse.status !== 303 && request.body != null && request.body.source == null) {
        return Promise.resolve(makeNetworkError());
      }
      if ([301, 302].includes(actualResponse.status) && request.method === "POST" || actualResponse.status === 303 && !GET_OR_HEAD.includes(request.method)) {
        request.method = "GET";
        request.body = null;
        for (const headerName of requestBodyHeader) {
          request.headersList.delete(headerName);
        }
      }
      if (!sameOrigin(requestCurrentURL(request), locationURL)) {
        request.headersList.delete("authorization", true);
        request.headersList.delete("proxy-authorization", true);
        request.headersList.delete("cookie", true);
        request.headersList.delete("host", true);
      }
      if (request.body != null) {
        assert(request.body.source != null);
        request.body = safelyExtractBody(request.body.source)[0];
      }
      const timingInfo = fetchParams.timingInfo;
      timingInfo.redirectEndTime = timingInfo.postRedirectStartTime = coarsenedSharedCurrentTime(fetchParams.crossOriginIsolatedCapability);
      if (timingInfo.redirectStartTime === 0) {
        timingInfo.redirectStartTime = timingInfo.startTime;
      }
      request.urlList.push(locationURL);
      setRequestReferrerPolicyOnRedirect(request, actualResponse);
      return mainFetch(fetchParams, true);
    }
    async function httpNetworkOrCacheFetch(fetchParams, isAuthenticationFetch = false, isNewConnectionFetch = false) {
      const request = fetchParams.request;
      let httpFetchParams = null;
      let httpRequest = null;
      let response = null;
      const httpCache = null;
      const revalidatingFlag = false;
      if (request.window === "no-window" && request.redirect === "error") {
        httpFetchParams = fetchParams;
        httpRequest = request;
      } else {
        httpRequest = cloneRequest(request);
        httpFetchParams = { ...fetchParams };
        httpFetchParams.request = httpRequest;
      }
      const includeCredentials = request.credentials === "include" || request.credentials === "same-origin" && request.responseTainting === "basic";
      const contentLength = httpRequest.body ? httpRequest.body.length : null;
      let contentLengthHeaderValue = null;
      if (httpRequest.body == null && ["POST", "PUT"].includes(httpRequest.method)) {
        contentLengthHeaderValue = "0";
      }
      if (contentLength != null) {
        contentLengthHeaderValue = isomorphicEncode(`${contentLength}`);
      }
      if (contentLengthHeaderValue != null) {
        httpRequest.headersList.append("content-length", contentLengthHeaderValue, true);
      }
      if (contentLength != null && httpRequest.keepalive) {
      }
      if (webidl.is.URL(httpRequest.referrer)) {
        httpRequest.headersList.append("referer", isomorphicEncode(httpRequest.referrer.href), true);
      }
      appendRequestOriginHeader(httpRequest);
      appendFetchMetadata(httpRequest);
      if (!httpRequest.headersList.contains("user-agent", true)) {
        httpRequest.headersList.append("user-agent", defaultUserAgent, true);
      }
      if (httpRequest.cache === "default" && (httpRequest.headersList.contains("if-modified-since", true) || httpRequest.headersList.contains("if-none-match", true) || httpRequest.headersList.contains("if-unmodified-since", true) || httpRequest.headersList.contains("if-match", true) || httpRequest.headersList.contains("if-range", true))) {
        httpRequest.cache = "no-store";
      }
      if (httpRequest.cache === "no-cache" && !httpRequest.preventNoCacheCacheControlHeaderModification && !httpRequest.headersList.contains("cache-control", true)) {
        httpRequest.headersList.append("cache-control", "max-age=0", true);
      }
      if (httpRequest.cache === "no-store" || httpRequest.cache === "reload") {
        if (!httpRequest.headersList.contains("pragma", true)) {
          httpRequest.headersList.append("pragma", "no-cache", true);
        }
        if (!httpRequest.headersList.contains("cache-control", true)) {
          httpRequest.headersList.append("cache-control", "no-cache", true);
        }
      }
      if (httpRequest.headersList.contains("range", true)) {
        httpRequest.headersList.append("accept-encoding", "identity", true);
      }
      if (!httpRequest.headersList.contains("accept-encoding", true)) {
        if (urlHasHttpsScheme(requestCurrentURL(httpRequest))) {
          httpRequest.headersList.append("accept-encoding", "br, gzip, deflate", true);
        } else {
          httpRequest.headersList.append("accept-encoding", "gzip, deflate", true);
        }
      }
      httpRequest.headersList.delete("host", true);
      if (includeCredentials) {
      }
      if (httpCache == null) {
        httpRequest.cache = "no-store";
      }
      if (httpRequest.cache !== "no-store" && httpRequest.cache !== "reload") {
      }
      if (response == null) {
        if (httpRequest.cache === "only-if-cached") {
          return makeNetworkError("only if cached");
        }
        const forwardResponse = await httpNetworkFetch(
          httpFetchParams,
          includeCredentials,
          isNewConnectionFetch
        );
        if (!safeMethodsSet.has(httpRequest.method) && forwardResponse.status >= 200 && forwardResponse.status <= 399) {
        }
        if (revalidatingFlag && forwardResponse.status === 304) {
        }
        if (response == null) {
          response = forwardResponse;
        }
      }
      response.urlList = [...httpRequest.urlList];
      if (httpRequest.headersList.contains("range", true)) {
        response.rangeRequested = true;
      }
      response.requestIncludesCredentials = includeCredentials;
      if (response.status === 407) {
        if (request.window === "no-window") {
          return makeNetworkError();
        }
        if (isCancelled(fetchParams)) {
          return makeAppropriateNetworkError(fetchParams);
        }
        return makeNetworkError("proxy authentication required");
      }
      if (
        // responses status is 421
        response.status === 421 && // isNewConnectionFetch is false
        !isNewConnectionFetch && // requests body is null, or requests body is non-null and requests bodys source is non-null
        (request.body == null || request.body.source != null)
      ) {
        if (isCancelled(fetchParams)) {
          return makeAppropriateNetworkError(fetchParams);
        }
        fetchParams.controller.connection.destroy();
        response = await httpNetworkOrCacheFetch(
          fetchParams,
          isAuthenticationFetch,
          true
        );
      }
      if (isAuthenticationFetch) {
      }
      return response;
    }
    async function httpNetworkFetch(fetchParams, includeCredentials = false, forceNewConnection = false) {
      assert(!fetchParams.controller.connection || fetchParams.controller.connection.destroyed);
      fetchParams.controller.connection = {
        abort: null,
        destroyed: false,
        destroy(err, abort = true) {
          if (!this.destroyed) {
            this.destroyed = true;
            if (abort) {
              this.abort?.(err ?? new DOMException("The operation was aborted.", "AbortError"));
            }
          }
        }
      };
      const request = fetchParams.request;
      let response = null;
      const timingInfo = fetchParams.timingInfo;
      const httpCache = null;
      if (httpCache == null) {
        request.cache = "no-store";
      }
      const newConnection = forceNewConnection ? "yes" : "no";
      if (request.mode === "websocket") {
      } else {
      }
      let requestBody = null;
      if (request.body == null && fetchParams.processRequestEndOfBody) {
        queueMicrotask(() => fetchParams.processRequestEndOfBody());
      } else if (request.body != null) {
        const processBodyChunk = async function* (bytes) {
          if (isCancelled(fetchParams)) {
            return;
          }
          yield bytes;
          fetchParams.processRequestBodyChunkLength?.(bytes.byteLength);
        };
        const processEndOfBody = () => {
          if (isCancelled(fetchParams)) {
            return;
          }
          if (fetchParams.processRequestEndOfBody) {
            fetchParams.processRequestEndOfBody();
          }
        };
        const processBodyError = (e) => {
          if (isCancelled(fetchParams)) {
            return;
          }
          if (e.name === "AbortError") {
            fetchParams.controller.abort();
          } else {
            fetchParams.controller.terminate(e);
          }
        };
        requestBody = async function* () {
          try {
            for await (const bytes of request.body.stream) {
              yield* processBodyChunk(bytes);
            }
            processEndOfBody();
          } catch (err) {
            processBodyError(err);
          }
        }();
      }
      try {
        const { body, status, statusText, headersList, socket } = await dispatch({ body: requestBody });
        if (socket) {
          response = makeResponse({ status, statusText, headersList, socket });
        } else {
          const iterator = body[Symbol.asyncIterator]();
          fetchParams.controller.next = () => iterator.next();
          response = makeResponse({ status, statusText, headersList });
        }
      } catch (err) {
        if (err.name === "AbortError") {
          fetchParams.controller.connection.destroy();
          return makeAppropriateNetworkError(fetchParams, err);
        }
        return makeNetworkError(err);
      }
      const pullAlgorithm = () => {
        return fetchParams.controller.resume();
      };
      const cancelAlgorithm = (reason) => {
        if (!isCancelled(fetchParams)) {
          fetchParams.controller.abort(reason);
        }
      };
      const stream = new ReadableStream(
        {
          start(controller) {
            fetchParams.controller.controller = controller;
          },
          pull: pullAlgorithm,
          cancel: cancelAlgorithm,
          type: "bytes"
        }
      );
      response.body = { stream, source: null, length: null };
      if (!fetchParams.controller.resume) {
        fetchParams.controller.on("terminated", onAborted);
      }
      fetchParams.controller.resume = async () => {
        while (true) {
          let bytes;
          let isFailure;
          try {
            const { done, value } = await fetchParams.controller.next();
            if (isAborted(fetchParams)) {
              break;
            }
            bytes = done ? void 0 : value;
          } catch (err) {
            if (fetchParams.controller.ended && !timingInfo.encodedBodySize) {
              bytes = void 0;
            } else {
              bytes = err;
              isFailure = true;
            }
          }
          if (bytes === void 0) {
            readableStreamClose(fetchParams.controller.controller);
            finalizeResponse(fetchParams, response);
            return;
          }
          timingInfo.decodedBodySize += bytes?.byteLength ?? 0;
          if (isFailure) {
            fetchParams.controller.terminate(bytes);
            return;
          }
          const buffer = new Uint8Array(bytes);
          if (buffer.byteLength) {
            fetchParams.controller.controller.enqueue(buffer);
          }
          if (isErrored(stream)) {
            fetchParams.controller.terminate();
            return;
          }
          if (fetchParams.controller.controller.desiredSize <= 0) {
            return;
          }
        }
      };
      function onAborted(reason) {
        if (isAborted(fetchParams)) {
          response.aborted = true;
          if (isReadable(stream)) {
            fetchParams.controller.controller.error(
              fetchParams.controller.serializedAbortReason
            );
          }
        } else {
          if (isReadable(stream)) {
            fetchParams.controller.controller.error(new TypeError("terminated", {
              cause: isErrorLike(reason) ? reason : void 0
            }));
          }
        }
        fetchParams.controller.connection.destroy();
      }
      return response;
      function dispatch({ body }) {
        const url = requestCurrentURL(request);
        const agent = fetchParams.controller.dispatcher;
        return new Promise((resolve, reject) => agent.dispatch(
          {
            path: url.pathname + url.search,
            origin: url.origin,
            method: request.method,
            body: agent.isMockActive ? request.body && (request.body.source || request.body.stream) : body,
            headers: request.headersList.entries,
            maxRedirections: 0,
            upgrade: request.mode === "websocket" ? "websocket" : void 0
          },
          {
            body: null,
            abort: null,
            onConnect(abort) {
              const { connection } = fetchParams.controller;
              timingInfo.finalConnectionTimingInfo = clampAndCoarsenConnectionTimingInfo(void 0, timingInfo.postRedirectStartTime, fetchParams.crossOriginIsolatedCapability);
              if (connection.destroyed) {
                abort(new DOMException("The operation was aborted.", "AbortError"));
              } else {
                fetchParams.controller.on("terminated", abort);
                this.abort = connection.abort = abort;
              }
              timingInfo.finalNetworkRequestStartTime = coarsenedSharedCurrentTime(fetchParams.crossOriginIsolatedCapability);
            },
            onResponseStarted() {
              timingInfo.finalNetworkResponseStartTime = coarsenedSharedCurrentTime(fetchParams.crossOriginIsolatedCapability);
            },
            onHeaders(status, rawHeaders, resume, statusText) {
              if (status < 200) {
                return false;
              }
              let codings = [];
              const headersList = new HeadersList();
              for (let i = 0; i < rawHeaders.length; i += 2) {
                headersList.append(bufferToLowerCasedHeaderName(rawHeaders[i]), rawHeaders[i + 1].toString("latin1"), true);
              }
              const contentEncoding = headersList.get("content-encoding", true);
              if (contentEncoding) {
                codings = contentEncoding.toLowerCase().split(",").map((x) => x.trim());
              }
              const location = headersList.get("location", true);
              this.body = new Readable({ read: resume });
              const decoders = [];
              const willFollow = location && request.redirect === "follow" && redirectStatusSet.has(status);
              if (codings.length !== 0 && request.method !== "HEAD" && request.method !== "CONNECT" && !nullBodyStatus.includes(status) && !willFollow) {
                for (let i = codings.length - 1; i >= 0; --i) {
                  const coding = codings[i];
                  if (coding === "x-gzip" || coding === "gzip") {
                    decoders.push(zlib.createGunzip({
                      // Be less strict when decoding compressed responses, since sometimes
                      // servers send slightly invalid responses that are still accepted
                      // by common browsers.
                      // Always using Z_SYNC_FLUSH is what cURL does.
                      flush: zlib.constants.Z_SYNC_FLUSH,
                      finishFlush: zlib.constants.Z_SYNC_FLUSH
                    }));
                  } else if (coding === "deflate") {
                    decoders.push(createInflate({
                      flush: zlib.constants.Z_SYNC_FLUSH,
                      finishFlush: zlib.constants.Z_SYNC_FLUSH
                    }));
                  } else if (coding === "br") {
                    decoders.push(zlib.createBrotliDecompress({
                      flush: zlib.constants.BROTLI_OPERATION_FLUSH,
                      finishFlush: zlib.constants.BROTLI_OPERATION_FLUSH
                    }));
                  } else if (coding === "zstd" && typeof zlib.createZstdDecompress === "function") {
                    decoders.push(zlib.createZstdDecompress({
                      flush: zlib.constants.ZSTD_e_continue,
                      finishFlush: zlib.constants.ZSTD_e_end
                    }));
                  } else {
                    decoders.length = 0;
                    break;
                  }
                }
              }
              const onError = this.onError.bind(this);
              resolve({
                status,
                statusText,
                headersList,
                body: decoders.length ? pipeline(this.body, ...decoders, (err) => {
                  if (err) {
                    this.onError(err);
                  }
                }).on("error", onError) : this.body.on("error", onError)
              });
              return true;
            },
            onData(chunk) {
              if (fetchParams.controller.dump) {
                return;
              }
              const bytes = chunk;
              timingInfo.encodedBodySize += bytes.byteLength;
              return this.body.push(bytes);
            },
            onComplete() {
              if (this.abort) {
                fetchParams.controller.off("terminated", this.abort);
              }
              fetchParams.controller.ended = true;
              this.body.push(null);
            },
            onError(error) {
              if (this.abort) {
                fetchParams.controller.off("terminated", this.abort);
              }
              this.body?.destroy(error);
              fetchParams.controller.terminate(error);
              reject(error);
            },
            onUpgrade(status, rawHeaders, socket) {
              if (status !== 101) {
                return;
              }
              const headersList = new HeadersList();
              for (let i = 0; i < rawHeaders.length; i += 2) {
                headersList.append(bufferToLowerCasedHeaderName(rawHeaders[i]), rawHeaders[i + 1].toString("latin1"), true);
              }
              resolve({
                status,
                statusText: STATUS_CODES[status],
                headersList,
                socket
              });
              return true;
            }
          }
        ));
      }
    }
    module2.exports = {
      fetch: fetch2,
      Fetch,
      fetching,
      finalizeAndReportTiming
    };
  }
});

// node_modules/undici/lib/web/cache/util.js
var require_util6 = __commonJS({
  "node_modules/undici/lib/web/cache/util.js"(exports2, module2) {
    "use strict";
    var assert = require("node:assert");
    var { URLSerializer } = require_data_url();
    var { isValidHeaderName } = require_util5();
    function urlEquals(A, B, excludeFragment = false) {
      const serializedA = URLSerializer(A, excludeFragment);
      const serializedB = URLSerializer(B, excludeFragment);
      return serializedA === serializedB;
    }
    function getFieldValues(header) {
      assert(header !== null);
      const values = [];
      for (let value of header.split(",")) {
        value = value.trim();
        if (isValidHeaderName(value)) {
          values.push(value);
        }
      }
      return values;
    }
    module2.exports = {
      urlEquals,
      getFieldValues
    };
  }
});

// node_modules/undici/lib/web/cache/cache.js
var require_cache3 = __commonJS({
  "node_modules/undici/lib/web/cache/cache.js"(exports2, module2) {
    "use strict";
    var assert = require("node:assert");
    var { kConstruct } = require_symbols4();
    var { urlEquals, getFieldValues } = require_util6();
    var { kEnumerableProperty, isDisturbed } = require_util4();
    var { webidl } = require_webidl();
    var { cloneResponse, fromInnerResponse, getResponseState } = require_response2();
    var { Request, fromInnerRequest, getRequestState } = require_request4();
    var { fetching } = require_fetch();
    var { urlIsHttpHttpsScheme, readAllBytes } = require_util5();
    var { createDeferredPromise } = require_promise();
    var Cache = class _Cache {
      /**
       * @see https://w3c.github.io/ServiceWorker/#dfn-relevant-request-response-list
       * @type {requestResponseList}
       */
      #relevantRequestResponseList;
      constructor() {
        if (arguments[0] !== kConstruct) {
          webidl.illegalConstructor();
        }
        webidl.util.markAsUncloneable(this);
        this.#relevantRequestResponseList = arguments[1];
      }
      async match(request, options = {}) {
        webidl.brandCheck(this, _Cache);
        const prefix = "Cache.match";
        webidl.argumentLengthCheck(arguments, 1, prefix);
        request = webidl.converters.RequestInfo(request);
        options = webidl.converters.CacheQueryOptions(options, prefix, "options");
        const p = this.#internalMatchAll(request, options, 1);
        if (p.length === 0) {
          return;
        }
        return p[0];
      }
      async matchAll(request = void 0, options = {}) {
        webidl.brandCheck(this, _Cache);
        const prefix = "Cache.matchAll";
        if (request !== void 0) request = webidl.converters.RequestInfo(request);
        options = webidl.converters.CacheQueryOptions(options, prefix, "options");
        return this.#internalMatchAll(request, options);
      }
      async add(request) {
        webidl.brandCheck(this, _Cache);
        const prefix = "Cache.add";
        webidl.argumentLengthCheck(arguments, 1, prefix);
        request = webidl.converters.RequestInfo(request);
        const requests = [request];
        const responseArrayPromise = this.addAll(requests);
        return await responseArrayPromise;
      }
      async addAll(requests) {
        webidl.brandCheck(this, _Cache);
        const prefix = "Cache.addAll";
        webidl.argumentLengthCheck(arguments, 1, prefix);
        const responsePromises = [];
        const requestList = [];
        for (let request of requests) {
          if (request === void 0) {
            throw webidl.errors.conversionFailed({
              prefix,
              argument: "Argument 1",
              types: ["undefined is not allowed"]
            });
          }
          request = webidl.converters.RequestInfo(request);
          if (typeof request === "string") {
            continue;
          }
          const r = getRequestState(request);
          if (!urlIsHttpHttpsScheme(r.url) || r.method !== "GET") {
            throw webidl.errors.exception({
              header: prefix,
              message: "Expected http/s scheme when method is not GET."
            });
          }
        }
        const fetchControllers = [];
        for (const request of requests) {
          const r = getRequestState(new Request(request));
          if (!urlIsHttpHttpsScheme(r.url)) {
            throw webidl.errors.exception({
              header: prefix,
              message: "Expected http/s scheme."
            });
          }
          r.initiator = "fetch";
          r.destination = "subresource";
          requestList.push(r);
          const responsePromise = createDeferredPromise();
          fetchControllers.push(fetching({
            request: r,
            processResponse(response) {
              if (response.type === "error" || response.status === 206 || response.status < 200 || response.status > 299) {
                responsePromise.reject(webidl.errors.exception({
                  header: "Cache.addAll",
                  message: "Received an invalid status code or the request failed."
                }));
              } else if (response.headersList.contains("vary")) {
                const fieldValues = getFieldValues(response.headersList.get("vary"));
                for (const fieldValue of fieldValues) {
                  if (fieldValue === "*") {
                    responsePromise.reject(webidl.errors.exception({
                      header: "Cache.addAll",
                      message: "invalid vary field value"
                    }));
                    for (const controller of fetchControllers) {
                      controller.abort();
                    }
                    return;
                  }
                }
              }
            },
            processResponseEndOfBody(response) {
              if (response.aborted) {
                responsePromise.reject(new DOMException("aborted", "AbortError"));
                return;
              }
              responsePromise.resolve(response);
            }
          }));
          responsePromises.push(responsePromise.promise);
        }
        const p = Promise.all(responsePromises);
        const responses = await p;
        const operations = [];
        let index = 0;
        for (const response of responses) {
          const operation = {
            type: "put",
            // 7.3.2
            request: requestList[index],
            // 7.3.3
            response
            // 7.3.4
          };
          operations.push(operation);
          index++;
        }
        const cacheJobPromise = createDeferredPromise();
        let errorData = null;
        try {
          this.#batchCacheOperations(operations);
        } catch (e) {
          errorData = e;
        }
        queueMicrotask(() => {
          if (errorData === null) {
            cacheJobPromise.resolve(void 0);
          } else {
            cacheJobPromise.reject(errorData);
          }
        });
        return cacheJobPromise.promise;
      }
      async put(request, response) {
        webidl.brandCheck(this, _Cache);
        const prefix = "Cache.put";
        webidl.argumentLengthCheck(arguments, 2, prefix);
        request = webidl.converters.RequestInfo(request);
        response = webidl.converters.Response(response, prefix, "response");
        let innerRequest = null;
        if (webidl.is.Request(request)) {
          innerRequest = getRequestState(request);
        } else {
          innerRequest = getRequestState(new Request(request));
        }
        if (!urlIsHttpHttpsScheme(innerRequest.url) || innerRequest.method !== "GET") {
          throw webidl.errors.exception({
            header: prefix,
            message: "Expected an http/s scheme when method is not GET"
          });
        }
        const innerResponse = getResponseState(response);
        if (innerResponse.status === 206) {
          throw webidl.errors.exception({
            header: prefix,
            message: "Got 206 status"
          });
        }
        if (innerResponse.headersList.contains("vary")) {
          const fieldValues = getFieldValues(innerResponse.headersList.get("vary"));
          for (const fieldValue of fieldValues) {
            if (fieldValue === "*") {
              throw webidl.errors.exception({
                header: prefix,
                message: "Got * vary field value"
              });
            }
          }
        }
        if (innerResponse.body && (isDisturbed(innerResponse.body.stream) || innerResponse.body.stream.locked)) {
          throw webidl.errors.exception({
            header: prefix,
            message: "Response body is locked or disturbed"
          });
        }
        const clonedResponse = cloneResponse(innerResponse);
        const bodyReadPromise = createDeferredPromise();
        if (innerResponse.body != null) {
          const stream = innerResponse.body.stream;
          const reader = stream.getReader();
          readAllBytes(reader, bodyReadPromise.resolve, bodyReadPromise.reject);
        } else {
          bodyReadPromise.resolve(void 0);
        }
        const operations = [];
        const operation = {
          type: "put",
          // 14.
          request: innerRequest,
          // 15.
          response: clonedResponse
          // 16.
        };
        operations.push(operation);
        const bytes = await bodyReadPromise.promise;
        if (clonedResponse.body != null) {
          clonedResponse.body.source = bytes;
        }
        const cacheJobPromise = createDeferredPromise();
        let errorData = null;
        try {
          this.#batchCacheOperations(operations);
        } catch (e) {
          errorData = e;
        }
        queueMicrotask(() => {
          if (errorData === null) {
            cacheJobPromise.resolve();
          } else {
            cacheJobPromise.reject(errorData);
          }
        });
        return cacheJobPromise.promise;
      }
      async delete(request, options = {}) {
        webidl.brandCheck(this, _Cache);
        const prefix = "Cache.delete";
        webidl.argumentLengthCheck(arguments, 1, prefix);
        request = webidl.converters.RequestInfo(request);
        options = webidl.converters.CacheQueryOptions(options, prefix, "options");
        let r = null;
        if (webidl.is.Request(request)) {
          r = getRequestState(request);
          if (r.method !== "GET" && !options.ignoreMethod) {
            return false;
          }
        } else {
          assert(typeof request === "string");
          r = getRequestState(new Request(request));
        }
        const operations = [];
        const operation = {
          type: "delete",
          request: r,
          options
        };
        operations.push(operation);
        const cacheJobPromise = createDeferredPromise();
        let errorData = null;
        let requestResponses;
        try {
          requestResponses = this.#batchCacheOperations(operations);
        } catch (e) {
          errorData = e;
        }
        queueMicrotask(() => {
          if (errorData === null) {
            cacheJobPromise.resolve(!!requestResponses?.length);
          } else {
            cacheJobPromise.reject(errorData);
          }
        });
        return cacheJobPromise.promise;
      }
      /**
       * @see https://w3c.github.io/ServiceWorker/#dom-cache-keys
       * @param {any} request
       * @param {import('../../types/cache').CacheQueryOptions} options
       * @returns {Promise<readonly Request[]>}
       */
      async keys(request = void 0, options = {}) {
        webidl.brandCheck(this, _Cache);
        const prefix = "Cache.keys";
        if (request !== void 0) request = webidl.converters.RequestInfo(request);
        options = webidl.converters.CacheQueryOptions(options, prefix, "options");
        let r = null;
        if (request !== void 0) {
          if (webidl.is.Request(request)) {
            r = getRequestState(request);
            if (r.method !== "GET" && !options.ignoreMethod) {
              return [];
            }
          } else if (typeof request === "string") {
            r = getRequestState(new Request(request));
          }
        }
        const promise = createDeferredPromise();
        const requests = [];
        if (request === void 0) {
          for (const requestResponse of this.#relevantRequestResponseList) {
            requests.push(requestResponse[0]);
          }
        } else {
          const requestResponses = this.#queryCache(r, options);
          for (const requestResponse of requestResponses) {
            requests.push(requestResponse[0]);
          }
        }
        queueMicrotask(() => {
          const requestList = [];
          for (const request2 of requests) {
            const requestObject = fromInnerRequest(
              request2,
              void 0,
              new AbortController().signal,
              "immutable"
            );
            requestList.push(requestObject);
          }
          promise.resolve(Object.freeze(requestList));
        });
        return promise.promise;
      }
      /**
       * @see https://w3c.github.io/ServiceWorker/#batch-cache-operations-algorithm
       * @param {CacheBatchOperation[]} operations
       * @returns {requestResponseList}
       */
      #batchCacheOperations(operations) {
        const cache = this.#relevantRequestResponseList;
        const backupCache = [...cache];
        const addedItems = [];
        const resultList = [];
        try {
          for (const operation of operations) {
            if (operation.type !== "delete" && operation.type !== "put") {
              throw webidl.errors.exception({
                header: "Cache.#batchCacheOperations",
                message: 'operation type does not match "delete" or "put"'
              });
            }
            if (operation.type === "delete" && operation.response != null) {
              throw webidl.errors.exception({
                header: "Cache.#batchCacheOperations",
                message: "delete operation should not have an associated response"
              });
            }
            if (this.#queryCache(operation.request, operation.options, addedItems).length) {
              throw new DOMException("???", "InvalidStateError");
            }
            let requestResponses;
            if (operation.type === "delete") {
              requestResponses = this.#queryCache(operation.request, operation.options);
              if (requestResponses.length === 0) {
                return [];
              }
              for (const requestResponse of requestResponses) {
                const idx = cache.indexOf(requestResponse);
                assert(idx !== -1);
                cache.splice(idx, 1);
              }
            } else if (operation.type === "put") {
              if (operation.response == null) {
                throw webidl.errors.exception({
                  header: "Cache.#batchCacheOperations",
                  message: "put operation should have an associated response"
                });
              }
              const r = operation.request;
              if (!urlIsHttpHttpsScheme(r.url)) {
                throw webidl.errors.exception({
                  header: "Cache.#batchCacheOperations",
                  message: "expected http or https scheme"
                });
              }
              if (r.method !== "GET") {
                throw webidl.errors.exception({
                  header: "Cache.#batchCacheOperations",
                  message: "not get method"
                });
              }
              if (operation.options != null) {
                throw webidl.errors.exception({
                  header: "Cache.#batchCacheOperations",
                  message: "options must not be defined"
                });
              }
              requestResponses = this.#queryCache(operation.request);
              for (const requestResponse of requestResponses) {
                const idx = cache.indexOf(requestResponse);
                assert(idx !== -1);
                cache.splice(idx, 1);
              }
              cache.push([operation.request, operation.response]);
              addedItems.push([operation.request, operation.response]);
            }
            resultList.push([operation.request, operation.response]);
          }
          return resultList;
        } catch (e) {
          this.#relevantRequestResponseList.length = 0;
          this.#relevantRequestResponseList = backupCache;
          throw e;
        }
      }
      /**
       * @see https://w3c.github.io/ServiceWorker/#query-cache
       * @param {any} requestQuery
       * @param {import('../../types/cache').CacheQueryOptions} options
       * @param {requestResponseList} targetStorage
       * @returns {requestResponseList}
       */
      #queryCache(requestQuery, options, targetStorage) {
        const resultList = [];
        const storage = targetStorage ?? this.#relevantRequestResponseList;
        for (const requestResponse of storage) {
          const [cachedRequest, cachedResponse] = requestResponse;
          if (this.#requestMatchesCachedItem(requestQuery, cachedRequest, cachedResponse, options)) {
            resultList.push(requestResponse);
          }
        }
        return resultList;
      }
      /**
       * @see https://w3c.github.io/ServiceWorker/#request-matches-cached-item-algorithm
       * @param {any} requestQuery
       * @param {any} request
       * @param {any | null} response
       * @param {import('../../types/cache').CacheQueryOptions | undefined} options
       * @returns {boolean}
       */
      #requestMatchesCachedItem(requestQuery, request, response = null, options) {
        const queryURL = new URL(requestQuery.url);
        const cachedURL = new URL(request.url);
        if (options?.ignoreSearch) {
          cachedURL.search = "";
          queryURL.search = "";
        }
        if (!urlEquals(queryURL, cachedURL, true)) {
          return false;
        }
        if (response == null || options?.ignoreVary || !response.headersList.contains("vary")) {
          return true;
        }
        const fieldValues = getFieldValues(response.headersList.get("vary"));
        for (const fieldValue of fieldValues) {
          if (fieldValue === "*") {
            return false;
          }
          const requestValue = request.headersList.get(fieldValue);
          const queryValue = requestQuery.headersList.get(fieldValue);
          if (requestValue !== queryValue) {
            return false;
          }
        }
        return true;
      }
      #internalMatchAll(request, options, maxResponses = Infinity) {
        let r = null;
        if (request !== void 0) {
          if (webidl.is.Request(request)) {
            r = getRequestState(request);
            if (r.method !== "GET" && !options.ignoreMethod) {
              return [];
            }
          } else if (typeof request === "string") {
            r = getRequestState(new Request(request));
          }
        }
        const responses = [];
        if (request === void 0) {
          for (const requestResponse of this.#relevantRequestResponseList) {
            responses.push(requestResponse[1]);
          }
        } else {
          const requestResponses = this.#queryCache(r, options);
          for (const requestResponse of requestResponses) {
            responses.push(requestResponse[1]);
          }
        }
        const responseList = [];
        for (const response of responses) {
          const responseObject = fromInnerResponse(response, "immutable");
          responseList.push(responseObject.clone());
          if (responseList.length >= maxResponses) {
            break;
          }
        }
        return Object.freeze(responseList);
      }
    };
    Object.defineProperties(Cache.prototype, {
      [Symbol.toStringTag]: {
        value: "Cache",
        configurable: true
      },
      match: kEnumerableProperty,
      matchAll: kEnumerableProperty,
      add: kEnumerableProperty,
      addAll: kEnumerableProperty,
      put: kEnumerableProperty,
      delete: kEnumerableProperty,
      keys: kEnumerableProperty
    });
    var cacheQueryOptionConverters = [
      {
        key: "ignoreSearch",
        converter: webidl.converters.boolean,
        defaultValue: () => false
      },
      {
        key: "ignoreMethod",
        converter: webidl.converters.boolean,
        defaultValue: () => false
      },
      {
        key: "ignoreVary",
        converter: webidl.converters.boolean,
        defaultValue: () => false
      }
    ];
    webidl.converters.CacheQueryOptions = webidl.dictionaryConverter(cacheQueryOptionConverters);
    webidl.converters.MultiCacheQueryOptions = webidl.dictionaryConverter([
      ...cacheQueryOptionConverters,
      {
        key: "cacheName",
        converter: webidl.converters.DOMString
      }
    ]);
    webidl.converters.Response = webidl.interfaceConverter(
      webidl.is.Response,
      "Response"
    );
    webidl.converters["sequence<RequestInfo>"] = webidl.sequenceConverter(
      webidl.converters.RequestInfo
    );
    module2.exports = {
      Cache
    };
  }
});

// node_modules/undici/lib/web/cache/cachestorage.js
var require_cachestorage = __commonJS({
  "node_modules/undici/lib/web/cache/cachestorage.js"(exports2, module2) {
    "use strict";
    var { Cache } = require_cache3();
    var { webidl } = require_webidl();
    var { kEnumerableProperty } = require_util4();
    var { kConstruct } = require_symbols4();
    var CacheStorage = class _CacheStorage {
      /**
       * @see https://w3c.github.io/ServiceWorker/#dfn-relevant-name-to-cache-map
       * @type {Map<string, import('./cache').requestResponseList}
       */
      #caches = /* @__PURE__ */ new Map();
      constructor() {
        if (arguments[0] !== kConstruct) {
          webidl.illegalConstructor();
        }
        webidl.util.markAsUncloneable(this);
      }
      async match(request, options = {}) {
        webidl.brandCheck(this, _CacheStorage);
        webidl.argumentLengthCheck(arguments, 1, "CacheStorage.match");
        request = webidl.converters.RequestInfo(request);
        options = webidl.converters.MultiCacheQueryOptions(options);
        if (options.cacheName != null) {
          if (this.#caches.has(options.cacheName)) {
            const cacheList = this.#caches.get(options.cacheName);
            const cache = new Cache(kConstruct, cacheList);
            return await cache.match(request, options);
          }
        } else {
          for (const cacheList of this.#caches.values()) {
            const cache = new Cache(kConstruct, cacheList);
            const response = await cache.match(request, options);
            if (response !== void 0) {
              return response;
            }
          }
        }
      }
      /**
       * @see https://w3c.github.io/ServiceWorker/#cache-storage-has
       * @param {string} cacheName
       * @returns {Promise<boolean>}
       */
      async has(cacheName) {
        webidl.brandCheck(this, _CacheStorage);
        const prefix = "CacheStorage.has";
        webidl.argumentLengthCheck(arguments, 1, prefix);
        cacheName = webidl.converters.DOMString(cacheName, prefix, "cacheName");
        return this.#caches.has(cacheName);
      }
      /**
       * @see https://w3c.github.io/ServiceWorker/#dom-cachestorage-open
       * @param {string} cacheName
       * @returns {Promise<Cache>}
       */
      async open(cacheName) {
        webidl.brandCheck(this, _CacheStorage);
        const prefix = "CacheStorage.open";
        webidl.argumentLengthCheck(arguments, 1, prefix);
        cacheName = webidl.converters.DOMString(cacheName, prefix, "cacheName");
        if (this.#caches.has(cacheName)) {
          const cache2 = this.#caches.get(cacheName);
          return new Cache(kConstruct, cache2);
        }
        const cache = [];
        this.#caches.set(cacheName, cache);
        return new Cache(kConstruct, cache);
      }
      /**
       * @see https://w3c.github.io/ServiceWorker/#cache-storage-delete
       * @param {string} cacheName
       * @returns {Promise<boolean>}
       */
      async delete(cacheName) {
        webidl.brandCheck(this, _CacheStorage);
        const prefix = "CacheStorage.delete";
        webidl.argumentLengthCheck(arguments, 1, prefix);
        cacheName = webidl.converters.DOMString(cacheName, prefix, "cacheName");
        return this.#caches.delete(cacheName);
      }
      /**
       * @see https://w3c.github.io/ServiceWorker/#cache-storage-keys
       * @returns {Promise<string[]>}
       */
      async keys() {
        webidl.brandCheck(this, _CacheStorage);
        const keys = this.#caches.keys();
        return [...keys];
      }
    };
    Object.defineProperties(CacheStorage.prototype, {
      [Symbol.toStringTag]: {
        value: "CacheStorage",
        configurable: true
      },
      match: kEnumerableProperty,
      has: kEnumerableProperty,
      open: kEnumerableProperty,
      delete: kEnumerableProperty,
      keys: kEnumerableProperty
    });
    module2.exports = {
      CacheStorage
    };
  }
});

// node_modules/undici/lib/web/cookies/constants.js
var require_constants6 = __commonJS({
  "node_modules/undici/lib/web/cookies/constants.js"(exports2, module2) {
    "use strict";
    var maxAttributeValueSize = 1024;
    var maxNameValuePairSize = 4096;
    module2.exports = {
      maxAttributeValueSize,
      maxNameValuePairSize
    };
  }
});

// node_modules/undici/lib/web/cookies/util.js
var require_util7 = __commonJS({
  "node_modules/undici/lib/web/cookies/util.js"(exports2, module2) {
    "use strict";
    function isCTLExcludingHtab(value) {
      for (let i = 0; i < value.length; ++i) {
        const code = value.charCodeAt(i);
        if (code >= 0 && code <= 8 || code >= 10 && code <= 31 || code === 127) {
          return true;
        }
      }
      return false;
    }
    function validateCookieName(name) {
      for (let i = 0; i < name.length; ++i) {
        const code = name.charCodeAt(i);
        if (code < 33 || // exclude CTLs (0-31), SP and HT
        code > 126 || // exclude non-ascii and DEL
        code === 34 || // "
        code === 40 || // (
        code === 41 || // )
        code === 60 || // <
        code === 62 || // >
        code === 64 || // @
        code === 44 || // ,
        code === 59 || // ;
        code === 58 || // :
        code === 92 || // \
        code === 47 || // /
        code === 91 || // [
        code === 93 || // ]
        code === 63 || // ?
        code === 61 || // =
        code === 123 || // {
        code === 125) {
          throw new Error("Invalid cookie name");
        }
      }
    }
    function validateCookieValue(value) {
      let len = value.length;
      let i = 0;
      if (value[0] === '"') {
        if (len === 1 || value[len - 1] !== '"') {
          throw new Error("Invalid cookie value");
        }
        --len;
        ++i;
      }
      while (i < len) {
        const code = value.charCodeAt(i++);
        if (code < 33 || // exclude CTLs (0-31)
        code > 126 || // non-ascii and DEL (127)
        code === 34 || // "
        code === 44 || // ,
        code === 59 || // ;
        code === 92) {
          throw new Error("Invalid cookie value");
        }
      }
    }
    function validateCookiePath(path4) {
      for (let i = 0; i < path4.length; ++i) {
        const code = path4.charCodeAt(i);
        if (code < 32 || // exclude CTLs (0-31)
        code === 127 || // DEL
        code === 59) {
          throw new Error("Invalid cookie path");
        }
      }
    }
    function validateCookieDomain(domain) {
      if (domain.startsWith("-") || domain.endsWith(".") || domain.endsWith("-")) {
        throw new Error("Invalid cookie domain");
      }
    }
    var IMFDays = [
      "Sun",
      "Mon",
      "Tue",
      "Wed",
      "Thu",
      "Fri",
      "Sat"
    ];
    var IMFMonths = [
      "Jan",
      "Feb",
      "Mar",
      "Apr",
      "May",
      "Jun",
      "Jul",
      "Aug",
      "Sep",
      "Oct",
      "Nov",
      "Dec"
    ];
    var IMFPaddedNumbers = Array(61).fill(0).map((_, i) => i.toString().padStart(2, "0"));
    function toIMFDate(date) {
      if (typeof date === "number") {
        date = new Date(date);
      }
      return `${IMFDays[date.getUTCDay()]}, ${IMFPaddedNumbers[date.getUTCDate()]} ${IMFMonths[date.getUTCMonth()]} ${date.getUTCFullYear()} ${IMFPaddedNumbers[date.getUTCHours()]}:${IMFPaddedNumbers[date.getUTCMinutes()]}:${IMFPaddedNumbers[date.getUTCSeconds()]} GMT`;
    }
    function validateCookieMaxAge(maxAge) {
      if (maxAge < 0) {
        throw new Error("Invalid cookie max-age");
      }
    }
    function stringify(cookie) {
      if (cookie.name.length === 0) {
        return null;
      }
      validateCookieName(cookie.name);
      validateCookieValue(cookie.value);
      const out = [`${cookie.name}=${cookie.value}`];
      if (cookie.name.startsWith("__Secure-")) {
        cookie.secure = true;
      }
      if (cookie.name.startsWith("__Host-")) {
        cookie.secure = true;
        cookie.domain = null;
        cookie.path = "/";
      }
      if (cookie.secure) {
        out.push("Secure");
      }
      if (cookie.httpOnly) {
        out.push("HttpOnly");
      }
      if (typeof cookie.maxAge === "number") {
        validateCookieMaxAge(cookie.maxAge);
        out.push(`Max-Age=${cookie.maxAge}`);
      }
      if (cookie.domain) {
        validateCookieDomain(cookie.domain);
        out.push(`Domain=${cookie.domain}`);
      }
      if (cookie.path) {
        validateCookiePath(cookie.path);
        out.push(`Path=${cookie.path}`);
      }
      if (cookie.expires && cookie.expires.toString() !== "Invalid Date") {
        out.push(`Expires=${toIMFDate(cookie.expires)}`);
      }
      if (cookie.sameSite) {
        out.push(`SameSite=${cookie.sameSite}`);
      }
      for (const part of cookie.unparsed) {
        if (!part.includes("=")) {
          throw new Error("Invalid unparsed");
        }
        const [key, ...value] = part.split("=");
        out.push(`${key.trim()}=${value.join("=")}`);
      }
      return out.join("; ");
    }
    module2.exports = {
      isCTLExcludingHtab,
      validateCookieName,
      validateCookiePath,
      validateCookieValue,
      toIMFDate,
      stringify
    };
  }
});

// node_modules/undici/lib/web/cookies/parse.js
var require_parse6 = __commonJS({
  "node_modules/undici/lib/web/cookies/parse.js"(exports2, module2) {
    "use strict";
    var { maxNameValuePairSize, maxAttributeValueSize } = require_constants6();
    var { isCTLExcludingHtab } = require_util7();
    var { collectASequenceOfCodePointsFast } = require_data_url();
    var assert = require("node:assert");
    var { unescape: unescape2 } = require("node:querystring");
    function parseSetCookie(header) {
      if (isCTLExcludingHtab(header)) {
        return null;
      }
      let nameValuePair = "";
      let unparsedAttributes = "";
      let name = "";
      let value = "";
      if (header.includes(";")) {
        const position = { position: 0 };
        nameValuePair = collectASequenceOfCodePointsFast(";", header, position);
        unparsedAttributes = header.slice(position.position);
      } else {
        nameValuePair = header;
      }
      if (!nameValuePair.includes("=")) {
        value = nameValuePair;
      } else {
        const position = { position: 0 };
        name = collectASequenceOfCodePointsFast(
          "=",
          nameValuePair,
          position
        );
        value = nameValuePair.slice(position.position + 1);
      }
      name = name.trim();
      value = value.trim();
      if (name.length + value.length > maxNameValuePairSize) {
        return null;
      }
      return {
        name,
        value: unescape2(value),
        ...parseUnparsedAttributes(unparsedAttributes)
      };
    }
    function parseUnparsedAttributes(unparsedAttributes, cookieAttributeList = {}) {
      if (unparsedAttributes.length === 0) {
        return cookieAttributeList;
      }
      assert(unparsedAttributes[0] === ";");
      unparsedAttributes = unparsedAttributes.slice(1);
      let cookieAv = "";
      if (unparsedAttributes.includes(";")) {
        cookieAv = collectASequenceOfCodePointsFast(
          ";",
          unparsedAttributes,
          { position: 0 }
        );
        unparsedAttributes = unparsedAttributes.slice(cookieAv.length);
      } else {
        cookieAv = unparsedAttributes;
        unparsedAttributes = "";
      }
      let attributeName = "";
      let attributeValue = "";
      if (cookieAv.includes("=")) {
        const position = { position: 0 };
        attributeName = collectASequenceOfCodePointsFast(
          "=",
          cookieAv,
          position
        );
        attributeValue = cookieAv.slice(position.position + 1);
      } else {
        attributeName = cookieAv;
      }
      attributeName = attributeName.trim();
      attributeValue = attributeValue.trim();
      if (attributeValue.length > maxAttributeValueSize) {
        return parseUnparsedAttributes(unparsedAttributes, cookieAttributeList);
      }
      const attributeNameLowercase = attributeName.toLowerCase();
      if (attributeNameLowercase === "expires") {
        const expiryTime = new Date(attributeValue);
        cookieAttributeList.expires = expiryTime;
      } else if (attributeNameLowercase === "max-age") {
        const charCode = attributeValue.charCodeAt(0);
        if ((charCode < 48 || charCode > 57) && attributeValue[0] !== "-") {
          return parseUnparsedAttributes(unparsedAttributes, cookieAttributeList);
        }
        if (!/^\d+$/.test(attributeValue)) {
          return parseUnparsedAttributes(unparsedAttributes, cookieAttributeList);
        }
        const deltaSeconds = Number(attributeValue);
        cookieAttributeList.maxAge = deltaSeconds;
      } else if (attributeNameLowercase === "domain") {
        let cookieDomain = attributeValue;
        if (cookieDomain[0] === ".") {
          cookieDomain = cookieDomain.slice(1);
        }
        cookieDomain = cookieDomain.toLowerCase();
        cookieAttributeList.domain = cookieDomain;
      } else if (attributeNameLowercase === "path") {
        let cookiePath = "";
        if (attributeValue.length === 0 || attributeValue[0] !== "/") {
          cookiePath = "/";
        } else {
          cookiePath = attributeValue;
        }
        cookieAttributeList.path = cookiePath;
      } else if (attributeNameLowercase === "secure") {
        cookieAttributeList.secure = true;
      } else if (attributeNameLowercase === "httponly") {
        cookieAttributeList.httpOnly = true;
      } else if (attributeNameLowercase === "samesite") {
        let enforcement = "Default";
        const attributeValueLowercase = attributeValue.toLowerCase();
        if (attributeValueLowercase.includes("none")) {
          enforcement = "None";
        }
        if (attributeValueLowercase.includes("strict")) {
          enforcement = "Strict";
        }
        if (attributeValueLowercase.includes("lax")) {
          enforcement = "Lax";
        }
        cookieAttributeList.sameSite = enforcement;
      } else {
        cookieAttributeList.unparsed ??= [];
        cookieAttributeList.unparsed.push(`${attributeName}=${attributeValue}`);
      }
      return parseUnparsedAttributes(unparsedAttributes, cookieAttributeList);
    }
    module2.exports = {
      parseSetCookie,
      parseUnparsedAttributes
    };
  }
});

// node_modules/undici/lib/web/cookies/index.js
var require_cookies = __commonJS({
  "node_modules/undici/lib/web/cookies/index.js"(exports2, module2) {
    "use strict";
    var { parseSetCookie } = require_parse6();
    var { stringify } = require_util7();
    var { webidl } = require_webidl();
    var { Headers: Headers2 } = require_headers();
    var brandChecks = webidl.brandCheckMultiple([Headers2, globalThis.Headers].filter(Boolean));
    function getCookies(headers) {
      webidl.argumentLengthCheck(arguments, 1, "getCookies");
      brandChecks(headers);
      const cookie = headers.get("cookie");
      const out = {};
      if (!cookie) {
        return out;
      }
      for (const piece of cookie.split(";")) {
        const [name, ...value] = piece.split("=");
        out[name.trim()] = value.join("=");
      }
      return out;
    }
    function deleteCookie(headers, name, attributes) {
      brandChecks(headers);
      const prefix = "deleteCookie";
      webidl.argumentLengthCheck(arguments, 2, prefix);
      name = webidl.converters.DOMString(name, prefix, "name");
      attributes = webidl.converters.DeleteCookieAttributes(attributes);
      setCookie(headers, {
        name,
        value: "",
        expires: /* @__PURE__ */ new Date(0),
        ...attributes
      });
    }
    function getSetCookies(headers) {
      webidl.argumentLengthCheck(arguments, 1, "getSetCookies");
      brandChecks(headers);
      const cookies = headers.getSetCookie();
      if (!cookies) {
        return [];
      }
      return cookies.map((pair) => parseSetCookie(pair));
    }
    function parseCookie(cookie) {
      cookie = webidl.converters.DOMString(cookie);
      return parseSetCookie(cookie);
    }
    function setCookie(headers, cookie) {
      webidl.argumentLengthCheck(arguments, 2, "setCookie");
      brandChecks(headers);
      cookie = webidl.converters.Cookie(cookie);
      const str = stringify(cookie);
      if (str) {
        headers.append("set-cookie", str, true);
      }
    }
    webidl.converters.DeleteCookieAttributes = webidl.dictionaryConverter([
      {
        converter: webidl.nullableConverter(webidl.converters.DOMString),
        key: "path",
        defaultValue: () => null
      },
      {
        converter: webidl.nullableConverter(webidl.converters.DOMString),
        key: "domain",
        defaultValue: () => null
      }
    ]);
    webidl.converters.Cookie = webidl.dictionaryConverter([
      {
        converter: webidl.converters.DOMString,
        key: "name"
      },
      {
        converter: webidl.converters.DOMString,
        key: "value"
      },
      {
        converter: webidl.nullableConverter((value) => {
          if (typeof value === "number") {
            return webidl.converters["unsigned long long"](value);
          }
          return new Date(value);
        }),
        key: "expires",
        defaultValue: () => null
      },
      {
        converter: webidl.nullableConverter(webidl.converters["long long"]),
        key: "maxAge",
        defaultValue: () => null
      },
      {
        converter: webidl.nullableConverter(webidl.converters.DOMString),
        key: "domain",
        defaultValue: () => null
      },
      {
        converter: webidl.nullableConverter(webidl.converters.DOMString),
        key: "path",
        defaultValue: () => null
      },
      {
        converter: webidl.nullableConverter(webidl.converters.boolean),
        key: "secure",
        defaultValue: () => null
      },
      {
        converter: webidl.nullableConverter(webidl.converters.boolean),
        key: "httpOnly",
        defaultValue: () => null
      },
      {
        converter: webidl.converters.USVString,
        key: "sameSite",
        allowedValues: ["Strict", "Lax", "None"]
      },
      {
        converter: webidl.sequenceConverter(webidl.converters.DOMString),
        key: "unparsed",
        defaultValue: () => new Array(0)
      }
    ]);
    module2.exports = {
      getCookies,
      deleteCookie,
      getSetCookies,
      setCookie,
      parseCookie
    };
  }
});

// node_modules/undici/lib/web/websocket/events.js
var require_events = __commonJS({
  "node_modules/undici/lib/web/websocket/events.js"(exports2, module2) {
    "use strict";
    var { webidl } = require_webidl();
    var { kEnumerableProperty } = require_util4();
    var { kConstruct } = require_symbols4();
    var MessageEvent = class _MessageEvent extends Event {
      #eventInit;
      constructor(type, eventInitDict = {}) {
        if (type === kConstruct) {
          super(arguments[1], arguments[2]);
          webidl.util.markAsUncloneable(this);
          return;
        }
        const prefix = "MessageEvent constructor";
        webidl.argumentLengthCheck(arguments, 1, prefix);
        type = webidl.converters.DOMString(type, prefix, "type");
        eventInitDict = webidl.converters.MessageEventInit(eventInitDict, prefix, "eventInitDict");
        super(type, eventInitDict);
        this.#eventInit = eventInitDict;
        webidl.util.markAsUncloneable(this);
      }
      get data() {
        webidl.brandCheck(this, _MessageEvent);
        return this.#eventInit.data;
      }
      get origin() {
        webidl.brandCheck(this, _MessageEvent);
        return this.#eventInit.origin;
      }
      get lastEventId() {
        webidl.brandCheck(this, _MessageEvent);
        return this.#eventInit.lastEventId;
      }
      get source() {
        webidl.brandCheck(this, _MessageEvent);
        return this.#eventInit.source;
      }
      get ports() {
        webidl.brandCheck(this, _MessageEvent);
        if (!Object.isFrozen(this.#eventInit.ports)) {
          Object.freeze(this.#eventInit.ports);
        }
        return this.#eventInit.ports;
      }
      initMessageEvent(type, bubbles = false, cancelable = false, data = null, origin = "", lastEventId = "", source = null, ports = []) {
        webidl.brandCheck(this, _MessageEvent);
        webidl.argumentLengthCheck(arguments, 1, "MessageEvent.initMessageEvent");
        return new _MessageEvent(type, {
          bubbles,
          cancelable,
          data,
          origin,
          lastEventId,
          source,
          ports
        });
      }
      static createFastMessageEvent(type, init) {
        const messageEvent = new _MessageEvent(kConstruct, type, init);
        messageEvent.#eventInit = init;
        messageEvent.#eventInit.data ??= null;
        messageEvent.#eventInit.origin ??= "";
        messageEvent.#eventInit.lastEventId ??= "";
        messageEvent.#eventInit.source ??= null;
        messageEvent.#eventInit.ports ??= [];
        return messageEvent;
      }
    };
    var { createFastMessageEvent } = MessageEvent;
    delete MessageEvent.createFastMessageEvent;
    var CloseEvent = class _CloseEvent extends Event {
      #eventInit;
      constructor(type, eventInitDict = {}) {
        const prefix = "CloseEvent constructor";
        webidl.argumentLengthCheck(arguments, 1, prefix);
        type = webidl.converters.DOMString(type, prefix, "type");
        eventInitDict = webidl.converters.CloseEventInit(eventInitDict);
        super(type, eventInitDict);
        this.#eventInit = eventInitDict;
        webidl.util.markAsUncloneable(this);
      }
      get wasClean() {
        webidl.brandCheck(this, _CloseEvent);
        return this.#eventInit.wasClean;
      }
      get code() {
        webidl.brandCheck(this, _CloseEvent);
        return this.#eventInit.code;
      }
      get reason() {
        webidl.brandCheck(this, _CloseEvent);
        return this.#eventInit.reason;
      }
    };
    var ErrorEvent = class _ErrorEvent extends Event {
      #eventInit;
      constructor(type, eventInitDict) {
        const prefix = "ErrorEvent constructor";
        webidl.argumentLengthCheck(arguments, 1, prefix);
        super(type, eventInitDict);
        webidl.util.markAsUncloneable(this);
        type = webidl.converters.DOMString(type, prefix, "type");
        eventInitDict = webidl.converters.ErrorEventInit(eventInitDict ?? {});
        this.#eventInit = eventInitDict;
      }
      get message() {
        webidl.brandCheck(this, _ErrorEvent);
        return this.#eventInit.message;
      }
      get filename() {
        webidl.brandCheck(this, _ErrorEvent);
        return this.#eventInit.filename;
      }
      get lineno() {
        webidl.brandCheck(this, _ErrorEvent);
        return this.#eventInit.lineno;
      }
      get colno() {
        webidl.brandCheck(this, _ErrorEvent);
        return this.#eventInit.colno;
      }
      get error() {
        webidl.brandCheck(this, _ErrorEvent);
        return this.#eventInit.error;
      }
    };
    Object.defineProperties(MessageEvent.prototype, {
      [Symbol.toStringTag]: {
        value: "MessageEvent",
        configurable: true
      },
      data: kEnumerableProperty,
      origin: kEnumerableProperty,
      lastEventId: kEnumerableProperty,
      source: kEnumerableProperty,
      ports: kEnumerableProperty,
      initMessageEvent: kEnumerableProperty
    });
    Object.defineProperties(CloseEvent.prototype, {
      [Symbol.toStringTag]: {
        value: "CloseEvent",
        configurable: true
      },
      reason: kEnumerableProperty,
      code: kEnumerableProperty,
      wasClean: kEnumerableProperty
    });
    Object.defineProperties(ErrorEvent.prototype, {
      [Symbol.toStringTag]: {
        value: "ErrorEvent",
        configurable: true
      },
      message: kEnumerableProperty,
      filename: kEnumerableProperty,
      lineno: kEnumerableProperty,
      colno: kEnumerableProperty,
      error: kEnumerableProperty
    });
    webidl.converters.MessagePort = webidl.interfaceConverter(
      webidl.is.MessagePort,
      "MessagePort"
    );
    webidl.converters["sequence<MessagePort>"] = webidl.sequenceConverter(
      webidl.converters.MessagePort
    );
    var eventInit = [
      {
        key: "bubbles",
        converter: webidl.converters.boolean,
        defaultValue: () => false
      },
      {
        key: "cancelable",
        converter: webidl.converters.boolean,
        defaultValue: () => false
      },
      {
        key: "composed",
        converter: webidl.converters.boolean,
        defaultValue: () => false
      }
    ];
    webidl.converters.MessageEventInit = webidl.dictionaryConverter([
      ...eventInit,
      {
        key: "data",
        converter: webidl.converters.any,
        defaultValue: () => null
      },
      {
        key: "origin",
        converter: webidl.converters.USVString,
        defaultValue: () => ""
      },
      {
        key: "lastEventId",
        converter: webidl.converters.DOMString,
        defaultValue: () => ""
      },
      {
        key: "source",
        // Node doesn't implement WindowProxy or ServiceWorker, so the only
        // valid value for source is a MessagePort.
        converter: webidl.nullableConverter(webidl.converters.MessagePort),
        defaultValue: () => null
      },
      {
        key: "ports",
        converter: webidl.converters["sequence<MessagePort>"],
        defaultValue: () => new Array(0)
      }
    ]);
    webidl.converters.CloseEventInit = webidl.dictionaryConverter([
      ...eventInit,
      {
        key: "wasClean",
        converter: webidl.converters.boolean,
        defaultValue: () => false
      },
      {
        key: "code",
        converter: webidl.converters["unsigned short"],
        defaultValue: () => 0
      },
      {
        key: "reason",
        converter: webidl.converters.USVString,
        defaultValue: () => ""
      }
    ]);
    webidl.converters.ErrorEventInit = webidl.dictionaryConverter([
      ...eventInit,
      {
        key: "message",
        converter: webidl.converters.DOMString,
        defaultValue: () => ""
      },
      {
        key: "filename",
        converter: webidl.converters.USVString,
        defaultValue: () => ""
      },
      {
        key: "lineno",
        converter: webidl.converters["unsigned long"],
        defaultValue: () => 0
      },
      {
        key: "colno",
        converter: webidl.converters["unsigned long"],
        defaultValue: () => 0
      },
      {
        key: "error",
        converter: webidl.converters.any
      }
    ]);
    module2.exports = {
      MessageEvent,
      CloseEvent,
      ErrorEvent,
      createFastMessageEvent
    };
  }
});

// node_modules/undici/lib/web/websocket/constants.js
var require_constants7 = __commonJS({
  "node_modules/undici/lib/web/websocket/constants.js"(exports2, module2) {
    "use strict";
    var uid = "258EAFA5-E914-47DA-95CA-C5AB0DC85B11";
    var staticPropertyDescriptors = {
      enumerable: true,
      writable: false,
      configurable: false
    };
    var states = {
      CONNECTING: 0,
      OPEN: 1,
      CLOSING: 2,
      CLOSED: 3
    };
    var sentCloseFrameState = {
      SENT: 1,
      RECEIVED: 2
    };
    var opcodes = {
      CONTINUATION: 0,
      TEXT: 1,
      BINARY: 2,
      CLOSE: 8,
      PING: 9,
      PONG: 10
    };
    var maxUnsigned16Bit = 65535;
    var parserStates = {
      INFO: 0,
      PAYLOADLENGTH_16: 2,
      PAYLOADLENGTH_64: 3,
      READ_DATA: 4
    };
    var emptyBuffer = Buffer.allocUnsafe(0);
    var sendHints = {
      text: 1,
      typedArray: 2,
      arrayBuffer: 3,
      blob: 4
    };
    module2.exports = {
      uid,
      sentCloseFrameState,
      staticPropertyDescriptors,
      states,
      opcodes,
      maxUnsigned16Bit,
      parserStates,
      emptyBuffer,
      sendHints
    };
  }
});

// node_modules/undici/lib/web/websocket/util.js
var require_util8 = __commonJS({
  "node_modules/undici/lib/web/websocket/util.js"(exports2, module2) {
    "use strict";
    var { states, opcodes } = require_constants7();
    var { isUtf8 } = require("node:buffer");
    var { collectASequenceOfCodePointsFast, removeHTTPWhitespace } = require_data_url();
    function isConnecting(readyState) {
      return readyState === states.CONNECTING;
    }
    function isEstablished(readyState) {
      return readyState === states.OPEN;
    }
    function isClosing(readyState) {
      return readyState === states.CLOSING;
    }
    function isClosed(readyState) {
      return readyState === states.CLOSED;
    }
    function fireEvent(e, target, eventFactory = (type, init) => new Event(type, init), eventInitDict = {}) {
      const event = eventFactory(e, eventInitDict);
      target.dispatchEvent(event);
    }
    function websocketMessageReceived(handler, type, data) {
      handler.onMessage(type, data);
    }
    function toArrayBuffer(buffer) {
      if (buffer.byteLength === buffer.buffer.byteLength) {
        return buffer.buffer;
      }
      return new Uint8Array(buffer).buffer;
    }
    function isValidSubprotocol(protocol) {
      if (protocol.length === 0) {
        return false;
      }
      for (let i = 0; i < protocol.length; ++i) {
        const code = protocol.charCodeAt(i);
        if (code < 33 || // CTL, contains SP (0x20) and HT (0x09)
        code > 126 || code === 34 || // "
        code === 40 || // (
        code === 41 || // )
        code === 44 || // ,
        code === 47 || // /
        code === 58 || // :
        code === 59 || // ;
        code === 60 || // <
        code === 61 || // =
        code === 62 || // >
        code === 63 || // ?
        code === 64 || // @
        code === 91 || // [
        code === 92 || // \
        code === 93 || // ]
        code === 123 || // {
        code === 125) {
          return false;
        }
      }
      return true;
    }
    function isValidStatusCode(code) {
      if (code >= 1e3 && code < 1015) {
        return code !== 1004 && // reserved
        code !== 1005 && // "MUST NOT be set as a status code"
        code !== 1006;
      }
      return code >= 3e3 && code <= 4999;
    }
    function isControlFrame(opcode) {
      return opcode === opcodes.CLOSE || opcode === opcodes.PING || opcode === opcodes.PONG;
    }
    function isContinuationFrame(opcode) {
      return opcode === opcodes.CONTINUATION;
    }
    function isTextBinaryFrame(opcode) {
      return opcode === opcodes.TEXT || opcode === opcodes.BINARY;
    }
    function isValidOpcode(opcode) {
      return isTextBinaryFrame(opcode) || isContinuationFrame(opcode) || isControlFrame(opcode);
    }
    function parseExtensions(extensions) {
      const position = { position: 0 };
      const extensionList = /* @__PURE__ */ new Map();
      while (position.position < extensions.length) {
        const pair = collectASequenceOfCodePointsFast(";", extensions, position);
        const [name, value = ""] = pair.split("=", 2);
        extensionList.set(
          removeHTTPWhitespace(name, true, false),
          removeHTTPWhitespace(value, false, true)
        );
        position.position++;
      }
      return extensionList;
    }
    function isValidClientWindowBits(value) {
      for (let i = 0; i < value.length; i++) {
        const byte = value.charCodeAt(i);
        if (byte < 48 || byte > 57) {
          return false;
        }
      }
      return true;
    }
    function getURLRecord(url, baseURL) {
      let urlRecord;
      try {
        urlRecord = new URL(url, baseURL);
      } catch (e) {
        throw new DOMException(e, "SyntaxError");
      }
      if (urlRecord.protocol === "http:") {
        urlRecord.protocol = "ws:";
      } else if (urlRecord.protocol === "https:") {
        urlRecord.protocol = "wss:";
      }
      if (urlRecord.protocol !== "ws:" && urlRecord.protocol !== "wss:") {
        throw new DOMException("expected a ws: or wss: url", "SyntaxError");
      }
      if (urlRecord.hash.length || urlRecord.href.endsWith("#")) {
        throw new DOMException("hash", "SyntaxError");
      }
      return urlRecord;
    }
    function validateCloseCodeAndReason(code, reason) {
      if (code !== null) {
        if (code !== 1e3 && (code < 3e3 || code > 4999)) {
          throw new DOMException("invalid code", "InvalidAccessError");
        }
      }
      if (reason !== null) {
        const reasonBytesLength = Buffer.byteLength(reason);
        if (reasonBytesLength > 123) {
          throw new DOMException(`Reason must be less than 123 bytes; received ${reasonBytesLength}`, "SyntaxError");
        }
      }
    }
    var utf8Decode = (() => {
      if (typeof process.versions.icu === "string") {
        const fatalDecoder = new TextDecoder("utf-8", { fatal: true });
        return fatalDecoder.decode.bind(fatalDecoder);
      }
      return function(buffer) {
        if (isUtf8(buffer)) {
          return buffer.toString("utf-8");
        }
        throw new TypeError("Invalid utf-8 received.");
      };
    })();
    module2.exports = {
      isConnecting,
      isEstablished,
      isClosing,
      isClosed,
      fireEvent,
      isValidSubprotocol,
      isValidStatusCode,
      websocketMessageReceived,
      utf8Decode,
      isControlFrame,
      isContinuationFrame,
      isTextBinaryFrame,
      isValidOpcode,
      parseExtensions,
      isValidClientWindowBits,
      toArrayBuffer,
      getURLRecord,
      validateCloseCodeAndReason
    };
  }
});

// node_modules/undici/lib/web/websocket/frame.js
var require_frame = __commonJS({
  "node_modules/undici/lib/web/websocket/frame.js"(exports2, module2) {
    "use strict";
    var { maxUnsigned16Bit, opcodes } = require_constants7();
    var BUFFER_SIZE = 8 * 1024;
    var crypto2;
    var buffer = null;
    var bufIdx = BUFFER_SIZE;
    try {
      crypto2 = require("node:crypto");
    } catch {
      crypto2 = {
        // not full compatibility, but minimum.
        randomFillSync: function randomFillSync(buffer2, _offset, _size) {
          for (let i = 0; i < buffer2.length; ++i) {
            buffer2[i] = Math.random() * 255 | 0;
          }
          return buffer2;
        }
      };
    }
    function generateMask() {
      if (bufIdx === BUFFER_SIZE) {
        bufIdx = 0;
        crypto2.randomFillSync(buffer ??= Buffer.allocUnsafeSlow(BUFFER_SIZE), 0, BUFFER_SIZE);
      }
      return [buffer[bufIdx++], buffer[bufIdx++], buffer[bufIdx++], buffer[bufIdx++]];
    }
    var WebsocketFrameSend = class {
      /**
       * @param {Buffer|undefined} data
       */
      constructor(data) {
        this.frameData = data;
      }
      createFrame(opcode) {
        const frameData = this.frameData;
        const maskKey = generateMask();
        const bodyLength = frameData?.byteLength ?? 0;
        let payloadLength = bodyLength;
        let offset = 6;
        if (bodyLength > maxUnsigned16Bit) {
          offset += 8;
          payloadLength = 127;
        } else if (bodyLength > 125) {
          offset += 2;
          payloadLength = 126;
        }
        const buffer2 = Buffer.allocUnsafe(bodyLength + offset);
        buffer2[0] = buffer2[1] = 0;
        buffer2[0] |= 128;
        buffer2[0] = (buffer2[0] & 240) + opcode;
        buffer2[offset - 4] = maskKey[0];
        buffer2[offset - 3] = maskKey[1];
        buffer2[offset - 2] = maskKey[2];
        buffer2[offset - 1] = maskKey[3];
        buffer2[1] = payloadLength;
        if (payloadLength === 126) {
          buffer2.writeUInt16BE(bodyLength, 2);
        } else if (payloadLength === 127) {
          buffer2[2] = buffer2[3] = 0;
          buffer2.writeUIntBE(bodyLength, 4, 6);
        }
        buffer2[1] |= 128;
        for (let i = 0; i < bodyLength; ++i) {
          buffer2[offset + i] = frameData[i] ^ maskKey[i & 3];
        }
        return buffer2;
      }
      /**
       * @param {Uint8Array} buffer
       */
      static createFastTextFrame(buffer2) {
        const maskKey = generateMask();
        const bodyLength = buffer2.length;
        for (let i = 0; i < bodyLength; ++i) {
          buffer2[i] ^= maskKey[i & 3];
        }
        let payloadLength = bodyLength;
        let offset = 6;
        if (bodyLength > maxUnsigned16Bit) {
          offset += 8;
          payloadLength = 127;
        } else if (bodyLength > 125) {
          offset += 2;
          payloadLength = 126;
        }
        const head = Buffer.allocUnsafeSlow(offset);
        head[0] = 128 | opcodes.TEXT;
        head[1] = payloadLength | 128;
        head[offset - 4] = maskKey[0];
        head[offset - 3] = maskKey[1];
        head[offset - 2] = maskKey[2];
        head[offset - 1] = maskKey[3];
        if (payloadLength === 126) {
          head.writeUInt16BE(bodyLength, 2);
        } else if (payloadLength === 127) {
          head[2] = head[3] = 0;
          head.writeUIntBE(bodyLength, 4, 6);
        }
        return [head, buffer2];
      }
    };
    module2.exports = {
      WebsocketFrameSend,
      generateMask
      // for benchmark
    };
  }
});

// node_modules/undici/lib/web/websocket/connection.js
var require_connection = __commonJS({
  "node_modules/undici/lib/web/websocket/connection.js"(exports2, module2) {
    "use strict";
    var { uid, states, sentCloseFrameState, emptyBuffer, opcodes } = require_constants7();
    var { parseExtensions, isClosed, isClosing, isEstablished, validateCloseCodeAndReason } = require_util8();
    var { makeRequest } = require_request4();
    var { fetching } = require_fetch();
    var { Headers: Headers2, getHeadersList } = require_headers();
    var { getDecodeSplit } = require_util5();
    var { WebsocketFrameSend } = require_frame();
    var assert = require("node:assert");
    var crypto2;
    try {
      crypto2 = require("node:crypto");
    } catch {
    }
    function establishWebSocketConnection(url, protocols, client, handler, options) {
      const requestURL = url;
      requestURL.protocol = url.protocol === "ws:" ? "http:" : "https:";
      const request = makeRequest({
        urlList: [requestURL],
        client,
        serviceWorkers: "none",
        referrer: "no-referrer",
        mode: "websocket",
        credentials: "include",
        cache: "no-store",
        redirect: "error"
      });
      if (options.headers) {
        const headersList = getHeadersList(new Headers2(options.headers));
        request.headersList = headersList;
      }
      const keyValue = crypto2.randomBytes(16).toString("base64");
      request.headersList.append("sec-websocket-key", keyValue, true);
      request.headersList.append("sec-websocket-version", "13", true);
      for (const protocol of protocols) {
        request.headersList.append("sec-websocket-protocol", protocol, true);
      }
      const permessageDeflate = "permessage-deflate; client_max_window_bits";
      request.headersList.append("sec-websocket-extensions", permessageDeflate, true);
      const controller = fetching({
        request,
        useParallelQueue: true,
        dispatcher: options.dispatcher,
        processResponse(response) {
          if (response.type === "error") {
            handler.readyState = states.CLOSED;
          }
          if (response.type === "error" || response.status !== 101) {
            failWebsocketConnection(handler, 1002, "Received network error or non-101 status code.", response.error);
            return;
          }
          if (protocols.length !== 0 && !response.headersList.get("Sec-WebSocket-Protocol")) {
            failWebsocketConnection(handler, 1002, "Server did not respond with sent protocols.");
            return;
          }
          if (response.headersList.get("Upgrade")?.toLowerCase() !== "websocket") {
            failWebsocketConnection(handler, 1002, 'Server did not set Upgrade header to "websocket".');
            return;
          }
          if (response.headersList.get("Connection")?.toLowerCase() !== "upgrade") {
            failWebsocketConnection(handler, 1002, 'Server did not set Connection header to "upgrade".');
            return;
          }
          const secWSAccept = response.headersList.get("Sec-WebSocket-Accept");
          const digest = crypto2.createHash("sha1").update(keyValue + uid).digest("base64");
          if (secWSAccept !== digest) {
            failWebsocketConnection(handler, 1002, "Incorrect hash received in Sec-WebSocket-Accept header.");
            return;
          }
          const secExtension = response.headersList.get("Sec-WebSocket-Extensions");
          let extensions;
          if (secExtension !== null) {
            extensions = parseExtensions(secExtension);
            if (!extensions.has("permessage-deflate")) {
              failWebsocketConnection(handler, 1002, "Sec-WebSocket-Extensions header does not match.");
              return;
            }
          }
          const secProtocol = response.headersList.get("Sec-WebSocket-Protocol");
          if (secProtocol !== null) {
            const requestProtocols = getDecodeSplit("sec-websocket-protocol", request.headersList);
            if (!requestProtocols.includes(secProtocol)) {
              failWebsocketConnection(handler, 1002, "Protocol was not set in the opening handshake.");
              return;
            }
          }
          response.socket.on("data", handler.onSocketData);
          response.socket.on("close", handler.onSocketClose);
          response.socket.on("error", handler.onSocketError);
          handler.wasEverConnected = true;
          handler.onConnectionEstablished(response, extensions);
        }
      });
      return controller;
    }
    function closeWebSocketConnection(object, code, reason, validate = false) {
      code ??= null;
      reason ??= "";
      if (validate) validateCloseCodeAndReason(code, reason);
      if (isClosed(object.readyState) || isClosing(object.readyState)) {
      } else if (!isEstablished(object.readyState)) {
        failWebsocketConnection(object);
        object.readyState = states.CLOSING;
      } else if (!object.closeState.has(sentCloseFrameState.SENT) && !object.closeState.has(sentCloseFrameState.RECEIVED)) {
        const frame = new WebsocketFrameSend();
        if (reason.length !== 0 && code === null) {
          code = 1e3;
        }
        assert(code === null || Number.isInteger(code));
        if (code === null && reason.length === 0) {
          frame.frameData = emptyBuffer;
        } else if (code !== null && reason === null) {
          frame.frameData = Buffer.allocUnsafe(2);
          frame.frameData.writeUInt16BE(code, 0);
        } else if (code !== null && reason !== null) {
          frame.frameData = Buffer.allocUnsafe(2 + Buffer.byteLength(reason));
          frame.frameData.writeUInt16BE(code, 0);
          frame.frameData.write(reason, 2, "utf-8");
        } else {
          frame.frameData = emptyBuffer;
        }
        object.socket.write(frame.createFrame(opcodes.CLOSE));
        object.closeState.add(sentCloseFrameState.SENT);
        object.readyState = states.CLOSING;
      } else {
        object.readyState = states.CLOSING;
      }
    }
    function failWebsocketConnection(handler, code, reason, cause) {
      if (isEstablished(handler.readyState)) {
        closeWebSocketConnection(handler, code, reason, false);
      }
      handler.controller.abort();
      if (handler.socket?.destroyed === false) {
        handler.socket.destroy();
      }
      handler.onFail(code, reason, cause);
    }
    module2.exports = {
      establishWebSocketConnection,
      failWebsocketConnection,
      closeWebSocketConnection
    };
  }
});

// node_modules/undici/lib/web/websocket/permessage-deflate.js
var require_permessage_deflate = __commonJS({
  "node_modules/undici/lib/web/websocket/permessage-deflate.js"(exports2, module2) {
    "use strict";
    var { createInflateRaw, Z_DEFAULT_WINDOWBITS } = require("node:zlib");
    var { isValidClientWindowBits } = require_util8();
    var tail = Buffer.from([0, 0, 255, 255]);
    var kBuffer = Symbol("kBuffer");
    var kLength = Symbol("kLength");
    var PerMessageDeflate = class {
      /** @type {import('node:zlib').InflateRaw} */
      #inflate;
      #options = {};
      constructor(extensions) {
        this.#options.serverNoContextTakeover = extensions.has("server_no_context_takeover");
        this.#options.serverMaxWindowBits = extensions.get("server_max_window_bits");
      }
      decompress(chunk, fin, callback) {
        if (!this.#inflate) {
          let windowBits = Z_DEFAULT_WINDOWBITS;
          if (this.#options.serverMaxWindowBits) {
            if (!isValidClientWindowBits(this.#options.serverMaxWindowBits)) {
              callback(new Error("Invalid server_max_window_bits"));
              return;
            }
            windowBits = Number.parseInt(this.#options.serverMaxWindowBits);
          }
          this.#inflate = createInflateRaw({ windowBits });
          this.#inflate[kBuffer] = [];
          this.#inflate[kLength] = 0;
          this.#inflate.on("data", (data) => {
            this.#inflate[kBuffer].push(data);
            this.#inflate[kLength] += data.length;
          });
          this.#inflate.on("error", (err) => {
            this.#inflate = null;
            callback(err);
          });
        }
        this.#inflate.write(chunk);
        if (fin) {
          this.#inflate.write(tail);
        }
        this.#inflate.flush(() => {
          const full = Buffer.concat(this.#inflate[kBuffer], this.#inflate[kLength]);
          this.#inflate[kBuffer].length = 0;
          this.#inflate[kLength] = 0;
          callback(null, full);
        });
      }
    };
    module2.exports = { PerMessageDeflate };
  }
});

// node_modules/undici/lib/web/websocket/receiver.js
var require_receiver = __commonJS({
  "node_modules/undici/lib/web/websocket/receiver.js"(exports2, module2) {
    "use strict";
    var { Writable } = require("node:stream");
    var assert = require("node:assert");
    var { parserStates, opcodes, states, emptyBuffer, sentCloseFrameState } = require_constants7();
    var {
      isValidStatusCode,
      isValidOpcode,
      websocketMessageReceived,
      utf8Decode,
      isControlFrame,
      isTextBinaryFrame,
      isContinuationFrame
    } = require_util8();
    var { failWebsocketConnection } = require_connection();
    var { WebsocketFrameSend } = require_frame();
    var { PerMessageDeflate } = require_permessage_deflate();
    var ByteParser = class extends Writable {
      #buffers = [];
      #fragmentsBytes = 0;
      #byteOffset = 0;
      #loop = false;
      #state = parserStates.INFO;
      #info = {};
      #fragments = [];
      /** @type {Map<string, PerMessageDeflate>} */
      #extensions;
      /** @type {import('./websocket').Handler} */
      #handler;
      constructor(handler, extensions) {
        super();
        this.#handler = handler;
        this.#extensions = extensions == null ? /* @__PURE__ */ new Map() : extensions;
        if (this.#extensions.has("permessage-deflate")) {
          this.#extensions.set("permessage-deflate", new PerMessageDeflate(extensions));
        }
      }
      /**
       * @param {Buffer} chunk
       * @param {() => void} callback
       */
      _write(chunk, _, callback) {
        this.#buffers.push(chunk);
        this.#byteOffset += chunk.length;
        this.#loop = true;
        this.run(callback);
      }
      /**
       * Runs whenever a new chunk is received.
       * Callback is called whenever there are no more chunks buffering,
       * or not enough bytes are buffered to parse.
       */
      run(callback) {
        while (this.#loop) {
          if (this.#state === parserStates.INFO) {
            if (this.#byteOffset < 2) {
              return callback();
            }
            const buffer = this.consume(2);
            const fin = (buffer[0] & 128) !== 0;
            const opcode = buffer[0] & 15;
            const masked = (buffer[1] & 128) === 128;
            const fragmented = !fin && opcode !== opcodes.CONTINUATION;
            const payloadLength = buffer[1] & 127;
            const rsv1 = buffer[0] & 64;
            const rsv2 = buffer[0] & 32;
            const rsv3 = buffer[0] & 16;
            if (!isValidOpcode(opcode)) {
              failWebsocketConnection(this.#handler, 1002, "Invalid opcode received");
              return callback();
            }
            if (masked) {
              failWebsocketConnection(this.#handler, 1002, "Frame cannot be masked");
              return callback();
            }
            if (rsv1 !== 0 && !this.#extensions.has("permessage-deflate")) {
              failWebsocketConnection(this.#handler, 1002, "Expected RSV1 to be clear.");
              return;
            }
            if (rsv2 !== 0 || rsv3 !== 0) {
              failWebsocketConnection(this.#handler, 1002, "RSV1, RSV2, RSV3 must be clear");
              return;
            }
            if (fragmented && !isTextBinaryFrame(opcode)) {
              failWebsocketConnection(this.#handler, 1002, "Invalid frame type was fragmented.");
              return;
            }
            if (isTextBinaryFrame(opcode) && this.#fragments.length > 0) {
              failWebsocketConnection(this.#handler, 1002, "Expected continuation frame");
              return;
            }
            if (this.#info.fragmented && fragmented) {
              failWebsocketConnection(this.#handler, 1002, "Fragmented frame exceeded 125 bytes.");
              return;
            }
            if ((payloadLength > 125 || fragmented) && isControlFrame(opcode)) {
              failWebsocketConnection(this.#handler, 1002, "Control frame either too large or fragmented");
              return;
            }
            if (isContinuationFrame(opcode) && this.#fragments.length === 0 && !this.#info.compressed) {
              failWebsocketConnection(this.#handler, 1002, "Unexpected continuation frame");
              return;
            }
            if (payloadLength <= 125) {
              this.#info.payloadLength = payloadLength;
              this.#state = parserStates.READ_DATA;
            } else if (payloadLength === 126) {
              this.#state = parserStates.PAYLOADLENGTH_16;
            } else if (payloadLength === 127) {
              this.#state = parserStates.PAYLOADLENGTH_64;
            }
            if (isTextBinaryFrame(opcode)) {
              this.#info.binaryType = opcode;
              this.#info.compressed = rsv1 !== 0;
            }
            this.#info.opcode = opcode;
            this.#info.masked = masked;
            this.#info.fin = fin;
            this.#info.fragmented = fragmented;
          } else if (this.#state === parserStates.PAYLOADLENGTH_16) {
            if (this.#byteOffset < 2) {
              return callback();
            }
            const buffer = this.consume(2);
            this.#info.payloadLength = buffer.readUInt16BE(0);
            this.#state = parserStates.READ_DATA;
          } else if (this.#state === parserStates.PAYLOADLENGTH_64) {
            if (this.#byteOffset < 8) {
              return callback();
            }
            const buffer = this.consume(8);
            const upper = buffer.readUInt32BE(0);
            if (upper > 2 ** 31 - 1) {
              failWebsocketConnection(this.#handler, 1009, "Received payload length > 2^31 bytes.");
              return;
            }
            const lower = buffer.readUInt32BE(4);
            this.#info.payloadLength = (upper << 8) + lower;
            this.#state = parserStates.READ_DATA;
          } else if (this.#state === parserStates.READ_DATA) {
            if (this.#byteOffset < this.#info.payloadLength) {
              return callback();
            }
            const body = this.consume(this.#info.payloadLength);
            if (isControlFrame(this.#info.opcode)) {
              this.#loop = this.parseControlFrame(body);
              this.#state = parserStates.INFO;
            } else {
              if (!this.#info.compressed) {
                this.writeFragments(body);
                if (!this.#info.fragmented && this.#info.fin) {
                  websocketMessageReceived(this.#handler, this.#info.binaryType, this.consumeFragments());
                }
                this.#state = parserStates.INFO;
              } else {
                this.#extensions.get("permessage-deflate").decompress(body, this.#info.fin, (error, data) => {
                  if (error) {
                    failWebsocketConnection(this.#handler, 1007, error.message);
                    return;
                  }
                  this.writeFragments(data);
                  if (!this.#info.fin) {
                    this.#state = parserStates.INFO;
                    this.#loop = true;
                    this.run(callback);
                    return;
                  }
                  websocketMessageReceived(this.#handler, this.#info.binaryType, this.consumeFragments());
                  this.#loop = true;
                  this.#state = parserStates.INFO;
                  this.run(callback);
                });
                this.#loop = false;
                break;
              }
            }
          }
        }
      }
      /**
       * Take n bytes from the buffered Buffers
       * @param {number} n
       * @returns {Buffer}
       */
      consume(n) {
        if (n > this.#byteOffset) {
          throw new Error("Called consume() before buffers satiated.");
        } else if (n === 0) {
          return emptyBuffer;
        }
        this.#byteOffset -= n;
        const first = this.#buffers[0];
        if (first.length > n) {
          this.#buffers[0] = first.subarray(n, first.length);
          return first.subarray(0, n);
        } else if (first.length === n) {
          return this.#buffers.shift();
        } else {
          let offset = 0;
          const buffer = Buffer.allocUnsafeSlow(n);
          while (offset !== n) {
            const next = this.#buffers[0];
            const length = next.length;
            if (length + offset === n) {
              buffer.set(this.#buffers.shift(), offset);
              break;
            } else if (length + offset > n) {
              buffer.set(next.subarray(0, n - offset), offset);
              this.#buffers[0] = next.subarray(n - offset);
              break;
            } else {
              buffer.set(this.#buffers.shift(), offset);
              offset += length;
            }
          }
          return buffer;
        }
      }
      writeFragments(fragment) {
        this.#fragmentsBytes += fragment.length;
        this.#fragments.push(fragment);
      }
      consumeFragments() {
        const fragments = this.#fragments;
        if (fragments.length === 1) {
          this.#fragmentsBytes = 0;
          return fragments.shift();
        }
        let offset = 0;
        const output = Buffer.allocUnsafeSlow(this.#fragmentsBytes);
        for (let i = 0; i < fragments.length; ++i) {
          const buffer = fragments[i];
          output.set(buffer, offset);
          offset += buffer.length;
        }
        this.#fragments = [];
        this.#fragmentsBytes = 0;
        return output;
      }
      parseCloseBody(data) {
        assert(data.length !== 1);
        let code;
        if (data.length >= 2) {
          code = data.readUInt16BE(0);
        }
        if (code !== void 0 && !isValidStatusCode(code)) {
          return { code: 1002, reason: "Invalid status code", error: true };
        }
        let reason = data.subarray(2);
        if (reason[0] === 239 && reason[1] === 187 && reason[2] === 191) {
          reason = reason.subarray(3);
        }
        try {
          reason = utf8Decode(reason);
        } catch {
          return { code: 1007, reason: "Invalid UTF-8", error: true };
        }
        return { code, reason, error: false };
      }
      /**
       * Parses control frames.
       * @param {Buffer} body
       */
      parseControlFrame(body) {
        const { opcode, payloadLength } = this.#info;
        if (opcode === opcodes.CLOSE) {
          if (payloadLength === 1) {
            failWebsocketConnection(this.#handler, 1002, "Received close frame with a 1-byte body.");
            return false;
          }
          this.#info.closeInfo = this.parseCloseBody(body);
          if (this.#info.closeInfo.error) {
            const { code, reason } = this.#info.closeInfo;
            failWebsocketConnection(this.#handler, code, reason);
            return false;
          }
          if (!this.#handler.closeState.has(sentCloseFrameState.SENT) && !this.#handler.closeState.has(sentCloseFrameState.RECEIVED)) {
            let body2 = emptyBuffer;
            if (this.#info.closeInfo.code) {
              body2 = Buffer.allocUnsafe(2);
              body2.writeUInt16BE(this.#info.closeInfo.code, 0);
            }
            const closeFrame = new WebsocketFrameSend(body2);
            this.#handler.socket.write(closeFrame.createFrame(opcodes.CLOSE));
            this.#handler.closeState.add(sentCloseFrameState.SENT);
          }
          this.#handler.readyState = states.CLOSING;
          this.#handler.closeState.add(sentCloseFrameState.RECEIVED);
          return false;
        } else if (opcode === opcodes.PING) {
          if (!this.#handler.closeState.has(sentCloseFrameState.RECEIVED)) {
            const frame = new WebsocketFrameSend(body);
            this.#handler.socket.write(frame.createFrame(opcodes.PONG));
            this.#handler.onPing(body);
          }
        } else if (opcode === opcodes.PONG) {
          this.#handler.onPong(body);
        }
        return true;
      }
      get closingInfo() {
        return this.#info.closeInfo;
      }
    };
    module2.exports = {
      ByteParser
    };
  }
});

// node_modules/undici/lib/web/websocket/sender.js
var require_sender = __commonJS({
  "node_modules/undici/lib/web/websocket/sender.js"(exports2, module2) {
    "use strict";
    var { WebsocketFrameSend } = require_frame();
    var { opcodes, sendHints } = require_constants7();
    var FixedQueue = require_fixed_queue();
    var SendQueue = class {
      /**
       * @type {FixedQueue}
       */
      #queue = new FixedQueue();
      /**
       * @type {boolean}
       */
      #running = false;
      /** @type {import('node:net').Socket} */
      #socket;
      constructor(socket) {
        this.#socket = socket;
      }
      add(item, cb, hint) {
        if (hint !== sendHints.blob) {
          if (!this.#running) {
            if (hint === sendHints.text) {
              const { 0: head, 1: body } = WebsocketFrameSend.createFastTextFrame(item);
              this.#socket.cork();
              this.#socket.write(head);
              this.#socket.write(body, cb);
              this.#socket.uncork();
            } else {
              this.#socket.write(createFrame(item, hint), cb);
            }
          } else {
            const node2 = {
              promise: null,
              callback: cb,
              frame: createFrame(item, hint)
            };
            this.#queue.push(node2);
          }
          return;
        }
        const node = {
          promise: item.arrayBuffer().then((ab) => {
            node.promise = null;
            node.frame = createFrame(ab, hint);
          }),
          callback: cb,
          frame: null
        };
        this.#queue.push(node);
        if (!this.#running) {
          this.#run();
        }
      }
      async #run() {
        this.#running = true;
        const queue = this.#queue;
        while (!queue.isEmpty()) {
          const node = queue.shift();
          if (node.promise !== null) {
            await node.promise;
          }
          this.#socket.write(node.frame, node.callback);
          node.callback = node.frame = null;
        }
        this.#running = false;
      }
    };
    function createFrame(data, hint) {
      return new WebsocketFrameSend(toBuffer(data, hint)).createFrame(hint === sendHints.text ? opcodes.TEXT : opcodes.BINARY);
    }
    function toBuffer(data, hint) {
      switch (hint) {
        case sendHints.text:
        case sendHints.typedArray:
          return new Uint8Array(data.buffer, data.byteOffset, data.byteLength);
        case sendHints.arrayBuffer:
        case sendHints.blob:
          return new Uint8Array(data);
      }
    }
    module2.exports = { SendQueue };
  }
});

// node_modules/undici/lib/web/websocket/websocket.js
var require_websocket = __commonJS({
  "node_modules/undici/lib/web/websocket/websocket.js"(exports2, module2) {
    "use strict";
    var { webidl } = require_webidl();
    var { URLSerializer } = require_data_url();
    var { environmentSettingsObject } = require_util5();
    var { staticPropertyDescriptors, states, sentCloseFrameState, sendHints, opcodes } = require_constants7();
    var {
      isConnecting,
      isEstablished,
      isClosing,
      isClosed,
      isValidSubprotocol,
      fireEvent,
      utf8Decode,
      toArrayBuffer,
      getURLRecord
    } = require_util8();
    var { establishWebSocketConnection, closeWebSocketConnection, failWebsocketConnection } = require_connection();
    var { ByteParser } = require_receiver();
    var { kEnumerableProperty } = require_util4();
    var { getGlobalDispatcher } = require_global2();
    var { types } = require("node:util");
    var { ErrorEvent, CloseEvent, createFastMessageEvent } = require_events();
    var { SendQueue } = require_sender();
    var { WebsocketFrameSend } = require_frame();
    var { channels } = require_diagnostics();
    var WebSocket = class _WebSocket extends EventTarget {
      #events = {
        open: null,
        error: null,
        close: null,
        message: null
      };
      #bufferedAmount = 0;
      #protocol = "";
      #extensions = "";
      /** @type {SendQueue} */
      #sendQueue;
      /** @type {Handler} */
      #handler = {
        onConnectionEstablished: (response, extensions) => this.#onConnectionEstablished(response, extensions),
        onFail: (code, reason, cause) => this.#onFail(code, reason, cause),
        onMessage: (opcode, data) => this.#onMessage(opcode, data),
        onParserError: (err) => failWebsocketConnection(this.#handler, null, err.message),
        onParserDrain: () => this.#onParserDrain(),
        onSocketData: (chunk) => {
          if (!this.#parser.write(chunk)) {
            this.#handler.socket.pause();
          }
        },
        onSocketError: (err) => {
          this.#handler.readyState = states.CLOSING;
          if (channels.socketError.hasSubscribers) {
            channels.socketError.publish(err);
          }
          this.#handler.socket.destroy();
        },
        onSocketClose: () => this.#onSocketClose(),
        onPing: (body) => {
          if (channels.ping.hasSubscribers) {
            channels.ping.publish({
              payload: body,
              websocket: this
            });
          }
        },
        onPong: (body) => {
          if (channels.pong.hasSubscribers) {
            channels.pong.publish({
              payload: body,
              websocket: this
            });
          }
        },
        readyState: states.CONNECTING,
        socket: null,
        closeState: /* @__PURE__ */ new Set(),
        controller: null,
        wasEverConnected: false
      };
      #url;
      #binaryType;
      /** @type {import('./receiver').ByteParser} */
      #parser;
      /**
       * @param {string} url
       * @param {string|string[]} protocols
       */
      constructor(url, protocols = []) {
        super();
        webidl.util.markAsUncloneable(this);
        const prefix = "WebSocket constructor";
        webidl.argumentLengthCheck(arguments, 1, prefix);
        const options = webidl.converters["DOMString or sequence<DOMString> or WebSocketInit"](protocols, prefix, "options");
        url = webidl.converters.USVString(url);
        protocols = options.protocols;
        const baseURL = environmentSettingsObject.settingsObject.baseUrl;
        const urlRecord = getURLRecord(url, baseURL);
        if (typeof protocols === "string") {
          protocols = [protocols];
        }
        if (protocols.length !== new Set(protocols.map((p) => p.toLowerCase())).size) {
          throw new DOMException("Invalid Sec-WebSocket-Protocol value", "SyntaxError");
        }
        if (protocols.length > 0 && !protocols.every((p) => isValidSubprotocol(p))) {
          throw new DOMException("Invalid Sec-WebSocket-Protocol value", "SyntaxError");
        }
        this.#url = new URL(urlRecord.href);
        const client = environmentSettingsObject.settingsObject;
        this.#handler.controller = establishWebSocketConnection(
          urlRecord,
          protocols,
          client,
          this.#handler,
          options
        );
        this.#handler.readyState = _WebSocket.CONNECTING;
        this.#binaryType = "blob";
      }
      /**
       * @see https://websockets.spec.whatwg.org/#dom-websocket-close
       * @param {number|undefined} code
       * @param {string|undefined} reason
       */
      close(code = void 0, reason = void 0) {
        webidl.brandCheck(this, _WebSocket);
        const prefix = "WebSocket.close";
        if (code !== void 0) {
          code = webidl.converters["unsigned short"](code, prefix, "code", { clamp: true });
        }
        if (reason !== void 0) {
          reason = webidl.converters.USVString(reason);
        }
        code ??= null;
        reason ??= "";
        closeWebSocketConnection(this.#handler, code, reason, true);
      }
      /**
       * @see https://websockets.spec.whatwg.org/#dom-websocket-send
       * @param {NodeJS.TypedArray|ArrayBuffer|Blob|string} data
       */
      send(data) {
        webidl.brandCheck(this, _WebSocket);
        const prefix = "WebSocket.send";
        webidl.argumentLengthCheck(arguments, 1, prefix);
        data = webidl.converters.WebSocketSendData(data, prefix, "data");
        if (isConnecting(this.#handler.readyState)) {
          throw new DOMException("Sent before connected.", "InvalidStateError");
        }
        if (!isEstablished(this.#handler.readyState) || isClosing(this.#handler.readyState)) {
          return;
        }
        if (typeof data === "string") {
          const buffer = Buffer.from(data);
          this.#bufferedAmount += buffer.byteLength;
          this.#sendQueue.add(buffer, () => {
            this.#bufferedAmount -= buffer.byteLength;
          }, sendHints.text);
        } else if (types.isArrayBuffer(data)) {
          this.#bufferedAmount += data.byteLength;
          this.#sendQueue.add(data, () => {
            this.#bufferedAmount -= data.byteLength;
          }, sendHints.arrayBuffer);
        } else if (ArrayBuffer.isView(data)) {
          this.#bufferedAmount += data.byteLength;
          this.#sendQueue.add(data, () => {
            this.#bufferedAmount -= data.byteLength;
          }, sendHints.typedArray);
        } else if (webidl.is.Blob(data)) {
          this.#bufferedAmount += data.size;
          this.#sendQueue.add(data, () => {
            this.#bufferedAmount -= data.size;
          }, sendHints.blob);
        }
      }
      get readyState() {
        webidl.brandCheck(this, _WebSocket);
        return this.#handler.readyState;
      }
      get bufferedAmount() {
        webidl.brandCheck(this, _WebSocket);
        return this.#bufferedAmount;
      }
      get url() {
        webidl.brandCheck(this, _WebSocket);
        return URLSerializer(this.#url);
      }
      get extensions() {
        webidl.brandCheck(this, _WebSocket);
        return this.#extensions;
      }
      get protocol() {
        webidl.brandCheck(this, _WebSocket);
        return this.#protocol;
      }
      get onopen() {
        webidl.brandCheck(this, _WebSocket);
        return this.#events.open;
      }
      set onopen(fn) {
        webidl.brandCheck(this, _WebSocket);
        if (this.#events.open) {
          this.removeEventListener("open", this.#events.open);
        }
        if (typeof fn === "function") {
          this.#events.open = fn;
          this.addEventListener("open", fn);
        } else {
          this.#events.open = null;
        }
      }
      get onerror() {
        webidl.brandCheck(this, _WebSocket);
        return this.#events.error;
      }
      set onerror(fn) {
        webidl.brandCheck(this, _WebSocket);
        if (this.#events.error) {
          this.removeEventListener("error", this.#events.error);
        }
        if (typeof fn === "function") {
          this.#events.error = fn;
          this.addEventListener("error", fn);
        } else {
          this.#events.error = null;
        }
      }
      get onclose() {
        webidl.brandCheck(this, _WebSocket);
        return this.#events.close;
      }
      set onclose(fn) {
        webidl.brandCheck(this, _WebSocket);
        if (this.#events.close) {
          this.removeEventListener("close", this.#events.close);
        }
        if (typeof fn === "function") {
          this.#events.close = fn;
          this.addEventListener("close", fn);
        } else {
          this.#events.close = null;
        }
      }
      get onmessage() {
        webidl.brandCheck(this, _WebSocket);
        return this.#events.message;
      }
      set onmessage(fn) {
        webidl.brandCheck(this, _WebSocket);
        if (this.#events.message) {
          this.removeEventListener("message", this.#events.message);
        }
        if (typeof fn === "function") {
          this.#events.message = fn;
          this.addEventListener("message", fn);
        } else {
          this.#events.message = null;
        }
      }
      get binaryType() {
        webidl.brandCheck(this, _WebSocket);
        return this.#binaryType;
      }
      set binaryType(type) {
        webidl.brandCheck(this, _WebSocket);
        if (type !== "blob" && type !== "arraybuffer") {
          this.#binaryType = "blob";
        } else {
          this.#binaryType = type;
        }
      }
      /**
       * @see https://websockets.spec.whatwg.org/#feedback-from-the-protocol
       */
      #onConnectionEstablished(response, parsedExtensions) {
        this.#handler.socket = response.socket;
        const parser = new ByteParser(this.#handler, parsedExtensions);
        parser.on("drain", () => this.#handler.onParserDrain());
        parser.on("error", (err) => this.#handler.onParserError(err));
        this.#parser = parser;
        this.#sendQueue = new SendQueue(response.socket);
        this.#handler.readyState = states.OPEN;
        const extensions = response.headersList.get("sec-websocket-extensions");
        if (extensions !== null) {
          this.#extensions = extensions;
        }
        const protocol = response.headersList.get("sec-websocket-protocol");
        if (protocol !== null) {
          this.#protocol = protocol;
        }
        fireEvent("open", this);
        if (channels.open.hasSubscribers) {
          channels.open.publish({
            address: response.socket.address(),
            protocol: this.#protocol,
            extensions: this.#extensions,
            websocket: this
          });
        }
      }
      #onFail(code, reason, cause) {
        if (reason) {
          fireEvent("error", this, (type, init) => new ErrorEvent(type, init), {
            error: new Error(reason, cause ? { cause } : void 0),
            message: reason
          });
        }
        if (!this.#handler.wasEverConnected) {
          this.#handler.readyState = states.CLOSED;
          fireEvent("close", this, (type, init) => new CloseEvent(type, init), {
            wasClean: false,
            code,
            reason
          });
        }
      }
      #onMessage(type, data) {
        if (this.#handler.readyState !== states.OPEN) {
          return;
        }
        let dataForEvent;
        if (type === opcodes.TEXT) {
          try {
            dataForEvent = utf8Decode(data);
          } catch {
            failWebsocketConnection(this.#handler, 1007, "Received invalid UTF-8 in text frame.");
            return;
          }
        } else if (type === opcodes.BINARY) {
          if (this.#binaryType === "blob") {
            dataForEvent = new Blob([data]);
          } else {
            dataForEvent = toArrayBuffer(data);
          }
        }
        fireEvent("message", this, createFastMessageEvent, {
          origin: this.#url.origin,
          data: dataForEvent
        });
      }
      #onParserDrain() {
        this.#handler.socket.resume();
      }
      /**
       * @see https://websockets.spec.whatwg.org/#feedback-from-the-protocol
       * @see https://datatracker.ietf.org/doc/html/rfc6455#section-7.1.4
       */
      #onSocketClose() {
        const wasClean = this.#handler.closeState.has(sentCloseFrameState.SENT) && this.#handler.closeState.has(sentCloseFrameState.RECEIVED);
        let code = 1005;
        let reason = "";
        const result = this.#parser.closingInfo;
        if (result && !result.error) {
          code = result.code ?? 1005;
          reason = result.reason;
        } else if (!this.#handler.closeState.has(sentCloseFrameState.RECEIVED)) {
          code = 1006;
        }
        this.#handler.readyState = states.CLOSED;
        fireEvent("close", this, (type, init) => new CloseEvent(type, init), {
          wasClean,
          code,
          reason
        });
        if (channels.close.hasSubscribers) {
          channels.close.publish({
            websocket: this,
            code,
            reason
          });
        }
      }
      /**
       * @param {WebSocket} ws
       * @param {Buffer|undefined} buffer
       */
      static ping(ws, buffer) {
        if (Buffer.isBuffer(buffer)) {
          if (buffer.length > 125) {
            throw new TypeError("A PING frame cannot have a body larger than 125 bytes.");
          }
        } else if (buffer !== void 0) {
          throw new TypeError("Expected buffer payload");
        }
        const readyState = ws.#handler.readyState;
        if (isEstablished(readyState) && !isClosing(readyState) && !isClosed(readyState)) {
          const frame = new WebsocketFrameSend(buffer);
          ws.#handler.socket.write(frame.createFrame(opcodes.PING));
        }
      }
    };
    var { ping } = WebSocket;
    Reflect.deleteProperty(WebSocket, "ping");
    WebSocket.CONNECTING = WebSocket.prototype.CONNECTING = states.CONNECTING;
    WebSocket.OPEN = WebSocket.prototype.OPEN = states.OPEN;
    WebSocket.CLOSING = WebSocket.prototype.CLOSING = states.CLOSING;
    WebSocket.CLOSED = WebSocket.prototype.CLOSED = states.CLOSED;
    Object.defineProperties(WebSocket.prototype, {
      CONNECTING: staticPropertyDescriptors,
      OPEN: staticPropertyDescriptors,
      CLOSING: staticPropertyDescriptors,
      CLOSED: staticPropertyDescriptors,
      url: kEnumerableProperty,
      readyState: kEnumerableProperty,
      bufferedAmount: kEnumerableProperty,
      onopen: kEnumerableProperty,
      onerror: kEnumerableProperty,
      onclose: kEnumerableProperty,
      close: kEnumerableProperty,
      onmessage: kEnumerableProperty,
      binaryType: kEnumerableProperty,
      send: kEnumerableProperty,
      extensions: kEnumerableProperty,
      protocol: kEnumerableProperty,
      [Symbol.toStringTag]: {
        value: "WebSocket",
        writable: false,
        enumerable: false,
        configurable: true
      }
    });
    Object.defineProperties(WebSocket, {
      CONNECTING: staticPropertyDescriptors,
      OPEN: staticPropertyDescriptors,
      CLOSING: staticPropertyDescriptors,
      CLOSED: staticPropertyDescriptors
    });
    webidl.converters["sequence<DOMString>"] = webidl.sequenceConverter(
      webidl.converters.DOMString
    );
    webidl.converters["DOMString or sequence<DOMString>"] = function(V, prefix, argument) {
      if (webidl.util.Type(V) === webidl.util.Types.OBJECT && Symbol.iterator in V) {
        return webidl.converters["sequence<DOMString>"](V);
      }
      return webidl.converters.DOMString(V, prefix, argument);
    };
    webidl.converters.WebSocketInit = webidl.dictionaryConverter([
      {
        key: "protocols",
        converter: webidl.converters["DOMString or sequence<DOMString>"],
        defaultValue: () => new Array(0)
      },
      {
        key: "dispatcher",
        converter: webidl.converters.any,
        defaultValue: () => getGlobalDispatcher()
      },
      {
        key: "headers",
        converter: webidl.nullableConverter(webidl.converters.HeadersInit)
      }
    ]);
    webidl.converters["DOMString or sequence<DOMString> or WebSocketInit"] = function(V) {
      if (webidl.util.Type(V) === webidl.util.Types.OBJECT && !(Symbol.iterator in V)) {
        return webidl.converters.WebSocketInit(V);
      }
      return { protocols: webidl.converters["DOMString or sequence<DOMString>"](V) };
    };
    webidl.converters.WebSocketSendData = function(V) {
      if (webidl.util.Type(V) === webidl.util.Types.OBJECT) {
        if (webidl.is.Blob(V)) {
          return V;
        }
        if (ArrayBuffer.isView(V) || types.isArrayBuffer(V)) {
          return V;
        }
      }
      return webidl.converters.USVString(V);
    };
    module2.exports = {
      WebSocket,
      ping
    };
  }
});

// node_modules/undici/lib/web/websocket/stream/websocketerror.js
var require_websocketerror = __commonJS({
  "node_modules/undici/lib/web/websocket/stream/websocketerror.js"(exports2, module2) {
    "use strict";
    var { webidl } = require_webidl();
    var { validateCloseCodeAndReason } = require_util8();
    var { kConstruct } = require_symbols4();
    var { kEnumerableProperty } = require_util4();
    var WebSocketError = class _WebSocketError extends DOMException {
      #closeCode;
      #reason;
      constructor(message = "", init = void 0) {
        message = webidl.converters.DOMString(message, "WebSocketError", "message");
        super(message, "WebSocketError");
        if (init === kConstruct) {
          return;
        } else if (init !== null) {
          init = webidl.converters.WebSocketCloseInfo(init);
        }
        let code = init.closeCode ?? null;
        const reason = init.reason ?? "";
        validateCloseCodeAndReason(code, reason);
        if (reason.length !== 0 && code === null) {
          code = 1e3;
        }
        this.#closeCode = code;
        this.#reason = reason;
      }
      get closeCode() {
        return this.#closeCode;
      }
      get reason() {
        return this.#reason;
      }
      /**
       * @param {string} message
       * @param {number|null} code
       * @param {string} reason
       */
      static createUnvalidatedWebSocketError(message, code, reason) {
        const error = new _WebSocketError(message, kConstruct);
        error.#closeCode = code;
        error.#reason = reason;
        return error;
      }
    };
    var { createUnvalidatedWebSocketError } = WebSocketError;
    delete WebSocketError.createUnvalidatedWebSocketError;
    Object.defineProperties(WebSocketError.prototype, {
      closeCode: kEnumerableProperty,
      reason: kEnumerableProperty,
      [Symbol.toStringTag]: {
        value: "WebSocketError",
        writable: false,
        enumerable: false,
        configurable: true
      }
    });
    webidl.is.WebSocketError = webidl.util.MakeTypeAssertion(WebSocketError);
    module2.exports = { WebSocketError, createUnvalidatedWebSocketError };
  }
});

// node_modules/undici/lib/web/websocket/stream/websocketstream.js
var require_websocketstream = __commonJS({
  "node_modules/undici/lib/web/websocket/stream/websocketstream.js"(exports2, module2) {
    "use strict";
    var { createDeferredPromise } = require_promise();
    var { environmentSettingsObject } = require_util5();
    var { states, opcodes, sentCloseFrameState } = require_constants7();
    var { webidl } = require_webidl();
    var { getURLRecord, isValidSubprotocol, isEstablished, utf8Decode } = require_util8();
    var { establishWebSocketConnection, failWebsocketConnection, closeWebSocketConnection } = require_connection();
    var { types } = require("node:util");
    var { channels } = require_diagnostics();
    var { WebsocketFrameSend } = require_frame();
    var { ByteParser } = require_receiver();
    var { WebSocketError, createUnvalidatedWebSocketError } = require_websocketerror();
    var { utf8DecodeBytes } = require_util5();
    var { kEnumerableProperty } = require_util4();
    var emittedExperimentalWarning = false;
    var WebSocketStream = class {
      // Each WebSocketStream object has an associated url , which is a URL record .
      /** @type {URL} */
      #url;
      // Each WebSocketStream object has an associated opened promise , which is a promise.
      /** @type {import('../../../util/promise').DeferredPromise} */
      #openedPromise;
      // Each WebSocketStream object has an associated closed promise , which is a promise.
      /** @type {import('../../../util/promise').DeferredPromise} */
      #closedPromise;
      // Each WebSocketStream object has an associated readable stream , which is a ReadableStream .
      /** @type {ReadableStream} */
      #readableStream;
      /** @type {ReadableStreamDefaultController} */
      #readableStreamController;
      // Each WebSocketStream object has an associated writable stream , which is a WritableStream .
      /** @type {WritableStream} */
      #writableStream;
      // Each WebSocketStream object has an associated boolean handshake aborted , which is initially false.
      #handshakeAborted = false;
      /** @type {import('../websocket').Handler} */
      #handler = {
        // https://whatpr.org/websockets/48/7b748d3...d5570f3.html#feedback-to-websocket-stream-from-the-protocol
        onConnectionEstablished: (response, extensions) => this.#onConnectionEstablished(response, extensions),
        onFail: (_code, _reason) => {
        },
        onMessage: (opcode, data) => this.#onMessage(opcode, data),
        onParserError: (err) => failWebsocketConnection(this.#handler, null, err.message),
        onParserDrain: () => this.#handler.socket.resume(),
        onSocketData: (chunk) => {
          if (!this.#parser.write(chunk)) {
            this.#handler.socket.pause();
          }
        },
        onSocketError: (err) => {
          this.#handler.readyState = states.CLOSING;
          if (channels.socketError.hasSubscribers) {
            channels.socketError.publish(err);
          }
          this.#handler.socket.destroy();
        },
        onSocketClose: () => this.#onSocketClose(),
        onPing: () => {
        },
        onPong: () => {
        },
        readyState: states.CONNECTING,
        socket: null,
        closeState: /* @__PURE__ */ new Set(),
        controller: null,
        wasEverConnected: false
      };
      /** @type {import('../receiver').ByteParser} */
      #parser;
      constructor(url, options = void 0) {
        if (!emittedExperimentalWarning) {
          process.emitWarning("WebSocketStream is experimental! Expect it to change at any time.", {
            code: "UNDICI-WSS"
          });
          emittedExperimentalWarning = true;
        }
        webidl.argumentLengthCheck(arguments, 1, "WebSocket");
        url = webidl.converters.USVString(url);
        if (options !== null) {
          options = webidl.converters.WebSocketStreamOptions(options);
        }
        const baseURL = environmentSettingsObject.settingsObject.baseUrl;
        const urlRecord = getURLRecord(url, baseURL);
        const protocols = options.protocols;
        if (protocols.length !== new Set(protocols.map((p) => p.toLowerCase())).size) {
          throw new DOMException("Invalid Sec-WebSocket-Protocol value", "SyntaxError");
        }
        if (protocols.length > 0 && !protocols.every((p) => isValidSubprotocol(p))) {
          throw new DOMException("Invalid Sec-WebSocket-Protocol value", "SyntaxError");
        }
        this.#url = urlRecord.toString();
        this.#openedPromise = createDeferredPromise();
        this.#closedPromise = createDeferredPromise();
        if (options.signal != null) {
          const signal = options.signal;
          if (signal.aborted) {
            this.#openedPromise.reject(signal.reason);
            this.#closedPromise.reject(signal.reason);
            return;
          }
          signal.addEventListener("abort", () => {
            if (!isEstablished(this.#handler.readyState)) {
              failWebsocketConnection(this.#handler);
              this.#handler.readyState = states.CLOSING;
              this.#openedPromise.reject(signal.reason);
              this.#closedPromise.reject(signal.reason);
              this.#handshakeAborted = true;
            }
          }, { once: true });
        }
        const client = environmentSettingsObject.settingsObject;
        this.#handler.controller = establishWebSocketConnection(
          urlRecord,
          protocols,
          client,
          this.#handler,
          options
        );
      }
      // The url getter steps are to return this 's url , serialized .
      get url() {
        return this.#url.toString();
      }
      // The opened getter steps are to return this 's opened promise .
      get opened() {
        return this.#openedPromise.promise;
      }
      // The closed getter steps are to return this 's closed promise .
      get closed() {
        return this.#closedPromise.promise;
      }
      // The close( closeInfo ) method steps are:
      close(closeInfo = void 0) {
        if (closeInfo !== null) {
          closeInfo = webidl.converters.WebSocketCloseInfo(closeInfo);
        }
        const code = closeInfo.closeCode ?? null;
        const reason = closeInfo.reason;
        closeWebSocketConnection(this.#handler, code, reason, true);
      }
      #write(chunk) {
        const promise = createDeferredPromise();
        let data = null;
        let opcode = null;
        if (ArrayBuffer.isView(chunk) || types.isArrayBuffer(chunk)) {
          data = new Uint8Array(ArrayBuffer.isView(chunk) ? new Uint8Array(chunk.buffer, chunk.byteOffset, chunk.byteLength) : chunk);
          opcode = opcodes.BINARY;
        } else {
          let string;
          try {
            string = webidl.converters.DOMString(chunk);
          } catch (e) {
            promise.reject(e);
            return;
          }
          data = new TextEncoder().encode(string);
          opcode = opcodes.TEXT;
        }
        if (!this.#handler.closeState.has(sentCloseFrameState.SENT) && !this.#handler.closeState.has(sentCloseFrameState.RECEIVED)) {
          const frame = new WebsocketFrameSend(data);
          this.#handler.socket.write(frame.createFrame(opcode), () => {
            promise.resolve(void 0);
          });
        }
        return promise;
      }
      /** @type {import('../websocket').Handler['onConnectionEstablished']} */
      #onConnectionEstablished(response, parsedExtensions) {
        this.#handler.socket = response.socket;
        const parser = new ByteParser(this.#handler, parsedExtensions);
        parser.on("drain", () => this.#handler.onParserDrain());
        parser.on("error", (err) => this.#handler.onParserError(err));
        this.#parser = parser;
        this.#handler.readyState = states.OPEN;
        const extensions = parsedExtensions ?? "";
        const protocol = response.headersList.get("sec-websocket-protocol") ?? "";
        const readable = new ReadableStream({
          start: (controller) => {
            this.#readableStreamController = controller;
          },
          pull(controller) {
            let chunk;
            while (controller.desiredSize > 0 && (chunk = response.socket.read()) !== null) {
              controller.enqueue(chunk);
            }
          },
          cancel: (reason) => this.#cancel(reason)
        });
        const writable = new WritableStream({
          write: (chunk) => this.#write(chunk),
          close: () => closeWebSocketConnection(this.#handler, null, null),
          abort: (reason) => this.#closeUsingReason(reason)
        });
        this.#readableStream = readable;
        this.#writableStream = writable;
        this.#openedPromise.resolve({
          extensions,
          protocol,
          readable,
          writable
        });
      }
      /** @type {import('../websocket').Handler['onMessage']} */
      #onMessage(type, data) {
        if (this.#handler.readyState !== states.OPEN) {
          return;
        }
        let chunk;
        if (type === opcodes.TEXT) {
          try {
            chunk = utf8Decode(data);
          } catch {
            failWebsocketConnection(this.#handler, "Received invalid UTF-8 in text frame.");
            return;
          }
        } else if (type === opcodes.BINARY) {
          chunk = new Uint8Array(data.buffer, data.byteOffset, data.byteLength);
        }
        this.#readableStreamController.enqueue(chunk);
      }
      /** @type {import('../websocket').Handler['onSocketClose']} */
      #onSocketClose() {
        const wasClean = this.#handler.closeState.has(sentCloseFrameState.SENT) && this.#handler.closeState.has(sentCloseFrameState.RECEIVED);
        this.#handler.readyState = states.CLOSED;
        if (this.#handshakeAborted) {
          return;
        }
        if (!this.#handler.wasEverConnected) {
          this.#openedPromise.reject(new WebSocketError("Socket never opened"));
        }
        const result = this.#parser.closingInfo;
        let code = result?.code ?? 1005;
        if (!this.#handler.closeState.has(sentCloseFrameState.SENT) && !this.#handler.closeState.has(sentCloseFrameState.RECEIVED)) {
          code = 1006;
        }
        const reason = result?.reason == null ? "" : utf8DecodeBytes(Buffer.from(result.reason));
        if (wasClean) {
          this.#readableStreamController.close();
          if (!this.#writableStream.locked) {
            this.#writableStream.abort(new DOMException("A closed WebSocketStream cannot be written to", "InvalidStateError"));
          }
          this.#closedPromise.resolve({
            closeCode: code,
            reason
          });
        } else {
          const error = createUnvalidatedWebSocketError("unclean close", code, reason);
          this.#readableStreamController.error(error);
          this.#writableStream.abort(error);
          this.#closedPromise.reject(error);
        }
      }
      #closeUsingReason(reason) {
        let code = null;
        let reasonString = "";
        if (webidl.is.WebSocketError(reason)) {
          code = reason.closeCode;
          reasonString = reason.reason;
        }
        closeWebSocketConnection(this.#handler, code, reasonString);
      }
      //  To cancel a WebSocketStream stream given reason , close using reason giving stream and reason .
      #cancel(reason) {
        this.#closeUsingReason(reason);
      }
    };
    Object.defineProperties(WebSocketStream.prototype, {
      url: kEnumerableProperty,
      opened: kEnumerableProperty,
      closed: kEnumerableProperty,
      close: kEnumerableProperty,
      [Symbol.toStringTag]: {
        value: "WebSocketStream",
        writable: false,
        enumerable: false,
        configurable: true
      }
    });
    webidl.converters.WebSocketStreamOptions = webidl.dictionaryConverter([
      {
        key: "protocols",
        converter: webidl.sequenceConverter(webidl.converters.USVString),
        defaultValue: () => []
      },
      {
        key: "signal",
        converter: webidl.nullableConverter(webidl.converters.AbortSignal),
        defaultValue: () => null
      }
    ]);
    webidl.converters.WebSocketCloseInfo = webidl.dictionaryConverter([
      {
        key: "closeCode",
        converter: (V) => webidl.converters["unsigned short"](V, { enforceRange: true })
      },
      {
        key: "reason",
        converter: webidl.converters.USVString,
        defaultValue: () => ""
      }
    ]);
    module2.exports = { WebSocketStream };
  }
});

// node_modules/undici/lib/web/eventsource/util.js
var require_util9 = __commonJS({
  "node_modules/undici/lib/web/eventsource/util.js"(exports2, module2) {
    "use strict";
    function isValidLastEventId(value) {
      return value.indexOf("\0") === -1;
    }
    function isASCIINumber(value) {
      if (value.length === 0) return false;
      for (let i = 0; i < value.length; i++) {
        if (value.charCodeAt(i) < 48 || value.charCodeAt(i) > 57) return false;
      }
      return true;
    }
    function delay(ms) {
      return new Promise((resolve) => {
        setTimeout(resolve, ms);
      });
    }
    module2.exports = {
      isValidLastEventId,
      isASCIINumber,
      delay
    };
  }
});

// node_modules/undici/lib/web/eventsource/eventsource-stream.js
var require_eventsource_stream = __commonJS({
  "node_modules/undici/lib/web/eventsource/eventsource-stream.js"(exports2, module2) {
    "use strict";
    var { Transform } = require("node:stream");
    var { isASCIINumber, isValidLastEventId } = require_util9();
    var BOM = [239, 187, 191];
    var LF = 10;
    var CR = 13;
    var COLON = 58;
    var SPACE = 32;
    var EventSourceStream = class extends Transform {
      /**
       * @type {eventSourceSettings}
       */
      state;
      /**
       * Leading byte-order-mark check.
       * @type {boolean}
       */
      checkBOM = true;
      /**
       * @type {boolean}
       */
      crlfCheck = false;
      /**
       * @type {boolean}
       */
      eventEndCheck = false;
      /**
       * @type {Buffer|null}
       */
      buffer = null;
      pos = 0;
      event = {
        data: void 0,
        event: void 0,
        id: void 0,
        retry: void 0
      };
      /**
       * @param {object} options
       * @param {boolean} [options.readableObjectMode]
       * @param {eventSourceSettings} [options.eventSourceSettings]
       * @param {(chunk: any, encoding?: BufferEncoding | undefined) => boolean} [options.push]
       */
      constructor(options = {}) {
        options.readableObjectMode = true;
        super(options);
        this.state = options.eventSourceSettings || {};
        if (options.push) {
          this.push = options.push;
        }
      }
      /**
       * @param {Buffer} chunk
       * @param {string} _encoding
       * @param {Function} callback
       * @returns {void}
       */
      _transform(chunk, _encoding, callback) {
        if (chunk.length === 0) {
          callback();
          return;
        }
        if (this.buffer) {
          this.buffer = Buffer.concat([this.buffer, chunk]);
        } else {
          this.buffer = chunk;
        }
        if (this.checkBOM) {
          switch (this.buffer.length) {
            case 1:
              if (this.buffer[0] === BOM[0]) {
                callback();
                return;
              }
              this.checkBOM = false;
              callback();
              return;
            case 2:
              if (this.buffer[0] === BOM[0] && this.buffer[1] === BOM[1]) {
                callback();
                return;
              }
              this.checkBOM = false;
              break;
            case 3:
              if (this.buffer[0] === BOM[0] && this.buffer[1] === BOM[1] && this.buffer[2] === BOM[2]) {
                this.buffer = Buffer.alloc(0);
                this.checkBOM = false;
                callback();
                return;
              }
              this.checkBOM = false;
              break;
            default:
              if (this.buffer[0] === BOM[0] && this.buffer[1] === BOM[1] && this.buffer[2] === BOM[2]) {
                this.buffer = this.buffer.subarray(3);
              }
              this.checkBOM = false;
              break;
          }
        }
        while (this.pos < this.buffer.length) {
          if (this.eventEndCheck) {
            if (this.crlfCheck) {
              if (this.buffer[this.pos] === LF) {
                this.buffer = this.buffer.subarray(this.pos + 1);
                this.pos = 0;
                this.crlfCheck = false;
                continue;
              }
              this.crlfCheck = false;
            }
            if (this.buffer[this.pos] === LF || this.buffer[this.pos] === CR) {
              if (this.buffer[this.pos] === CR) {
                this.crlfCheck = true;
              }
              this.buffer = this.buffer.subarray(this.pos + 1);
              this.pos = 0;
              if (this.event.data !== void 0 || this.event.event || this.event.id || this.event.retry) {
                this.processEvent(this.event);
              }
              this.clearEvent();
              continue;
            }
            this.eventEndCheck = false;
            continue;
          }
          if (this.buffer[this.pos] === LF || this.buffer[this.pos] === CR) {
            if (this.buffer[this.pos] === CR) {
              this.crlfCheck = true;
            }
            this.parseLine(this.buffer.subarray(0, this.pos), this.event);
            this.buffer = this.buffer.subarray(this.pos + 1);
            this.pos = 0;
            this.eventEndCheck = true;
            continue;
          }
          this.pos++;
        }
        callback();
      }
      /**
       * @param {Buffer} line
       * @param {EventSourceStreamEvent} event
       */
      parseLine(line, event) {
        if (line.length === 0) {
          return;
        }
        const colonPosition = line.indexOf(COLON);
        if (colonPosition === 0) {
          return;
        }
        let field = "";
        let value = "";
        if (colonPosition !== -1) {
          field = line.subarray(0, colonPosition).toString("utf8");
          let valueStart = colonPosition + 1;
          if (line[valueStart] === SPACE) {
            ++valueStart;
          }
          value = line.subarray(valueStart).toString("utf8");
        } else {
          field = line.toString("utf8");
          value = "";
        }
        switch (field) {
          case "data":
            if (event[field] === void 0) {
              event[field] = value;
            } else {
              event[field] += `
${value}`;
            }
            break;
          case "retry":
            if (isASCIINumber(value)) {
              event[field] = value;
            }
            break;
          case "id":
            if (isValidLastEventId(value)) {
              event[field] = value;
            }
            break;
          case "event":
            if (value.length > 0) {
              event[field] = value;
            }
            break;
        }
      }
      /**
       * @param {EventSourceStreamEvent} event
       */
      processEvent(event) {
        if (event.retry && isASCIINumber(event.retry)) {
          this.state.reconnectionTime = parseInt(event.retry, 10);
        }
        if (event.id && isValidLastEventId(event.id)) {
          this.state.lastEventId = event.id;
        }
        if (event.data !== void 0) {
          this.push({
            type: event.event || "message",
            options: {
              data: event.data,
              lastEventId: this.state.lastEventId,
              origin: this.state.origin
            }
          });
        }
      }
      clearEvent() {
        this.event = {
          data: void 0,
          event: void 0,
          id: void 0,
          retry: void 0
        };
      }
    };
    module2.exports = {
      EventSourceStream
    };
  }
});

// node_modules/undici/lib/web/eventsource/eventsource.js
var require_eventsource = __commonJS({
  "node_modules/undici/lib/web/eventsource/eventsource.js"(exports2, module2) {
    "use strict";
    var { pipeline } = require("node:stream");
    var { fetching } = require_fetch();
    var { makeRequest } = require_request4();
    var { webidl } = require_webidl();
    var { EventSourceStream } = require_eventsource_stream();
    var { parseMIMEType } = require_data_url();
    var { createFastMessageEvent } = require_events();
    var { isNetworkError } = require_response2();
    var { delay } = require_util9();
    var { kEnumerableProperty } = require_util4();
    var { environmentSettingsObject } = require_util5();
    var experimentalWarned = false;
    var defaultReconnectionTime = 3e3;
    var CONNECTING = 0;
    var OPEN = 1;
    var CLOSED = 2;
    var ANONYMOUS = "anonymous";
    var USE_CREDENTIALS = "use-credentials";
    var EventSource = class _EventSource extends EventTarget {
      #events = {
        open: null,
        error: null,
        message: null
      };
      #url;
      #withCredentials = false;
      /**
       * @type {ReadyState}
       */
      #readyState = CONNECTING;
      #request = null;
      #controller = null;
      #dispatcher;
      /**
       * @type {import('./eventsource-stream').eventSourceSettings}
       */
      #state;
      /**
       * Creates a new EventSource object.
       * @param {string} url
       * @param {EventSourceInit} [eventSourceInitDict={}]
       * @see https://html.spec.whatwg.org/multipage/server-sent-events.html#the-eventsource-interface
       */
      constructor(url, eventSourceInitDict = {}) {
        super();
        webidl.util.markAsUncloneable(this);
        const prefix = "EventSource constructor";
        webidl.argumentLengthCheck(arguments, 1, prefix);
        if (!experimentalWarned) {
          experimentalWarned = true;
          process.emitWarning("EventSource is experimental, expect them to change at any time.", {
            code: "UNDICI-ES"
          });
        }
        url = webidl.converters.USVString(url);
        eventSourceInitDict = webidl.converters.EventSourceInitDict(eventSourceInitDict, prefix, "eventSourceInitDict");
        this.#dispatcher = eventSourceInitDict.dispatcher;
        this.#state = {
          lastEventId: "",
          reconnectionTime: defaultReconnectionTime
        };
        const settings = environmentSettingsObject;
        let urlRecord;
        try {
          urlRecord = new URL(url, settings.settingsObject.baseUrl);
          this.#state.origin = urlRecord.origin;
        } catch (e) {
          throw new DOMException(e, "SyntaxError");
        }
        this.#url = urlRecord.href;
        let corsAttributeState = ANONYMOUS;
        if (eventSourceInitDict.withCredentials === true) {
          corsAttributeState = USE_CREDENTIALS;
          this.#withCredentials = true;
        }
        const initRequest = {
          redirect: "follow",
          keepalive: true,
          // @see https://html.spec.whatwg.org/multipage/urls-and-fetching.html#cors-settings-attributes
          mode: "cors",
          credentials: corsAttributeState === "anonymous" ? "same-origin" : "omit",
          referrer: "no-referrer"
        };
        initRequest.client = environmentSettingsObject.settingsObject;
        initRequest.headersList = [["accept", { name: "accept", value: "text/event-stream" }]];
        initRequest.cache = "no-store";
        initRequest.initiator = "other";
        initRequest.urlList = [new URL(this.#url)];
        this.#request = makeRequest(initRequest);
        this.#connect();
      }
      /**
       * Returns the state of this EventSource object's connection. It can have the
       * values described below.
       * @returns {ReadyState}
       * @readonly
       */
      get readyState() {
        return this.#readyState;
      }
      /**
       * Returns the URL providing the event stream.
       * @readonly
       * @returns {string}
       */
      get url() {
        return this.#url;
      }
      /**
       * Returns a boolean indicating whether the EventSource object was
       * instantiated with CORS credentials set (true), or not (false, the default).
       */
      get withCredentials() {
        return this.#withCredentials;
      }
      #connect() {
        if (this.#readyState === CLOSED) return;
        this.#readyState = CONNECTING;
        const fetchParams = {
          request: this.#request,
          dispatcher: this.#dispatcher
        };
        const processEventSourceEndOfBody = (response) => {
          if (!isNetworkError(response)) {
            return this.#reconnect();
          }
        };
        fetchParams.processResponseEndOfBody = processEventSourceEndOfBody;
        fetchParams.processResponse = (response) => {
          if (isNetworkError(response)) {
            if (response.aborted) {
              this.close();
              this.dispatchEvent(new Event("error"));
              return;
            } else {
              this.#reconnect();
              return;
            }
          }
          const contentType = response.headersList.get("content-type", true);
          const mimeType = contentType !== null ? parseMIMEType(contentType) : "failure";
          const contentTypeValid = mimeType !== "failure" && mimeType.essence === "text/event-stream";
          if (response.status !== 200 || contentTypeValid === false) {
            this.close();
            this.dispatchEvent(new Event("error"));
            return;
          }
          this.#readyState = OPEN;
          this.dispatchEvent(new Event("open"));
          this.#state.origin = response.urlList[response.urlList.length - 1].origin;
          const eventSourceStream = new EventSourceStream({
            eventSourceSettings: this.#state,
            push: (event) => {
              this.dispatchEvent(createFastMessageEvent(
                event.type,
                event.options
              ));
            }
          });
          pipeline(
            response.body.stream,
            eventSourceStream,
            (error) => {
              if (error?.aborted === false) {
                this.close();
                this.dispatchEvent(new Event("error"));
              }
            }
          );
        };
        this.#controller = fetching(fetchParams);
      }
      /**
       * @see https://html.spec.whatwg.org/multipage/server-sent-events.html#sse-processing-model
       * @returns {Promise<void>}
       */
      async #reconnect() {
        if (this.#readyState === CLOSED) return;
        this.#readyState = CONNECTING;
        this.dispatchEvent(new Event("error"));
        await delay(this.#state.reconnectionTime);
        if (this.#readyState !== CONNECTING) return;
        if (this.#state.lastEventId.length) {
          this.#request.headersList.set("last-event-id", this.#state.lastEventId, true);
        }
        this.#connect();
      }
      /**
       * Closes the connection, if any, and sets the readyState attribute to
       * CLOSED.
       */
      close() {
        webidl.brandCheck(this, _EventSource);
        if (this.#readyState === CLOSED) return;
        this.#readyState = CLOSED;
        this.#controller.abort();
        this.#request = null;
      }
      get onopen() {
        return this.#events.open;
      }
      set onopen(fn) {
        if (this.#events.open) {
          this.removeEventListener("open", this.#events.open);
        }
        if (typeof fn === "function") {
          this.#events.open = fn;
          this.addEventListener("open", fn);
        } else {
          this.#events.open = null;
        }
      }
      get onmessage() {
        return this.#events.message;
      }
      set onmessage(fn) {
        if (this.#events.message) {
          this.removeEventListener("message", this.#events.message);
        }
        if (typeof fn === "function") {
          this.#events.message = fn;
          this.addEventListener("message", fn);
        } else {
          this.#events.message = null;
        }
      }
      get onerror() {
        return this.#events.error;
      }
      set onerror(fn) {
        if (this.#events.error) {
          this.removeEventListener("error", this.#events.error);
        }
        if (typeof fn === "function") {
          this.#events.error = fn;
          this.addEventListener("error", fn);
        } else {
          this.#events.error = null;
        }
      }
    };
    var constantsPropertyDescriptors = {
      CONNECTING: {
        __proto__: null,
        configurable: false,
        enumerable: true,
        value: CONNECTING,
        writable: false
      },
      OPEN: {
        __proto__: null,
        configurable: false,
        enumerable: true,
        value: OPEN,
        writable: false
      },
      CLOSED: {
        __proto__: null,
        configurable: false,
        enumerable: true,
        value: CLOSED,
        writable: false
      }
    };
    Object.defineProperties(EventSource, constantsPropertyDescriptors);
    Object.defineProperties(EventSource.prototype, constantsPropertyDescriptors);
    Object.defineProperties(EventSource.prototype, {
      close: kEnumerableProperty,
      onerror: kEnumerableProperty,
      onmessage: kEnumerableProperty,
      onopen: kEnumerableProperty,
      readyState: kEnumerableProperty,
      url: kEnumerableProperty,
      withCredentials: kEnumerableProperty
    });
    webidl.converters.EventSourceInitDict = webidl.dictionaryConverter([
      {
        key: "withCredentials",
        converter: webidl.converters.boolean,
        defaultValue: () => false
      },
      {
        key: "dispatcher",
        // undici only
        converter: webidl.converters.any
      }
    ]);
    module2.exports = {
      EventSource,
      defaultReconnectionTime
    };
  }
});

// node_modules/undici/index.js
var require_undici = __commonJS({
  "node_modules/undici/index.js"(exports2, module2) {
    "use strict";
    var Client = require_client();
    var Dispatcher = require_dispatcher();
    var Pool = require_pool();
    var BalancedPool = require_balanced_pool();
    var Agent = require_agent();
    var ProxyAgent = require_proxy_agent();
    var EnvHttpProxyAgent = require_env_http_proxy_agent();
    var RetryAgent = require_retry_agent();
    var H2CClient = require_h2c_client();
    var errors = require_errors5();
    var util = require_util4();
    var { InvalidArgumentError } = errors;
    var api = require_api();
    var buildConnector = require_connect();
    var MockClient = require_mock_client();
    var { MockCallHistory, MockCallHistoryLog } = require_mock_call_history();
    var MockAgent = require_mock_agent();
    var MockPool = require_mock_pool();
    var SnapshotAgent = require_snapshot_agent();
    var mockErrors = require_mock_errors();
    var RetryHandler = require_retry_handler();
    var { getGlobalDispatcher, setGlobalDispatcher } = require_global2();
    var DecoratorHandler = require_decorator_handler();
    var RedirectHandler = require_redirect_handler();
    Object.assign(Dispatcher.prototype, api);
    module2.exports.Dispatcher = Dispatcher;
    module2.exports.Client = Client;
    module2.exports.Pool = Pool;
    module2.exports.BalancedPool = BalancedPool;
    module2.exports.Agent = Agent;
    module2.exports.ProxyAgent = ProxyAgent;
    module2.exports.EnvHttpProxyAgent = EnvHttpProxyAgent;
    module2.exports.RetryAgent = RetryAgent;
    module2.exports.H2CClient = H2CClient;
    module2.exports.RetryHandler = RetryHandler;
    module2.exports.DecoratorHandler = DecoratorHandler;
    module2.exports.RedirectHandler = RedirectHandler;
    module2.exports.interceptors = {
      redirect: require_redirect(),
      responseError: require_response_error(),
      retry: require_retry(),
      dump: require_dump(),
      dns: require_dns(),
      cache: require_cache2()
    };
    module2.exports.cacheStores = {
      MemoryCacheStore: require_memory_cache_store()
    };
    var SqliteCacheStore = require_sqlite_cache_store();
    module2.exports.cacheStores.SqliteCacheStore = SqliteCacheStore;
    module2.exports.buildConnector = buildConnector;
    module2.exports.errors = errors;
    module2.exports.util = {
      parseHeaders: util.parseHeaders,
      headerNameToString: util.headerNameToString
    };
    function makeDispatcher(fn) {
      return (url, opts, handler) => {
        if (typeof opts === "function") {
          handler = opts;
          opts = null;
        }
        if (!url || typeof url !== "string" && typeof url !== "object" && !(url instanceof URL)) {
          throw new InvalidArgumentError("invalid url");
        }
        if (opts != null && typeof opts !== "object") {
          throw new InvalidArgumentError("invalid opts");
        }
        if (opts && opts.path != null) {
          if (typeof opts.path !== "string") {
            throw new InvalidArgumentError("invalid opts.path");
          }
          let path4 = opts.path;
          if (!opts.path.startsWith("/")) {
            path4 = `/${path4}`;
          }
          url = new URL(util.parseOrigin(url).origin + path4);
        } else {
          if (!opts) {
            opts = typeof url === "object" ? url : {};
          }
          url = util.parseURL(url);
        }
        const { agent, dispatcher = getGlobalDispatcher() } = opts;
        if (agent) {
          throw new InvalidArgumentError("unsupported opts.agent. Did you mean opts.client?");
        }
        return fn.call(dispatcher, {
          ...opts,
          origin: url.origin,
          path: url.search ? `${url.pathname}${url.search}` : url.pathname,
          method: opts.method || (opts.body ? "PUT" : "GET")
        }, handler);
      };
    }
    module2.exports.setGlobalDispatcher = setGlobalDispatcher;
    module2.exports.getGlobalDispatcher = getGlobalDispatcher;
    var fetchImpl = require_fetch().fetch;
    module2.exports.fetch = async function fetch2(init, options = void 0) {
      try {
        return await fetchImpl(init, options);
      } catch (err) {
        if (err && typeof err === "object") {
          Error.captureStackTrace(err);
        }
        throw err;
      }
    };
    module2.exports.Headers = require_headers().Headers;
    module2.exports.Response = require_response2().Response;
    module2.exports.Request = require_request4().Request;
    module2.exports.FormData = require_formdata().FormData;
    var { setGlobalOrigin, getGlobalOrigin } = require_global();
    module2.exports.setGlobalOrigin = setGlobalOrigin;
    module2.exports.getGlobalOrigin = getGlobalOrigin;
    var { CacheStorage } = require_cachestorage();
    var { kConstruct } = require_symbols4();
    module2.exports.caches = new CacheStorage(kConstruct);
    var { deleteCookie, getCookies, getSetCookies, setCookie, parseCookie } = require_cookies();
    module2.exports.deleteCookie = deleteCookie;
    module2.exports.getCookies = getCookies;
    module2.exports.getSetCookies = getSetCookies;
    module2.exports.setCookie = setCookie;
    module2.exports.parseCookie = parseCookie;
    var { parseMIMEType, serializeAMimeType } = require_data_url();
    module2.exports.parseMIMEType = parseMIMEType;
    module2.exports.serializeAMimeType = serializeAMimeType;
    var { CloseEvent, ErrorEvent, MessageEvent } = require_events();
    var { WebSocket, ping } = require_websocket();
    module2.exports.WebSocket = WebSocket;
    module2.exports.CloseEvent = CloseEvent;
    module2.exports.ErrorEvent = ErrorEvent;
    module2.exports.MessageEvent = MessageEvent;
    module2.exports.ping = ping;
    module2.exports.WebSocketStream = require_websocketstream().WebSocketStream;
    module2.exports.WebSocketError = require_websocketerror().WebSocketError;
    module2.exports.request = makeDispatcher(api.request);
    module2.exports.stream = makeDispatcher(api.stream);
    module2.exports.pipeline = makeDispatcher(api.pipeline);
    module2.exports.connect = makeDispatcher(api.connect);
    module2.exports.upgrade = makeDispatcher(api.upgrade);
    module2.exports.MockClient = MockClient;
    module2.exports.MockCallHistory = MockCallHistory;
    module2.exports.MockCallHistoryLog = MockCallHistoryLog;
    module2.exports.MockPool = MockPool;
    module2.exports.MockAgent = MockAgent;
    module2.exports.SnapshotAgent = SnapshotAgent;
    module2.exports.mockErrors = mockErrors;
    var { EventSource } = require_eventsource();
    module2.exports.EventSource = EventSource;
    function install() {
      globalThis.fetch = module2.exports.fetch;
      globalThis.Headers = module2.exports.Headers;
      globalThis.Response = module2.exports.Response;
      globalThis.Request = module2.exports.Request;
      globalThis.FormData = module2.exports.FormData;
      globalThis.WebSocket = module2.exports.WebSocket;
      globalThis.CloseEvent = module2.exports.CloseEvent;
      globalThis.ErrorEvent = module2.exports.ErrorEvent;
      globalThis.MessageEvent = module2.exports.MessageEvent;
      globalThis.EventSource = module2.exports.EventSource;
    }
    module2.exports.install = install;
  }
});

// node_modules/@isaacs/balanced-match/dist/commonjs/index.js
var require_commonjs = __commonJS({
  "node_modules/@isaacs/balanced-match/dist/commonjs/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.range = exports2.balanced = void 0;
    var balanced = (a, b, str) => {
      const ma = a instanceof RegExp ? maybeMatch(a, str) : a;
      const mb = b instanceof RegExp ? maybeMatch(b, str) : b;
      const r = ma !== null && mb != null && (0, exports2.range)(ma, mb, str);
      return r && {
        start: r[0],
        end: r[1],
        pre: str.slice(0, r[0]),
        body: str.slice(r[0] + ma.length, r[1]),
        post: str.slice(r[1] + mb.length)
      };
    };
    exports2.balanced = balanced;
    var maybeMatch = (reg, str) => {
      const m = str.match(reg);
      return m ? m[0] : null;
    };
    var range = (a, b, str) => {
      let begs, beg, left, right = void 0, result;
      let ai = str.indexOf(a);
      let bi2 = str.indexOf(b, ai + 1);
      let i = ai;
      if (ai >= 0 && bi2 > 0) {
        if (a === b) {
          return [ai, bi2];
        }
        begs = [];
        left = str.length;
        while (i >= 0 && !result) {
          if (i === ai) {
            begs.push(i);
            ai = str.indexOf(a, i + 1);
          } else if (begs.length === 1) {
            const r = begs.pop();
            if (r !== void 0)
              result = [r, bi2];
          } else {
            beg = begs.pop();
            if (beg !== void 0 && beg < left) {
              left = beg;
              right = bi2;
            }
            bi2 = str.indexOf(b, i + 1);
          }
          i = ai < bi2 && ai >= 0 ? ai : bi2;
        }
        if (begs.length && right !== void 0) {
          result = [left, right];
        }
      }
      return result;
    };
    exports2.range = range;
  }
});

// node_modules/@isaacs/brace-expansion/dist/commonjs/index.js
var require_commonjs2 = __commonJS({
  "node_modules/@isaacs/brace-expansion/dist/commonjs/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.expand = expand;
    var balanced_match_1 = require_commonjs();
    var escSlash = "\0SLASH" + Math.random() + "\0";
    var escOpen = "\0OPEN" + Math.random() + "\0";
    var escClose = "\0CLOSE" + Math.random() + "\0";
    var escComma = "\0COMMA" + Math.random() + "\0";
    var escPeriod = "\0PERIOD" + Math.random() + "\0";
    var escSlashPattern = new RegExp(escSlash, "g");
    var escOpenPattern = new RegExp(escOpen, "g");
    var escClosePattern = new RegExp(escClose, "g");
    var escCommaPattern = new RegExp(escComma, "g");
    var escPeriodPattern = new RegExp(escPeriod, "g");
    var slashPattern = /\\\\/g;
    var openPattern = /\\{/g;
    var closePattern = /\\}/g;
    var commaPattern = /\\,/g;
    var periodPattern = /\\./g;
    function numeric(str) {
      return !isNaN(str) ? parseInt(str, 10) : str.charCodeAt(0);
    }
    function escapeBraces(str) {
      return str.replace(slashPattern, escSlash).replace(openPattern, escOpen).replace(closePattern, escClose).replace(commaPattern, escComma).replace(periodPattern, escPeriod);
    }
    function unescapeBraces(str) {
      return str.replace(escSlashPattern, "\\").replace(escOpenPattern, "{").replace(escClosePattern, "}").replace(escCommaPattern, ",").replace(escPeriodPattern, ".");
    }
    function parseCommaParts(str) {
      if (!str) {
        return [""];
      }
      const parts = [];
      const m = (0, balanced_match_1.balanced)("{", "}", str);
      if (!m) {
        return str.split(",");
      }
      const { pre, body, post } = m;
      const p = pre.split(",");
      p[p.length - 1] += "{" + body + "}";
      const postParts = parseCommaParts(post);
      if (post.length) {
        ;
        p[p.length - 1] += postParts.shift();
        p.push.apply(p, postParts);
      }
      parts.push.apply(parts, p);
      return parts;
    }
    function expand(str) {
      if (!str) {
        return [];
      }
      if (str.slice(0, 2) === "{}") {
        str = "\\{\\}" + str.slice(2);
      }
      return expand_(escapeBraces(str), true).map(unescapeBraces);
    }
    function embrace(str) {
      return "{" + str + "}";
    }
    function isPadded(el) {
      return /^-?0\d/.test(el);
    }
    function lte(i, y) {
      return i <= y;
    }
    function gte(i, y) {
      return i >= y;
    }
    function expand_(str, isTop) {
      const expansions = [];
      const m = (0, balanced_match_1.balanced)("{", "}", str);
      if (!m)
        return [str];
      const pre = m.pre;
      const post = m.post.length ? expand_(m.post, false) : [""];
      if (/\$$/.test(m.pre)) {
        for (let k = 0; k < post.length; k++) {
          const expansion = pre + "{" + m.body + "}" + post[k];
          expansions.push(expansion);
        }
      } else {
        const isNumericSequence = /^-?\d+\.\.-?\d+(?:\.\.-?\d+)?$/.test(m.body);
        const isAlphaSequence = /^[a-zA-Z]\.\.[a-zA-Z](?:\.\.-?\d+)?$/.test(m.body);
        const isSequence = isNumericSequence || isAlphaSequence;
        const isOptions = m.body.indexOf(",") >= 0;
        if (!isSequence && !isOptions) {
          if (m.post.match(/,(?!,).*\}/)) {
            str = m.pre + "{" + m.body + escClose + m.post;
            return expand_(str);
          }
          return [str];
        }
        let n;
        if (isSequence) {
          n = m.body.split(/\.\./);
        } else {
          n = parseCommaParts(m.body);
          if (n.length === 1 && n[0] !== void 0) {
            n = expand_(n[0], false).map(embrace);
            if (n.length === 1) {
              return post.map((p) => m.pre + n[0] + p);
            }
          }
        }
        let N;
        if (isSequence && n[0] !== void 0 && n[1] !== void 0) {
          const x = numeric(n[0]);
          const y = numeric(n[1]);
          const width = Math.max(n[0].length, n[1].length);
          let incr = n.length === 3 && n[2] !== void 0 ? Math.abs(numeric(n[2])) : 1;
          let test = lte;
          const reverse = y < x;
          if (reverse) {
            incr *= -1;
            test = gte;
          }
          const pad = n.some(isPadded);
          N = [];
          for (let i = x; test(i, y); i += incr) {
            let c;
            if (isAlphaSequence) {
              c = String.fromCharCode(i);
              if (c === "\\") {
                c = "";
              }
            } else {
              c = String(i);
              if (pad) {
                const need = width - c.length;
                if (need > 0) {
                  const z2 = new Array(need + 1).join("0");
                  if (i < 0) {
                    c = "-" + z2 + c.slice(1);
                  } else {
                    c = z2 + c;
                  }
                }
              }
            }
            N.push(c);
          }
        } else {
          N = [];
          for (let j = 0; j < n.length; j++) {
            N.push.apply(N, expand_(n[j], false));
          }
        }
        for (let j = 0; j < N.length; j++) {
          for (let k = 0; k < post.length; k++) {
            const expansion = pre + N[j] + post[k];
            if (!isTop || isSequence || expansion) {
              expansions.push(expansion);
            }
          }
        }
      }
      return expansions;
    }
  }
});

// node_modules/minimatch/dist/commonjs/assert-valid-pattern.js
var require_assert_valid_pattern = __commonJS({
  "node_modules/minimatch/dist/commonjs/assert-valid-pattern.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.assertValidPattern = void 0;
    var MAX_PATTERN_LENGTH = 1024 * 64;
    var assertValidPattern = (pattern) => {
      if (typeof pattern !== "string") {
        throw new TypeError("invalid pattern");
      }
      if (pattern.length > MAX_PATTERN_LENGTH) {
        throw new TypeError("pattern is too long");
      }
    };
    exports2.assertValidPattern = assertValidPattern;
  }
});

// node_modules/minimatch/dist/commonjs/brace-expressions.js
var require_brace_expressions = __commonJS({
  "node_modules/minimatch/dist/commonjs/brace-expressions.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.parseClass = void 0;
    var posixClasses = {
      "[:alnum:]": ["\\p{L}\\p{Nl}\\p{Nd}", true],
      "[:alpha:]": ["\\p{L}\\p{Nl}", true],
      "[:ascii:]": ["\\x00-\\x7f", false],
      "[:blank:]": ["\\p{Zs}\\t", true],
      "[:cntrl:]": ["\\p{Cc}", true],
      "[:digit:]": ["\\p{Nd}", true],
      "[:graph:]": ["\\p{Z}\\p{C}", true, true],
      "[:lower:]": ["\\p{Ll}", true],
      "[:print:]": ["\\p{C}", true],
      "[:punct:]": ["\\p{P}", true],
      "[:space:]": ["\\p{Z}\\t\\r\\n\\v\\f", true],
      "[:upper:]": ["\\p{Lu}", true],
      "[:word:]": ["\\p{L}\\p{Nl}\\p{Nd}\\p{Pc}", true],
      "[:xdigit:]": ["A-Fa-f0-9", false]
    };
    var braceEscape = (s) => s.replace(/[[\]\\-]/g, "\\$&");
    var regexpEscape = (s) => s.replace(/[-[\]{}()*+?.,\\^$|#\s]/g, "\\$&");
    var rangesToString = (ranges) => ranges.join("");
    var parseClass = (glob, position) => {
      const pos = position;
      if (glob.charAt(pos) !== "[") {
        throw new Error("not in a brace expression");
      }
      const ranges = [];
      const negs = [];
      let i = pos + 1;
      let sawStart = false;
      let uflag = false;
      let escaping = false;
      let negate = false;
      let endPos = pos;
      let rangeStart = "";
      WHILE: while (i < glob.length) {
        const c = glob.charAt(i);
        if ((c === "!" || c === "^") && i === pos + 1) {
          negate = true;
          i++;
          continue;
        }
        if (c === "]" && sawStart && !escaping) {
          endPos = i + 1;
          break;
        }
        sawStart = true;
        if (c === "\\") {
          if (!escaping) {
            escaping = true;
            i++;
            continue;
          }
        }
        if (c === "[" && !escaping) {
          for (const [cls, [unip, u, neg]] of Object.entries(posixClasses)) {
            if (glob.startsWith(cls, i)) {
              if (rangeStart) {
                return ["$.", false, glob.length - pos, true];
              }
              i += cls.length;
              if (neg)
                negs.push(unip);
              else
                ranges.push(unip);
              uflag = uflag || u;
              continue WHILE;
            }
          }
        }
        escaping = false;
        if (rangeStart) {
          if (c > rangeStart) {
            ranges.push(braceEscape(rangeStart) + "-" + braceEscape(c));
          } else if (c === rangeStart) {
            ranges.push(braceEscape(c));
          }
          rangeStart = "";
          i++;
          continue;
        }
        if (glob.startsWith("-]", i + 1)) {
          ranges.push(braceEscape(c + "-"));
          i += 2;
          continue;
        }
        if (glob.startsWith("-", i + 1)) {
          rangeStart = c;
          i += 2;
          continue;
        }
        ranges.push(braceEscape(c));
        i++;
      }
      if (endPos < i) {
        return ["", false, 0, false];
      }
      if (!ranges.length && !negs.length) {
        return ["$.", false, glob.length - pos, true];
      }
      if (negs.length === 0 && ranges.length === 1 && /^\\?.$/.test(ranges[0]) && !negate) {
        const r = ranges[0].length === 2 ? ranges[0].slice(-1) : ranges[0];
        return [regexpEscape(r), false, endPos - pos, false];
      }
      const sranges = "[" + (negate ? "^" : "") + rangesToString(ranges) + "]";
      const snegs = "[" + (negate ? "" : "^") + rangesToString(negs) + "]";
      const comb = ranges.length && negs.length ? "(" + sranges + "|" + snegs + ")" : ranges.length ? sranges : snegs;
      return [comb, uflag, endPos - pos, true];
    };
    exports2.parseClass = parseClass;
  }
});

// node_modules/minimatch/dist/commonjs/unescape.js
var require_unescape = __commonJS({
  "node_modules/minimatch/dist/commonjs/unescape.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.unescape = void 0;
    var unescape2 = (s, { windowsPathsNoEscape = false } = {}) => {
      return windowsPathsNoEscape ? s.replace(/\[([^\/\\])\]/g, "$1") : s.replace(/((?!\\).|^)\[([^\/\\])\]/g, "$1$2").replace(/\\([^\/])/g, "$1");
    };
    exports2.unescape = unescape2;
  }
});

// node_modules/minimatch/dist/commonjs/ast.js
var require_ast = __commonJS({
  "node_modules/minimatch/dist/commonjs/ast.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.AST = void 0;
    var brace_expressions_js_1 = require_brace_expressions();
    var unescape_js_1 = require_unescape();
    var types = /* @__PURE__ */ new Set(["!", "?", "+", "*", "@"]);
    var isExtglobType = (c) => types.has(c);
    var startNoTraversal = "(?!(?:^|/)\\.\\.?(?:$|/))";
    var startNoDot = "(?!\\.)";
    var addPatternStart = /* @__PURE__ */ new Set(["[", "."]);
    var justDots = /* @__PURE__ */ new Set(["..", "."]);
    var reSpecials = new Set("().*{}+?[]^$\\!");
    var regExpEscape = (s) => s.replace(/[-[\]{}()*+?.,\\^$|#\s]/g, "\\$&");
    var qmark = "[^/]";
    var star = qmark + "*?";
    var starNoEmpty = qmark + "+?";
    var AST = class _AST {
      type;
      #root;
      #hasMagic;
      #uflag = false;
      #parts = [];
      #parent;
      #parentIndex;
      #negs;
      #filledNegs = false;
      #options;
      #toString;
      // set to true if it's an extglob with no children
      // (which really means one child of '')
      #emptyExt = false;
      constructor(type, parent, options = {}) {
        this.type = type;
        if (type)
          this.#hasMagic = true;
        this.#parent = parent;
        this.#root = this.#parent ? this.#parent.#root : this;
        this.#options = this.#root === this ? options : this.#root.#options;
        this.#negs = this.#root === this ? [] : this.#root.#negs;
        if (type === "!" && !this.#root.#filledNegs)
          this.#negs.push(this);
        this.#parentIndex = this.#parent ? this.#parent.#parts.length : 0;
      }
      get hasMagic() {
        if (this.#hasMagic !== void 0)
          return this.#hasMagic;
        for (const p of this.#parts) {
          if (typeof p === "string")
            continue;
          if (p.type || p.hasMagic)
            return this.#hasMagic = true;
        }
        return this.#hasMagic;
      }
      // reconstructs the pattern
      toString() {
        if (this.#toString !== void 0)
          return this.#toString;
        if (!this.type) {
          return this.#toString = this.#parts.map((p) => String(p)).join("");
        } else {
          return this.#toString = this.type + "(" + this.#parts.map((p) => String(p)).join("|") + ")";
        }
      }
      #fillNegs() {
        if (this !== this.#root)
          throw new Error("should only call on root");
        if (this.#filledNegs)
          return this;
        this.toString();
        this.#filledNegs = true;
        let n;
        while (n = this.#negs.pop()) {
          if (n.type !== "!")
            continue;
          let p = n;
          let pp2 = p.#parent;
          while (pp2) {
            for (let i = p.#parentIndex + 1; !pp2.type && i < pp2.#parts.length; i++) {
              for (const part of n.#parts) {
                if (typeof part === "string") {
                  throw new Error("string part in extglob AST??");
                }
                part.copyIn(pp2.#parts[i]);
              }
            }
            p = pp2;
            pp2 = p.#parent;
          }
        }
        return this;
      }
      push(...parts) {
        for (const p of parts) {
          if (p === "")
            continue;
          if (typeof p !== "string" && !(p instanceof _AST && p.#parent === this)) {
            throw new Error("invalid part: " + p);
          }
          this.#parts.push(p);
        }
      }
      toJSON() {
        const ret = this.type === null ? this.#parts.slice().map((p) => typeof p === "string" ? p : p.toJSON()) : [this.type, ...this.#parts.map((p) => p.toJSON())];
        if (this.isStart() && !this.type)
          ret.unshift([]);
        if (this.isEnd() && (this === this.#root || this.#root.#filledNegs && this.#parent?.type === "!")) {
          ret.push({});
        }
        return ret;
      }
      isStart() {
        if (this.#root === this)
          return true;
        if (!this.#parent?.isStart())
          return false;
        if (this.#parentIndex === 0)
          return true;
        const p = this.#parent;
        for (let i = 0; i < this.#parentIndex; i++) {
          const pp2 = p.#parts[i];
          if (!(pp2 instanceof _AST && pp2.type === "!")) {
            return false;
          }
        }
        return true;
      }
      isEnd() {
        if (this.#root === this)
          return true;
        if (this.#parent?.type === "!")
          return true;
        if (!this.#parent?.isEnd())
          return false;
        if (!this.type)
          return this.#parent?.isEnd();
        const pl2 = this.#parent ? this.#parent.#parts.length : 0;
        return this.#parentIndex === pl2 - 1;
      }
      copyIn(part) {
        if (typeof part === "string")
          this.push(part);
        else
          this.push(part.clone(this));
      }
      clone(parent) {
        const c = new _AST(this.type, parent);
        for (const p of this.#parts) {
          c.copyIn(p);
        }
        return c;
      }
      static #parseAST(str, ast, pos, opt) {
        let escaping = false;
        let inBrace = false;
        let braceStart = -1;
        let braceNeg = false;
        if (ast.type === null) {
          let i2 = pos;
          let acc2 = "";
          while (i2 < str.length) {
            const c = str.charAt(i2++);
            if (escaping || c === "\\") {
              escaping = !escaping;
              acc2 += c;
              continue;
            }
            if (inBrace) {
              if (i2 === braceStart + 1) {
                if (c === "^" || c === "!") {
                  braceNeg = true;
                }
              } else if (c === "]" && !(i2 === braceStart + 2 && braceNeg)) {
                inBrace = false;
              }
              acc2 += c;
              continue;
            } else if (c === "[") {
              inBrace = true;
              braceStart = i2;
              braceNeg = false;
              acc2 += c;
              continue;
            }
            if (!opt.noext && isExtglobType(c) && str.charAt(i2) === "(") {
              ast.push(acc2);
              acc2 = "";
              const ext = new _AST(c, ast);
              i2 = _AST.#parseAST(str, ext, i2, opt);
              ast.push(ext);
              continue;
            }
            acc2 += c;
          }
          ast.push(acc2);
          return i2;
        }
        let i = pos + 1;
        let part = new _AST(null, ast);
        const parts = [];
        let acc = "";
        while (i < str.length) {
          const c = str.charAt(i++);
          if (escaping || c === "\\") {
            escaping = !escaping;
            acc += c;
            continue;
          }
          if (inBrace) {
            if (i === braceStart + 1) {
              if (c === "^" || c === "!") {
                braceNeg = true;
              }
            } else if (c === "]" && !(i === braceStart + 2 && braceNeg)) {
              inBrace = false;
            }
            acc += c;
            continue;
          } else if (c === "[") {
            inBrace = true;
            braceStart = i;
            braceNeg = false;
            acc += c;
            continue;
          }
          if (isExtglobType(c) && str.charAt(i) === "(") {
            part.push(acc);
            acc = "";
            const ext = new _AST(c, part);
            part.push(ext);
            i = _AST.#parseAST(str, ext, i, opt);
            continue;
          }
          if (c === "|") {
            part.push(acc);
            acc = "";
            parts.push(part);
            part = new _AST(null, ast);
            continue;
          }
          if (c === ")") {
            if (acc === "" && ast.#parts.length === 0) {
              ast.#emptyExt = true;
            }
            part.push(acc);
            acc = "";
            ast.push(...parts, part);
            return i;
          }
          acc += c;
        }
        ast.type = null;
        ast.#hasMagic = void 0;
        ast.#parts = [str.substring(pos - 1)];
        return i;
      }
      static fromGlob(pattern, options = {}) {
        const ast = new _AST(null, void 0, options);
        _AST.#parseAST(pattern, ast, 0, options);
        return ast;
      }
      // returns the regular expression if there's magic, or the unescaped
      // string if not.
      toMMPattern() {
        if (this !== this.#root)
          return this.#root.toMMPattern();
        const glob = this.toString();
        const [re, body, hasMagic, uflag] = this.toRegExpSource();
        const anyMagic = hasMagic || this.#hasMagic || this.#options.nocase && !this.#options.nocaseMagicOnly && glob.toUpperCase() !== glob.toLowerCase();
        if (!anyMagic) {
          return body;
        }
        const flags = (this.#options.nocase ? "i" : "") + (uflag ? "u" : "");
        return Object.assign(new RegExp(`^${re}$`, flags), {
          _src: re,
          _glob: glob
        });
      }
      get options() {
        return this.#options;
      }
      // returns the string match, the regexp source, whether there's magic
      // in the regexp (so a regular expression is required) and whether or
      // not the uflag is needed for the regular expression (for posix classes)
      // TODO: instead of injecting the start/end at this point, just return
      // the BODY of the regexp, along with the start/end portions suitable
      // for binding the start/end in either a joined full-path makeRe context
      // (where we bind to (^|/), or a standalone matchPart context (where
      // we bind to ^, and not /).  Otherwise slashes get duped!
      //
      // In part-matching mode, the start is:
      // - if not isStart: nothing
      // - if traversal possible, but not allowed: ^(?!\.\.?$)
      // - if dots allowed or not possible: ^
      // - if dots possible and not allowed: ^(?!\.)
      // end is:
      // - if not isEnd(): nothing
      // - else: $
      //
      // In full-path matching mode, we put the slash at the START of the
      // pattern, so start is:
      // - if first pattern: same as part-matching mode
      // - if not isStart(): nothing
      // - if traversal possible, but not allowed: /(?!\.\.?(?:$|/))
      // - if dots allowed or not possible: /
      // - if dots possible and not allowed: /(?!\.)
      // end is:
      // - if last pattern, same as part-matching mode
      // - else nothing
      //
      // Always put the (?:$|/) on negated tails, though, because that has to be
      // there to bind the end of the negated pattern portion, and it's easier to
      // just stick it in now rather than try to inject it later in the middle of
      // the pattern.
      //
      // We can just always return the same end, and leave it up to the caller
      // to know whether it's going to be used joined or in parts.
      // And, if the start is adjusted slightly, can do the same there:
      // - if not isStart: nothing
      // - if traversal possible, but not allowed: (?:/|^)(?!\.\.?$)
      // - if dots allowed or not possible: (?:/|^)
      // - if dots possible and not allowed: (?:/|^)(?!\.)
      //
      // But it's better to have a simpler binding without a conditional, for
      // performance, so probably better to return both start options.
      //
      // Then the caller just ignores the end if it's not the first pattern,
      // and the start always gets applied.
      //
      // But that's always going to be $ if it's the ending pattern, or nothing,
      // so the caller can just attach $ at the end of the pattern when building.
      //
      // So the todo is:
      // - better detect what kind of start is needed
      // - return both flavors of starting pattern
      // - attach $ at the end of the pattern when creating the actual RegExp
      //
      // Ah, but wait, no, that all only applies to the root when the first pattern
      // is not an extglob. If the first pattern IS an extglob, then we need all
      // that dot prevention biz to live in the extglob portions, because eg
      // +(*|.x*) can match .xy but not .yx.
      //
      // So, return the two flavors if it's #root and the first child is not an
      // AST, otherwise leave it to the child AST to handle it, and there,
      // use the (?:^|/) style of start binding.
      //
      // Even simplified further:
      // - Since the start for a join is eg /(?!\.) and the start for a part
      // is ^(?!\.), we can just prepend (?!\.) to the pattern (either root
      // or start or whatever) and prepend ^ or / at the Regexp construction.
      toRegExpSource(allowDot) {
        const dot = allowDot ?? !!this.#options.dot;
        if (this.#root === this)
          this.#fillNegs();
        if (!this.type) {
          const noEmpty = this.isStart() && this.isEnd();
          const src = this.#parts.map((p) => {
            const [re, _, hasMagic, uflag] = typeof p === "string" ? _AST.#parseGlob(p, this.#hasMagic, noEmpty) : p.toRegExpSource(allowDot);
            this.#hasMagic = this.#hasMagic || hasMagic;
            this.#uflag = this.#uflag || uflag;
            return re;
          }).join("");
          let start2 = "";
          if (this.isStart()) {
            if (typeof this.#parts[0] === "string") {
              const dotTravAllowed = this.#parts.length === 1 && justDots.has(this.#parts[0]);
              if (!dotTravAllowed) {
                const aps = addPatternStart;
                const needNoTrav = (
                  // dots are allowed, and the pattern starts with [ or .
                  dot && aps.has(src.charAt(0)) || // the pattern starts with \., and then [ or .
                  src.startsWith("\\.") && aps.has(src.charAt(2)) || // the pattern starts with \.\., and then [ or .
                  src.startsWith("\\.\\.") && aps.has(src.charAt(4))
                );
                const needNoDot = !dot && !allowDot && aps.has(src.charAt(0));
                start2 = needNoTrav ? startNoTraversal : needNoDot ? startNoDot : "";
              }
            }
          }
          let end = "";
          if (this.isEnd() && this.#root.#filledNegs && this.#parent?.type === "!") {
            end = "(?:$|\\/)";
          }
          const final2 = start2 + src + end;
          return [
            final2,
            (0, unescape_js_1.unescape)(src),
            this.#hasMagic = !!this.#hasMagic,
            this.#uflag
          ];
        }
        const repeated = this.type === "*" || this.type === "+";
        const start = this.type === "!" ? "(?:(?!(?:" : "(?:";
        let body = this.#partsToRegExp(dot);
        if (this.isStart() && this.isEnd() && !body && this.type !== "!") {
          const s = this.toString();
          this.#parts = [s];
          this.type = null;
          this.#hasMagic = void 0;
          return [s, (0, unescape_js_1.unescape)(this.toString()), false, false];
        }
        let bodyDotAllowed = !repeated || allowDot || dot || !startNoDot ? "" : this.#partsToRegExp(true);
        if (bodyDotAllowed === body) {
          bodyDotAllowed = "";
        }
        if (bodyDotAllowed) {
          body = `(?:${body})(?:${bodyDotAllowed})*?`;
        }
        let final = "";
        if (this.type === "!" && this.#emptyExt) {
          final = (this.isStart() && !dot ? startNoDot : "") + starNoEmpty;
        } else {
          const close = this.type === "!" ? (
            // !() must match something,but !(x) can match ''
            "))" + (this.isStart() && !dot && !allowDot ? startNoDot : "") + star + ")"
          ) : this.type === "@" ? ")" : this.type === "?" ? ")?" : this.type === "+" && bodyDotAllowed ? ")" : this.type === "*" && bodyDotAllowed ? `)?` : `)${this.type}`;
          final = start + body + close;
        }
        return [
          final,
          (0, unescape_js_1.unescape)(body),
          this.#hasMagic = !!this.#hasMagic,
          this.#uflag
        ];
      }
      #partsToRegExp(dot) {
        return this.#parts.map((p) => {
          if (typeof p === "string") {
            throw new Error("string type in extglob ast??");
          }
          const [re, _, _hasMagic, uflag] = p.toRegExpSource(dot);
          this.#uflag = this.#uflag || uflag;
          return re;
        }).filter((p) => !(this.isStart() && this.isEnd()) || !!p).join("|");
      }
      static #parseGlob(glob, hasMagic, noEmpty = false) {
        let escaping = false;
        let re = "";
        let uflag = false;
        for (let i = 0; i < glob.length; i++) {
          const c = glob.charAt(i);
          if (escaping) {
            escaping = false;
            re += (reSpecials.has(c) ? "\\" : "") + c;
            continue;
          }
          if (c === "\\") {
            if (i === glob.length - 1) {
              re += "\\\\";
            } else {
              escaping = true;
            }
            continue;
          }
          if (c === "[") {
            const [src, needUflag, consumed, magic] = (0, brace_expressions_js_1.parseClass)(glob, i);
            if (consumed) {
              re += src;
              uflag = uflag || needUflag;
              i += consumed - 1;
              hasMagic = hasMagic || magic;
              continue;
            }
          }
          if (c === "*") {
            if (noEmpty && glob === "*")
              re += starNoEmpty;
            else
              re += star;
            hasMagic = true;
            continue;
          }
          if (c === "?") {
            re += qmark;
            hasMagic = true;
            continue;
          }
          re += regExpEscape(c);
        }
        return [re, (0, unescape_js_1.unescape)(glob), !!hasMagic, uflag];
      }
    };
    exports2.AST = AST;
  }
});

// node_modules/minimatch/dist/commonjs/escape.js
var require_escape = __commonJS({
  "node_modules/minimatch/dist/commonjs/escape.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.escape = void 0;
    var escape2 = (s, { windowsPathsNoEscape = false } = {}) => {
      return windowsPathsNoEscape ? s.replace(/[?*()[\]]/g, "[$&]") : s.replace(/[?*()[\]\\]/g, "\\$&");
    };
    exports2.escape = escape2;
  }
});

// node_modules/minimatch/dist/commonjs/index.js
var require_commonjs3 = __commonJS({
  "node_modules/minimatch/dist/commonjs/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.unescape = exports2.escape = exports2.AST = exports2.Minimatch = exports2.match = exports2.makeRe = exports2.braceExpand = exports2.defaults = exports2.filter = exports2.GLOBSTAR = exports2.sep = exports2.minimatch = void 0;
    var brace_expansion_1 = require_commonjs2();
    var assert_valid_pattern_js_1 = require_assert_valid_pattern();
    var ast_js_1 = require_ast();
    var escape_js_1 = require_escape();
    var unescape_js_1 = require_unescape();
    var minimatch = (p, pattern, options = {}) => {
      (0, assert_valid_pattern_js_1.assertValidPattern)(pattern);
      if (!options.nocomment && pattern.charAt(0) === "#") {
        return false;
      }
      return new Minimatch(pattern, options).match(p);
    };
    exports2.minimatch = minimatch;
    var starDotExtRE = /^\*+([^+@!?\*\[\(]*)$/;
    var starDotExtTest = (ext2) => (f) => !f.startsWith(".") && f.endsWith(ext2);
    var starDotExtTestDot = (ext2) => (f) => f.endsWith(ext2);
    var starDotExtTestNocase = (ext2) => {
      ext2 = ext2.toLowerCase();
      return (f) => !f.startsWith(".") && f.toLowerCase().endsWith(ext2);
    };
    var starDotExtTestNocaseDot = (ext2) => {
      ext2 = ext2.toLowerCase();
      return (f) => f.toLowerCase().endsWith(ext2);
    };
    var starDotStarRE = /^\*+\.\*+$/;
    var starDotStarTest = (f) => !f.startsWith(".") && f.includes(".");
    var starDotStarTestDot = (f) => f !== "." && f !== ".." && f.includes(".");
    var dotStarRE = /^\.\*+$/;
    var dotStarTest = (f) => f !== "." && f !== ".." && f.startsWith(".");
    var starRE = /^\*+$/;
    var starTest = (f) => f.length !== 0 && !f.startsWith(".");
    var starTestDot = (f) => f.length !== 0 && f !== "." && f !== "..";
    var qmarksRE = /^\?+([^+@!?\*\[\(]*)?$/;
    var qmarksTestNocase = ([$0, ext2 = ""]) => {
      const noext = qmarksTestNoExt([$0]);
      if (!ext2)
        return noext;
      ext2 = ext2.toLowerCase();
      return (f) => noext(f) && f.toLowerCase().endsWith(ext2);
    };
    var qmarksTestNocaseDot = ([$0, ext2 = ""]) => {
      const noext = qmarksTestNoExtDot([$0]);
      if (!ext2)
        return noext;
      ext2 = ext2.toLowerCase();
      return (f) => noext(f) && f.toLowerCase().endsWith(ext2);
    };
    var qmarksTestDot = ([$0, ext2 = ""]) => {
      const noext = qmarksTestNoExtDot([$0]);
      return !ext2 ? noext : (f) => noext(f) && f.endsWith(ext2);
    };
    var qmarksTest = ([$0, ext2 = ""]) => {
      const noext = qmarksTestNoExt([$0]);
      return !ext2 ? noext : (f) => noext(f) && f.endsWith(ext2);
    };
    var qmarksTestNoExt = ([$0]) => {
      const len = $0.length;
      return (f) => f.length === len && !f.startsWith(".");
    };
    var qmarksTestNoExtDot = ([$0]) => {
      const len = $0.length;
      return (f) => f.length === len && f !== "." && f !== "..";
    };
    var defaultPlatform = typeof process === "object" && process ? typeof process.env === "object" && process.env && process.env.__MINIMATCH_TESTING_PLATFORM__ || process.platform : "posix";
    var path4 = {
      win32: { sep: "\\" },
      posix: { sep: "/" }
    };
    exports2.sep = defaultPlatform === "win32" ? path4.win32.sep : path4.posix.sep;
    exports2.minimatch.sep = exports2.sep;
    exports2.GLOBSTAR = Symbol("globstar **");
    exports2.minimatch.GLOBSTAR = exports2.GLOBSTAR;
    var qmark = "[^/]";
    var star = qmark + "*?";
    var twoStarDot = "(?:(?!(?:\\/|^)(?:\\.{1,2})($|\\/)).)*?";
    var twoStarNoDot = "(?:(?!(?:\\/|^)\\.).)*?";
    var filter = (pattern, options = {}) => (p) => (0, exports2.minimatch)(p, pattern, options);
    exports2.filter = filter;
    exports2.minimatch.filter = exports2.filter;
    var ext = (a, b = {}) => Object.assign({}, a, b);
    var defaults = (def) => {
      if (!def || typeof def !== "object" || !Object.keys(def).length) {
        return exports2.minimatch;
      }
      const orig = exports2.minimatch;
      const m = (p, pattern, options = {}) => orig(p, pattern, ext(def, options));
      return Object.assign(m, {
        Minimatch: class Minimatch extends orig.Minimatch {
          constructor(pattern, options = {}) {
            super(pattern, ext(def, options));
          }
          static defaults(options) {
            return orig.defaults(ext(def, options)).Minimatch;
          }
        },
        AST: class AST extends orig.AST {
          /* c8 ignore start */
          constructor(type, parent, options = {}) {
            super(type, parent, ext(def, options));
          }
          /* c8 ignore stop */
          static fromGlob(pattern, options = {}) {
            return orig.AST.fromGlob(pattern, ext(def, options));
          }
        },
        unescape: (s, options = {}) => orig.unescape(s, ext(def, options)),
        escape: (s, options = {}) => orig.escape(s, ext(def, options)),
        filter: (pattern, options = {}) => orig.filter(pattern, ext(def, options)),
        defaults: (options) => orig.defaults(ext(def, options)),
        makeRe: (pattern, options = {}) => orig.makeRe(pattern, ext(def, options)),
        braceExpand: (pattern, options = {}) => orig.braceExpand(pattern, ext(def, options)),
        match: (list, pattern, options = {}) => orig.match(list, pattern, ext(def, options)),
        sep: orig.sep,
        GLOBSTAR: exports2.GLOBSTAR
      });
    };
    exports2.defaults = defaults;
    exports2.minimatch.defaults = exports2.defaults;
    var braceExpand = (pattern, options = {}) => {
      (0, assert_valid_pattern_js_1.assertValidPattern)(pattern);
      if (options.nobrace || !/\{(?:(?!\{).)*\}/.test(pattern)) {
        return [pattern];
      }
      return (0, brace_expansion_1.expand)(pattern);
    };
    exports2.braceExpand = braceExpand;
    exports2.minimatch.braceExpand = exports2.braceExpand;
    var makeRe = (pattern, options = {}) => new Minimatch(pattern, options).makeRe();
    exports2.makeRe = makeRe;
    exports2.minimatch.makeRe = exports2.makeRe;
    var match = (list, pattern, options = {}) => {
      const mm = new Minimatch(pattern, options);
      list = list.filter((f) => mm.match(f));
      if (mm.options.nonull && !list.length) {
        list.push(pattern);
      }
      return list;
    };
    exports2.match = match;
    exports2.minimatch.match = exports2.match;
    var globMagic = /[?*]|[+@!]\(.*?\)|\[|\]/;
    var regExpEscape = (s) => s.replace(/[-[\]{}()*+?.,\\^$|#\s]/g, "\\$&");
    var Minimatch = class {
      options;
      set;
      pattern;
      windowsPathsNoEscape;
      nonegate;
      negate;
      comment;
      empty;
      preserveMultipleSlashes;
      partial;
      globSet;
      globParts;
      nocase;
      isWindows;
      platform;
      windowsNoMagicRoot;
      regexp;
      constructor(pattern, options = {}) {
        (0, assert_valid_pattern_js_1.assertValidPattern)(pattern);
        options = options || {};
        this.options = options;
        this.pattern = pattern;
        this.platform = options.platform || defaultPlatform;
        this.isWindows = this.platform === "win32";
        this.windowsPathsNoEscape = !!options.windowsPathsNoEscape || options.allowWindowsEscape === false;
        if (this.windowsPathsNoEscape) {
          this.pattern = this.pattern.replace(/\\/g, "/");
        }
        this.preserveMultipleSlashes = !!options.preserveMultipleSlashes;
        this.regexp = null;
        this.negate = false;
        this.nonegate = !!options.nonegate;
        this.comment = false;
        this.empty = false;
        this.partial = !!options.partial;
        this.nocase = !!this.options.nocase;
        this.windowsNoMagicRoot = options.windowsNoMagicRoot !== void 0 ? options.windowsNoMagicRoot : !!(this.isWindows && this.nocase);
        this.globSet = [];
        this.globParts = [];
        this.set = [];
        this.make();
      }
      hasMagic() {
        if (this.options.magicalBraces && this.set.length > 1) {
          return true;
        }
        for (const pattern of this.set) {
          for (const part of pattern) {
            if (typeof part !== "string")
              return true;
          }
        }
        return false;
      }
      debug(..._) {
      }
      make() {
        const pattern = this.pattern;
        const options = this.options;
        if (!options.nocomment && pattern.charAt(0) === "#") {
          this.comment = true;
          return;
        }
        if (!pattern) {
          this.empty = true;
          return;
        }
        this.parseNegate();
        this.globSet = [...new Set(this.braceExpand())];
        if (options.debug) {
          this.debug = (...args) => console.error(...args);
        }
        this.debug(this.pattern, this.globSet);
        const rawGlobParts = this.globSet.map((s) => this.slashSplit(s));
        this.globParts = this.preprocess(rawGlobParts);
        this.debug(this.pattern, this.globParts);
        let set = this.globParts.map((s, _, __2) => {
          if (this.isWindows && this.windowsNoMagicRoot) {
            const isUNC = s[0] === "" && s[1] === "" && (s[2] === "?" || !globMagic.test(s[2])) && !globMagic.test(s[3]);
            const isDrive = /^[a-z]:/i.test(s[0]);
            if (isUNC) {
              return [...s.slice(0, 4), ...s.slice(4).map((ss) => this.parse(ss))];
            } else if (isDrive) {
              return [s[0], ...s.slice(1).map((ss) => this.parse(ss))];
            }
          }
          return s.map((ss) => this.parse(ss));
        });
        this.debug(this.pattern, set);
        this.set = set.filter((s) => s.indexOf(false) === -1);
        if (this.isWindows) {
          for (let i = 0; i < this.set.length; i++) {
            const p = this.set[i];
            if (p[0] === "" && p[1] === "" && this.globParts[i][2] === "?" && typeof p[3] === "string" && /^[a-z]:$/i.test(p[3])) {
              p[2] = "?";
            }
          }
        }
        this.debug(this.pattern, this.set);
      }
      // various transforms to equivalent pattern sets that are
      // faster to process in a filesystem walk.  The goal is to
      // eliminate what we can, and push all ** patterns as far
      // to the right as possible, even if it increases the number
      // of patterns that we have to process.
      preprocess(globParts) {
        if (this.options.noglobstar) {
          for (let i = 0; i < globParts.length; i++) {
            for (let j = 0; j < globParts[i].length; j++) {
              if (globParts[i][j] === "**") {
                globParts[i][j] = "*";
              }
            }
          }
        }
        const { optimizationLevel = 1 } = this.options;
        if (optimizationLevel >= 2) {
          globParts = this.firstPhasePreProcess(globParts);
          globParts = this.secondPhasePreProcess(globParts);
        } else if (optimizationLevel >= 1) {
          globParts = this.levelOneOptimize(globParts);
        } else {
          globParts = this.adjascentGlobstarOptimize(globParts);
        }
        return globParts;
      }
      // just get rid of adjascent ** portions
      adjascentGlobstarOptimize(globParts) {
        return globParts.map((parts) => {
          let gs = -1;
          while (-1 !== (gs = parts.indexOf("**", gs + 1))) {
            let i = gs;
            while (parts[i + 1] === "**") {
              i++;
            }
            if (i !== gs) {
              parts.splice(gs, i - gs);
            }
          }
          return parts;
        });
      }
      // get rid of adjascent ** and resolve .. portions
      levelOneOptimize(globParts) {
        return globParts.map((parts) => {
          parts = parts.reduce((set, part) => {
            const prev = set[set.length - 1];
            if (part === "**" && prev === "**") {
              return set;
            }
            if (part === "..") {
              if (prev && prev !== ".." && prev !== "." && prev !== "**") {
                set.pop();
                return set;
              }
            }
            set.push(part);
            return set;
          }, []);
          return parts.length === 0 ? [""] : parts;
        });
      }
      levelTwoFileOptimize(parts) {
        if (!Array.isArray(parts)) {
          parts = this.slashSplit(parts);
        }
        let didSomething = false;
        do {
          didSomething = false;
          if (!this.preserveMultipleSlashes) {
            for (let i = 1; i < parts.length - 1; i++) {
              const p = parts[i];
              if (i === 1 && p === "" && parts[0] === "")
                continue;
              if (p === "." || p === "") {
                didSomething = true;
                parts.splice(i, 1);
                i--;
              }
            }
            if (parts[0] === "." && parts.length === 2 && (parts[1] === "." || parts[1] === "")) {
              didSomething = true;
              parts.pop();
            }
          }
          let dd2 = 0;
          while (-1 !== (dd2 = parts.indexOf("..", dd2 + 1))) {
            const p = parts[dd2 - 1];
            if (p && p !== "." && p !== ".." && p !== "**") {
              didSomething = true;
              parts.splice(dd2 - 1, 2);
              dd2 -= 2;
            }
          }
        } while (didSomething);
        return parts.length === 0 ? [""] : parts;
      }
      // First phase: single-pattern processing
      // <pre> is 1 or more portions
      // <rest> is 1 or more portions
      // <p> is any portion other than ., .., '', or **
      // <e> is . or ''
      //
      // **/.. is *brutal* for filesystem walking performance, because
      // it effectively resets the recursive walk each time it occurs,
      // and ** cannot be reduced out by a .. pattern part like a regexp
      // or most strings (other than .., ., and '') can be.
      //
      // <pre>/**/../<p>/<p>/<rest> -> {<pre>/../<p>/<p>/<rest>,<pre>/**/<p>/<p>/<rest>}
      // <pre>/<e>/<rest> -> <pre>/<rest>
      // <pre>/<p>/../<rest> -> <pre>/<rest>
      // **/**/<rest> -> **/<rest>
      //
      // **/*/<rest> -> */**/<rest> <== not valid because ** doesn't follow
      // this WOULD be allowed if ** did follow symlinks, or * didn't
      firstPhasePreProcess(globParts) {
        let didSomething = false;
        do {
          didSomething = false;
          for (let parts of globParts) {
            let gs = -1;
            while (-1 !== (gs = parts.indexOf("**", gs + 1))) {
              let gss = gs;
              while (parts[gss + 1] === "**") {
                gss++;
              }
              if (gss > gs) {
                parts.splice(gs + 1, gss - gs);
              }
              let next = parts[gs + 1];
              const p = parts[gs + 2];
              const p2 = parts[gs + 3];
              if (next !== "..")
                continue;
              if (!p || p === "." || p === ".." || !p2 || p2 === "." || p2 === "..") {
                continue;
              }
              didSomething = true;
              parts.splice(gs, 1);
              const other = parts.slice(0);
              other[gs] = "**";
              globParts.push(other);
              gs--;
            }
            if (!this.preserveMultipleSlashes) {
              for (let i = 1; i < parts.length - 1; i++) {
                const p = parts[i];
                if (i === 1 && p === "" && parts[0] === "")
                  continue;
                if (p === "." || p === "") {
                  didSomething = true;
                  parts.splice(i, 1);
                  i--;
                }
              }
              if (parts[0] === "." && parts.length === 2 && (parts[1] === "." || parts[1] === "")) {
                didSomething = true;
                parts.pop();
              }
            }
            let dd2 = 0;
            while (-1 !== (dd2 = parts.indexOf("..", dd2 + 1))) {
              const p = parts[dd2 - 1];
              if (p && p !== "." && p !== ".." && p !== "**") {
                didSomething = true;
                const needDot = dd2 === 1 && parts[dd2 + 1] === "**";
                const splin = needDot ? ["."] : [];
                parts.splice(dd2 - 1, 2, ...splin);
                if (parts.length === 0)
                  parts.push("");
                dd2 -= 2;
              }
            }
          }
        } while (didSomething);
        return globParts;
      }
      // second phase: multi-pattern dedupes
      // {<pre>/*/<rest>,<pre>/<p>/<rest>} -> <pre>/*/<rest>
      // {<pre>/<rest>,<pre>/<rest>} -> <pre>/<rest>
      // {<pre>/**/<rest>,<pre>/<rest>} -> <pre>/**/<rest>
      //
      // {<pre>/**/<rest>,<pre>/**/<p>/<rest>} -> <pre>/**/<rest>
      // ^-- not valid because ** doens't follow symlinks
      secondPhasePreProcess(globParts) {
        for (let i = 0; i < globParts.length - 1; i++) {
          for (let j = i + 1; j < globParts.length; j++) {
            const matched = this.partsMatch(globParts[i], globParts[j], !this.preserveMultipleSlashes);
            if (matched) {
              globParts[i] = [];
              globParts[j] = matched;
              break;
            }
          }
        }
        return globParts.filter((gs) => gs.length);
      }
      partsMatch(a, b, emptyGSMatch = false) {
        let ai = 0;
        let bi2 = 0;
        let result = [];
        let which = "";
        while (ai < a.length && bi2 < b.length) {
          if (a[ai] === b[bi2]) {
            result.push(which === "b" ? b[bi2] : a[ai]);
            ai++;
            bi2++;
          } else if (emptyGSMatch && a[ai] === "**" && b[bi2] === a[ai + 1]) {
            result.push(a[ai]);
            ai++;
          } else if (emptyGSMatch && b[bi2] === "**" && a[ai] === b[bi2 + 1]) {
            result.push(b[bi2]);
            bi2++;
          } else if (a[ai] === "*" && b[bi2] && (this.options.dot || !b[bi2].startsWith(".")) && b[bi2] !== "**") {
            if (which === "b")
              return false;
            which = "a";
            result.push(a[ai]);
            ai++;
            bi2++;
          } else if (b[bi2] === "*" && a[ai] && (this.options.dot || !a[ai].startsWith(".")) && a[ai] !== "**") {
            if (which === "a")
              return false;
            which = "b";
            result.push(b[bi2]);
            ai++;
            bi2++;
          } else {
            return false;
          }
        }
        return a.length === b.length && result;
      }
      parseNegate() {
        if (this.nonegate)
          return;
        const pattern = this.pattern;
        let negate = false;
        let negateOffset = 0;
        for (let i = 0; i < pattern.length && pattern.charAt(i) === "!"; i++) {
          negate = !negate;
          negateOffset++;
        }
        if (negateOffset)
          this.pattern = pattern.slice(negateOffset);
        this.negate = negate;
      }
      // set partial to true to test if, for example,
      // "/a/b" matches the start of "/*/b/*/d"
      // Partial means, if you run out of file before you run
      // out of pattern, then that's fine, as long as all
      // the parts match.
      matchOne(file, pattern, partial = false) {
        const options = this.options;
        if (this.isWindows) {
          const fileDrive = typeof file[0] === "string" && /^[a-z]:$/i.test(file[0]);
          const fileUNC = !fileDrive && file[0] === "" && file[1] === "" && file[2] === "?" && /^[a-z]:$/i.test(file[3]);
          const patternDrive = typeof pattern[0] === "string" && /^[a-z]:$/i.test(pattern[0]);
          const patternUNC = !patternDrive && pattern[0] === "" && pattern[1] === "" && pattern[2] === "?" && typeof pattern[3] === "string" && /^[a-z]:$/i.test(pattern[3]);
          const fdi = fileUNC ? 3 : fileDrive ? 0 : void 0;
          const pdi = patternUNC ? 3 : patternDrive ? 0 : void 0;
          if (typeof fdi === "number" && typeof pdi === "number") {
            const [fd, pd] = [file[fdi], pattern[pdi]];
            if (fd.toLowerCase() === pd.toLowerCase()) {
              pattern[pdi] = fd;
              if (pdi > fdi) {
                pattern = pattern.slice(pdi);
              } else if (fdi > pdi) {
                file = file.slice(fdi);
              }
            }
          }
        }
        const { optimizationLevel = 1 } = this.options;
        if (optimizationLevel >= 2) {
          file = this.levelTwoFileOptimize(file);
        }
        this.debug("matchOne", this, { file, pattern });
        this.debug("matchOne", file.length, pattern.length);
        for (var fi = 0, pi = 0, fl2 = file.length, pl2 = pattern.length; fi < fl2 && pi < pl2; fi++, pi++) {
          this.debug("matchOne loop");
          var p = pattern[pi];
          var f = file[fi];
          this.debug(pattern, p, f);
          if (p === false) {
            return false;
          }
          if (p === exports2.GLOBSTAR) {
            this.debug("GLOBSTAR", [pattern, p, f]);
            var fr = fi;
            var pr = pi + 1;
            if (pr === pl2) {
              this.debug("** at the end");
              for (; fi < fl2; fi++) {
                if (file[fi] === "." || file[fi] === ".." || !options.dot && file[fi].charAt(0) === ".")
                  return false;
              }
              return true;
            }
            while (fr < fl2) {
              var swallowee = file[fr];
              this.debug("\nglobstar while", file, fr, pattern, pr, swallowee);
              if (this.matchOne(file.slice(fr), pattern.slice(pr), partial)) {
                this.debug("globstar found match!", fr, fl2, swallowee);
                return true;
              } else {
                if (swallowee === "." || swallowee === ".." || !options.dot && swallowee.charAt(0) === ".") {
                  this.debug("dot detected!", file, fr, pattern, pr);
                  break;
                }
                this.debug("globstar swallow a segment, and continue");
                fr++;
              }
            }
            if (partial) {
              this.debug("\n>>> no match, partial?", file, fr, pattern, pr);
              if (fr === fl2) {
                return true;
              }
            }
            return false;
          }
          let hit;
          if (typeof p === "string") {
            hit = f === p;
            this.debug("string match", p, f, hit);
          } else {
            hit = p.test(f);
            this.debug("pattern match", p, f, hit);
          }
          if (!hit)
            return false;
        }
        if (fi === fl2 && pi === pl2) {
          return true;
        } else if (fi === fl2) {
          return partial;
        } else if (pi === pl2) {
          return fi === fl2 - 1 && file[fi] === "";
        } else {
          throw new Error("wtf?");
        }
      }
      braceExpand() {
        return (0, exports2.braceExpand)(this.pattern, this.options);
      }
      parse(pattern) {
        (0, assert_valid_pattern_js_1.assertValidPattern)(pattern);
        const options = this.options;
        if (pattern === "**")
          return exports2.GLOBSTAR;
        if (pattern === "")
          return "";
        let m;
        let fastTest = null;
        if (m = pattern.match(starRE)) {
          fastTest = options.dot ? starTestDot : starTest;
        } else if (m = pattern.match(starDotExtRE)) {
          fastTest = (options.nocase ? options.dot ? starDotExtTestNocaseDot : starDotExtTestNocase : options.dot ? starDotExtTestDot : starDotExtTest)(m[1]);
        } else if (m = pattern.match(qmarksRE)) {
          fastTest = (options.nocase ? options.dot ? qmarksTestNocaseDot : qmarksTestNocase : options.dot ? qmarksTestDot : qmarksTest)(m);
        } else if (m = pattern.match(starDotStarRE)) {
          fastTest = options.dot ? starDotStarTestDot : starDotStarTest;
        } else if (m = pattern.match(dotStarRE)) {
          fastTest = dotStarTest;
        }
        const re = ast_js_1.AST.fromGlob(pattern, this.options).toMMPattern();
        if (fastTest && typeof re === "object") {
          Reflect.defineProperty(re, "test", { value: fastTest });
        }
        return re;
      }
      makeRe() {
        if (this.regexp || this.regexp === false)
          return this.regexp;
        const set = this.set;
        if (!set.length) {
          this.regexp = false;
          return this.regexp;
        }
        const options = this.options;
        const twoStar = options.noglobstar ? star : options.dot ? twoStarDot : twoStarNoDot;
        const flags = new Set(options.nocase ? ["i"] : []);
        let re = set.map((pattern) => {
          const pp2 = pattern.map((p) => {
            if (p instanceof RegExp) {
              for (const f of p.flags.split(""))
                flags.add(f);
            }
            return typeof p === "string" ? regExpEscape(p) : p === exports2.GLOBSTAR ? exports2.GLOBSTAR : p._src;
          });
          pp2.forEach((p, i) => {
            const next = pp2[i + 1];
            const prev = pp2[i - 1];
            if (p !== exports2.GLOBSTAR || prev === exports2.GLOBSTAR) {
              return;
            }
            if (prev === void 0) {
              if (next !== void 0 && next !== exports2.GLOBSTAR) {
                pp2[i + 1] = "(?:\\/|" + twoStar + "\\/)?" + next;
              } else {
                pp2[i] = twoStar;
              }
            } else if (next === void 0) {
              pp2[i - 1] = prev + "(?:\\/|" + twoStar + ")?";
            } else if (next !== exports2.GLOBSTAR) {
              pp2[i - 1] = prev + "(?:\\/|\\/" + twoStar + "\\/)" + next;
              pp2[i + 1] = exports2.GLOBSTAR;
            }
          });
          return pp2.filter((p) => p !== exports2.GLOBSTAR).join("/");
        }).join("|");
        const [open, close] = set.length > 1 ? ["(?:", ")"] : ["", ""];
        re = "^" + open + re + close + "$";
        if (this.negate)
          re = "^(?!" + re + ").+$";
        try {
          this.regexp = new RegExp(re, [...flags].join(""));
        } catch (ex) {
          this.regexp = false;
        }
        return this.regexp;
      }
      slashSplit(p) {
        if (this.preserveMultipleSlashes) {
          return p.split("/");
        } else if (this.isWindows && /^\/\/[^\/]+/.test(p)) {
          return ["", ...p.split(/\/+/)];
        } else {
          return p.split(/\/+/);
        }
      }
      match(f, partial = this.partial) {
        this.debug("match", f, this.pattern);
        if (this.comment) {
          return false;
        }
        if (this.empty) {
          return f === "";
        }
        if (f === "/" && partial) {
          return true;
        }
        const options = this.options;
        if (this.isWindows) {
          f = f.split("\\").join("/");
        }
        const ff = this.slashSplit(f);
        this.debug(this.pattern, "split", ff);
        const set = this.set;
        this.debug(this.pattern, "set", set);
        let filename = ff[ff.length - 1];
        if (!filename) {
          for (let i = ff.length - 2; !filename && i >= 0; i--) {
            filename = ff[i];
          }
        }
        for (let i = 0; i < set.length; i++) {
          const pattern = set[i];
          let file = ff;
          if (options.matchBase && pattern.length === 1) {
            file = [filename];
          }
          const hit = this.matchOne(file, pattern, partial);
          if (hit) {
            if (options.flipNegate) {
              return true;
            }
            return !this.negate;
          }
        }
        if (options.flipNegate) {
          return false;
        }
        return this.negate;
      }
      static defaults(def) {
        return exports2.minimatch.defaults(def).Minimatch;
      }
    };
    exports2.Minimatch = Minimatch;
    var ast_js_2 = require_ast();
    Object.defineProperty(exports2, "AST", { enumerable: true, get: function() {
      return ast_js_2.AST;
    } });
    var escape_js_2 = require_escape();
    Object.defineProperty(exports2, "escape", { enumerable: true, get: function() {
      return escape_js_2.escape;
    } });
    var unescape_js_2 = require_unescape();
    Object.defineProperty(exports2, "unescape", { enumerable: true, get: function() {
      return unescape_js_2.unescape;
    } });
    exports2.minimatch.AST = ast_js_1.AST;
    exports2.minimatch.Minimatch = Minimatch;
    exports2.minimatch.escape = escape_js_1.escape;
    exports2.minimatch.unescape = unescape_js_1.unescape;
  }
});

// node_modules/lru-cache/dist/commonjs/index.js
var require_commonjs4 = __commonJS({
  "node_modules/lru-cache/dist/commonjs/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.LRUCache = void 0;
    var perf = typeof performance === "object" && performance && typeof performance.now === "function" ? performance : Date;
    var warned = /* @__PURE__ */ new Set();
    var PROCESS = typeof process === "object" && !!process ? process : {};
    var emitWarning = (msg, type, code, fn) => {
      typeof PROCESS.emitWarning === "function" ? PROCESS.emitWarning(msg, type, code, fn) : console.error(`[${code}] ${type}: ${msg}`);
    };
    var AC = globalThis.AbortController;
    var AS = globalThis.AbortSignal;
    if (typeof AC === "undefined") {
      AS = class AbortSignal {
        onabort;
        _onabort = [];
        reason;
        aborted = false;
        addEventListener(_, fn) {
          this._onabort.push(fn);
        }
      };
      AC = class AbortController {
        constructor() {
          warnACPolyfill();
        }
        signal = new AS();
        abort(reason) {
          if (this.signal.aborted)
            return;
          this.signal.reason = reason;
          this.signal.aborted = true;
          for (const fn of this.signal._onabort) {
            fn(reason);
          }
          this.signal.onabort?.(reason);
        }
      };
      let printACPolyfillWarning = PROCESS.env?.LRU_CACHE_IGNORE_AC_WARNING !== "1";
      const warnACPolyfill = () => {
        if (!printACPolyfillWarning)
          return;
        printACPolyfillWarning = false;
        emitWarning("AbortController is not defined. If using lru-cache in node 14, load an AbortController polyfill from the `node-abort-controller` package. A minimal polyfill is provided for use by LRUCache.fetch(), but it should not be relied upon in other contexts (eg, passing it to other APIs that use AbortController/AbortSignal might have undesirable effects). You may disable this with LRU_CACHE_IGNORE_AC_WARNING=1 in the env.", "NO_ABORT_CONTROLLER", "ENOTSUP", warnACPolyfill);
      };
    }
    var shouldWarn = (code) => !warned.has(code);
    var TYPE = Symbol("type");
    var isPosInt = (n) => n && n === Math.floor(n) && n > 0 && isFinite(n);
    var getUintArray = (max) => !isPosInt(max) ? null : max <= Math.pow(2, 8) ? Uint8Array : max <= Math.pow(2, 16) ? Uint16Array : max <= Math.pow(2, 32) ? Uint32Array : max <= Number.MAX_SAFE_INTEGER ? ZeroArray : null;
    var ZeroArray = class extends Array {
      constructor(size) {
        super(size);
        this.fill(0);
      }
    };
    var Stack = class _Stack {
      heap;
      length;
      // private constructor
      static #constructing = false;
      static create(max) {
        const HeapCls = getUintArray(max);
        if (!HeapCls)
          return [];
        _Stack.#constructing = true;
        const s = new _Stack(max, HeapCls);
        _Stack.#constructing = false;
        return s;
      }
      constructor(max, HeapCls) {
        if (!_Stack.#constructing) {
          throw new TypeError("instantiate Stack using Stack.create(n)");
        }
        this.heap = new HeapCls(max);
        this.length = 0;
      }
      push(n) {
        this.heap[this.length++] = n;
      }
      pop() {
        return this.heap[--this.length];
      }
    };
    var LRUCache = class _LRUCache {
      // options that cannot be changed without disaster
      #max;
      #maxSize;
      #dispose;
      #onInsert;
      #disposeAfter;
      #fetchMethod;
      #memoMethod;
      /**
       * {@link LRUCache.OptionsBase.ttl}
       */
      ttl;
      /**
       * {@link LRUCache.OptionsBase.ttlResolution}
       */
      ttlResolution;
      /**
       * {@link LRUCache.OptionsBase.ttlAutopurge}
       */
      ttlAutopurge;
      /**
       * {@link LRUCache.OptionsBase.updateAgeOnGet}
       */
      updateAgeOnGet;
      /**
       * {@link LRUCache.OptionsBase.updateAgeOnHas}
       */
      updateAgeOnHas;
      /**
       * {@link LRUCache.OptionsBase.allowStale}
       */
      allowStale;
      /**
       * {@link LRUCache.OptionsBase.noDisposeOnSet}
       */
      noDisposeOnSet;
      /**
       * {@link LRUCache.OptionsBase.noUpdateTTL}
       */
      noUpdateTTL;
      /**
       * {@link LRUCache.OptionsBase.maxEntrySize}
       */
      maxEntrySize;
      /**
       * {@link LRUCache.OptionsBase.sizeCalculation}
       */
      sizeCalculation;
      /**
       * {@link LRUCache.OptionsBase.noDeleteOnFetchRejection}
       */
      noDeleteOnFetchRejection;
      /**
       * {@link LRUCache.OptionsBase.noDeleteOnStaleGet}
       */
      noDeleteOnStaleGet;
      /**
       * {@link LRUCache.OptionsBase.allowStaleOnFetchAbort}
       */
      allowStaleOnFetchAbort;
      /**
       * {@link LRUCache.OptionsBase.allowStaleOnFetchRejection}
       */
      allowStaleOnFetchRejection;
      /**
       * {@link LRUCache.OptionsBase.ignoreFetchAbort}
       */
      ignoreFetchAbort;
      // computed properties
      #size;
      #calculatedSize;
      #keyMap;
      #keyList;
      #valList;
      #next;
      #prev;
      #head;
      #tail;
      #free;
      #disposed;
      #sizes;
      #starts;
      #ttls;
      #hasDispose;
      #hasFetchMethod;
      #hasDisposeAfter;
      #hasOnInsert;
      /**
       * Do not call this method unless you need to inspect the
       * inner workings of the cache.  If anything returned by this
       * object is modified in any way, strange breakage may occur.
       *
       * These fields are private for a reason!
       *
       * @internal
       */
      static unsafeExposeInternals(c) {
        return {
          // properties
          starts: c.#starts,
          ttls: c.#ttls,
          sizes: c.#sizes,
          keyMap: c.#keyMap,
          keyList: c.#keyList,
          valList: c.#valList,
          next: c.#next,
          prev: c.#prev,
          get head() {
            return c.#head;
          },
          get tail() {
            return c.#tail;
          },
          free: c.#free,
          // methods
          isBackgroundFetch: (p) => c.#isBackgroundFetch(p),
          backgroundFetch: (k, index, options, context) => c.#backgroundFetch(k, index, options, context),
          moveToTail: (index) => c.#moveToTail(index),
          indexes: (options) => c.#indexes(options),
          rindexes: (options) => c.#rindexes(options),
          isStale: (index) => c.#isStale(index)
        };
      }
      // Protected read-only members
      /**
       * {@link LRUCache.OptionsBase.max} (read-only)
       */
      get max() {
        return this.#max;
      }
      /**
       * {@link LRUCache.OptionsBase.maxSize} (read-only)
       */
      get maxSize() {
        return this.#maxSize;
      }
      /**
       * The total computed size of items in the cache (read-only)
       */
      get calculatedSize() {
        return this.#calculatedSize;
      }
      /**
       * The number of items stored in the cache (read-only)
       */
      get size() {
        return this.#size;
      }
      /**
       * {@link LRUCache.OptionsBase.fetchMethod} (read-only)
       */
      get fetchMethod() {
        return this.#fetchMethod;
      }
      get memoMethod() {
        return this.#memoMethod;
      }
      /**
       * {@link LRUCache.OptionsBase.dispose} (read-only)
       */
      get dispose() {
        return this.#dispose;
      }
      /**
       * {@link LRUCache.OptionsBase.onInsert} (read-only)
       */
      get onInsert() {
        return this.#onInsert;
      }
      /**
       * {@link LRUCache.OptionsBase.disposeAfter} (read-only)
       */
      get disposeAfter() {
        return this.#disposeAfter;
      }
      constructor(options) {
        const { max = 0, ttl, ttlResolution = 1, ttlAutopurge, updateAgeOnGet, updateAgeOnHas, allowStale, dispose, onInsert, disposeAfter, noDisposeOnSet, noUpdateTTL, maxSize = 0, maxEntrySize = 0, sizeCalculation, fetchMethod, memoMethod, noDeleteOnFetchRejection, noDeleteOnStaleGet, allowStaleOnFetchRejection, allowStaleOnFetchAbort, ignoreFetchAbort } = options;
        if (max !== 0 && !isPosInt(max)) {
          throw new TypeError("max option must be a nonnegative integer");
        }
        const UintArray = max ? getUintArray(max) : Array;
        if (!UintArray) {
          throw new Error("invalid max value: " + max);
        }
        this.#max = max;
        this.#maxSize = maxSize;
        this.maxEntrySize = maxEntrySize || this.#maxSize;
        this.sizeCalculation = sizeCalculation;
        if (this.sizeCalculation) {
          if (!this.#maxSize && !this.maxEntrySize) {
            throw new TypeError("cannot set sizeCalculation without setting maxSize or maxEntrySize");
          }
          if (typeof this.sizeCalculation !== "function") {
            throw new TypeError("sizeCalculation set to non-function");
          }
        }
        if (memoMethod !== void 0 && typeof memoMethod !== "function") {
          throw new TypeError("memoMethod must be a function if defined");
        }
        this.#memoMethod = memoMethod;
        if (fetchMethod !== void 0 && typeof fetchMethod !== "function") {
          throw new TypeError("fetchMethod must be a function if specified");
        }
        this.#fetchMethod = fetchMethod;
        this.#hasFetchMethod = !!fetchMethod;
        this.#keyMap = /* @__PURE__ */ new Map();
        this.#keyList = new Array(max).fill(void 0);
        this.#valList = new Array(max).fill(void 0);
        this.#next = new UintArray(max);
        this.#prev = new UintArray(max);
        this.#head = 0;
        this.#tail = 0;
        this.#free = Stack.create(max);
        this.#size = 0;
        this.#calculatedSize = 0;
        if (typeof dispose === "function") {
          this.#dispose = dispose;
        }
        if (typeof onInsert === "function") {
          this.#onInsert = onInsert;
        }
        if (typeof disposeAfter === "function") {
          this.#disposeAfter = disposeAfter;
          this.#disposed = [];
        } else {
          this.#disposeAfter = void 0;
          this.#disposed = void 0;
        }
        this.#hasDispose = !!this.#dispose;
        this.#hasOnInsert = !!this.#onInsert;
        this.#hasDisposeAfter = !!this.#disposeAfter;
        this.noDisposeOnSet = !!noDisposeOnSet;
        this.noUpdateTTL = !!noUpdateTTL;
        this.noDeleteOnFetchRejection = !!noDeleteOnFetchRejection;
        this.allowStaleOnFetchRejection = !!allowStaleOnFetchRejection;
        this.allowStaleOnFetchAbort = !!allowStaleOnFetchAbort;
        this.ignoreFetchAbort = !!ignoreFetchAbort;
        if (this.maxEntrySize !== 0) {
          if (this.#maxSize !== 0) {
            if (!isPosInt(this.#maxSize)) {
              throw new TypeError("maxSize must be a positive integer if specified");
            }
          }
          if (!isPosInt(this.maxEntrySize)) {
            throw new TypeError("maxEntrySize must be a positive integer if specified");
          }
          this.#initializeSizeTracking();
        }
        this.allowStale = !!allowStale;
        this.noDeleteOnStaleGet = !!noDeleteOnStaleGet;
        this.updateAgeOnGet = !!updateAgeOnGet;
        this.updateAgeOnHas = !!updateAgeOnHas;
        this.ttlResolution = isPosInt(ttlResolution) || ttlResolution === 0 ? ttlResolution : 1;
        this.ttlAutopurge = !!ttlAutopurge;
        this.ttl = ttl || 0;
        if (this.ttl) {
          if (!isPosInt(this.ttl)) {
            throw new TypeError("ttl must be a positive integer if specified");
          }
          this.#initializeTTLTracking();
        }
        if (this.#max === 0 && this.ttl === 0 && this.#maxSize === 0) {
          throw new TypeError("At least one of max, maxSize, or ttl is required");
        }
        if (!this.ttlAutopurge && !this.#max && !this.#maxSize) {
          const code = "LRU_CACHE_UNBOUNDED";
          if (shouldWarn(code)) {
            warned.add(code);
            const msg = "TTL caching without ttlAutopurge, max, or maxSize can result in unbounded memory consumption.";
            emitWarning(msg, "UnboundedCacheWarning", code, _LRUCache);
          }
        }
      }
      /**
       * Return the number of ms left in the item's TTL. If item is not in cache,
       * returns `0`. Returns `Infinity` if item is in cache without a defined TTL.
       */
      getRemainingTTL(key) {
        return this.#keyMap.has(key) ? Infinity : 0;
      }
      #initializeTTLTracking() {
        const ttls = new ZeroArray(this.#max);
        const starts = new ZeroArray(this.#max);
        this.#ttls = ttls;
        this.#starts = starts;
        this.#setItemTTL = (index, ttl, start = perf.now()) => {
          starts[index] = ttl !== 0 ? start : 0;
          ttls[index] = ttl;
          if (ttl !== 0 && this.ttlAutopurge) {
            const t = setTimeout(() => {
              if (this.#isStale(index)) {
                this.#delete(this.#keyList[index], "expire");
              }
            }, ttl + 1);
            if (t.unref) {
              t.unref();
            }
          }
        };
        this.#updateItemAge = (index) => {
          starts[index] = ttls[index] !== 0 ? perf.now() : 0;
        };
        this.#statusTTL = (status, index) => {
          if (ttls[index]) {
            const ttl = ttls[index];
            const start = starts[index];
            if (!ttl || !start)
              return;
            status.ttl = ttl;
            status.start = start;
            status.now = cachedNow || getNow();
            const age = status.now - start;
            status.remainingTTL = ttl - age;
          }
        };
        let cachedNow = 0;
        const getNow = () => {
          const n = perf.now();
          if (this.ttlResolution > 0) {
            cachedNow = n;
            const t = setTimeout(() => cachedNow = 0, this.ttlResolution);
            if (t.unref) {
              t.unref();
            }
          }
          return n;
        };
        this.getRemainingTTL = (key) => {
          const index = this.#keyMap.get(key);
          if (index === void 0) {
            return 0;
          }
          const ttl = ttls[index];
          const start = starts[index];
          if (!ttl || !start) {
            return Infinity;
          }
          const age = (cachedNow || getNow()) - start;
          return ttl - age;
        };
        this.#isStale = (index) => {
          const s = starts[index];
          const t = ttls[index];
          return !!t && !!s && (cachedNow || getNow()) - s > t;
        };
      }
      // conditionally set private methods related to TTL
      #updateItemAge = () => {
      };
      #statusTTL = () => {
      };
      #setItemTTL = () => {
      };
      /* c8 ignore stop */
      #isStale = () => false;
      #initializeSizeTracking() {
        const sizes = new ZeroArray(this.#max);
        this.#calculatedSize = 0;
        this.#sizes = sizes;
        this.#removeItemSize = (index) => {
          this.#calculatedSize -= sizes[index];
          sizes[index] = 0;
        };
        this.#requireSize = (k, v, size, sizeCalculation) => {
          if (this.#isBackgroundFetch(v)) {
            return 0;
          }
          if (!isPosInt(size)) {
            if (sizeCalculation) {
              if (typeof sizeCalculation !== "function") {
                throw new TypeError("sizeCalculation must be a function");
              }
              size = sizeCalculation(v, k);
              if (!isPosInt(size)) {
                throw new TypeError("sizeCalculation return invalid (expect positive integer)");
              }
            } else {
              throw new TypeError("invalid size value (must be positive integer). When maxSize or maxEntrySize is used, sizeCalculation or size must be set.");
            }
          }
          return size;
        };
        this.#addItemSize = (index, size, status) => {
          sizes[index] = size;
          if (this.#maxSize) {
            const maxSize = this.#maxSize - sizes[index];
            while (this.#calculatedSize > maxSize) {
              this.#evict(true);
            }
          }
          this.#calculatedSize += sizes[index];
          if (status) {
            status.entrySize = size;
            status.totalCalculatedSize = this.#calculatedSize;
          }
        };
      }
      #removeItemSize = (_i) => {
      };
      #addItemSize = (_i, _s2, _st) => {
      };
      #requireSize = (_k, _v, size, sizeCalculation) => {
        if (size || sizeCalculation) {
          throw new TypeError("cannot set size without setting maxSize or maxEntrySize on cache");
        }
        return 0;
      };
      *#indexes({ allowStale = this.allowStale } = {}) {
        if (this.#size) {
          for (let i = this.#tail; true; ) {
            if (!this.#isValidIndex(i)) {
              break;
            }
            if (allowStale || !this.#isStale(i)) {
              yield i;
            }
            if (i === this.#head) {
              break;
            } else {
              i = this.#prev[i];
            }
          }
        }
      }
      *#rindexes({ allowStale = this.allowStale } = {}) {
        if (this.#size) {
          for (let i = this.#head; true; ) {
            if (!this.#isValidIndex(i)) {
              break;
            }
            if (allowStale || !this.#isStale(i)) {
              yield i;
            }
            if (i === this.#tail) {
              break;
            } else {
              i = this.#next[i];
            }
          }
        }
      }
      #isValidIndex(index) {
        return index !== void 0 && this.#keyMap.get(this.#keyList[index]) === index;
      }
      /**
       * Return a generator yielding `[key, value]` pairs,
       * in order from most recently used to least recently used.
       */
      *entries() {
        for (const i of this.#indexes()) {
          if (this.#valList[i] !== void 0 && this.#keyList[i] !== void 0 && !this.#isBackgroundFetch(this.#valList[i])) {
            yield [this.#keyList[i], this.#valList[i]];
          }
        }
      }
      /**
       * Inverse order version of {@link LRUCache.entries}
       *
       * Return a generator yielding `[key, value]` pairs,
       * in order from least recently used to most recently used.
       */
      *rentries() {
        for (const i of this.#rindexes()) {
          if (this.#valList[i] !== void 0 && this.#keyList[i] !== void 0 && !this.#isBackgroundFetch(this.#valList[i])) {
            yield [this.#keyList[i], this.#valList[i]];
          }
        }
      }
      /**
       * Return a generator yielding the keys in the cache,
       * in order from most recently used to least recently used.
       */
      *keys() {
        for (const i of this.#indexes()) {
          const k = this.#keyList[i];
          if (k !== void 0 && !this.#isBackgroundFetch(this.#valList[i])) {
            yield k;
          }
        }
      }
      /**
       * Inverse order version of {@link LRUCache.keys}
       *
       * Return a generator yielding the keys in the cache,
       * in order from least recently used to most recently used.
       */
      *rkeys() {
        for (const i of this.#rindexes()) {
          const k = this.#keyList[i];
          if (k !== void 0 && !this.#isBackgroundFetch(this.#valList[i])) {
            yield k;
          }
        }
      }
      /**
       * Return a generator yielding the values in the cache,
       * in order from most recently used to least recently used.
       */
      *values() {
        for (const i of this.#indexes()) {
          const v = this.#valList[i];
          if (v !== void 0 && !this.#isBackgroundFetch(this.#valList[i])) {
            yield this.#valList[i];
          }
        }
      }
      /**
       * Inverse order version of {@link LRUCache.values}
       *
       * Return a generator yielding the values in the cache,
       * in order from least recently used to most recently used.
       */
      *rvalues() {
        for (const i of this.#rindexes()) {
          const v = this.#valList[i];
          if (v !== void 0 && !this.#isBackgroundFetch(this.#valList[i])) {
            yield this.#valList[i];
          }
        }
      }
      /**
       * Iterating over the cache itself yields the same results as
       * {@link LRUCache.entries}
       */
      [Symbol.iterator]() {
        return this.entries();
      }
      /**
       * A String value that is used in the creation of the default string
       * description of an object. Called by the built-in method
       * `Object.prototype.toString`.
       */
      [Symbol.toStringTag] = "LRUCache";
      /**
       * Find a value for which the supplied fn method returns a truthy value,
       * similar to `Array.find()`. fn is called as `fn(value, key, cache)`.
       */
      find(fn, getOptions = {}) {
        for (const i of this.#indexes()) {
          const v = this.#valList[i];
          const value = this.#isBackgroundFetch(v) ? v.__staleWhileFetching : v;
          if (value === void 0)
            continue;
          if (fn(value, this.#keyList[i], this)) {
            return this.get(this.#keyList[i], getOptions);
          }
        }
      }
      /**
       * Call the supplied function on each item in the cache, in order from most
       * recently used to least recently used.
       *
       * `fn` is called as `fn(value, key, cache)`.
       *
       * If `thisp` is provided, function will be called in the `this`-context of
       * the provided object, or the cache if no `thisp` object is provided.
       *
       * Does not update age or recenty of use, or iterate over stale values.
       */
      forEach(fn, thisp = this) {
        for (const i of this.#indexes()) {
          const v = this.#valList[i];
          const value = this.#isBackgroundFetch(v) ? v.__staleWhileFetching : v;
          if (value === void 0)
            continue;
          fn.call(thisp, value, this.#keyList[i], this);
        }
      }
      /**
       * The same as {@link LRUCache.forEach} but items are iterated over in
       * reverse order.  (ie, less recently used items are iterated over first.)
       */
      rforEach(fn, thisp = this) {
        for (const i of this.#rindexes()) {
          const v = this.#valList[i];
          const value = this.#isBackgroundFetch(v) ? v.__staleWhileFetching : v;
          if (value === void 0)
            continue;
          fn.call(thisp, value, this.#keyList[i], this);
        }
      }
      /**
       * Delete any stale entries. Returns true if anything was removed,
       * false otherwise.
       */
      purgeStale() {
        let deleted = false;
        for (const i of this.#rindexes({ allowStale: true })) {
          if (this.#isStale(i)) {
            this.#delete(this.#keyList[i], "expire");
            deleted = true;
          }
        }
        return deleted;
      }
      /**
       * Get the extended info about a given entry, to get its value, size, and
       * TTL info simultaneously. Returns `undefined` if the key is not present.
       *
       * Unlike {@link LRUCache#dump}, which is designed to be portable and survive
       * serialization, the `start` value is always the current timestamp, and the
       * `ttl` is a calculated remaining time to live (negative if expired).
       *
       * Always returns stale values, if their info is found in the cache, so be
       * sure to check for expirations (ie, a negative {@link LRUCache.Entry#ttl})
       * if relevant.
       */
      info(key) {
        const i = this.#keyMap.get(key);
        if (i === void 0)
          return void 0;
        const v = this.#valList[i];
        const value = this.#isBackgroundFetch(v) ? v.__staleWhileFetching : v;
        if (value === void 0)
          return void 0;
        const entry = { value };
        if (this.#ttls && this.#starts) {
          const ttl = this.#ttls[i];
          const start = this.#starts[i];
          if (ttl && start) {
            const remain = ttl - (perf.now() - start);
            entry.ttl = remain;
            entry.start = Date.now();
          }
        }
        if (this.#sizes) {
          entry.size = this.#sizes[i];
        }
        return entry;
      }
      /**
       * Return an array of [key, {@link LRUCache.Entry}] tuples which can be
       * passed to {@link LRUCache#load}.
       *
       * The `start` fields are calculated relative to a portable `Date.now()`
       * timestamp, even if `performance.now()` is available.
       *
       * Stale entries are always included in the `dump`, even if
       * {@link LRUCache.OptionsBase.allowStale} is false.
       *
       * Note: this returns an actual array, not a generator, so it can be more
       * easily passed around.
       */
      dump() {
        const arr = [];
        for (const i of this.#indexes({ allowStale: true })) {
          const key = this.#keyList[i];
          const v = this.#valList[i];
          const value = this.#isBackgroundFetch(v) ? v.__staleWhileFetching : v;
          if (value === void 0 || key === void 0)
            continue;
          const entry = { value };
          if (this.#ttls && this.#starts) {
            entry.ttl = this.#ttls[i];
            const age = perf.now() - this.#starts[i];
            entry.start = Math.floor(Date.now() - age);
          }
          if (this.#sizes) {
            entry.size = this.#sizes[i];
          }
          arr.unshift([key, entry]);
        }
        return arr;
      }
      /**
       * Reset the cache and load in the items in entries in the order listed.
       *
       * The shape of the resulting cache may be different if the same options are
       * not used in both caches.
       *
       * The `start` fields are assumed to be calculated relative to a portable
       * `Date.now()` timestamp, even if `performance.now()` is available.
       */
      load(arr) {
        this.clear();
        for (const [key, entry] of arr) {
          if (entry.start) {
            const age = Date.now() - entry.start;
            entry.start = perf.now() - age;
          }
          this.set(key, entry.value, entry);
        }
      }
      /**
       * Add a value to the cache.
       *
       * Note: if `undefined` is specified as a value, this is an alias for
       * {@link LRUCache#delete}
       *
       * Fields on the {@link LRUCache.SetOptions} options param will override
       * their corresponding values in the constructor options for the scope
       * of this single `set()` operation.
       *
       * If `start` is provided, then that will set the effective start
       * time for the TTL calculation. Note that this must be a previous
       * value of `performance.now()` if supported, or a previous value of
       * `Date.now()` if not.
       *
       * Options object may also include `size`, which will prevent
       * calling the `sizeCalculation` function and just use the specified
       * number if it is a positive integer, and `noDisposeOnSet` which
       * will prevent calling a `dispose` function in the case of
       * overwrites.
       *
       * If the `size` (or return value of `sizeCalculation`) for a given
       * entry is greater than `maxEntrySize`, then the item will not be
       * added to the cache.
       *
       * Will update the recency of the entry.
       *
       * If the value is `undefined`, then this is an alias for
       * `cache.delete(key)`. `undefined` is never stored in the cache.
       */
      set(k, v, setOptions = {}) {
        if (v === void 0) {
          this.delete(k);
          return this;
        }
        const { ttl = this.ttl, start, noDisposeOnSet = this.noDisposeOnSet, sizeCalculation = this.sizeCalculation, status } = setOptions;
        let { noUpdateTTL = this.noUpdateTTL } = setOptions;
        const size = this.#requireSize(k, v, setOptions.size || 0, sizeCalculation);
        if (this.maxEntrySize && size > this.maxEntrySize) {
          if (status) {
            status.set = "miss";
            status.maxEntrySizeExceeded = true;
          }
          this.#delete(k, "set");
          return this;
        }
        let index = this.#size === 0 ? void 0 : this.#keyMap.get(k);
        if (index === void 0) {
          index = this.#size === 0 ? this.#tail : this.#free.length !== 0 ? this.#free.pop() : this.#size === this.#max ? this.#evict(false) : this.#size;
          this.#keyList[index] = k;
          this.#valList[index] = v;
          this.#keyMap.set(k, index);
          this.#next[this.#tail] = index;
          this.#prev[index] = this.#tail;
          this.#tail = index;
          this.#size++;
          this.#addItemSize(index, size, status);
          if (status)
            status.set = "add";
          noUpdateTTL = false;
          if (this.#hasOnInsert) {
            this.#onInsert?.(v, k, "add");
          }
        } else {
          this.#moveToTail(index);
          const oldVal = this.#valList[index];
          if (v !== oldVal) {
            if (this.#hasFetchMethod && this.#isBackgroundFetch(oldVal)) {
              oldVal.__abortController.abort(new Error("replaced"));
              const { __staleWhileFetching: s } = oldVal;
              if (s !== void 0 && !noDisposeOnSet) {
                if (this.#hasDispose) {
                  this.#dispose?.(s, k, "set");
                }
                if (this.#hasDisposeAfter) {
                  this.#disposed?.push([s, k, "set"]);
                }
              }
            } else if (!noDisposeOnSet) {
              if (this.#hasDispose) {
                this.#dispose?.(oldVal, k, "set");
              }
              if (this.#hasDisposeAfter) {
                this.#disposed?.push([oldVal, k, "set"]);
              }
            }
            this.#removeItemSize(index);
            this.#addItemSize(index, size, status);
            this.#valList[index] = v;
            if (status) {
              status.set = "replace";
              const oldValue = oldVal && this.#isBackgroundFetch(oldVal) ? oldVal.__staleWhileFetching : oldVal;
              if (oldValue !== void 0)
                status.oldValue = oldValue;
            }
          } else if (status) {
            status.set = "update";
          }
          if (this.#hasOnInsert) {
            this.onInsert?.(v, k, v === oldVal ? "update" : "replace");
          }
        }
        if (ttl !== 0 && !this.#ttls) {
          this.#initializeTTLTracking();
        }
        if (this.#ttls) {
          if (!noUpdateTTL) {
            this.#setItemTTL(index, ttl, start);
          }
          if (status)
            this.#statusTTL(status, index);
        }
        if (!noDisposeOnSet && this.#hasDisposeAfter && this.#disposed) {
          const dt = this.#disposed;
          let task;
          while (task = dt?.shift()) {
            this.#disposeAfter?.(...task);
          }
        }
        return this;
      }
      /**
       * Evict the least recently used item, returning its value or
       * `undefined` if cache is empty.
       */
      pop() {
        try {
          while (this.#size) {
            const val = this.#valList[this.#head];
            this.#evict(true);
            if (this.#isBackgroundFetch(val)) {
              if (val.__staleWhileFetching) {
                return val.__staleWhileFetching;
              }
            } else if (val !== void 0) {
              return val;
            }
          }
        } finally {
          if (this.#hasDisposeAfter && this.#disposed) {
            const dt = this.#disposed;
            let task;
            while (task = dt?.shift()) {
              this.#disposeAfter?.(...task);
            }
          }
        }
      }
      #evict(free) {
        const head = this.#head;
        const k = this.#keyList[head];
        const v = this.#valList[head];
        if (this.#hasFetchMethod && this.#isBackgroundFetch(v)) {
          v.__abortController.abort(new Error("evicted"));
        } else if (this.#hasDispose || this.#hasDisposeAfter) {
          if (this.#hasDispose) {
            this.#dispose?.(v, k, "evict");
          }
          if (this.#hasDisposeAfter) {
            this.#disposed?.push([v, k, "evict"]);
          }
        }
        this.#removeItemSize(head);
        if (free) {
          this.#keyList[head] = void 0;
          this.#valList[head] = void 0;
          this.#free.push(head);
        }
        if (this.#size === 1) {
          this.#head = this.#tail = 0;
          this.#free.length = 0;
        } else {
          this.#head = this.#next[head];
        }
        this.#keyMap.delete(k);
        this.#size--;
        return head;
      }
      /**
       * Check if a key is in the cache, without updating the recency of use.
       * Will return false if the item is stale, even though it is technically
       * in the cache.
       *
       * Check if a key is in the cache, without updating the recency of
       * use. Age is updated if {@link LRUCache.OptionsBase.updateAgeOnHas} is set
       * to `true` in either the options or the constructor.
       *
       * Will return `false` if the item is stale, even though it is technically in
       * the cache. The difference can be determined (if it matters) by using a
       * `status` argument, and inspecting the `has` field.
       *
       * Will not update item age unless
       * {@link LRUCache.OptionsBase.updateAgeOnHas} is set.
       */
      has(k, hasOptions = {}) {
        const { updateAgeOnHas = this.updateAgeOnHas, status } = hasOptions;
        const index = this.#keyMap.get(k);
        if (index !== void 0) {
          const v = this.#valList[index];
          if (this.#isBackgroundFetch(v) && v.__staleWhileFetching === void 0) {
            return false;
          }
          if (!this.#isStale(index)) {
            if (updateAgeOnHas) {
              this.#updateItemAge(index);
            }
            if (status) {
              status.has = "hit";
              this.#statusTTL(status, index);
            }
            return true;
          } else if (status) {
            status.has = "stale";
            this.#statusTTL(status, index);
          }
        } else if (status) {
          status.has = "miss";
        }
        return false;
      }
      /**
       * Like {@link LRUCache#get} but doesn't update recency or delete stale
       * items.
       *
       * Returns `undefined` if the item is stale, unless
       * {@link LRUCache.OptionsBase.allowStale} is set.
       */
      peek(k, peekOptions = {}) {
        const { allowStale = this.allowStale } = peekOptions;
        const index = this.#keyMap.get(k);
        if (index === void 0 || !allowStale && this.#isStale(index)) {
          return;
        }
        const v = this.#valList[index];
        return this.#isBackgroundFetch(v) ? v.__staleWhileFetching : v;
      }
      #backgroundFetch(k, index, options, context) {
        const v = index === void 0 ? void 0 : this.#valList[index];
        if (this.#isBackgroundFetch(v)) {
          return v;
        }
        const ac = new AC();
        const { signal } = options;
        signal?.addEventListener("abort", () => ac.abort(signal.reason), {
          signal: ac.signal
        });
        const fetchOpts = {
          signal: ac.signal,
          options,
          context
        };
        const cb = (v2, updateCache = false) => {
          const { aborted } = ac.signal;
          const ignoreAbort = options.ignoreFetchAbort && v2 !== void 0;
          if (options.status) {
            if (aborted && !updateCache) {
              options.status.fetchAborted = true;
              options.status.fetchError = ac.signal.reason;
              if (ignoreAbort)
                options.status.fetchAbortIgnored = true;
            } else {
              options.status.fetchResolved = true;
            }
          }
          if (aborted && !ignoreAbort && !updateCache) {
            return fetchFail(ac.signal.reason);
          }
          const bf2 = p;
          if (this.#valList[index] === p) {
            if (v2 === void 0) {
              if (bf2.__staleWhileFetching) {
                this.#valList[index] = bf2.__staleWhileFetching;
              } else {
                this.#delete(k, "fetch");
              }
            } else {
              if (options.status)
                options.status.fetchUpdated = true;
              this.set(k, v2, fetchOpts.options);
            }
          }
          return v2;
        };
        const eb = (er) => {
          if (options.status) {
            options.status.fetchRejected = true;
            options.status.fetchError = er;
          }
          return fetchFail(er);
        };
        const fetchFail = (er) => {
          const { aborted } = ac.signal;
          const allowStaleAborted = aborted && options.allowStaleOnFetchAbort;
          const allowStale = allowStaleAborted || options.allowStaleOnFetchRejection;
          const noDelete = allowStale || options.noDeleteOnFetchRejection;
          const bf2 = p;
          if (this.#valList[index] === p) {
            const del = !noDelete || bf2.__staleWhileFetching === void 0;
            if (del) {
              this.#delete(k, "fetch");
            } else if (!allowStaleAborted) {
              this.#valList[index] = bf2.__staleWhileFetching;
            }
          }
          if (allowStale) {
            if (options.status && bf2.__staleWhileFetching !== void 0) {
              options.status.returnedStale = true;
            }
            return bf2.__staleWhileFetching;
          } else if (bf2.__returned === bf2) {
            throw er;
          }
        };
        const pcall = (res, rej) => {
          const fmp = this.#fetchMethod?.(k, v, fetchOpts);
          if (fmp && fmp instanceof Promise) {
            fmp.then((v2) => res(v2 === void 0 ? void 0 : v2), rej);
          }
          ac.signal.addEventListener("abort", () => {
            if (!options.ignoreFetchAbort || options.allowStaleOnFetchAbort) {
              res(void 0);
              if (options.allowStaleOnFetchAbort) {
                res = (v2) => cb(v2, true);
              }
            }
          });
        };
        if (options.status)
          options.status.fetchDispatched = true;
        const p = new Promise(pcall).then(cb, eb);
        const bf = Object.assign(p, {
          __abortController: ac,
          __staleWhileFetching: v,
          __returned: void 0
        });
        if (index === void 0) {
          this.set(k, bf, { ...fetchOpts.options, status: void 0 });
          index = this.#keyMap.get(k);
        } else {
          this.#valList[index] = bf;
        }
        return bf;
      }
      #isBackgroundFetch(p) {
        if (!this.#hasFetchMethod)
          return false;
        const b = p;
        return !!b && b instanceof Promise && b.hasOwnProperty("__staleWhileFetching") && b.__abortController instanceof AC;
      }
      async fetch(k, fetchOptions = {}) {
        const {
          // get options
          allowStale = this.allowStale,
          updateAgeOnGet = this.updateAgeOnGet,
          noDeleteOnStaleGet = this.noDeleteOnStaleGet,
          // set options
          ttl = this.ttl,
          noDisposeOnSet = this.noDisposeOnSet,
          size = 0,
          sizeCalculation = this.sizeCalculation,
          noUpdateTTL = this.noUpdateTTL,
          // fetch exclusive options
          noDeleteOnFetchRejection = this.noDeleteOnFetchRejection,
          allowStaleOnFetchRejection = this.allowStaleOnFetchRejection,
          ignoreFetchAbort = this.ignoreFetchAbort,
          allowStaleOnFetchAbort = this.allowStaleOnFetchAbort,
          context,
          forceRefresh = false,
          status,
          signal
        } = fetchOptions;
        if (!this.#hasFetchMethod) {
          if (status)
            status.fetch = "get";
          return this.get(k, {
            allowStale,
            updateAgeOnGet,
            noDeleteOnStaleGet,
            status
          });
        }
        const options = {
          allowStale,
          updateAgeOnGet,
          noDeleteOnStaleGet,
          ttl,
          noDisposeOnSet,
          size,
          sizeCalculation,
          noUpdateTTL,
          noDeleteOnFetchRejection,
          allowStaleOnFetchRejection,
          allowStaleOnFetchAbort,
          ignoreFetchAbort,
          status,
          signal
        };
        let index = this.#keyMap.get(k);
        if (index === void 0) {
          if (status)
            status.fetch = "miss";
          const p = this.#backgroundFetch(k, index, options, context);
          return p.__returned = p;
        } else {
          const v = this.#valList[index];
          if (this.#isBackgroundFetch(v)) {
            const stale = allowStale && v.__staleWhileFetching !== void 0;
            if (status) {
              status.fetch = "inflight";
              if (stale)
                status.returnedStale = true;
            }
            return stale ? v.__staleWhileFetching : v.__returned = v;
          }
          const isStale = this.#isStale(index);
          if (!forceRefresh && !isStale) {
            if (status)
              status.fetch = "hit";
            this.#moveToTail(index);
            if (updateAgeOnGet) {
              this.#updateItemAge(index);
            }
            if (status)
              this.#statusTTL(status, index);
            return v;
          }
          const p = this.#backgroundFetch(k, index, options, context);
          const hasStale = p.__staleWhileFetching !== void 0;
          const staleVal = hasStale && allowStale;
          if (status) {
            status.fetch = isStale ? "stale" : "refresh";
            if (staleVal && isStale)
              status.returnedStale = true;
          }
          return staleVal ? p.__staleWhileFetching : p.__returned = p;
        }
      }
      async forceFetch(k, fetchOptions = {}) {
        const v = await this.fetch(k, fetchOptions);
        if (v === void 0)
          throw new Error("fetch() returned undefined");
        return v;
      }
      memo(k, memoOptions = {}) {
        const memoMethod = this.#memoMethod;
        if (!memoMethod) {
          throw new Error("no memoMethod provided to constructor");
        }
        const { context, forceRefresh, ...options } = memoOptions;
        const v = this.get(k, options);
        if (!forceRefresh && v !== void 0)
          return v;
        const vv = memoMethod(k, v, {
          options,
          context
        });
        this.set(k, vv, options);
        return vv;
      }
      /**
       * Return a value from the cache. Will update the recency of the cache
       * entry found.
       *
       * If the key is not found, get() will return `undefined`.
       */
      get(k, getOptions = {}) {
        const { allowStale = this.allowStale, updateAgeOnGet = this.updateAgeOnGet, noDeleteOnStaleGet = this.noDeleteOnStaleGet, status } = getOptions;
        const index = this.#keyMap.get(k);
        if (index !== void 0) {
          const value = this.#valList[index];
          const fetching = this.#isBackgroundFetch(value);
          if (status)
            this.#statusTTL(status, index);
          if (this.#isStale(index)) {
            if (status)
              status.get = "stale";
            if (!fetching) {
              if (!noDeleteOnStaleGet) {
                this.#delete(k, "expire");
              }
              if (status && allowStale)
                status.returnedStale = true;
              return allowStale ? value : void 0;
            } else {
              if (status && allowStale && value.__staleWhileFetching !== void 0) {
                status.returnedStale = true;
              }
              return allowStale ? value.__staleWhileFetching : void 0;
            }
          } else {
            if (status)
              status.get = "hit";
            if (fetching) {
              return value.__staleWhileFetching;
            }
            this.#moveToTail(index);
            if (updateAgeOnGet) {
              this.#updateItemAge(index);
            }
            return value;
          }
        } else if (status) {
          status.get = "miss";
        }
      }
      #connect(p, n) {
        this.#prev[n] = p;
        this.#next[p] = n;
      }
      #moveToTail(index) {
        if (index !== this.#tail) {
          if (index === this.#head) {
            this.#head = this.#next[index];
          } else {
            this.#connect(this.#prev[index], this.#next[index]);
          }
          this.#connect(this.#tail, index);
          this.#tail = index;
        }
      }
      /**
       * Deletes a key out of the cache.
       *
       * Returns true if the key was deleted, false otherwise.
       */
      delete(k) {
        return this.#delete(k, "delete");
      }
      #delete(k, reason) {
        let deleted = false;
        if (this.#size !== 0) {
          const index = this.#keyMap.get(k);
          if (index !== void 0) {
            deleted = true;
            if (this.#size === 1) {
              this.#clear(reason);
            } else {
              this.#removeItemSize(index);
              const v = this.#valList[index];
              if (this.#isBackgroundFetch(v)) {
                v.__abortController.abort(new Error("deleted"));
              } else if (this.#hasDispose || this.#hasDisposeAfter) {
                if (this.#hasDispose) {
                  this.#dispose?.(v, k, reason);
                }
                if (this.#hasDisposeAfter) {
                  this.#disposed?.push([v, k, reason]);
                }
              }
              this.#keyMap.delete(k);
              this.#keyList[index] = void 0;
              this.#valList[index] = void 0;
              if (index === this.#tail) {
                this.#tail = this.#prev[index];
              } else if (index === this.#head) {
                this.#head = this.#next[index];
              } else {
                const pi = this.#prev[index];
                this.#next[pi] = this.#next[index];
                const ni = this.#next[index];
                this.#prev[ni] = this.#prev[index];
              }
              this.#size--;
              this.#free.push(index);
            }
          }
        }
        if (this.#hasDisposeAfter && this.#disposed?.length) {
          const dt = this.#disposed;
          let task;
          while (task = dt?.shift()) {
            this.#disposeAfter?.(...task);
          }
        }
        return deleted;
      }
      /**
       * Clear the cache entirely, throwing away all values.
       */
      clear() {
        return this.#clear("delete");
      }
      #clear(reason) {
        for (const index of this.#rindexes({ allowStale: true })) {
          const v = this.#valList[index];
          if (this.#isBackgroundFetch(v)) {
            v.__abortController.abort(new Error("deleted"));
          } else {
            const k = this.#keyList[index];
            if (this.#hasDispose) {
              this.#dispose?.(v, k, reason);
            }
            if (this.#hasDisposeAfter) {
              this.#disposed?.push([v, k, reason]);
            }
          }
        }
        this.#keyMap.clear();
        this.#valList.fill(void 0);
        this.#keyList.fill(void 0);
        if (this.#ttls && this.#starts) {
          this.#ttls.fill(0);
          this.#starts.fill(0);
        }
        if (this.#sizes) {
          this.#sizes.fill(0);
        }
        this.#head = 0;
        this.#tail = 0;
        this.#free.length = 0;
        this.#calculatedSize = 0;
        this.#size = 0;
        if (this.#hasDisposeAfter && this.#disposed) {
          const dt = this.#disposed;
          let task;
          while (task = dt?.shift()) {
            this.#disposeAfter?.(...task);
          }
        }
      }
    };
    exports2.LRUCache = LRUCache;
  }
});

// node_modules/minipass/dist/commonjs/index.js
var require_commonjs5 = __commonJS({
  "node_modules/minipass/dist/commonjs/index.js"(exports2) {
    "use strict";
    var __importDefault = exports2 && exports2.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.Minipass = exports2.isWritable = exports2.isReadable = exports2.isStream = void 0;
    var proc = typeof process === "object" && process ? process : {
      stdout: null,
      stderr: null
    };
    var node_events_1 = require("node:events");
    var node_stream_1 = __importDefault(require("node:stream"));
    var node_string_decoder_1 = require("node:string_decoder");
    var isStream = (s) => !!s && typeof s === "object" && (s instanceof Minipass || s instanceof node_stream_1.default || (0, exports2.isReadable)(s) || (0, exports2.isWritable)(s));
    exports2.isStream = isStream;
    var isReadable = (s) => !!s && typeof s === "object" && s instanceof node_events_1.EventEmitter && typeof s.pipe === "function" && // node core Writable streams have a pipe() method, but it throws
    s.pipe !== node_stream_1.default.Writable.prototype.pipe;
    exports2.isReadable = isReadable;
    var isWritable = (s) => !!s && typeof s === "object" && s instanceof node_events_1.EventEmitter && typeof s.write === "function" && typeof s.end === "function";
    exports2.isWritable = isWritable;
    var EOF = Symbol("EOF");
    var MAYBE_EMIT_END = Symbol("maybeEmitEnd");
    var EMITTED_END = Symbol("emittedEnd");
    var EMITTING_END = Symbol("emittingEnd");
    var EMITTED_ERROR = Symbol("emittedError");
    var CLOSED = Symbol("closed");
    var READ = Symbol("read");
    var FLUSH = Symbol("flush");
    var FLUSHCHUNK = Symbol("flushChunk");
    var ENCODING = Symbol("encoding");
    var DECODER = Symbol("decoder");
    var FLOWING = Symbol("flowing");
    var PAUSED = Symbol("paused");
    var RESUME = Symbol("resume");
    var BUFFER = Symbol("buffer");
    var PIPES = Symbol("pipes");
    var BUFFERLENGTH = Symbol("bufferLength");
    var BUFFERPUSH = Symbol("bufferPush");
    var BUFFERSHIFT = Symbol("bufferShift");
    var OBJECTMODE = Symbol("objectMode");
    var DESTROYED = Symbol("destroyed");
    var ERROR = Symbol("error");
    var EMITDATA = Symbol("emitData");
    var EMITEND = Symbol("emitEnd");
    var EMITEND2 = Symbol("emitEnd2");
    var ASYNC = Symbol("async");
    var ABORT = Symbol("abort");
    var ABORTED = Symbol("aborted");
    var SIGNAL = Symbol("signal");
    var DATALISTENERS = Symbol("dataListeners");
    var DISCARDED = Symbol("discarded");
    var defer = (fn) => Promise.resolve().then(fn);
    var nodefer = (fn) => fn();
    var isEndish = (ev) => ev === "end" || ev === "finish" || ev === "prefinish";
    var isArrayBufferLike = (b) => b instanceof ArrayBuffer || !!b && typeof b === "object" && b.constructor && b.constructor.name === "ArrayBuffer" && b.byteLength >= 0;
    var isArrayBufferView = (b) => !Buffer.isBuffer(b) && ArrayBuffer.isView(b);
    var Pipe = class {
      src;
      dest;
      opts;
      ondrain;
      constructor(src, dest, opts) {
        this.src = src;
        this.dest = dest;
        this.opts = opts;
        this.ondrain = () => src[RESUME]();
        this.dest.on("drain", this.ondrain);
      }
      unpipe() {
        this.dest.removeListener("drain", this.ondrain);
      }
      // only here for the prototype
      /* c8 ignore start */
      proxyErrors(_er) {
      }
      /* c8 ignore stop */
      end() {
        this.unpipe();
        if (this.opts.end)
          this.dest.end();
      }
    };
    var PipeProxyErrors = class extends Pipe {
      unpipe() {
        this.src.removeListener("error", this.proxyErrors);
        super.unpipe();
      }
      constructor(src, dest, opts) {
        super(src, dest, opts);
        this.proxyErrors = (er) => dest.emit("error", er);
        src.on("error", this.proxyErrors);
      }
    };
    var isObjectModeOptions = (o) => !!o.objectMode;
    var isEncodingOptions = (o) => !o.objectMode && !!o.encoding && o.encoding !== "buffer";
    var Minipass = class extends node_events_1.EventEmitter {
      [FLOWING] = false;
      [PAUSED] = false;
      [PIPES] = [];
      [BUFFER] = [];
      [OBJECTMODE];
      [ENCODING];
      [ASYNC];
      [DECODER];
      [EOF] = false;
      [EMITTED_END] = false;
      [EMITTING_END] = false;
      [CLOSED] = false;
      [EMITTED_ERROR] = null;
      [BUFFERLENGTH] = 0;
      [DESTROYED] = false;
      [SIGNAL];
      [ABORTED] = false;
      [DATALISTENERS] = 0;
      [DISCARDED] = false;
      /**
       * true if the stream can be written
       */
      writable = true;
      /**
       * true if the stream can be read
       */
      readable = true;
      /**
       * If `RType` is Buffer, then options do not need to be provided.
       * Otherwise, an options object must be provided to specify either
       * {@link Minipass.SharedOptions.objectMode} or
       * {@link Minipass.SharedOptions.encoding}, as appropriate.
       */
      constructor(...args) {
        const options = args[0] || {};
        super();
        if (options.objectMode && typeof options.encoding === "string") {
          throw new TypeError("Encoding and objectMode may not be used together");
        }
        if (isObjectModeOptions(options)) {
          this[OBJECTMODE] = true;
          this[ENCODING] = null;
        } else if (isEncodingOptions(options)) {
          this[ENCODING] = options.encoding;
          this[OBJECTMODE] = false;
        } else {
          this[OBJECTMODE] = false;
          this[ENCODING] = null;
        }
        this[ASYNC] = !!options.async;
        this[DECODER] = this[ENCODING] ? new node_string_decoder_1.StringDecoder(this[ENCODING]) : null;
        if (options && options.debugExposeBuffer === true) {
          Object.defineProperty(this, "buffer", { get: () => this[BUFFER] });
        }
        if (options && options.debugExposePipes === true) {
          Object.defineProperty(this, "pipes", { get: () => this[PIPES] });
        }
        const { signal } = options;
        if (signal) {
          this[SIGNAL] = signal;
          if (signal.aborted) {
            this[ABORT]();
          } else {
            signal.addEventListener("abort", () => this[ABORT]());
          }
        }
      }
      /**
       * The amount of data stored in the buffer waiting to be read.
       *
       * For Buffer strings, this will be the total byte length.
       * For string encoding streams, this will be the string character length,
       * according to JavaScript's `string.length` logic.
       * For objectMode streams, this is a count of the items waiting to be
       * emitted.
       */
      get bufferLength() {
        return this[BUFFERLENGTH];
      }
      /**
       * The `BufferEncoding` currently in use, or `null`
       */
      get encoding() {
        return this[ENCODING];
      }
      /**
       * @deprecated - This is a read only property
       */
      set encoding(_enc) {
        throw new Error("Encoding must be set at instantiation time");
      }
      /**
       * @deprecated - Encoding may only be set at instantiation time
       */
      setEncoding(_enc) {
        throw new Error("Encoding must be set at instantiation time");
      }
      /**
       * True if this is an objectMode stream
       */
      get objectMode() {
        return this[OBJECTMODE];
      }
      /**
       * @deprecated - This is a read-only property
       */
      set objectMode(_om) {
        throw new Error("objectMode must be set at instantiation time");
      }
      /**
       * true if this is an async stream
       */
      get ["async"]() {
        return this[ASYNC];
      }
      /**
       * Set to true to make this stream async.
       *
       * Once set, it cannot be unset, as this would potentially cause incorrect
       * behavior.  Ie, a sync stream can be made async, but an async stream
       * cannot be safely made sync.
       */
      set ["async"](a) {
        this[ASYNC] = this[ASYNC] || !!a;
      }
      // drop everything and get out of the flow completely
      [ABORT]() {
        this[ABORTED] = true;
        this.emit("abort", this[SIGNAL]?.reason);
        this.destroy(this[SIGNAL]?.reason);
      }
      /**
       * True if the stream has been aborted.
       */
      get aborted() {
        return this[ABORTED];
      }
      /**
       * No-op setter. Stream aborted status is set via the AbortSignal provided
       * in the constructor options.
       */
      set aborted(_) {
      }
      write(chunk, encoding, cb) {
        if (this[ABORTED])
          return false;
        if (this[EOF])
          throw new Error("write after end");
        if (this[DESTROYED]) {
          this.emit("error", Object.assign(new Error("Cannot call write after a stream was destroyed"), { code: "ERR_STREAM_DESTROYED" }));
          return true;
        }
        if (typeof encoding === "function") {
          cb = encoding;
          encoding = "utf8";
        }
        if (!encoding)
          encoding = "utf8";
        const fn = this[ASYNC] ? defer : nodefer;
        if (!this[OBJECTMODE] && !Buffer.isBuffer(chunk)) {
          if (isArrayBufferView(chunk)) {
            chunk = Buffer.from(chunk.buffer, chunk.byteOffset, chunk.byteLength);
          } else if (isArrayBufferLike(chunk)) {
            chunk = Buffer.from(chunk);
          } else if (typeof chunk !== "string") {
            throw new Error("Non-contiguous data written to non-objectMode stream");
          }
        }
        if (this[OBJECTMODE]) {
          if (this[FLOWING] && this[BUFFERLENGTH] !== 0)
            this[FLUSH](true);
          if (this[FLOWING])
            this.emit("data", chunk);
          else
            this[BUFFERPUSH](chunk);
          if (this[BUFFERLENGTH] !== 0)
            this.emit("readable");
          if (cb)
            fn(cb);
          return this[FLOWING];
        }
        if (!chunk.length) {
          if (this[BUFFERLENGTH] !== 0)
            this.emit("readable");
          if (cb)
            fn(cb);
          return this[FLOWING];
        }
        if (typeof chunk === "string" && // unless it is a string already ready for us to use
        !(encoding === this[ENCODING] && !this[DECODER]?.lastNeed)) {
          chunk = Buffer.from(chunk, encoding);
        }
        if (Buffer.isBuffer(chunk) && this[ENCODING]) {
          chunk = this[DECODER].write(chunk);
        }
        if (this[FLOWING] && this[BUFFERLENGTH] !== 0)
          this[FLUSH](true);
        if (this[FLOWING])
          this.emit("data", chunk);
        else
          this[BUFFERPUSH](chunk);
        if (this[BUFFERLENGTH] !== 0)
          this.emit("readable");
        if (cb)
          fn(cb);
        return this[FLOWING];
      }
      /**
       * Low-level explicit read method.
       *
       * In objectMode, the argument is ignored, and one item is returned if
       * available.
       *
       * `n` is the number of bytes (or in the case of encoding streams,
       * characters) to consume. If `n` is not provided, then the entire buffer
       * is returned, or `null` is returned if no data is available.
       *
       * If `n` is greater that the amount of data in the internal buffer,
       * then `null` is returned.
       */
      read(n) {
        if (this[DESTROYED])
          return null;
        this[DISCARDED] = false;
        if (this[BUFFERLENGTH] === 0 || n === 0 || n && n > this[BUFFERLENGTH]) {
          this[MAYBE_EMIT_END]();
          return null;
        }
        if (this[OBJECTMODE])
          n = null;
        if (this[BUFFER].length > 1 && !this[OBJECTMODE]) {
          this[BUFFER] = [
            this[ENCODING] ? this[BUFFER].join("") : Buffer.concat(this[BUFFER], this[BUFFERLENGTH])
          ];
        }
        const ret = this[READ](n || null, this[BUFFER][0]);
        this[MAYBE_EMIT_END]();
        return ret;
      }
      [READ](n, chunk) {
        if (this[OBJECTMODE])
          this[BUFFERSHIFT]();
        else {
          const c = chunk;
          if (n === c.length || n === null)
            this[BUFFERSHIFT]();
          else if (typeof c === "string") {
            this[BUFFER][0] = c.slice(n);
            chunk = c.slice(0, n);
            this[BUFFERLENGTH] -= n;
          } else {
            this[BUFFER][0] = c.subarray(n);
            chunk = c.subarray(0, n);
            this[BUFFERLENGTH] -= n;
          }
        }
        this.emit("data", chunk);
        if (!this[BUFFER].length && !this[EOF])
          this.emit("drain");
        return chunk;
      }
      end(chunk, encoding, cb) {
        if (typeof chunk === "function") {
          cb = chunk;
          chunk = void 0;
        }
        if (typeof encoding === "function") {
          cb = encoding;
          encoding = "utf8";
        }
        if (chunk !== void 0)
          this.write(chunk, encoding);
        if (cb)
          this.once("end", cb);
        this[EOF] = true;
        this.writable = false;
        if (this[FLOWING] || !this[PAUSED])
          this[MAYBE_EMIT_END]();
        return this;
      }
      // don't let the internal resume be overwritten
      [RESUME]() {
        if (this[DESTROYED])
          return;
        if (!this[DATALISTENERS] && !this[PIPES].length) {
          this[DISCARDED] = true;
        }
        this[PAUSED] = false;
        this[FLOWING] = true;
        this.emit("resume");
        if (this[BUFFER].length)
          this[FLUSH]();
        else if (this[EOF])
          this[MAYBE_EMIT_END]();
        else
          this.emit("drain");
      }
      /**
       * Resume the stream if it is currently in a paused state
       *
       * If called when there are no pipe destinations or `data` event listeners,
       * this will place the stream in a "discarded" state, where all data will
       * be thrown away. The discarded state is removed if a pipe destination or
       * data handler is added, if pause() is called, or if any synchronous or
       * asynchronous iteration is started.
       */
      resume() {
        return this[RESUME]();
      }
      /**
       * Pause the stream
       */
      pause() {
        this[FLOWING] = false;
        this[PAUSED] = true;
        this[DISCARDED] = false;
      }
      /**
       * true if the stream has been forcibly destroyed
       */
      get destroyed() {
        return this[DESTROYED];
      }
      /**
       * true if the stream is currently in a flowing state, meaning that
       * any writes will be immediately emitted.
       */
      get flowing() {
        return this[FLOWING];
      }
      /**
       * true if the stream is currently in a paused state
       */
      get paused() {
        return this[PAUSED];
      }
      [BUFFERPUSH](chunk) {
        if (this[OBJECTMODE])
          this[BUFFERLENGTH] += 1;
        else
          this[BUFFERLENGTH] += chunk.length;
        this[BUFFER].push(chunk);
      }
      [BUFFERSHIFT]() {
        if (this[OBJECTMODE])
          this[BUFFERLENGTH] -= 1;
        else
          this[BUFFERLENGTH] -= this[BUFFER][0].length;
        return this[BUFFER].shift();
      }
      [FLUSH](noDrain = false) {
        do {
        } while (this[FLUSHCHUNK](this[BUFFERSHIFT]()) && this[BUFFER].length);
        if (!noDrain && !this[BUFFER].length && !this[EOF])
          this.emit("drain");
      }
      [FLUSHCHUNK](chunk) {
        this.emit("data", chunk);
        return this[FLOWING];
      }
      /**
       * Pipe all data emitted by this stream into the destination provided.
       *
       * Triggers the flow of data.
       */
      pipe(dest, opts) {
        if (this[DESTROYED])
          return dest;
        this[DISCARDED] = false;
        const ended = this[EMITTED_END];
        opts = opts || {};
        if (dest === proc.stdout || dest === proc.stderr)
          opts.end = false;
        else
          opts.end = opts.end !== false;
        opts.proxyErrors = !!opts.proxyErrors;
        if (ended) {
          if (opts.end)
            dest.end();
        } else {
          this[PIPES].push(!opts.proxyErrors ? new Pipe(this, dest, opts) : new PipeProxyErrors(this, dest, opts));
          if (this[ASYNC])
            defer(() => this[RESUME]());
          else
            this[RESUME]();
        }
        return dest;
      }
      /**
       * Fully unhook a piped destination stream.
       *
       * If the destination stream was the only consumer of this stream (ie,
       * there are no other piped destinations or `'data'` event listeners)
       * then the flow of data will stop until there is another consumer or
       * {@link Minipass#resume} is explicitly called.
       */
      unpipe(dest) {
        const p = this[PIPES].find((p2) => p2.dest === dest);
        if (p) {
          if (this[PIPES].length === 1) {
            if (this[FLOWING] && this[DATALISTENERS] === 0) {
              this[FLOWING] = false;
            }
            this[PIPES] = [];
          } else
            this[PIPES].splice(this[PIPES].indexOf(p), 1);
          p.unpipe();
        }
      }
      /**
       * Alias for {@link Minipass#on}
       */
      addListener(ev, handler) {
        return this.on(ev, handler);
      }
      /**
       * Mostly identical to `EventEmitter.on`, with the following
       * behavior differences to prevent data loss and unnecessary hangs:
       *
       * - Adding a 'data' event handler will trigger the flow of data
       *
       * - Adding a 'readable' event handler when there is data waiting to be read
       *   will cause 'readable' to be emitted immediately.
       *
       * - Adding an 'endish' event handler ('end', 'finish', etc.) which has
       *   already passed will cause the event to be emitted immediately and all
       *   handlers removed.
       *
       * - Adding an 'error' event handler after an error has been emitted will
       *   cause the event to be re-emitted immediately with the error previously
       *   raised.
       */
      on(ev, handler) {
        const ret = super.on(ev, handler);
        if (ev === "data") {
          this[DISCARDED] = false;
          this[DATALISTENERS]++;
          if (!this[PIPES].length && !this[FLOWING]) {
            this[RESUME]();
          }
        } else if (ev === "readable" && this[BUFFERLENGTH] !== 0) {
          super.emit("readable");
        } else if (isEndish(ev) && this[EMITTED_END]) {
          super.emit(ev);
          this.removeAllListeners(ev);
        } else if (ev === "error" && this[EMITTED_ERROR]) {
          const h = handler;
          if (this[ASYNC])
            defer(() => h.call(this, this[EMITTED_ERROR]));
          else
            h.call(this, this[EMITTED_ERROR]);
        }
        return ret;
      }
      /**
       * Alias for {@link Minipass#off}
       */
      removeListener(ev, handler) {
        return this.off(ev, handler);
      }
      /**
       * Mostly identical to `EventEmitter.off`
       *
       * If a 'data' event handler is removed, and it was the last consumer
       * (ie, there are no pipe destinations or other 'data' event listeners),
       * then the flow of data will stop until there is another consumer or
       * {@link Minipass#resume} is explicitly called.
       */
      off(ev, handler) {
        const ret = super.off(ev, handler);
        if (ev === "data") {
          this[DATALISTENERS] = this.listeners("data").length;
          if (this[DATALISTENERS] === 0 && !this[DISCARDED] && !this[PIPES].length) {
            this[FLOWING] = false;
          }
        }
        return ret;
      }
      /**
       * Mostly identical to `EventEmitter.removeAllListeners`
       *
       * If all 'data' event handlers are removed, and they were the last consumer
       * (ie, there are no pipe destinations), then the flow of data will stop
       * until there is another consumer or {@link Minipass#resume} is explicitly
       * called.
       */
      removeAllListeners(ev) {
        const ret = super.removeAllListeners(ev);
        if (ev === "data" || ev === void 0) {
          this[DATALISTENERS] = 0;
          if (!this[DISCARDED] && !this[PIPES].length) {
            this[FLOWING] = false;
          }
        }
        return ret;
      }
      /**
       * true if the 'end' event has been emitted
       */
      get emittedEnd() {
        return this[EMITTED_END];
      }
      [MAYBE_EMIT_END]() {
        if (!this[EMITTING_END] && !this[EMITTED_END] && !this[DESTROYED] && this[BUFFER].length === 0 && this[EOF]) {
          this[EMITTING_END] = true;
          this.emit("end");
          this.emit("prefinish");
          this.emit("finish");
          if (this[CLOSED])
            this.emit("close");
          this[EMITTING_END] = false;
        }
      }
      /**
       * Mostly identical to `EventEmitter.emit`, with the following
       * behavior differences to prevent data loss and unnecessary hangs:
       *
       * If the stream has been destroyed, and the event is something other
       * than 'close' or 'error', then `false` is returned and no handlers
       * are called.
       *
       * If the event is 'end', and has already been emitted, then the event
       * is ignored. If the stream is in a paused or non-flowing state, then
       * the event will be deferred until data flow resumes. If the stream is
       * async, then handlers will be called on the next tick rather than
       * immediately.
       *
       * If the event is 'close', and 'end' has not yet been emitted, then
       * the event will be deferred until after 'end' is emitted.
       *
       * If the event is 'error', and an AbortSignal was provided for the stream,
       * and there are no listeners, then the event is ignored, matching the
       * behavior of node core streams in the presense of an AbortSignal.
       *
       * If the event is 'finish' or 'prefinish', then all listeners will be
       * removed after emitting the event, to prevent double-firing.
       */
      emit(ev, ...args) {
        const data = args[0];
        if (ev !== "error" && ev !== "close" && ev !== DESTROYED && this[DESTROYED]) {
          return false;
        } else if (ev === "data") {
          return !this[OBJECTMODE] && !data ? false : this[ASYNC] ? (defer(() => this[EMITDATA](data)), true) : this[EMITDATA](data);
        } else if (ev === "end") {
          return this[EMITEND]();
        } else if (ev === "close") {
          this[CLOSED] = true;
          if (!this[EMITTED_END] && !this[DESTROYED])
            return false;
          const ret2 = super.emit("close");
          this.removeAllListeners("close");
          return ret2;
        } else if (ev === "error") {
          this[EMITTED_ERROR] = data;
          super.emit(ERROR, data);
          const ret2 = !this[SIGNAL] || this.listeners("error").length ? super.emit("error", data) : false;
          this[MAYBE_EMIT_END]();
          return ret2;
        } else if (ev === "resume") {
          const ret2 = super.emit("resume");
          this[MAYBE_EMIT_END]();
          return ret2;
        } else if (ev === "finish" || ev === "prefinish") {
          const ret2 = super.emit(ev);
          this.removeAllListeners(ev);
          return ret2;
        }
        const ret = super.emit(ev, ...args);
        this[MAYBE_EMIT_END]();
        return ret;
      }
      [EMITDATA](data) {
        for (const p of this[PIPES]) {
          if (p.dest.write(data) === false)
            this.pause();
        }
        const ret = this[DISCARDED] ? false : super.emit("data", data);
        this[MAYBE_EMIT_END]();
        return ret;
      }
      [EMITEND]() {
        if (this[EMITTED_END])
          return false;
        this[EMITTED_END] = true;
        this.readable = false;
        return this[ASYNC] ? (defer(() => this[EMITEND2]()), true) : this[EMITEND2]();
      }
      [EMITEND2]() {
        if (this[DECODER]) {
          const data = this[DECODER].end();
          if (data) {
            for (const p of this[PIPES]) {
              p.dest.write(data);
            }
            if (!this[DISCARDED])
              super.emit("data", data);
          }
        }
        for (const p of this[PIPES]) {
          p.end();
        }
        const ret = super.emit("end");
        this.removeAllListeners("end");
        return ret;
      }
      /**
       * Return a Promise that resolves to an array of all emitted data once
       * the stream ends.
       */
      async collect() {
        const buf = Object.assign([], {
          dataLength: 0
        });
        if (!this[OBJECTMODE])
          buf.dataLength = 0;
        const p = this.promise();
        this.on("data", (c) => {
          buf.push(c);
          if (!this[OBJECTMODE])
            buf.dataLength += c.length;
        });
        await p;
        return buf;
      }
      /**
       * Return a Promise that resolves to the concatenation of all emitted data
       * once the stream ends.
       *
       * Not allowed on objectMode streams.
       */
      async concat() {
        if (this[OBJECTMODE]) {
          throw new Error("cannot concat in objectMode");
        }
        const buf = await this.collect();
        return this[ENCODING] ? buf.join("") : Buffer.concat(buf, buf.dataLength);
      }
      /**
       * Return a void Promise that resolves once the stream ends.
       */
      async promise() {
        return new Promise((resolve, reject) => {
          this.on(DESTROYED, () => reject(new Error("stream destroyed")));
          this.on("error", (er) => reject(er));
          this.on("end", () => resolve());
        });
      }
      /**
       * Asynchronous `for await of` iteration.
       *
       * This will continue emitting all chunks until the stream terminates.
       */
      [Symbol.asyncIterator]() {
        this[DISCARDED] = false;
        let stopped = false;
        const stop = async () => {
          this.pause();
          stopped = true;
          return { value: void 0, done: true };
        };
        const next = () => {
          if (stopped)
            return stop();
          const res = this.read();
          if (res !== null)
            return Promise.resolve({ done: false, value: res });
          if (this[EOF])
            return stop();
          let resolve;
          let reject;
          const onerr = (er) => {
            this.off("data", ondata);
            this.off("end", onend);
            this.off(DESTROYED, ondestroy);
            stop();
            reject(er);
          };
          const ondata = (value) => {
            this.off("error", onerr);
            this.off("end", onend);
            this.off(DESTROYED, ondestroy);
            this.pause();
            resolve({ value, done: !!this[EOF] });
          };
          const onend = () => {
            this.off("error", onerr);
            this.off("data", ondata);
            this.off(DESTROYED, ondestroy);
            stop();
            resolve({ done: true, value: void 0 });
          };
          const ondestroy = () => onerr(new Error("stream destroyed"));
          return new Promise((res2, rej) => {
            reject = rej;
            resolve = res2;
            this.once(DESTROYED, ondestroy);
            this.once("error", onerr);
            this.once("end", onend);
            this.once("data", ondata);
          });
        };
        return {
          next,
          throw: stop,
          return: stop,
          [Symbol.asyncIterator]() {
            return this;
          }
        };
      }
      /**
       * Synchronous `for of` iteration.
       *
       * The iteration will terminate when the internal buffer runs out, even
       * if the stream has not yet terminated.
       */
      [Symbol.iterator]() {
        this[DISCARDED] = false;
        let stopped = false;
        const stop = () => {
          this.pause();
          this.off(ERROR, stop);
          this.off(DESTROYED, stop);
          this.off("end", stop);
          stopped = true;
          return { done: true, value: void 0 };
        };
        const next = () => {
          if (stopped)
            return stop();
          const value = this.read();
          return value === null ? stop() : { done: false, value };
        };
        this.once("end", stop);
        this.once(ERROR, stop);
        this.once(DESTROYED, stop);
        return {
          next,
          throw: stop,
          return: stop,
          [Symbol.iterator]() {
            return this;
          }
        };
      }
      /**
       * Destroy a stream, preventing it from being used for any further purpose.
       *
       * If the stream has a `close()` method, then it will be called on
       * destruction.
       *
       * After destruction, any attempt to write data, read data, or emit most
       * events will be ignored.
       *
       * If an error argument is provided, then it will be emitted in an
       * 'error' event.
       */
      destroy(er) {
        if (this[DESTROYED]) {
          if (er)
            this.emit("error", er);
          else
            this.emit(DESTROYED);
          return this;
        }
        this[DESTROYED] = true;
        this[DISCARDED] = true;
        this[BUFFER].length = 0;
        this[BUFFERLENGTH] = 0;
        const wc = this;
        if (typeof wc.close === "function" && !this[CLOSED])
          wc.close();
        if (er)
          this.emit("error", er);
        else
          this.emit(DESTROYED);
        return this;
      }
      /**
       * Alias for {@link isStream}
       *
       * Former export location, maintained for backwards compatibility.
       *
       * @deprecated
       */
      static get isStream() {
        return exports2.isStream;
      }
    };
    exports2.Minipass = Minipass;
  }
});

// node_modules/path-scurry/dist/commonjs/index.js
var require_commonjs6 = __commonJS({
  "node_modules/path-scurry/dist/commonjs/index.js"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports2 && exports2.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports2 && exports2.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.PathScurry = exports2.Path = exports2.PathScurryDarwin = exports2.PathScurryPosix = exports2.PathScurryWin32 = exports2.PathScurryBase = exports2.PathPosix = exports2.PathWin32 = exports2.PathBase = exports2.ChildrenCache = exports2.ResolveCache = void 0;
    var lru_cache_1 = require_commonjs4();
    var node_path_1 = require("node:path");
    var node_url_1 = require("node:url");
    var fs_1 = require("fs");
    var actualFS = __importStar(require("node:fs"));
    var realpathSync = fs_1.realpathSync.native;
    var promises_1 = require("node:fs/promises");
    var minipass_1 = require_commonjs5();
    var defaultFS = {
      lstatSync: fs_1.lstatSync,
      readdir: fs_1.readdir,
      readdirSync: fs_1.readdirSync,
      readlinkSync: fs_1.readlinkSync,
      realpathSync,
      promises: {
        lstat: promises_1.lstat,
        readdir: promises_1.readdir,
        readlink: promises_1.readlink,
        realpath: promises_1.realpath
      }
    };
    var fsFromOption = (fsOption) => !fsOption || fsOption === defaultFS || fsOption === actualFS ? defaultFS : {
      ...defaultFS,
      ...fsOption,
      promises: {
        ...defaultFS.promises,
        ...fsOption.promises || {}
      }
    };
    var uncDriveRegexp = /^\\\\\?\\([a-z]:)\\?$/i;
    var uncToDrive = (rootPath) => rootPath.replace(/\//g, "\\").replace(uncDriveRegexp, "$1\\");
    var eitherSep = /[\\\/]/;
    var UNKNOWN = 0;
    var IFIFO = 1;
    var IFCHR = 2;
    var IFDIR = 4;
    var IFBLK = 6;
    var IFREG = 8;
    var IFLNK = 10;
    var IFSOCK = 12;
    var IFMT = 15;
    var IFMT_UNKNOWN = ~IFMT;
    var READDIR_CALLED = 16;
    var LSTAT_CALLED = 32;
    var ENOTDIR = 64;
    var ENOENT = 128;
    var ENOREADLINK = 256;
    var ENOREALPATH = 512;
    var ENOCHILD = ENOTDIR | ENOENT | ENOREALPATH;
    var TYPEMASK = 1023;
    var entToType = (s) => s.isFile() ? IFREG : s.isDirectory() ? IFDIR : s.isSymbolicLink() ? IFLNK : s.isCharacterDevice() ? IFCHR : s.isBlockDevice() ? IFBLK : s.isSocket() ? IFSOCK : s.isFIFO() ? IFIFO : UNKNOWN;
    var normalizeCache = /* @__PURE__ */ new Map();
    var normalize = (s) => {
      const c = normalizeCache.get(s);
      if (c)
        return c;
      const n = s.normalize("NFKD");
      normalizeCache.set(s, n);
      return n;
    };
    var normalizeNocaseCache = /* @__PURE__ */ new Map();
    var normalizeNocase = (s) => {
      const c = normalizeNocaseCache.get(s);
      if (c)
        return c;
      const n = normalize(s.toLowerCase());
      normalizeNocaseCache.set(s, n);
      return n;
    };
    var ResolveCache = class extends lru_cache_1.LRUCache {
      constructor() {
        super({ max: 256 });
      }
    };
    exports2.ResolveCache = ResolveCache;
    var ChildrenCache = class extends lru_cache_1.LRUCache {
      constructor(maxSize = 16 * 1024) {
        super({
          maxSize,
          // parent + children
          sizeCalculation: (a) => a.length + 1
        });
      }
    };
    exports2.ChildrenCache = ChildrenCache;
    var setAsCwd = Symbol("PathScurry setAsCwd");
    var PathBase = class {
      /**
       * the basename of this path
       *
       * **Important**: *always* test the path name against any test string
       * usingthe {@link isNamed} method, and not by directly comparing this
       * string. Otherwise, unicode path strings that the system sees as identical
       * will not be properly treated as the same path, leading to incorrect
       * behavior and possible security issues.
       */
      name;
      /**
       * the Path entry corresponding to the path root.
       *
       * @internal
       */
      root;
      /**
       * All roots found within the current PathScurry family
       *
       * @internal
       */
      roots;
      /**
       * a reference to the parent path, or undefined in the case of root entries
       *
       * @internal
       */
      parent;
      /**
       * boolean indicating whether paths are compared case-insensitively
       * @internal
       */
      nocase;
      /**
       * boolean indicating that this path is the current working directory
       * of the PathScurry collection that contains it.
       */
      isCWD = false;
      // potential default fs override
      #fs;
      // Stats fields
      #dev;
      get dev() {
        return this.#dev;
      }
      #mode;
      get mode() {
        return this.#mode;
      }
      #nlink;
      get nlink() {
        return this.#nlink;
      }
      #uid;
      get uid() {
        return this.#uid;
      }
      #gid;
      get gid() {
        return this.#gid;
      }
      #rdev;
      get rdev() {
        return this.#rdev;
      }
      #blksize;
      get blksize() {
        return this.#blksize;
      }
      #ino;
      get ino() {
        return this.#ino;
      }
      #size;
      get size() {
        return this.#size;
      }
      #blocks;
      get blocks() {
        return this.#blocks;
      }
      #atimeMs;
      get atimeMs() {
        return this.#atimeMs;
      }
      #mtimeMs;
      get mtimeMs() {
        return this.#mtimeMs;
      }
      #ctimeMs;
      get ctimeMs() {
        return this.#ctimeMs;
      }
      #birthtimeMs;
      get birthtimeMs() {
        return this.#birthtimeMs;
      }
      #atime;
      get atime() {
        return this.#atime;
      }
      #mtime;
      get mtime() {
        return this.#mtime;
      }
      #ctime;
      get ctime() {
        return this.#ctime;
      }
      #birthtime;
      get birthtime() {
        return this.#birthtime;
      }
      #matchName;
      #depth;
      #fullpath;
      #fullpathPosix;
      #relative;
      #relativePosix;
      #type;
      #children;
      #linkTarget;
      #realpath;
      /**
       * This property is for compatibility with the Dirent class as of
       * Node v20, where Dirent['parentPath'] refers to the path of the
       * directory that was passed to readdir. For root entries, it's the path
       * to the entry itself.
       */
      get parentPath() {
        return (this.parent || this).fullpath();
      }
      /**
       * Deprecated alias for Dirent['parentPath'] Somewhat counterintuitively,
       * this property refers to the *parent* path, not the path object itself.
       *
       * @deprecated
       */
      get path() {
        return this.parentPath;
      }
      /**
       * Do not create new Path objects directly.  They should always be accessed
       * via the PathScurry class or other methods on the Path class.
       *
       * @internal
       */
      constructor(name, type = UNKNOWN, root, roots, nocase, children, opts) {
        this.name = name;
        this.#matchName = nocase ? normalizeNocase(name) : normalize(name);
        this.#type = type & TYPEMASK;
        this.nocase = nocase;
        this.roots = roots;
        this.root = root || this;
        this.#children = children;
        this.#fullpath = opts.fullpath;
        this.#relative = opts.relative;
        this.#relativePosix = opts.relativePosix;
        this.parent = opts.parent;
        if (this.parent) {
          this.#fs = this.parent.#fs;
        } else {
          this.#fs = fsFromOption(opts.fs);
        }
      }
      /**
       * Returns the depth of the Path object from its root.
       *
       * For example, a path at `/foo/bar` would have a depth of 2.
       */
      depth() {
        if (this.#depth !== void 0)
          return this.#depth;
        if (!this.parent)
          return this.#depth = 0;
        return this.#depth = this.parent.depth() + 1;
      }
      /**
       * @internal
       */
      childrenCache() {
        return this.#children;
      }
      /**
       * Get the Path object referenced by the string path, resolved from this Path
       */
      resolve(path4) {
        if (!path4) {
          return this;
        }
        const rootPath = this.getRootString(path4);
        const dir = path4.substring(rootPath.length);
        const dirParts = dir.split(this.splitSep);
        const result = rootPath ? this.getRoot(rootPath).#resolveParts(dirParts) : this.#resolveParts(dirParts);
        return result;
      }
      #resolveParts(dirParts) {
        let p = this;
        for (const part of dirParts) {
          p = p.child(part);
        }
        return p;
      }
      /**
       * Returns the cached children Path objects, if still available.  If they
       * have fallen out of the cache, then returns an empty array, and resets the
       * READDIR_CALLED bit, so that future calls to readdir() will require an fs
       * lookup.
       *
       * @internal
       */
      children() {
        const cached = this.#children.get(this);
        if (cached) {
          return cached;
        }
        const children = Object.assign([], { provisional: 0 });
        this.#children.set(this, children);
        this.#type &= ~READDIR_CALLED;
        return children;
      }
      /**
       * Resolves a path portion and returns or creates the child Path.
       *
       * Returns `this` if pathPart is `''` or `'.'`, or `parent` if pathPart is
       * `'..'`.
       *
       * This should not be called directly.  If `pathPart` contains any path
       * separators, it will lead to unsafe undefined behavior.
       *
       * Use `Path.resolve()` instead.
       *
       * @internal
       */
      child(pathPart, opts) {
        if (pathPart === "" || pathPart === ".") {
          return this;
        }
        if (pathPart === "..") {
          return this.parent || this;
        }
        const children = this.children();
        const name = this.nocase ? normalizeNocase(pathPart) : normalize(pathPart);
        for (const p of children) {
          if (p.#matchName === name) {
            return p;
          }
        }
        const s = this.parent ? this.sep : "";
        const fullpath = this.#fullpath ? this.#fullpath + s + pathPart : void 0;
        const pchild = this.newChild(pathPart, UNKNOWN, {
          ...opts,
          parent: this,
          fullpath
        });
        if (!this.canReaddir()) {
          pchild.#type |= ENOENT;
        }
        children.push(pchild);
        return pchild;
      }
      /**
       * The relative path from the cwd. If it does not share an ancestor with
       * the cwd, then this ends up being equivalent to the fullpath()
       */
      relative() {
        if (this.isCWD)
          return "";
        if (this.#relative !== void 0) {
          return this.#relative;
        }
        const name = this.name;
        const p = this.parent;
        if (!p) {
          return this.#relative = this.name;
        }
        const pv = p.relative();
        return pv + (!pv || !p.parent ? "" : this.sep) + name;
      }
      /**
       * The relative path from the cwd, using / as the path separator.
       * If it does not share an ancestor with
       * the cwd, then this ends up being equivalent to the fullpathPosix()
       * On posix systems, this is identical to relative().
       */
      relativePosix() {
        if (this.sep === "/")
          return this.relative();
        if (this.isCWD)
          return "";
        if (this.#relativePosix !== void 0)
          return this.#relativePosix;
        const name = this.name;
        const p = this.parent;
        if (!p) {
          return this.#relativePosix = this.fullpathPosix();
        }
        const pv = p.relativePosix();
        return pv + (!pv || !p.parent ? "" : "/") + name;
      }
      /**
       * The fully resolved path string for this Path entry
       */
      fullpath() {
        if (this.#fullpath !== void 0) {
          return this.#fullpath;
        }
        const name = this.name;
        const p = this.parent;
        if (!p) {
          return this.#fullpath = this.name;
        }
        const pv = p.fullpath();
        const fp = pv + (!p.parent ? "" : this.sep) + name;
        return this.#fullpath = fp;
      }
      /**
       * On platforms other than windows, this is identical to fullpath.
       *
       * On windows, this is overridden to return the forward-slash form of the
       * full UNC path.
       */
      fullpathPosix() {
        if (this.#fullpathPosix !== void 0)
          return this.#fullpathPosix;
        if (this.sep === "/")
          return this.#fullpathPosix = this.fullpath();
        if (!this.parent) {
          const p2 = this.fullpath().replace(/\\/g, "/");
          if (/^[a-z]:\//i.test(p2)) {
            return this.#fullpathPosix = `//?/${p2}`;
          } else {
            return this.#fullpathPosix = p2;
          }
        }
        const p = this.parent;
        const pfpp = p.fullpathPosix();
        const fpp = pfpp + (!pfpp || !p.parent ? "" : "/") + this.name;
        return this.#fullpathPosix = fpp;
      }
      /**
       * Is the Path of an unknown type?
       *
       * Note that we might know *something* about it if there has been a previous
       * filesystem operation, for example that it does not exist, or is not a
       * link, or whether it has child entries.
       */
      isUnknown() {
        return (this.#type & IFMT) === UNKNOWN;
      }
      isType(type) {
        return this[`is${type}`]();
      }
      getType() {
        return this.isUnknown() ? "Unknown" : this.isDirectory() ? "Directory" : this.isFile() ? "File" : this.isSymbolicLink() ? "SymbolicLink" : this.isFIFO() ? "FIFO" : this.isCharacterDevice() ? "CharacterDevice" : this.isBlockDevice() ? "BlockDevice" : (
          /* c8 ignore start */
          this.isSocket() ? "Socket" : "Unknown"
        );
      }
      /**
       * Is the Path a regular file?
       */
      isFile() {
        return (this.#type & IFMT) === IFREG;
      }
      /**
       * Is the Path a directory?
       */
      isDirectory() {
        return (this.#type & IFMT) === IFDIR;
      }
      /**
       * Is the path a character device?
       */
      isCharacterDevice() {
        return (this.#type & IFMT) === IFCHR;
      }
      /**
       * Is the path a block device?
       */
      isBlockDevice() {
        return (this.#type & IFMT) === IFBLK;
      }
      /**
       * Is the path a FIFO pipe?
       */
      isFIFO() {
        return (this.#type & IFMT) === IFIFO;
      }
      /**
       * Is the path a socket?
       */
      isSocket() {
        return (this.#type & IFMT) === IFSOCK;
      }
      /**
       * Is the path a symbolic link?
       */
      isSymbolicLink() {
        return (this.#type & IFLNK) === IFLNK;
      }
      /**
       * Return the entry if it has been subject of a successful lstat, or
       * undefined otherwise.
       *
       * Does not read the filesystem, so an undefined result *could* simply
       * mean that we haven't called lstat on it.
       */
      lstatCached() {
        return this.#type & LSTAT_CALLED ? this : void 0;
      }
      /**
       * Return the cached link target if the entry has been the subject of a
       * successful readlink, or undefined otherwise.
       *
       * Does not read the filesystem, so an undefined result *could* just mean we
       * don't have any cached data. Only use it if you are very sure that a
       * readlink() has been called at some point.
       */
      readlinkCached() {
        return this.#linkTarget;
      }
      /**
       * Returns the cached realpath target if the entry has been the subject
       * of a successful realpath, or undefined otherwise.
       *
       * Does not read the filesystem, so an undefined result *could* just mean we
       * don't have any cached data. Only use it if you are very sure that a
       * realpath() has been called at some point.
       */
      realpathCached() {
        return this.#realpath;
      }
      /**
       * Returns the cached child Path entries array if the entry has been the
       * subject of a successful readdir(), or [] otherwise.
       *
       * Does not read the filesystem, so an empty array *could* just mean we
       * don't have any cached data. Only use it if you are very sure that a
       * readdir() has been called recently enough to still be valid.
       */
      readdirCached() {
        const children = this.children();
        return children.slice(0, children.provisional);
      }
      /**
       * Return true if it's worth trying to readlink.  Ie, we don't (yet) have
       * any indication that readlink will definitely fail.
       *
       * Returns false if the path is known to not be a symlink, if a previous
       * readlink failed, or if the entry does not exist.
       */
      canReadlink() {
        if (this.#linkTarget)
          return true;
        if (!this.parent)
          return false;
        const ifmt = this.#type & IFMT;
        return !(ifmt !== UNKNOWN && ifmt !== IFLNK || this.#type & ENOREADLINK || this.#type & ENOENT);
      }
      /**
       * Return true if readdir has previously been successfully called on this
       * path, indicating that cachedReaddir() is likely valid.
       */
      calledReaddir() {
        return !!(this.#type & READDIR_CALLED);
      }
      /**
       * Returns true if the path is known to not exist. That is, a previous lstat
       * or readdir failed to verify its existence when that would have been
       * expected, or a parent entry was marked either enoent or enotdir.
       */
      isENOENT() {
        return !!(this.#type & ENOENT);
      }
      /**
       * Return true if the path is a match for the given path name.  This handles
       * case sensitivity and unicode normalization.
       *
       * Note: even on case-sensitive systems, it is **not** safe to test the
       * equality of the `.name` property to determine whether a given pathname
       * matches, due to unicode normalization mismatches.
       *
       * Always use this method instead of testing the `path.name` property
       * directly.
       */
      isNamed(n) {
        return !this.nocase ? this.#matchName === normalize(n) : this.#matchName === normalizeNocase(n);
      }
      /**
       * Return the Path object corresponding to the target of a symbolic link.
       *
       * If the Path is not a symbolic link, or if the readlink call fails for any
       * reason, `undefined` is returned.
       *
       * Result is cached, and thus may be outdated if the filesystem is mutated.
       */
      async readlink() {
        const target = this.#linkTarget;
        if (target) {
          return target;
        }
        if (!this.canReadlink()) {
          return void 0;
        }
        if (!this.parent) {
          return void 0;
        }
        try {
          const read = await this.#fs.promises.readlink(this.fullpath());
          const linkTarget = (await this.parent.realpath())?.resolve(read);
          if (linkTarget) {
            return this.#linkTarget = linkTarget;
          }
        } catch (er) {
          this.#readlinkFail(er.code);
          return void 0;
        }
      }
      /**
       * Synchronous {@link PathBase.readlink}
       */
      readlinkSync() {
        const target = this.#linkTarget;
        if (target) {
          return target;
        }
        if (!this.canReadlink()) {
          return void 0;
        }
        if (!this.parent) {
          return void 0;
        }
        try {
          const read = this.#fs.readlinkSync(this.fullpath());
          const linkTarget = this.parent.realpathSync()?.resolve(read);
          if (linkTarget) {
            return this.#linkTarget = linkTarget;
          }
        } catch (er) {
          this.#readlinkFail(er.code);
          return void 0;
        }
      }
      #readdirSuccess(children) {
        this.#type |= READDIR_CALLED;
        for (let p = children.provisional; p < children.length; p++) {
          const c = children[p];
          if (c)
            c.#markENOENT();
        }
      }
      #markENOENT() {
        if (this.#type & ENOENT)
          return;
        this.#type = (this.#type | ENOENT) & IFMT_UNKNOWN;
        this.#markChildrenENOENT();
      }
      #markChildrenENOENT() {
        const children = this.children();
        children.provisional = 0;
        for (const p of children) {
          p.#markENOENT();
        }
      }
      #markENOREALPATH() {
        this.#type |= ENOREALPATH;
        this.#markENOTDIR();
      }
      // save the information when we know the entry is not a dir
      #markENOTDIR() {
        if (this.#type & ENOTDIR)
          return;
        let t = this.#type;
        if ((t & IFMT) === IFDIR)
          t &= IFMT_UNKNOWN;
        this.#type = t | ENOTDIR;
        this.#markChildrenENOENT();
      }
      #readdirFail(code = "") {
        if (code === "ENOTDIR" || code === "EPERM") {
          this.#markENOTDIR();
        } else if (code === "ENOENT") {
          this.#markENOENT();
        } else {
          this.children().provisional = 0;
        }
      }
      #lstatFail(code = "") {
        if (code === "ENOTDIR") {
          const p = this.parent;
          p.#markENOTDIR();
        } else if (code === "ENOENT") {
          this.#markENOENT();
        }
      }
      #readlinkFail(code = "") {
        let ter = this.#type;
        ter |= ENOREADLINK;
        if (code === "ENOENT")
          ter |= ENOENT;
        if (code === "EINVAL" || code === "UNKNOWN") {
          ter &= IFMT_UNKNOWN;
        }
        this.#type = ter;
        if (code === "ENOTDIR" && this.parent) {
          this.parent.#markENOTDIR();
        }
      }
      #readdirAddChild(e, c) {
        return this.#readdirMaybePromoteChild(e, c) || this.#readdirAddNewChild(e, c);
      }
      #readdirAddNewChild(e, c) {
        const type = entToType(e);
        const child = this.newChild(e.name, type, { parent: this });
        const ifmt = child.#type & IFMT;
        if (ifmt !== IFDIR && ifmt !== IFLNK && ifmt !== UNKNOWN) {
          child.#type |= ENOTDIR;
        }
        c.unshift(child);
        c.provisional++;
        return child;
      }
      #readdirMaybePromoteChild(e, c) {
        for (let p = c.provisional; p < c.length; p++) {
          const pchild = c[p];
          const name = this.nocase ? normalizeNocase(e.name) : normalize(e.name);
          if (name !== pchild.#matchName) {
            continue;
          }
          return this.#readdirPromoteChild(e, pchild, p, c);
        }
      }
      #readdirPromoteChild(e, p, index, c) {
        const v = p.name;
        p.#type = p.#type & IFMT_UNKNOWN | entToType(e);
        if (v !== e.name)
          p.name = e.name;
        if (index !== c.provisional) {
          if (index === c.length - 1)
            c.pop();
          else
            c.splice(index, 1);
          c.unshift(p);
        }
        c.provisional++;
        return p;
      }
      /**
       * Call lstat() on this Path, and update all known information that can be
       * determined.
       *
       * Note that unlike `fs.lstat()`, the returned value does not contain some
       * information, such as `mode`, `dev`, `nlink`, and `ino`.  If that
       * information is required, you will need to call `fs.lstat` yourself.
       *
       * If the Path refers to a nonexistent file, or if the lstat call fails for
       * any reason, `undefined` is returned.  Otherwise the updated Path object is
       * returned.
       *
       * Results are cached, and thus may be out of date if the filesystem is
       * mutated.
       */
      async lstat() {
        if ((this.#type & ENOENT) === 0) {
          try {
            this.#applyStat(await this.#fs.promises.lstat(this.fullpath()));
            return this;
          } catch (er) {
            this.#lstatFail(er.code);
          }
        }
      }
      /**
       * synchronous {@link PathBase.lstat}
       */
      lstatSync() {
        if ((this.#type & ENOENT) === 0) {
          try {
            this.#applyStat(this.#fs.lstatSync(this.fullpath()));
            return this;
          } catch (er) {
            this.#lstatFail(er.code);
          }
        }
      }
      #applyStat(st) {
        const { atime, atimeMs, birthtime, birthtimeMs, blksize, blocks, ctime, ctimeMs, dev, gid, ino, mode, mtime, mtimeMs, nlink, rdev, size, uid } = st;
        this.#atime = atime;
        this.#atimeMs = atimeMs;
        this.#birthtime = birthtime;
        this.#birthtimeMs = birthtimeMs;
        this.#blksize = blksize;
        this.#blocks = blocks;
        this.#ctime = ctime;
        this.#ctimeMs = ctimeMs;
        this.#dev = dev;
        this.#gid = gid;
        this.#ino = ino;
        this.#mode = mode;
        this.#mtime = mtime;
        this.#mtimeMs = mtimeMs;
        this.#nlink = nlink;
        this.#rdev = rdev;
        this.#size = size;
        this.#uid = uid;
        const ifmt = entToType(st);
        this.#type = this.#type & IFMT_UNKNOWN | ifmt | LSTAT_CALLED;
        if (ifmt !== UNKNOWN && ifmt !== IFDIR && ifmt !== IFLNK) {
          this.#type |= ENOTDIR;
        }
      }
      #onReaddirCB = [];
      #readdirCBInFlight = false;
      #callOnReaddirCB(children) {
        this.#readdirCBInFlight = false;
        const cbs = this.#onReaddirCB.slice();
        this.#onReaddirCB.length = 0;
        cbs.forEach((cb) => cb(null, children));
      }
      /**
       * Standard node-style callback interface to get list of directory entries.
       *
       * If the Path cannot or does not contain any children, then an empty array
       * is returned.
       *
       * Results are cached, and thus may be out of date if the filesystem is
       * mutated.
       *
       * @param cb The callback called with (er, entries).  Note that the `er`
       * param is somewhat extraneous, as all readdir() errors are handled and
       * simply result in an empty set of entries being returned.
       * @param allowZalgo Boolean indicating that immediately known results should
       * *not* be deferred with `queueMicrotask`. Defaults to `false`. Release
       * zalgo at your peril, the dark pony lord is devious and unforgiving.
       */
      readdirCB(cb, allowZalgo = false) {
        if (!this.canReaddir()) {
          if (allowZalgo)
            cb(null, []);
          else
            queueMicrotask(() => cb(null, []));
          return;
        }
        const children = this.children();
        if (this.calledReaddir()) {
          const c = children.slice(0, children.provisional);
          if (allowZalgo)
            cb(null, c);
          else
            queueMicrotask(() => cb(null, c));
          return;
        }
        this.#onReaddirCB.push(cb);
        if (this.#readdirCBInFlight) {
          return;
        }
        this.#readdirCBInFlight = true;
        const fullpath = this.fullpath();
        this.#fs.readdir(fullpath, { withFileTypes: true }, (er, entries) => {
          if (er) {
            this.#readdirFail(er.code);
            children.provisional = 0;
          } else {
            for (const e of entries) {
              this.#readdirAddChild(e, children);
            }
            this.#readdirSuccess(children);
          }
          this.#callOnReaddirCB(children.slice(0, children.provisional));
          return;
        });
      }
      #asyncReaddirInFlight;
      /**
       * Return an array of known child entries.
       *
       * If the Path cannot or does not contain any children, then an empty array
       * is returned.
       *
       * Results are cached, and thus may be out of date if the filesystem is
       * mutated.
       */
      async readdir() {
        if (!this.canReaddir()) {
          return [];
        }
        const children = this.children();
        if (this.calledReaddir()) {
          return children.slice(0, children.provisional);
        }
        const fullpath = this.fullpath();
        if (this.#asyncReaddirInFlight) {
          await this.#asyncReaddirInFlight;
        } else {
          let resolve = () => {
          };
          this.#asyncReaddirInFlight = new Promise((res) => resolve = res);
          try {
            for (const e of await this.#fs.promises.readdir(fullpath, {
              withFileTypes: true
            })) {
              this.#readdirAddChild(e, children);
            }
            this.#readdirSuccess(children);
          } catch (er) {
            this.#readdirFail(er.code);
            children.provisional = 0;
          }
          this.#asyncReaddirInFlight = void 0;
          resolve();
        }
        return children.slice(0, children.provisional);
      }
      /**
       * synchronous {@link PathBase.readdir}
       */
      readdirSync() {
        if (!this.canReaddir()) {
          return [];
        }
        const children = this.children();
        if (this.calledReaddir()) {
          return children.slice(0, children.provisional);
        }
        const fullpath = this.fullpath();
        try {
          for (const e of this.#fs.readdirSync(fullpath, {
            withFileTypes: true
          })) {
            this.#readdirAddChild(e, children);
          }
          this.#readdirSuccess(children);
        } catch (er) {
          this.#readdirFail(er.code);
          children.provisional = 0;
        }
        return children.slice(0, children.provisional);
      }
      canReaddir() {
        if (this.#type & ENOCHILD)
          return false;
        const ifmt = IFMT & this.#type;
        if (!(ifmt === UNKNOWN || ifmt === IFDIR || ifmt === IFLNK)) {
          return false;
        }
        return true;
      }
      shouldWalk(dirs, walkFilter) {
        return (this.#type & IFDIR) === IFDIR && !(this.#type & ENOCHILD) && !dirs.has(this) && (!walkFilter || walkFilter(this));
      }
      /**
       * Return the Path object corresponding to path as resolved
       * by realpath(3).
       *
       * If the realpath call fails for any reason, `undefined` is returned.
       *
       * Result is cached, and thus may be outdated if the filesystem is mutated.
       * On success, returns a Path object.
       */
      async realpath() {
        if (this.#realpath)
          return this.#realpath;
        if ((ENOREALPATH | ENOREADLINK | ENOENT) & this.#type)
          return void 0;
        try {
          const rp = await this.#fs.promises.realpath(this.fullpath());
          return this.#realpath = this.resolve(rp);
        } catch (_) {
          this.#markENOREALPATH();
        }
      }
      /**
       * Synchronous {@link realpath}
       */
      realpathSync() {
        if (this.#realpath)
          return this.#realpath;
        if ((ENOREALPATH | ENOREADLINK | ENOENT) & this.#type)
          return void 0;
        try {
          const rp = this.#fs.realpathSync(this.fullpath());
          return this.#realpath = this.resolve(rp);
        } catch (_) {
          this.#markENOREALPATH();
        }
      }
      /**
       * Internal method to mark this Path object as the scurry cwd,
       * called by {@link PathScurry#chdir}
       *
       * @internal
       */
      [setAsCwd](oldCwd) {
        if (oldCwd === this)
          return;
        oldCwd.isCWD = false;
        this.isCWD = true;
        const changed = /* @__PURE__ */ new Set([]);
        let rp = [];
        let p = this;
        while (p && p.parent) {
          changed.add(p);
          p.#relative = rp.join(this.sep);
          p.#relativePosix = rp.join("/");
          p = p.parent;
          rp.push("..");
        }
        p = oldCwd;
        while (p && p.parent && !changed.has(p)) {
          p.#relative = void 0;
          p.#relativePosix = void 0;
          p = p.parent;
        }
      }
    };
    exports2.PathBase = PathBase;
    var PathWin32 = class _PathWin32 extends PathBase {
      /**
       * Separator for generating path strings.
       */
      sep = "\\";
      /**
       * Separator for parsing path strings.
       */
      splitSep = eitherSep;
      /**
       * Do not create new Path objects directly.  They should always be accessed
       * via the PathScurry class or other methods on the Path class.
       *
       * @internal
       */
      constructor(name, type = UNKNOWN, root, roots, nocase, children, opts) {
        super(name, type, root, roots, nocase, children, opts);
      }
      /**
       * @internal
       */
      newChild(name, type = UNKNOWN, opts = {}) {
        return new _PathWin32(name, type, this.root, this.roots, this.nocase, this.childrenCache(), opts);
      }
      /**
       * @internal
       */
      getRootString(path4) {
        return node_path_1.win32.parse(path4).root;
      }
      /**
       * @internal
       */
      getRoot(rootPath) {
        rootPath = uncToDrive(rootPath.toUpperCase());
        if (rootPath === this.root.name) {
          return this.root;
        }
        for (const [compare, root] of Object.entries(this.roots)) {
          if (this.sameRoot(rootPath, compare)) {
            return this.roots[rootPath] = root;
          }
        }
        return this.roots[rootPath] = new PathScurryWin32(rootPath, this).root;
      }
      /**
       * @internal
       */
      sameRoot(rootPath, compare = this.root.name) {
        rootPath = rootPath.toUpperCase().replace(/\//g, "\\").replace(uncDriveRegexp, "$1\\");
        return rootPath === compare;
      }
    };
    exports2.PathWin32 = PathWin32;
    var PathPosix = class _PathPosix extends PathBase {
      /**
       * separator for parsing path strings
       */
      splitSep = "/";
      /**
       * separator for generating path strings
       */
      sep = "/";
      /**
       * Do not create new Path objects directly.  They should always be accessed
       * via the PathScurry class or other methods on the Path class.
       *
       * @internal
       */
      constructor(name, type = UNKNOWN, root, roots, nocase, children, opts) {
        super(name, type, root, roots, nocase, children, opts);
      }
      /**
       * @internal
       */
      getRootString(path4) {
        return path4.startsWith("/") ? "/" : "";
      }
      /**
       * @internal
       */
      getRoot(_rootPath) {
        return this.root;
      }
      /**
       * @internal
       */
      newChild(name, type = UNKNOWN, opts = {}) {
        return new _PathPosix(name, type, this.root, this.roots, this.nocase, this.childrenCache(), opts);
      }
    };
    exports2.PathPosix = PathPosix;
    var PathScurryBase = class {
      /**
       * The root Path entry for the current working directory of this Scurry
       */
      root;
      /**
       * The string path for the root of this Scurry's current working directory
       */
      rootPath;
      /**
       * A collection of all roots encountered, referenced by rootPath
       */
      roots;
      /**
       * The Path entry corresponding to this PathScurry's current working directory.
       */
      cwd;
      #resolveCache;
      #resolvePosixCache;
      #children;
      /**
       * Perform path comparisons case-insensitively.
       *
       * Defaults true on Darwin and Windows systems, false elsewhere.
       */
      nocase;
      #fs;
      /**
       * This class should not be instantiated directly.
       *
       * Use PathScurryWin32, PathScurryDarwin, PathScurryPosix, or PathScurry
       *
       * @internal
       */
      constructor(cwd = process.cwd(), pathImpl, sep, { nocase, childrenCacheSize = 16 * 1024, fs: fs5 = defaultFS } = {}) {
        this.#fs = fsFromOption(fs5);
        if (cwd instanceof URL || cwd.startsWith("file://")) {
          cwd = (0, node_url_1.fileURLToPath)(cwd);
        }
        const cwdPath = pathImpl.resolve(cwd);
        this.roots = /* @__PURE__ */ Object.create(null);
        this.rootPath = this.parseRootPath(cwdPath);
        this.#resolveCache = new ResolveCache();
        this.#resolvePosixCache = new ResolveCache();
        this.#children = new ChildrenCache(childrenCacheSize);
        const split = cwdPath.substring(this.rootPath.length).split(sep);
        if (split.length === 1 && !split[0]) {
          split.pop();
        }
        if (nocase === void 0) {
          throw new TypeError("must provide nocase setting to PathScurryBase ctor");
        }
        this.nocase = nocase;
        this.root = this.newRoot(this.#fs);
        this.roots[this.rootPath] = this.root;
        let prev = this.root;
        let len = split.length - 1;
        const joinSep = pathImpl.sep;
        let abs = this.rootPath;
        let sawFirst = false;
        for (const part of split) {
          const l = len--;
          prev = prev.child(part, {
            relative: new Array(l).fill("..").join(joinSep),
            relativePosix: new Array(l).fill("..").join("/"),
            fullpath: abs += (sawFirst ? "" : joinSep) + part
          });
          sawFirst = true;
        }
        this.cwd = prev;
      }
      /**
       * Get the depth of a provided path, string, or the cwd
       */
      depth(path4 = this.cwd) {
        if (typeof path4 === "string") {
          path4 = this.cwd.resolve(path4);
        }
        return path4.depth();
      }
      /**
       * Return the cache of child entries.  Exposed so subclasses can create
       * child Path objects in a platform-specific way.
       *
       * @internal
       */
      childrenCache() {
        return this.#children;
      }
      /**
       * Resolve one or more path strings to a resolved string
       *
       * Same interface as require('path').resolve.
       *
       * Much faster than path.resolve() when called multiple times for the same
       * path, because the resolved Path objects are cached.  Much slower
       * otherwise.
       */
      resolve(...paths) {
        let r = "";
        for (let i = paths.length - 1; i >= 0; i--) {
          const p = paths[i];
          if (!p || p === ".")
            continue;
          r = r ? `${p}/${r}` : p;
          if (this.isAbsolute(p)) {
            break;
          }
        }
        const cached = this.#resolveCache.get(r);
        if (cached !== void 0) {
          return cached;
        }
        const result = this.cwd.resolve(r).fullpath();
        this.#resolveCache.set(r, result);
        return result;
      }
      /**
       * Resolve one or more path strings to a resolved string, returning
       * the posix path.  Identical to .resolve() on posix systems, but on
       * windows will return a forward-slash separated UNC path.
       *
       * Same interface as require('path').resolve.
       *
       * Much faster than path.resolve() when called multiple times for the same
       * path, because the resolved Path objects are cached.  Much slower
       * otherwise.
       */
      resolvePosix(...paths) {
        let r = "";
        for (let i = paths.length - 1; i >= 0; i--) {
          const p = paths[i];
          if (!p || p === ".")
            continue;
          r = r ? `${p}/${r}` : p;
          if (this.isAbsolute(p)) {
            break;
          }
        }
        const cached = this.#resolvePosixCache.get(r);
        if (cached !== void 0) {
          return cached;
        }
        const result = this.cwd.resolve(r).fullpathPosix();
        this.#resolvePosixCache.set(r, result);
        return result;
      }
      /**
       * find the relative path from the cwd to the supplied path string or entry
       */
      relative(entry = this.cwd) {
        if (typeof entry === "string") {
          entry = this.cwd.resolve(entry);
        }
        return entry.relative();
      }
      /**
       * find the relative path from the cwd to the supplied path string or
       * entry, using / as the path delimiter, even on Windows.
       */
      relativePosix(entry = this.cwd) {
        if (typeof entry === "string") {
          entry = this.cwd.resolve(entry);
        }
        return entry.relativePosix();
      }
      /**
       * Return the basename for the provided string or Path object
       */
      basename(entry = this.cwd) {
        if (typeof entry === "string") {
          entry = this.cwd.resolve(entry);
        }
        return entry.name;
      }
      /**
       * Return the dirname for the provided string or Path object
       */
      dirname(entry = this.cwd) {
        if (typeof entry === "string") {
          entry = this.cwd.resolve(entry);
        }
        return (entry.parent || entry).fullpath();
      }
      async readdir(entry = this.cwd, opts = {
        withFileTypes: true
      }) {
        if (typeof entry === "string") {
          entry = this.cwd.resolve(entry);
        } else if (!(entry instanceof PathBase)) {
          opts = entry;
          entry = this.cwd;
        }
        const { withFileTypes } = opts;
        if (!entry.canReaddir()) {
          return [];
        } else {
          const p = await entry.readdir();
          return withFileTypes ? p : p.map((e) => e.name);
        }
      }
      readdirSync(entry = this.cwd, opts = {
        withFileTypes: true
      }) {
        if (typeof entry === "string") {
          entry = this.cwd.resolve(entry);
        } else if (!(entry instanceof PathBase)) {
          opts = entry;
          entry = this.cwd;
        }
        const { withFileTypes = true } = opts;
        if (!entry.canReaddir()) {
          return [];
        } else if (withFileTypes) {
          return entry.readdirSync();
        } else {
          return entry.readdirSync().map((e) => e.name);
        }
      }
      /**
       * Call lstat() on the string or Path object, and update all known
       * information that can be determined.
       *
       * Note that unlike `fs.lstat()`, the returned value does not contain some
       * information, such as `mode`, `dev`, `nlink`, and `ino`.  If that
       * information is required, you will need to call `fs.lstat` yourself.
       *
       * If the Path refers to a nonexistent file, or if the lstat call fails for
       * any reason, `undefined` is returned.  Otherwise the updated Path object is
       * returned.
       *
       * Results are cached, and thus may be out of date if the filesystem is
       * mutated.
       */
      async lstat(entry = this.cwd) {
        if (typeof entry === "string") {
          entry = this.cwd.resolve(entry);
        }
        return entry.lstat();
      }
      /**
       * synchronous {@link PathScurryBase.lstat}
       */
      lstatSync(entry = this.cwd) {
        if (typeof entry === "string") {
          entry = this.cwd.resolve(entry);
        }
        return entry.lstatSync();
      }
      async readlink(entry = this.cwd, { withFileTypes } = {
        withFileTypes: false
      }) {
        if (typeof entry === "string") {
          entry = this.cwd.resolve(entry);
        } else if (!(entry instanceof PathBase)) {
          withFileTypes = entry.withFileTypes;
          entry = this.cwd;
        }
        const e = await entry.readlink();
        return withFileTypes ? e : e?.fullpath();
      }
      readlinkSync(entry = this.cwd, { withFileTypes } = {
        withFileTypes: false
      }) {
        if (typeof entry === "string") {
          entry = this.cwd.resolve(entry);
        } else if (!(entry instanceof PathBase)) {
          withFileTypes = entry.withFileTypes;
          entry = this.cwd;
        }
        const e = entry.readlinkSync();
        return withFileTypes ? e : e?.fullpath();
      }
      async realpath(entry = this.cwd, { withFileTypes } = {
        withFileTypes: false
      }) {
        if (typeof entry === "string") {
          entry = this.cwd.resolve(entry);
        } else if (!(entry instanceof PathBase)) {
          withFileTypes = entry.withFileTypes;
          entry = this.cwd;
        }
        const e = await entry.realpath();
        return withFileTypes ? e : e?.fullpath();
      }
      realpathSync(entry = this.cwd, { withFileTypes } = {
        withFileTypes: false
      }) {
        if (typeof entry === "string") {
          entry = this.cwd.resolve(entry);
        } else if (!(entry instanceof PathBase)) {
          withFileTypes = entry.withFileTypes;
          entry = this.cwd;
        }
        const e = entry.realpathSync();
        return withFileTypes ? e : e?.fullpath();
      }
      async walk(entry = this.cwd, opts = {}) {
        if (typeof entry === "string") {
          entry = this.cwd.resolve(entry);
        } else if (!(entry instanceof PathBase)) {
          opts = entry;
          entry = this.cwd;
        }
        const { withFileTypes = true, follow = false, filter, walkFilter } = opts;
        const results = [];
        if (!filter || filter(entry)) {
          results.push(withFileTypes ? entry : entry.fullpath());
        }
        const dirs = /* @__PURE__ */ new Set();
        const walk = (dir, cb) => {
          dirs.add(dir);
          dir.readdirCB((er, entries) => {
            if (er) {
              return cb(er);
            }
            let len = entries.length;
            if (!len)
              return cb();
            const next = () => {
              if (--len === 0) {
                cb();
              }
            };
            for (const e of entries) {
              if (!filter || filter(e)) {
                results.push(withFileTypes ? e : e.fullpath());
              }
              if (follow && e.isSymbolicLink()) {
                e.realpath().then((r) => r?.isUnknown() ? r.lstat() : r).then((r) => r?.shouldWalk(dirs, walkFilter) ? walk(r, next) : next());
              } else {
                if (e.shouldWalk(dirs, walkFilter)) {
                  walk(e, next);
                } else {
                  next();
                }
              }
            }
          }, true);
        };
        const start = entry;
        return new Promise((res, rej) => {
          walk(start, (er) => {
            if (er)
              return rej(er);
            res(results);
          });
        });
      }
      walkSync(entry = this.cwd, opts = {}) {
        if (typeof entry === "string") {
          entry = this.cwd.resolve(entry);
        } else if (!(entry instanceof PathBase)) {
          opts = entry;
          entry = this.cwd;
        }
        const { withFileTypes = true, follow = false, filter, walkFilter } = opts;
        const results = [];
        if (!filter || filter(entry)) {
          results.push(withFileTypes ? entry : entry.fullpath());
        }
        const dirs = /* @__PURE__ */ new Set([entry]);
        for (const dir of dirs) {
          const entries = dir.readdirSync();
          for (const e of entries) {
            if (!filter || filter(e)) {
              results.push(withFileTypes ? e : e.fullpath());
            }
            let r = e;
            if (e.isSymbolicLink()) {
              if (!(follow && (r = e.realpathSync())))
                continue;
              if (r.isUnknown())
                r.lstatSync();
            }
            if (r.shouldWalk(dirs, walkFilter)) {
              dirs.add(r);
            }
          }
        }
        return results;
      }
      /**
       * Support for `for await`
       *
       * Alias for {@link PathScurryBase.iterate}
       *
       * Note: As of Node 19, this is very slow, compared to other methods of
       * walking.  Consider using {@link PathScurryBase.stream} if memory overhead
       * and backpressure are concerns, or {@link PathScurryBase.walk} if not.
       */
      [Symbol.asyncIterator]() {
        return this.iterate();
      }
      iterate(entry = this.cwd, options = {}) {
        if (typeof entry === "string") {
          entry = this.cwd.resolve(entry);
        } else if (!(entry instanceof PathBase)) {
          options = entry;
          entry = this.cwd;
        }
        return this.stream(entry, options)[Symbol.asyncIterator]();
      }
      /**
       * Iterating over a PathScurry performs a synchronous walk.
       *
       * Alias for {@link PathScurryBase.iterateSync}
       */
      [Symbol.iterator]() {
        return this.iterateSync();
      }
      *iterateSync(entry = this.cwd, opts = {}) {
        if (typeof entry === "string") {
          entry = this.cwd.resolve(entry);
        } else if (!(entry instanceof PathBase)) {
          opts = entry;
          entry = this.cwd;
        }
        const { withFileTypes = true, follow = false, filter, walkFilter } = opts;
        if (!filter || filter(entry)) {
          yield withFileTypes ? entry : entry.fullpath();
        }
        const dirs = /* @__PURE__ */ new Set([entry]);
        for (const dir of dirs) {
          const entries = dir.readdirSync();
          for (const e of entries) {
            if (!filter || filter(e)) {
              yield withFileTypes ? e : e.fullpath();
            }
            let r = e;
            if (e.isSymbolicLink()) {
              if (!(follow && (r = e.realpathSync())))
                continue;
              if (r.isUnknown())
                r.lstatSync();
            }
            if (r.shouldWalk(dirs, walkFilter)) {
              dirs.add(r);
            }
          }
        }
      }
      stream(entry = this.cwd, opts = {}) {
        if (typeof entry === "string") {
          entry = this.cwd.resolve(entry);
        } else if (!(entry instanceof PathBase)) {
          opts = entry;
          entry = this.cwd;
        }
        const { withFileTypes = true, follow = false, filter, walkFilter } = opts;
        const results = new minipass_1.Minipass({ objectMode: true });
        if (!filter || filter(entry)) {
          results.write(withFileTypes ? entry : entry.fullpath());
        }
        const dirs = /* @__PURE__ */ new Set();
        const queue = [entry];
        let processing = 0;
        const process2 = () => {
          let paused = false;
          while (!paused) {
            const dir = queue.shift();
            if (!dir) {
              if (processing === 0)
                results.end();
              return;
            }
            processing++;
            dirs.add(dir);
            const onReaddir = (er, entries, didRealpaths = false) => {
              if (er)
                return results.emit("error", er);
              if (follow && !didRealpaths) {
                const promises = [];
                for (const e of entries) {
                  if (e.isSymbolicLink()) {
                    promises.push(e.realpath().then((r) => r?.isUnknown() ? r.lstat() : r));
                  }
                }
                if (promises.length) {
                  Promise.all(promises).then(() => onReaddir(null, entries, true));
                  return;
                }
              }
              for (const e of entries) {
                if (e && (!filter || filter(e))) {
                  if (!results.write(withFileTypes ? e : e.fullpath())) {
                    paused = true;
                  }
                }
              }
              processing--;
              for (const e of entries) {
                const r = e.realpathCached() || e;
                if (r.shouldWalk(dirs, walkFilter)) {
                  queue.push(r);
                }
              }
              if (paused && !results.flowing) {
                results.once("drain", process2);
              } else if (!sync) {
                process2();
              }
            };
            let sync = true;
            dir.readdirCB(onReaddir, true);
            sync = false;
          }
        };
        process2();
        return results;
      }
      streamSync(entry = this.cwd, opts = {}) {
        if (typeof entry === "string") {
          entry = this.cwd.resolve(entry);
        } else if (!(entry instanceof PathBase)) {
          opts = entry;
          entry = this.cwd;
        }
        const { withFileTypes = true, follow = false, filter, walkFilter } = opts;
        const results = new minipass_1.Minipass({ objectMode: true });
        const dirs = /* @__PURE__ */ new Set();
        if (!filter || filter(entry)) {
          results.write(withFileTypes ? entry : entry.fullpath());
        }
        const queue = [entry];
        let processing = 0;
        const process2 = () => {
          let paused = false;
          while (!paused) {
            const dir = queue.shift();
            if (!dir) {
              if (processing === 0)
                results.end();
              return;
            }
            processing++;
            dirs.add(dir);
            const entries = dir.readdirSync();
            for (const e of entries) {
              if (!filter || filter(e)) {
                if (!results.write(withFileTypes ? e : e.fullpath())) {
                  paused = true;
                }
              }
            }
            processing--;
            for (const e of entries) {
              let r = e;
              if (e.isSymbolicLink()) {
                if (!(follow && (r = e.realpathSync())))
                  continue;
                if (r.isUnknown())
                  r.lstatSync();
              }
              if (r.shouldWalk(dirs, walkFilter)) {
                queue.push(r);
              }
            }
          }
          if (paused && !results.flowing)
            results.once("drain", process2);
        };
        process2();
        return results;
      }
      chdir(path4 = this.cwd) {
        const oldCwd = this.cwd;
        this.cwd = typeof path4 === "string" ? this.cwd.resolve(path4) : path4;
        this.cwd[setAsCwd](oldCwd);
      }
    };
    exports2.PathScurryBase = PathScurryBase;
    var PathScurryWin32 = class extends PathScurryBase {
      /**
       * separator for generating path strings
       */
      sep = "\\";
      constructor(cwd = process.cwd(), opts = {}) {
        const { nocase = true } = opts;
        super(cwd, node_path_1.win32, "\\", { ...opts, nocase });
        this.nocase = nocase;
        for (let p = this.cwd; p; p = p.parent) {
          p.nocase = this.nocase;
        }
      }
      /**
       * @internal
       */
      parseRootPath(dir) {
        return node_path_1.win32.parse(dir).root.toUpperCase();
      }
      /**
       * @internal
       */
      newRoot(fs5) {
        return new PathWin32(this.rootPath, IFDIR, void 0, this.roots, this.nocase, this.childrenCache(), { fs: fs5 });
      }
      /**
       * Return true if the provided path string is an absolute path
       */
      isAbsolute(p) {
        return p.startsWith("/") || p.startsWith("\\") || /^[a-z]:(\/|\\)/i.test(p);
      }
    };
    exports2.PathScurryWin32 = PathScurryWin32;
    var PathScurryPosix = class extends PathScurryBase {
      /**
       * separator for generating path strings
       */
      sep = "/";
      constructor(cwd = process.cwd(), opts = {}) {
        const { nocase = false } = opts;
        super(cwd, node_path_1.posix, "/", { ...opts, nocase });
        this.nocase = nocase;
      }
      /**
       * @internal
       */
      parseRootPath(_dir) {
        return "/";
      }
      /**
       * @internal
       */
      newRoot(fs5) {
        return new PathPosix(this.rootPath, IFDIR, void 0, this.roots, this.nocase, this.childrenCache(), { fs: fs5 });
      }
      /**
       * Return true if the provided path string is an absolute path
       */
      isAbsolute(p) {
        return p.startsWith("/");
      }
    };
    exports2.PathScurryPosix = PathScurryPosix;
    var PathScurryDarwin = class extends PathScurryPosix {
      constructor(cwd = process.cwd(), opts = {}) {
        const { nocase = true } = opts;
        super(cwd, { ...opts, nocase });
      }
    };
    exports2.PathScurryDarwin = PathScurryDarwin;
    exports2.Path = process.platform === "win32" ? PathWin32 : PathPosix;
    exports2.PathScurry = process.platform === "win32" ? PathScurryWin32 : process.platform === "darwin" ? PathScurryDarwin : PathScurryPosix;
  }
});

// node_modules/glob/dist/commonjs/pattern.js
var require_pattern2 = __commonJS({
  "node_modules/glob/dist/commonjs/pattern.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.Pattern = void 0;
    var minimatch_1 = require_commonjs3();
    var isPatternList = (pl2) => pl2.length >= 1;
    var isGlobList = (gl2) => gl2.length >= 1;
    var Pattern = class _Pattern {
      #patternList;
      #globList;
      #index;
      length;
      #platform;
      #rest;
      #globString;
      #isDrive;
      #isUNC;
      #isAbsolute;
      #followGlobstar = true;
      constructor(patternList, globList, index, platform) {
        if (!isPatternList(patternList)) {
          throw new TypeError("empty pattern list");
        }
        if (!isGlobList(globList)) {
          throw new TypeError("empty glob list");
        }
        if (globList.length !== patternList.length) {
          throw new TypeError("mismatched pattern list and glob list lengths");
        }
        this.length = patternList.length;
        if (index < 0 || index >= this.length) {
          throw new TypeError("index out of range");
        }
        this.#patternList = patternList;
        this.#globList = globList;
        this.#index = index;
        this.#platform = platform;
        if (this.#index === 0) {
          if (this.isUNC()) {
            const [p0, p1, p2, p3, ...prest] = this.#patternList;
            const [g0, g1, g2, g3, ...grest] = this.#globList;
            if (prest[0] === "") {
              prest.shift();
              grest.shift();
            }
            const p = [p0, p1, p2, p3, ""].join("/");
            const g = [g0, g1, g2, g3, ""].join("/");
            this.#patternList = [p, ...prest];
            this.#globList = [g, ...grest];
            this.length = this.#patternList.length;
          } else if (this.isDrive() || this.isAbsolute()) {
            const [p1, ...prest] = this.#patternList;
            const [g1, ...grest] = this.#globList;
            if (prest[0] === "") {
              prest.shift();
              grest.shift();
            }
            const p = p1 + "/";
            const g = g1 + "/";
            this.#patternList = [p, ...prest];
            this.#globList = [g, ...grest];
            this.length = this.#patternList.length;
          }
        }
      }
      /**
       * The first entry in the parsed list of patterns
       */
      pattern() {
        return this.#patternList[this.#index];
      }
      /**
       * true of if pattern() returns a string
       */
      isString() {
        return typeof this.#patternList[this.#index] === "string";
      }
      /**
       * true of if pattern() returns GLOBSTAR
       */
      isGlobstar() {
        return this.#patternList[this.#index] === minimatch_1.GLOBSTAR;
      }
      /**
       * true if pattern() returns a regexp
       */
      isRegExp() {
        return this.#patternList[this.#index] instanceof RegExp;
      }
      /**
       * The /-joined set of glob parts that make up this pattern
       */
      globString() {
        return this.#globString = this.#globString || (this.#index === 0 ? this.isAbsolute() ? this.#globList[0] + this.#globList.slice(1).join("/") : this.#globList.join("/") : this.#globList.slice(this.#index).join("/"));
      }
      /**
       * true if there are more pattern parts after this one
       */
      hasMore() {
        return this.length > this.#index + 1;
      }
      /**
       * The rest of the pattern after this part, or null if this is the end
       */
      rest() {
        if (this.#rest !== void 0)
          return this.#rest;
        if (!this.hasMore())
          return this.#rest = null;
        this.#rest = new _Pattern(this.#patternList, this.#globList, this.#index + 1, this.#platform);
        this.#rest.#isAbsolute = this.#isAbsolute;
        this.#rest.#isUNC = this.#isUNC;
        this.#rest.#isDrive = this.#isDrive;
        return this.#rest;
      }
      /**
       * true if the pattern represents a //unc/path/ on windows
       */
      isUNC() {
        const pl2 = this.#patternList;
        return this.#isUNC !== void 0 ? this.#isUNC : this.#isUNC = this.#platform === "win32" && this.#index === 0 && pl2[0] === "" && pl2[1] === "" && typeof pl2[2] === "string" && !!pl2[2] && typeof pl2[3] === "string" && !!pl2[3];
      }
      // pattern like C:/...
      // split = ['C:', ...]
      // XXX: would be nice to handle patterns like `c:*` to test the cwd
      // in c: for *, but I don't know of a way to even figure out what that
      // cwd is without actually chdir'ing into it?
      /**
       * True if the pattern starts with a drive letter on Windows
       */
      isDrive() {
        const pl2 = this.#patternList;
        return this.#isDrive !== void 0 ? this.#isDrive : this.#isDrive = this.#platform === "win32" && this.#index === 0 && this.length > 1 && typeof pl2[0] === "string" && /^[a-z]:$/i.test(pl2[0]);
      }
      // pattern = '/' or '/...' or '/x/...'
      // split = ['', ''] or ['', ...] or ['', 'x', ...]
      // Drive and UNC both considered absolute on windows
      /**
       * True if the pattern is rooted on an absolute path
       */
      isAbsolute() {
        const pl2 = this.#patternList;
        return this.#isAbsolute !== void 0 ? this.#isAbsolute : this.#isAbsolute = pl2[0] === "" && pl2.length > 1 || this.isDrive() || this.isUNC();
      }
      /**
       * consume the root of the pattern, and return it
       */
      root() {
        const p = this.#patternList[0];
        return typeof p === "string" && this.isAbsolute() && this.#index === 0 ? p : "";
      }
      /**
       * Check to see if the current globstar pattern is allowed to follow
       * a symbolic link.
       */
      checkFollowGlobstar() {
        return !(this.#index === 0 || !this.isGlobstar() || !this.#followGlobstar);
      }
      /**
       * Mark that the current globstar pattern is following a symbolic link
       */
      markFollowGlobstar() {
        if (this.#index === 0 || !this.isGlobstar() || !this.#followGlobstar)
          return false;
        this.#followGlobstar = false;
        return true;
      }
    };
    exports2.Pattern = Pattern;
  }
});

// node_modules/glob/dist/commonjs/ignore.js
var require_ignore = __commonJS({
  "node_modules/glob/dist/commonjs/ignore.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.Ignore = void 0;
    var minimatch_1 = require_commonjs3();
    var pattern_js_1 = require_pattern2();
    var defaultPlatform = typeof process === "object" && process && typeof process.platform === "string" ? process.platform : "linux";
    var Ignore = class {
      relative;
      relativeChildren;
      absolute;
      absoluteChildren;
      platform;
      mmopts;
      constructor(ignored, { nobrace, nocase, noext, noglobstar, platform = defaultPlatform }) {
        this.relative = [];
        this.absolute = [];
        this.relativeChildren = [];
        this.absoluteChildren = [];
        this.platform = platform;
        this.mmopts = {
          dot: true,
          nobrace,
          nocase,
          noext,
          noglobstar,
          optimizationLevel: 2,
          platform,
          nocomment: true,
          nonegate: true
        };
        for (const ign of ignored)
          this.add(ign);
      }
      add(ign) {
        const mm = new minimatch_1.Minimatch(ign, this.mmopts);
        for (let i = 0; i < mm.set.length; i++) {
          const parsed = mm.set[i];
          const globParts = mm.globParts[i];
          if (!parsed || !globParts) {
            throw new Error("invalid pattern object");
          }
          while (parsed[0] === "." && globParts[0] === ".") {
            parsed.shift();
            globParts.shift();
          }
          const p = new pattern_js_1.Pattern(parsed, globParts, 0, this.platform);
          const m = new minimatch_1.Minimatch(p.globString(), this.mmopts);
          const children = globParts[globParts.length - 1] === "**";
          const absolute = p.isAbsolute();
          if (absolute)
            this.absolute.push(m);
          else
            this.relative.push(m);
          if (children) {
            if (absolute)
              this.absoluteChildren.push(m);
            else
              this.relativeChildren.push(m);
          }
        }
      }
      ignored(p) {
        const fullpath = p.fullpath();
        const fullpaths = `${fullpath}/`;
        const relative = p.relative() || ".";
        const relatives = `${relative}/`;
        for (const m of this.relative) {
          if (m.match(relative) || m.match(relatives))
            return true;
        }
        for (const m of this.absolute) {
          if (m.match(fullpath) || m.match(fullpaths))
            return true;
        }
        return false;
      }
      childrenIgnored(p) {
        const fullpath = p.fullpath() + "/";
        const relative = (p.relative() || ".") + "/";
        for (const m of this.relativeChildren) {
          if (m.match(relative))
            return true;
        }
        for (const m of this.absoluteChildren) {
          if (m.match(fullpath))
            return true;
        }
        return false;
      }
    };
    exports2.Ignore = Ignore;
  }
});

// node_modules/glob/dist/commonjs/processor.js
var require_processor = __commonJS({
  "node_modules/glob/dist/commonjs/processor.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.Processor = exports2.SubWalks = exports2.MatchRecord = exports2.HasWalkedCache = void 0;
    var minimatch_1 = require_commonjs3();
    var HasWalkedCache = class _HasWalkedCache {
      store;
      constructor(store = /* @__PURE__ */ new Map()) {
        this.store = store;
      }
      copy() {
        return new _HasWalkedCache(new Map(this.store));
      }
      hasWalked(target, pattern) {
        return this.store.get(target.fullpath())?.has(pattern.globString());
      }
      storeWalked(target, pattern) {
        const fullpath = target.fullpath();
        const cached = this.store.get(fullpath);
        if (cached)
          cached.add(pattern.globString());
        else
          this.store.set(fullpath, /* @__PURE__ */ new Set([pattern.globString()]));
      }
    };
    exports2.HasWalkedCache = HasWalkedCache;
    var MatchRecord = class {
      store = /* @__PURE__ */ new Map();
      add(target, absolute, ifDir) {
        const n = (absolute ? 2 : 0) | (ifDir ? 1 : 0);
        const current = this.store.get(target);
        this.store.set(target, current === void 0 ? n : n & current);
      }
      // match, absolute, ifdir
      entries() {
        return [...this.store.entries()].map(([path4, n]) => [
          path4,
          !!(n & 2),
          !!(n & 1)
        ]);
      }
    };
    exports2.MatchRecord = MatchRecord;
    var SubWalks = class {
      store = /* @__PURE__ */ new Map();
      add(target, pattern) {
        if (!target.canReaddir()) {
          return;
        }
        const subs = this.store.get(target);
        if (subs) {
          if (!subs.find((p) => p.globString() === pattern.globString())) {
            subs.push(pattern);
          }
        } else
          this.store.set(target, [pattern]);
      }
      get(target) {
        const subs = this.store.get(target);
        if (!subs) {
          throw new Error("attempting to walk unknown path");
        }
        return subs;
      }
      entries() {
        return this.keys().map((k) => [k, this.store.get(k)]);
      }
      keys() {
        return [...this.store.keys()].filter((t) => t.canReaddir());
      }
    };
    exports2.SubWalks = SubWalks;
    var Processor = class _Processor {
      hasWalkedCache;
      matches = new MatchRecord();
      subwalks = new SubWalks();
      patterns;
      follow;
      dot;
      opts;
      constructor(opts, hasWalkedCache) {
        this.opts = opts;
        this.follow = !!opts.follow;
        this.dot = !!opts.dot;
        this.hasWalkedCache = hasWalkedCache ? hasWalkedCache.copy() : new HasWalkedCache();
      }
      processPatterns(target, patterns) {
        this.patterns = patterns;
        const processingSet = patterns.map((p) => [target, p]);
        for (let [t, pattern] of processingSet) {
          this.hasWalkedCache.storeWalked(t, pattern);
          const root = pattern.root();
          const absolute = pattern.isAbsolute() && this.opts.absolute !== false;
          if (root) {
            t = t.resolve(root === "/" && this.opts.root !== void 0 ? this.opts.root : root);
            const rest2 = pattern.rest();
            if (!rest2) {
              this.matches.add(t, true, false);
              continue;
            } else {
              pattern = rest2;
            }
          }
          if (t.isENOENT())
            continue;
          let p;
          let rest;
          let changed = false;
          while (typeof (p = pattern.pattern()) === "string" && (rest = pattern.rest())) {
            const c = t.resolve(p);
            t = c;
            pattern = rest;
            changed = true;
          }
          p = pattern.pattern();
          rest = pattern.rest();
          if (changed) {
            if (this.hasWalkedCache.hasWalked(t, pattern))
              continue;
            this.hasWalkedCache.storeWalked(t, pattern);
          }
          if (typeof p === "string") {
            const ifDir = p === ".." || p === "" || p === ".";
            this.matches.add(t.resolve(p), absolute, ifDir);
            continue;
          } else if (p === minimatch_1.GLOBSTAR) {
            if (!t.isSymbolicLink() || this.follow || pattern.checkFollowGlobstar()) {
              this.subwalks.add(t, pattern);
            }
            const rp = rest?.pattern();
            const rrest = rest?.rest();
            if (!rest || (rp === "" || rp === ".") && !rrest) {
              this.matches.add(t, absolute, rp === "" || rp === ".");
            } else {
              if (rp === "..") {
                const tp = t.parent || t;
                if (!rrest)
                  this.matches.add(tp, absolute, true);
                else if (!this.hasWalkedCache.hasWalked(tp, rrest)) {
                  this.subwalks.add(tp, rrest);
                }
              }
            }
          } else if (p instanceof RegExp) {
            this.subwalks.add(t, pattern);
          }
        }
        return this;
      }
      subwalkTargets() {
        return this.subwalks.keys();
      }
      child() {
        return new _Processor(this.opts, this.hasWalkedCache);
      }
      // return a new Processor containing the subwalks for each
      // child entry, and a set of matches, and
      // a hasWalkedCache that's a copy of this one
      // then we're going to call
      filterEntries(parent, entries) {
        const patterns = this.subwalks.get(parent);
        const results = this.child();
        for (const e of entries) {
          for (const pattern of patterns) {
            const absolute = pattern.isAbsolute();
            const p = pattern.pattern();
            const rest = pattern.rest();
            if (p === minimatch_1.GLOBSTAR) {
              results.testGlobstar(e, pattern, rest, absolute);
            } else if (p instanceof RegExp) {
              results.testRegExp(e, p, rest, absolute);
            } else {
              results.testString(e, p, rest, absolute);
            }
          }
        }
        return results;
      }
      testGlobstar(e, pattern, rest, absolute) {
        if (this.dot || !e.name.startsWith(".")) {
          if (!pattern.hasMore()) {
            this.matches.add(e, absolute, false);
          }
          if (e.canReaddir()) {
            if (this.follow || !e.isSymbolicLink()) {
              this.subwalks.add(e, pattern);
            } else if (e.isSymbolicLink()) {
              if (rest && pattern.checkFollowGlobstar()) {
                this.subwalks.add(e, rest);
              } else if (pattern.markFollowGlobstar()) {
                this.subwalks.add(e, pattern);
              }
            }
          }
        }
        if (rest) {
          const rp = rest.pattern();
          if (typeof rp === "string" && // dots and empty were handled already
          rp !== ".." && rp !== "" && rp !== ".") {
            this.testString(e, rp, rest.rest(), absolute);
          } else if (rp === "..") {
            const ep2 = e.parent || e;
            this.subwalks.add(ep2, rest);
          } else if (rp instanceof RegExp) {
            this.testRegExp(e, rp, rest.rest(), absolute);
          }
        }
      }
      testRegExp(e, p, rest, absolute) {
        if (!p.test(e.name))
          return;
        if (!rest) {
          this.matches.add(e, absolute, false);
        } else {
          this.subwalks.add(e, rest);
        }
      }
      testString(e, p, rest, absolute) {
        if (!e.isNamed(p))
          return;
        if (!rest) {
          this.matches.add(e, absolute, false);
        } else {
          this.subwalks.add(e, rest);
        }
      }
    };
    exports2.Processor = Processor;
  }
});

// node_modules/glob/dist/commonjs/walker.js
var require_walker = __commonJS({
  "node_modules/glob/dist/commonjs/walker.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.GlobStream = exports2.GlobWalker = exports2.GlobUtil = void 0;
    var minipass_1 = require_commonjs5();
    var ignore_js_1 = require_ignore();
    var processor_js_1 = require_processor();
    var makeIgnore = (ignore, opts) => typeof ignore === "string" ? new ignore_js_1.Ignore([ignore], opts) : Array.isArray(ignore) ? new ignore_js_1.Ignore(ignore, opts) : ignore;
    var GlobUtil = class {
      path;
      patterns;
      opts;
      seen = /* @__PURE__ */ new Set();
      paused = false;
      aborted = false;
      #onResume = [];
      #ignore;
      #sep;
      signal;
      maxDepth;
      includeChildMatches;
      constructor(patterns, path4, opts) {
        this.patterns = patterns;
        this.path = path4;
        this.opts = opts;
        this.#sep = !opts.posix && opts.platform === "win32" ? "\\" : "/";
        this.includeChildMatches = opts.includeChildMatches !== false;
        if (opts.ignore || !this.includeChildMatches) {
          this.#ignore = makeIgnore(opts.ignore ?? [], opts);
          if (!this.includeChildMatches && typeof this.#ignore.add !== "function") {
            const m = "cannot ignore child matches, ignore lacks add() method.";
            throw new Error(m);
          }
        }
        this.maxDepth = opts.maxDepth || Infinity;
        if (opts.signal) {
          this.signal = opts.signal;
          this.signal.addEventListener("abort", () => {
            this.#onResume.length = 0;
          });
        }
      }
      #ignored(path4) {
        return this.seen.has(path4) || !!this.#ignore?.ignored?.(path4);
      }
      #childrenIgnored(path4) {
        return !!this.#ignore?.childrenIgnored?.(path4);
      }
      // backpressure mechanism
      pause() {
        this.paused = true;
      }
      resume() {
        if (this.signal?.aborted)
          return;
        this.paused = false;
        let fn = void 0;
        while (!this.paused && (fn = this.#onResume.shift())) {
          fn();
        }
      }
      onResume(fn) {
        if (this.signal?.aborted)
          return;
        if (!this.paused) {
          fn();
        } else {
          this.#onResume.push(fn);
        }
      }
      // do the requisite realpath/stat checking, and return the path
      // to add or undefined to filter it out.
      async matchCheck(e, ifDir) {
        if (ifDir && this.opts.nodir)
          return void 0;
        let rpc;
        if (this.opts.realpath) {
          rpc = e.realpathCached() || await e.realpath();
          if (!rpc)
            return void 0;
          e = rpc;
        }
        const needStat = e.isUnknown() || this.opts.stat;
        const s = needStat ? await e.lstat() : e;
        if (this.opts.follow && this.opts.nodir && s?.isSymbolicLink()) {
          const target = await s.realpath();
          if (target && (target.isUnknown() || this.opts.stat)) {
            await target.lstat();
          }
        }
        return this.matchCheckTest(s, ifDir);
      }
      matchCheckTest(e, ifDir) {
        return e && (this.maxDepth === Infinity || e.depth() <= this.maxDepth) && (!ifDir || e.canReaddir()) && (!this.opts.nodir || !e.isDirectory()) && (!this.opts.nodir || !this.opts.follow || !e.isSymbolicLink() || !e.realpathCached()?.isDirectory()) && !this.#ignored(e) ? e : void 0;
      }
      matchCheckSync(e, ifDir) {
        if (ifDir && this.opts.nodir)
          return void 0;
        let rpc;
        if (this.opts.realpath) {
          rpc = e.realpathCached() || e.realpathSync();
          if (!rpc)
            return void 0;
          e = rpc;
        }
        const needStat = e.isUnknown() || this.opts.stat;
        const s = needStat ? e.lstatSync() : e;
        if (this.opts.follow && this.opts.nodir && s?.isSymbolicLink()) {
          const target = s.realpathSync();
          if (target && (target?.isUnknown() || this.opts.stat)) {
            target.lstatSync();
          }
        }
        return this.matchCheckTest(s, ifDir);
      }
      matchFinish(e, absolute) {
        if (this.#ignored(e))
          return;
        if (!this.includeChildMatches && this.#ignore?.add) {
          const ign = `${e.relativePosix()}/**`;
          this.#ignore.add(ign);
        }
        const abs = this.opts.absolute === void 0 ? absolute : this.opts.absolute;
        this.seen.add(e);
        const mark = this.opts.mark && e.isDirectory() ? this.#sep : "";
        if (this.opts.withFileTypes) {
          this.matchEmit(e);
        } else if (abs) {
          const abs2 = this.opts.posix ? e.fullpathPosix() : e.fullpath();
          this.matchEmit(abs2 + mark);
        } else {
          const rel = this.opts.posix ? e.relativePosix() : e.relative();
          const pre = this.opts.dotRelative && !rel.startsWith(".." + this.#sep) ? "." + this.#sep : "";
          this.matchEmit(!rel ? "." + mark : pre + rel + mark);
        }
      }
      async match(e, absolute, ifDir) {
        const p = await this.matchCheck(e, ifDir);
        if (p)
          this.matchFinish(p, absolute);
      }
      matchSync(e, absolute, ifDir) {
        const p = this.matchCheckSync(e, ifDir);
        if (p)
          this.matchFinish(p, absolute);
      }
      walkCB(target, patterns, cb) {
        if (this.signal?.aborted)
          cb();
        this.walkCB2(target, patterns, new processor_js_1.Processor(this.opts), cb);
      }
      walkCB2(target, patterns, processor, cb) {
        if (this.#childrenIgnored(target))
          return cb();
        if (this.signal?.aborted)
          cb();
        if (this.paused) {
          this.onResume(() => this.walkCB2(target, patterns, processor, cb));
          return;
        }
        processor.processPatterns(target, patterns);
        let tasks = 1;
        const next = () => {
          if (--tasks === 0)
            cb();
        };
        for (const [m, absolute, ifDir] of processor.matches.entries()) {
          if (this.#ignored(m))
            continue;
          tasks++;
          this.match(m, absolute, ifDir).then(() => next());
        }
        for (const t of processor.subwalkTargets()) {
          if (this.maxDepth !== Infinity && t.depth() >= this.maxDepth) {
            continue;
          }
          tasks++;
          const childrenCached = t.readdirCached();
          if (t.calledReaddir())
            this.walkCB3(t, childrenCached, processor, next);
          else {
            t.readdirCB((_, entries) => this.walkCB3(t, entries, processor, next), true);
          }
        }
        next();
      }
      walkCB3(target, entries, processor, cb) {
        processor = processor.filterEntries(target, entries);
        let tasks = 1;
        const next = () => {
          if (--tasks === 0)
            cb();
        };
        for (const [m, absolute, ifDir] of processor.matches.entries()) {
          if (this.#ignored(m))
            continue;
          tasks++;
          this.match(m, absolute, ifDir).then(() => next());
        }
        for (const [target2, patterns] of processor.subwalks.entries()) {
          tasks++;
          this.walkCB2(target2, patterns, processor.child(), next);
        }
        next();
      }
      walkCBSync(target, patterns, cb) {
        if (this.signal?.aborted)
          cb();
        this.walkCB2Sync(target, patterns, new processor_js_1.Processor(this.opts), cb);
      }
      walkCB2Sync(target, patterns, processor, cb) {
        if (this.#childrenIgnored(target))
          return cb();
        if (this.signal?.aborted)
          cb();
        if (this.paused) {
          this.onResume(() => this.walkCB2Sync(target, patterns, processor, cb));
          return;
        }
        processor.processPatterns(target, patterns);
        let tasks = 1;
        const next = () => {
          if (--tasks === 0)
            cb();
        };
        for (const [m, absolute, ifDir] of processor.matches.entries()) {
          if (this.#ignored(m))
            continue;
          this.matchSync(m, absolute, ifDir);
        }
        for (const t of processor.subwalkTargets()) {
          if (this.maxDepth !== Infinity && t.depth() >= this.maxDepth) {
            continue;
          }
          tasks++;
          const children = t.readdirSync();
          this.walkCB3Sync(t, children, processor, next);
        }
        next();
      }
      walkCB3Sync(target, entries, processor, cb) {
        processor = processor.filterEntries(target, entries);
        let tasks = 1;
        const next = () => {
          if (--tasks === 0)
            cb();
        };
        for (const [m, absolute, ifDir] of processor.matches.entries()) {
          if (this.#ignored(m))
            continue;
          this.matchSync(m, absolute, ifDir);
        }
        for (const [target2, patterns] of processor.subwalks.entries()) {
          tasks++;
          this.walkCB2Sync(target2, patterns, processor.child(), next);
        }
        next();
      }
    };
    exports2.GlobUtil = GlobUtil;
    var GlobWalker = class extends GlobUtil {
      matches = /* @__PURE__ */ new Set();
      constructor(patterns, path4, opts) {
        super(patterns, path4, opts);
      }
      matchEmit(e) {
        this.matches.add(e);
      }
      async walk() {
        if (this.signal?.aborted)
          throw this.signal.reason;
        if (this.path.isUnknown()) {
          await this.path.lstat();
        }
        await new Promise((res, rej) => {
          this.walkCB(this.path, this.patterns, () => {
            if (this.signal?.aborted) {
              rej(this.signal.reason);
            } else {
              res(this.matches);
            }
          });
        });
        return this.matches;
      }
      walkSync() {
        if (this.signal?.aborted)
          throw this.signal.reason;
        if (this.path.isUnknown()) {
          this.path.lstatSync();
        }
        this.walkCBSync(this.path, this.patterns, () => {
          if (this.signal?.aborted)
            throw this.signal.reason;
        });
        return this.matches;
      }
    };
    exports2.GlobWalker = GlobWalker;
    var GlobStream = class extends GlobUtil {
      results;
      constructor(patterns, path4, opts) {
        super(patterns, path4, opts);
        this.results = new minipass_1.Minipass({
          signal: this.signal,
          objectMode: true
        });
        this.results.on("drain", () => this.resume());
        this.results.on("resume", () => this.resume());
      }
      matchEmit(e) {
        this.results.write(e);
        if (!this.results.flowing)
          this.pause();
      }
      stream() {
        const target = this.path;
        if (target.isUnknown()) {
          target.lstat().then(() => {
            this.walkCB(target, this.patterns, () => this.results.end());
          });
        } else {
          this.walkCB(target, this.patterns, () => this.results.end());
        }
        return this.results;
      }
      streamSync() {
        if (this.path.isUnknown()) {
          this.path.lstatSync();
        }
        this.walkCBSync(this.path, this.patterns, () => this.results.end());
        return this.results;
      }
    };
    exports2.GlobStream = GlobStream;
  }
});

// node_modules/glob/dist/commonjs/glob.js
var require_glob = __commonJS({
  "node_modules/glob/dist/commonjs/glob.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.Glob = void 0;
    var minimatch_1 = require_commonjs3();
    var node_url_1 = require("node:url");
    var path_scurry_1 = require_commonjs6();
    var pattern_js_1 = require_pattern2();
    var walker_js_1 = require_walker();
    var defaultPlatform = typeof process === "object" && process && typeof process.platform === "string" ? process.platform : "linux";
    var Glob = class {
      absolute;
      cwd;
      root;
      dot;
      dotRelative;
      follow;
      ignore;
      magicalBraces;
      mark;
      matchBase;
      maxDepth;
      nobrace;
      nocase;
      nodir;
      noext;
      noglobstar;
      pattern;
      platform;
      realpath;
      scurry;
      stat;
      signal;
      windowsPathsNoEscape;
      withFileTypes;
      includeChildMatches;
      /**
       * The options provided to the constructor.
       */
      opts;
      /**
       * An array of parsed immutable {@link Pattern} objects.
       */
      patterns;
      /**
       * All options are stored as properties on the `Glob` object.
       *
       * See {@link GlobOptions} for full options descriptions.
       *
       * Note that a previous `Glob` object can be passed as the
       * `GlobOptions` to another `Glob` instantiation to re-use settings
       * and caches with a new pattern.
       *
       * Traversal functions can be called multiple times to run the walk
       * again.
       */
      constructor(pattern, opts) {
        if (!opts)
          throw new TypeError("glob options required");
        this.withFileTypes = !!opts.withFileTypes;
        this.signal = opts.signal;
        this.follow = !!opts.follow;
        this.dot = !!opts.dot;
        this.dotRelative = !!opts.dotRelative;
        this.nodir = !!opts.nodir;
        this.mark = !!opts.mark;
        if (!opts.cwd) {
          this.cwd = "";
        } else if (opts.cwd instanceof URL || opts.cwd.startsWith("file://")) {
          opts.cwd = (0, node_url_1.fileURLToPath)(opts.cwd);
        }
        this.cwd = opts.cwd || "";
        this.root = opts.root;
        this.magicalBraces = !!opts.magicalBraces;
        this.nobrace = !!opts.nobrace;
        this.noext = !!opts.noext;
        this.realpath = !!opts.realpath;
        this.absolute = opts.absolute;
        this.includeChildMatches = opts.includeChildMatches !== false;
        this.noglobstar = !!opts.noglobstar;
        this.matchBase = !!opts.matchBase;
        this.maxDepth = typeof opts.maxDepth === "number" ? opts.maxDepth : Infinity;
        this.stat = !!opts.stat;
        this.ignore = opts.ignore;
        if (this.withFileTypes && this.absolute !== void 0) {
          throw new Error("cannot set absolute and withFileTypes:true");
        }
        if (typeof pattern === "string") {
          pattern = [pattern];
        }
        this.windowsPathsNoEscape = !!opts.windowsPathsNoEscape || opts.allowWindowsEscape === false;
        if (this.windowsPathsNoEscape) {
          pattern = pattern.map((p) => p.replace(/\\/g, "/"));
        }
        if (this.matchBase) {
          if (opts.noglobstar) {
            throw new TypeError("base matching requires globstar");
          }
          pattern = pattern.map((p) => p.includes("/") ? p : `./**/${p}`);
        }
        this.pattern = pattern;
        this.platform = opts.platform || defaultPlatform;
        this.opts = { ...opts, platform: this.platform };
        if (opts.scurry) {
          this.scurry = opts.scurry;
          if (opts.nocase !== void 0 && opts.nocase !== opts.scurry.nocase) {
            throw new Error("nocase option contradicts provided scurry option");
          }
        } else {
          const Scurry = opts.platform === "win32" ? path_scurry_1.PathScurryWin32 : opts.platform === "darwin" ? path_scurry_1.PathScurryDarwin : opts.platform ? path_scurry_1.PathScurryPosix : path_scurry_1.PathScurry;
          this.scurry = new Scurry(this.cwd, {
            nocase: opts.nocase,
            fs: opts.fs
          });
        }
        this.nocase = this.scurry.nocase;
        const nocaseMagicOnly = this.platform === "darwin" || this.platform === "win32";
        const mmo = {
          // default nocase based on platform
          ...opts,
          dot: this.dot,
          matchBase: this.matchBase,
          nobrace: this.nobrace,
          nocase: this.nocase,
          nocaseMagicOnly,
          nocomment: true,
          noext: this.noext,
          nonegate: true,
          optimizationLevel: 2,
          platform: this.platform,
          windowsPathsNoEscape: this.windowsPathsNoEscape,
          debug: !!this.opts.debug
        };
        const mms = this.pattern.map((p) => new minimatch_1.Minimatch(p, mmo));
        const [matchSet, globParts] = mms.reduce((set, m) => {
          set[0].push(...m.set);
          set[1].push(...m.globParts);
          return set;
        }, [[], []]);
        this.patterns = matchSet.map((set, i) => {
          const g = globParts[i];
          if (!g)
            throw new Error("invalid pattern object");
          return new pattern_js_1.Pattern(set, g, 0, this.platform);
        });
      }
      async walk() {
        return [
          ...await new walker_js_1.GlobWalker(this.patterns, this.scurry.cwd, {
            ...this.opts,
            maxDepth: this.maxDepth !== Infinity ? this.maxDepth + this.scurry.cwd.depth() : Infinity,
            platform: this.platform,
            nocase: this.nocase,
            includeChildMatches: this.includeChildMatches
          }).walk()
        ];
      }
      walkSync() {
        return [
          ...new walker_js_1.GlobWalker(this.patterns, this.scurry.cwd, {
            ...this.opts,
            maxDepth: this.maxDepth !== Infinity ? this.maxDepth + this.scurry.cwd.depth() : Infinity,
            platform: this.platform,
            nocase: this.nocase,
            includeChildMatches: this.includeChildMatches
          }).walkSync()
        ];
      }
      stream() {
        return new walker_js_1.GlobStream(this.patterns, this.scurry.cwd, {
          ...this.opts,
          maxDepth: this.maxDepth !== Infinity ? this.maxDepth + this.scurry.cwd.depth() : Infinity,
          platform: this.platform,
          nocase: this.nocase,
          includeChildMatches: this.includeChildMatches
        }).stream();
      }
      streamSync() {
        return new walker_js_1.GlobStream(this.patterns, this.scurry.cwd, {
          ...this.opts,
          maxDepth: this.maxDepth !== Infinity ? this.maxDepth + this.scurry.cwd.depth() : Infinity,
          platform: this.platform,
          nocase: this.nocase,
          includeChildMatches: this.includeChildMatches
        }).streamSync();
      }
      /**
       * Default sync iteration function. Returns a Generator that
       * iterates over the results.
       */
      iterateSync() {
        return this.streamSync()[Symbol.iterator]();
      }
      [Symbol.iterator]() {
        return this.iterateSync();
      }
      /**
       * Default async iteration function. Returns an AsyncGenerator that
       * iterates over the results.
       */
      iterate() {
        return this.stream()[Symbol.asyncIterator]();
      }
      [Symbol.asyncIterator]() {
        return this.iterate();
      }
    };
    exports2.Glob = Glob;
  }
});

// node_modules/glob/dist/commonjs/has-magic.js
var require_has_magic = __commonJS({
  "node_modules/glob/dist/commonjs/has-magic.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.hasMagic = void 0;
    var minimatch_1 = require_commonjs3();
    var hasMagic = (pattern, options = {}) => {
      if (!Array.isArray(pattern)) {
        pattern = [pattern];
      }
      for (const p of pattern) {
        if (new minimatch_1.Minimatch(p, options).hasMagic())
          return true;
      }
      return false;
    };
    exports2.hasMagic = hasMagic;
  }
});

// node_modules/glob/dist/commonjs/index.js
var require_commonjs7 = __commonJS({
  "node_modules/glob/dist/commonjs/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.glob = exports2.sync = exports2.iterate = exports2.iterateSync = exports2.stream = exports2.streamSync = exports2.Ignore = exports2.hasMagic = exports2.Glob = exports2.unescape = exports2.escape = void 0;
    exports2.globStreamSync = globStreamSync;
    exports2.globStream = globStream;
    exports2.globSync = globSync;
    exports2.globIterateSync = globIterateSync;
    exports2.globIterate = globIterate;
    var minimatch_1 = require_commonjs3();
    var glob_js_1 = require_glob();
    var has_magic_js_1 = require_has_magic();
    var minimatch_2 = require_commonjs3();
    Object.defineProperty(exports2, "escape", { enumerable: true, get: function() {
      return minimatch_2.escape;
    } });
    Object.defineProperty(exports2, "unescape", { enumerable: true, get: function() {
      return minimatch_2.unescape;
    } });
    var glob_js_2 = require_glob();
    Object.defineProperty(exports2, "Glob", { enumerable: true, get: function() {
      return glob_js_2.Glob;
    } });
    var has_magic_js_2 = require_has_magic();
    Object.defineProperty(exports2, "hasMagic", { enumerable: true, get: function() {
      return has_magic_js_2.hasMagic;
    } });
    var ignore_js_1 = require_ignore();
    Object.defineProperty(exports2, "Ignore", { enumerable: true, get: function() {
      return ignore_js_1.Ignore;
    } });
    function globStreamSync(pattern, options = {}) {
      return new glob_js_1.Glob(pattern, options).streamSync();
    }
    function globStream(pattern, options = {}) {
      return new glob_js_1.Glob(pattern, options).stream();
    }
    function globSync(pattern, options = {}) {
      return new glob_js_1.Glob(pattern, options).walkSync();
    }
    async function glob_(pattern, options = {}) {
      return new glob_js_1.Glob(pattern, options).walk();
    }
    function globIterateSync(pattern, options = {}) {
      return new glob_js_1.Glob(pattern, options).iterateSync();
    }
    function globIterate(pattern, options = {}) {
      return new glob_js_1.Glob(pattern, options).iterate();
    }
    exports2.streamSync = globStreamSync;
    exports2.stream = Object.assign(globStream, { sync: globStreamSync });
    exports2.iterateSync = globIterateSync;
    exports2.iterate = Object.assign(globIterate, {
      sync: globIterateSync
    });
    exports2.sync = Object.assign(globSync, {
      stream: globStreamSync,
      iterate: globIterateSync
    });
    exports2.glob = Object.assign(glob_, {
      glob: glob_,
      globSync,
      sync: exports2.sync,
      globStream,
      stream: exports2.stream,
      globStreamSync,
      streamSync: exports2.streamSync,
      globIterate,
      iterate: exports2.iterate,
      globIterateSync,
      iterateSync: exports2.iterateSync,
      Glob: glob_js_1.Glob,
      hasMagic: has_magic_js_1.hasMagic,
      escape: minimatch_1.escape,
      unescape: minimatch_1.unescape
    });
    exports2.glob.glob = exports2.glob;
  }
});

// node_modules/@fastify/send/lib/isUtf8MimeType.js
var require_isUtf8MimeType = __commonJS({
  "node_modules/@fastify/send/lib/isUtf8MimeType.js"(exports2, module2) {
    "use strict";
    function isUtf8MimeType(value) {
      const len = value.length;
      return len > 21 && value.indexOf("application/javascript") === 0 || len > 14 && value.indexOf("application/json") === 0 || len > 5 && value.indexOf("text/") === 0;
    }
    module2.exports.isUtf8MimeType = isUtf8MimeType;
  }
});

// node_modules/mime/Mime.js
var require_Mime = __commonJS({
  "node_modules/mime/Mime.js"(exports2, module2) {
    "use strict";
    function Mime() {
      this._types = /* @__PURE__ */ Object.create(null);
      this._extensions = /* @__PURE__ */ Object.create(null);
      for (let i = 0; i < arguments.length; i++) {
        this.define(arguments[i]);
      }
      this.define = this.define.bind(this);
      this.getType = this.getType.bind(this);
      this.getExtension = this.getExtension.bind(this);
    }
    Mime.prototype.define = function(typeMap, force) {
      for (let type in typeMap) {
        let extensions = typeMap[type].map(function(t) {
          return t.toLowerCase();
        });
        type = type.toLowerCase();
        for (let i = 0; i < extensions.length; i++) {
          const ext = extensions[i];
          if (ext[0] === "*") {
            continue;
          }
          if (!force && ext in this._types) {
            throw new Error(
              'Attempt to change mapping for "' + ext + '" extension from "' + this._types[ext] + '" to "' + type + '". Pass `force=true` to allow this, otherwise remove "' + ext + '" from the list of extensions for "' + type + '".'
            );
          }
          this._types[ext] = type;
        }
        if (force || !this._extensions[type]) {
          const ext = extensions[0];
          this._extensions[type] = ext[0] !== "*" ? ext : ext.substr(1);
        }
      }
    };
    Mime.prototype.getType = function(path4) {
      path4 = String(path4);
      let last = path4.replace(/^.*[/\\]/, "").toLowerCase();
      let ext = last.replace(/^.*\./, "").toLowerCase();
      let hasPath = last.length < path4.length;
      let hasDot = ext.length < last.length - 1;
      return (hasDot || !hasPath) && this._types[ext] || null;
    };
    Mime.prototype.getExtension = function(type) {
      type = /^\s*([^;\s]*)/.test(type) && RegExp.$1;
      return type && this._extensions[type.toLowerCase()] || null;
    };
    module2.exports = Mime;
  }
});

// node_modules/mime/types/standard.js
var require_standard = __commonJS({
  "node_modules/mime/types/standard.js"(exports2, module2) {
    module2.exports = { "application/andrew-inset": ["ez"], "application/applixware": ["aw"], "application/atom+xml": ["atom"], "application/atomcat+xml": ["atomcat"], "application/atomdeleted+xml": ["atomdeleted"], "application/atomsvc+xml": ["atomsvc"], "application/atsc-dwd+xml": ["dwd"], "application/atsc-held+xml": ["held"], "application/atsc-rsat+xml": ["rsat"], "application/bdoc": ["bdoc"], "application/calendar+xml": ["xcs"], "application/ccxml+xml": ["ccxml"], "application/cdfx+xml": ["cdfx"], "application/cdmi-capability": ["cdmia"], "application/cdmi-container": ["cdmic"], "application/cdmi-domain": ["cdmid"], "application/cdmi-object": ["cdmio"], "application/cdmi-queue": ["cdmiq"], "application/cu-seeme": ["cu"], "application/dash+xml": ["mpd"], "application/davmount+xml": ["davmount"], "application/docbook+xml": ["dbk"], "application/dssc+der": ["dssc"], "application/dssc+xml": ["xdssc"], "application/ecmascript": ["es", "ecma"], "application/emma+xml": ["emma"], "application/emotionml+xml": ["emotionml"], "application/epub+zip": ["epub"], "application/exi": ["exi"], "application/express": ["exp"], "application/fdt+xml": ["fdt"], "application/font-tdpfr": ["pfr"], "application/geo+json": ["geojson"], "application/gml+xml": ["gml"], "application/gpx+xml": ["gpx"], "application/gxf": ["gxf"], "application/gzip": ["gz"], "application/hjson": ["hjson"], "application/hyperstudio": ["stk"], "application/inkml+xml": ["ink", "inkml"], "application/ipfix": ["ipfix"], "application/its+xml": ["its"], "application/java-archive": ["jar", "war", "ear"], "application/java-serialized-object": ["ser"], "application/java-vm": ["class"], "application/javascript": ["js", "mjs"], "application/json": ["json", "map"], "application/json5": ["json5"], "application/jsonml+json": ["jsonml"], "application/ld+json": ["jsonld"], "application/lgr+xml": ["lgr"], "application/lost+xml": ["lostxml"], "application/mac-binhex40": ["hqx"], "application/mac-compactpro": ["cpt"], "application/mads+xml": ["mads"], "application/manifest+json": ["webmanifest"], "application/marc": ["mrc"], "application/marcxml+xml": ["mrcx"], "application/mathematica": ["ma", "nb", "mb"], "application/mathml+xml": ["mathml"], "application/mbox": ["mbox"], "application/mediaservercontrol+xml": ["mscml"], "application/metalink+xml": ["metalink"], "application/metalink4+xml": ["meta4"], "application/mets+xml": ["mets"], "application/mmt-aei+xml": ["maei"], "application/mmt-usd+xml": ["musd"], "application/mods+xml": ["mods"], "application/mp21": ["m21", "mp21"], "application/mp4": ["mp4s", "m4p"], "application/msword": ["doc", "dot"], "application/mxf": ["mxf"], "application/n-quads": ["nq"], "application/n-triples": ["nt"], "application/node": ["cjs"], "application/octet-stream": ["bin", "dms", "lrf", "mar", "so", "dist", "distz", "pkg", "bpk", "dump", "elc", "deploy", "exe", "dll", "deb", "dmg", "iso", "img", "msi", "msp", "msm", "buffer"], "application/oda": ["oda"], "application/oebps-package+xml": ["opf"], "application/ogg": ["ogx"], "application/omdoc+xml": ["omdoc"], "application/onenote": ["onetoc", "onetoc2", "onetmp", "onepkg"], "application/oxps": ["oxps"], "application/p2p-overlay+xml": ["relo"], "application/patch-ops-error+xml": ["xer"], "application/pdf": ["pdf"], "application/pgp-encrypted": ["pgp"], "application/pgp-signature": ["asc", "sig"], "application/pics-rules": ["prf"], "application/pkcs10": ["p10"], "application/pkcs7-mime": ["p7m", "p7c"], "application/pkcs7-signature": ["p7s"], "application/pkcs8": ["p8"], "application/pkix-attr-cert": ["ac"], "application/pkix-cert": ["cer"], "application/pkix-crl": ["crl"], "application/pkix-pkipath": ["pkipath"], "application/pkixcmp": ["pki"], "application/pls+xml": ["pls"], "application/postscript": ["ai", "eps", "ps"], "application/provenance+xml": ["provx"], "application/pskc+xml": ["pskcxml"], "application/raml+yaml": ["raml"], "application/rdf+xml": ["rdf", "owl"], "application/reginfo+xml": ["rif"], "application/relax-ng-compact-syntax": ["rnc"], "application/resource-lists+xml": ["rl"], "application/resource-lists-diff+xml": ["rld"], "application/rls-services+xml": ["rs"], "application/route-apd+xml": ["rapd"], "application/route-s-tsid+xml": ["sls"], "application/route-usd+xml": ["rusd"], "application/rpki-ghostbusters": ["gbr"], "application/rpki-manifest": ["mft"], "application/rpki-roa": ["roa"], "application/rsd+xml": ["rsd"], "application/rss+xml": ["rss"], "application/rtf": ["rtf"], "application/sbml+xml": ["sbml"], "application/scvp-cv-request": ["scq"], "application/scvp-cv-response": ["scs"], "application/scvp-vp-request": ["spq"], "application/scvp-vp-response": ["spp"], "application/sdp": ["sdp"], "application/senml+xml": ["senmlx"], "application/sensml+xml": ["sensmlx"], "application/set-payment-initiation": ["setpay"], "application/set-registration-initiation": ["setreg"], "application/shf+xml": ["shf"], "application/sieve": ["siv", "sieve"], "application/smil+xml": ["smi", "smil"], "application/sparql-query": ["rq"], "application/sparql-results+xml": ["srx"], "application/srgs": ["gram"], "application/srgs+xml": ["grxml"], "application/sru+xml": ["sru"], "application/ssdl+xml": ["ssdl"], "application/ssml+xml": ["ssml"], "application/swid+xml": ["swidtag"], "application/tei+xml": ["tei", "teicorpus"], "application/thraud+xml": ["tfi"], "application/timestamped-data": ["tsd"], "application/toml": ["toml"], "application/trig": ["trig"], "application/ttml+xml": ["ttml"], "application/ubjson": ["ubj"], "application/urc-ressheet+xml": ["rsheet"], "application/urc-targetdesc+xml": ["td"], "application/voicexml+xml": ["vxml"], "application/wasm": ["wasm"], "application/widget": ["wgt"], "application/winhlp": ["hlp"], "application/wsdl+xml": ["wsdl"], "application/wspolicy+xml": ["wspolicy"], "application/xaml+xml": ["xaml"], "application/xcap-att+xml": ["xav"], "application/xcap-caps+xml": ["xca"], "application/xcap-diff+xml": ["xdf"], "application/xcap-el+xml": ["xel"], "application/xcap-ns+xml": ["xns"], "application/xenc+xml": ["xenc"], "application/xhtml+xml": ["xhtml", "xht"], "application/xliff+xml": ["xlf"], "application/xml": ["xml", "xsl", "xsd", "rng"], "application/xml-dtd": ["dtd"], "application/xop+xml": ["xop"], "application/xproc+xml": ["xpl"], "application/xslt+xml": ["*xsl", "xslt"], "application/xspf+xml": ["xspf"], "application/xv+xml": ["mxml", "xhvml", "xvml", "xvm"], "application/yang": ["yang"], "application/yin+xml": ["yin"], "application/zip": ["zip"], "audio/3gpp": ["*3gpp"], "audio/adpcm": ["adp"], "audio/amr": ["amr"], "audio/basic": ["au", "snd"], "audio/midi": ["mid", "midi", "kar", "rmi"], "audio/mobile-xmf": ["mxmf"], "audio/mp3": ["*mp3"], "audio/mp4": ["m4a", "mp4a"], "audio/mpeg": ["mpga", "mp2", "mp2a", "mp3", "m2a", "m3a"], "audio/ogg": ["oga", "ogg", "spx", "opus"], "audio/s3m": ["s3m"], "audio/silk": ["sil"], "audio/wav": ["wav"], "audio/wave": ["*wav"], "audio/webm": ["weba"], "audio/xm": ["xm"], "font/collection": ["ttc"], "font/otf": ["otf"], "font/ttf": ["ttf"], "font/woff": ["woff"], "font/woff2": ["woff2"], "image/aces": ["exr"], "image/apng": ["apng"], "image/avif": ["avif"], "image/bmp": ["bmp"], "image/cgm": ["cgm"], "image/dicom-rle": ["drle"], "image/emf": ["emf"], "image/fits": ["fits"], "image/g3fax": ["g3"], "image/gif": ["gif"], "image/heic": ["heic"], "image/heic-sequence": ["heics"], "image/heif": ["heif"], "image/heif-sequence": ["heifs"], "image/hej2k": ["hej2"], "image/hsj2": ["hsj2"], "image/ief": ["ief"], "image/jls": ["jls"], "image/jp2": ["jp2", "jpg2"], "image/jpeg": ["jpeg", "jpg", "jpe"], "image/jph": ["jph"], "image/jphc": ["jhc"], "image/jpm": ["jpm"], "image/jpx": ["jpx", "jpf"], "image/jxr": ["jxr"], "image/jxra": ["jxra"], "image/jxrs": ["jxrs"], "image/jxs": ["jxs"], "image/jxsc": ["jxsc"], "image/jxsi": ["jxsi"], "image/jxss": ["jxss"], "image/ktx": ["ktx"], "image/ktx2": ["ktx2"], "image/png": ["png"], "image/sgi": ["sgi"], "image/svg+xml": ["svg", "svgz"], "image/t38": ["t38"], "image/tiff": ["tif", "tiff"], "image/tiff-fx": ["tfx"], "image/webp": ["webp"], "image/wmf": ["wmf"], "message/disposition-notification": ["disposition-notification"], "message/global": ["u8msg"], "message/global-delivery-status": ["u8dsn"], "message/global-disposition-notification": ["u8mdn"], "message/global-headers": ["u8hdr"], "message/rfc822": ["eml", "mime"], "model/3mf": ["3mf"], "model/gltf+json": ["gltf"], "model/gltf-binary": ["glb"], "model/iges": ["igs", "iges"], "model/mesh": ["msh", "mesh", "silo"], "model/mtl": ["mtl"], "model/obj": ["obj"], "model/step+xml": ["stpx"], "model/step+zip": ["stpz"], "model/step-xml+zip": ["stpxz"], "model/stl": ["stl"], "model/vrml": ["wrl", "vrml"], "model/x3d+binary": ["*x3db", "x3dbz"], "model/x3d+fastinfoset": ["x3db"], "model/x3d+vrml": ["*x3dv", "x3dvz"], "model/x3d+xml": ["x3d", "x3dz"], "model/x3d-vrml": ["x3dv"], "text/cache-manifest": ["appcache", "manifest"], "text/calendar": ["ics", "ifb"], "text/coffeescript": ["coffee", "litcoffee"], "text/css": ["css"], "text/csv": ["csv"], "text/html": ["html", "htm", "shtml"], "text/jade": ["jade"], "text/jsx": ["jsx"], "text/less": ["less"], "text/markdown": ["markdown", "md"], "text/mathml": ["mml"], "text/mdx": ["mdx"], "text/n3": ["n3"], "text/plain": ["txt", "text", "conf", "def", "list", "log", "in", "ini"], "text/richtext": ["rtx"], "text/rtf": ["*rtf"], "text/sgml": ["sgml", "sgm"], "text/shex": ["shex"], "text/slim": ["slim", "slm"], "text/spdx": ["spdx"], "text/stylus": ["stylus", "styl"], "text/tab-separated-values": ["tsv"], "text/troff": ["t", "tr", "roff", "man", "me", "ms"], "text/turtle": ["ttl"], "text/uri-list": ["uri", "uris", "urls"], "text/vcard": ["vcard"], "text/vtt": ["vtt"], "text/xml": ["*xml"], "text/yaml": ["yaml", "yml"], "video/3gpp": ["3gp", "3gpp"], "video/3gpp2": ["3g2"], "video/h261": ["h261"], "video/h263": ["h263"], "video/h264": ["h264"], "video/iso.segment": ["m4s"], "video/jpeg": ["jpgv"], "video/jpm": ["*jpm", "jpgm"], "video/mj2": ["mj2", "mjp2"], "video/mp2t": ["ts"], "video/mp4": ["mp4", "mp4v", "mpg4"], "video/mpeg": ["mpeg", "mpg", "mpe", "m1v", "m2v"], "video/ogg": ["ogv"], "video/quicktime": ["qt", "mov"], "video/webm": ["webm"] };
  }
});

// node_modules/mime/types/other.js
var require_other = __commonJS({
  "node_modules/mime/types/other.js"(exports2, module2) {
    module2.exports = { "application/prs.cww": ["cww"], "application/vnd.1000minds.decision-model+xml": ["1km"], "application/vnd.3gpp.pic-bw-large": ["plb"], "application/vnd.3gpp.pic-bw-small": ["psb"], "application/vnd.3gpp.pic-bw-var": ["pvb"], "application/vnd.3gpp2.tcap": ["tcap"], "application/vnd.3m.post-it-notes": ["pwn"], "application/vnd.accpac.simply.aso": ["aso"], "application/vnd.accpac.simply.imp": ["imp"], "application/vnd.acucobol": ["acu"], "application/vnd.acucorp": ["atc", "acutc"], "application/vnd.adobe.air-application-installer-package+zip": ["air"], "application/vnd.adobe.formscentral.fcdt": ["fcdt"], "application/vnd.adobe.fxp": ["fxp", "fxpl"], "application/vnd.adobe.xdp+xml": ["xdp"], "application/vnd.adobe.xfdf": ["xfdf"], "application/vnd.ahead.space": ["ahead"], "application/vnd.airzip.filesecure.azf": ["azf"], "application/vnd.airzip.filesecure.azs": ["azs"], "application/vnd.amazon.ebook": ["azw"], "application/vnd.americandynamics.acc": ["acc"], "application/vnd.amiga.ami": ["ami"], "application/vnd.android.package-archive": ["apk"], "application/vnd.anser-web-certificate-issue-initiation": ["cii"], "application/vnd.anser-web-funds-transfer-initiation": ["fti"], "application/vnd.antix.game-component": ["atx"], "application/vnd.apple.installer+xml": ["mpkg"], "application/vnd.apple.keynote": ["key"], "application/vnd.apple.mpegurl": ["m3u8"], "application/vnd.apple.numbers": ["numbers"], "application/vnd.apple.pages": ["pages"], "application/vnd.apple.pkpass": ["pkpass"], "application/vnd.aristanetworks.swi": ["swi"], "application/vnd.astraea-software.iota": ["iota"], "application/vnd.audiograph": ["aep"], "application/vnd.balsamiq.bmml+xml": ["bmml"], "application/vnd.blueice.multipass": ["mpm"], "application/vnd.bmi": ["bmi"], "application/vnd.businessobjects": ["rep"], "application/vnd.chemdraw+xml": ["cdxml"], "application/vnd.chipnuts.karaoke-mmd": ["mmd"], "application/vnd.cinderella": ["cdy"], "application/vnd.citationstyles.style+xml": ["csl"], "application/vnd.claymore": ["cla"], "application/vnd.cloanto.rp9": ["rp9"], "application/vnd.clonk.c4group": ["c4g", "c4d", "c4f", "c4p", "c4u"], "application/vnd.cluetrust.cartomobile-config": ["c11amc"], "application/vnd.cluetrust.cartomobile-config-pkg": ["c11amz"], "application/vnd.commonspace": ["csp"], "application/vnd.contact.cmsg": ["cdbcmsg"], "application/vnd.cosmocaller": ["cmc"], "application/vnd.crick.clicker": ["clkx"], "application/vnd.crick.clicker.keyboard": ["clkk"], "application/vnd.crick.clicker.palette": ["clkp"], "application/vnd.crick.clicker.template": ["clkt"], "application/vnd.crick.clicker.wordbank": ["clkw"], "application/vnd.criticaltools.wbs+xml": ["wbs"], "application/vnd.ctc-posml": ["pml"], "application/vnd.cups-ppd": ["ppd"], "application/vnd.curl.car": ["car"], "application/vnd.curl.pcurl": ["pcurl"], "application/vnd.dart": ["dart"], "application/vnd.data-vision.rdz": ["rdz"], "application/vnd.dbf": ["dbf"], "application/vnd.dece.data": ["uvf", "uvvf", "uvd", "uvvd"], "application/vnd.dece.ttml+xml": ["uvt", "uvvt"], "application/vnd.dece.unspecified": ["uvx", "uvvx"], "application/vnd.dece.zip": ["uvz", "uvvz"], "application/vnd.denovo.fcselayout-link": ["fe_launch"], "application/vnd.dna": ["dna"], "application/vnd.dolby.mlp": ["mlp"], "application/vnd.dpgraph": ["dpg"], "application/vnd.dreamfactory": ["dfac"], "application/vnd.ds-keypoint": ["kpxx"], "application/vnd.dvb.ait": ["ait"], "application/vnd.dvb.service": ["svc"], "application/vnd.dynageo": ["geo"], "application/vnd.ecowin.chart": ["mag"], "application/vnd.enliven": ["nml"], "application/vnd.epson.esf": ["esf"], "application/vnd.epson.msf": ["msf"], "application/vnd.epson.quickanime": ["qam"], "application/vnd.epson.salt": ["slt"], "application/vnd.epson.ssf": ["ssf"], "application/vnd.eszigno3+xml": ["es3", "et3"], "application/vnd.ezpix-album": ["ez2"], "application/vnd.ezpix-package": ["ez3"], "application/vnd.fdf": ["fdf"], "application/vnd.fdsn.mseed": ["mseed"], "application/vnd.fdsn.seed": ["seed", "dataless"], "application/vnd.flographit": ["gph"], "application/vnd.fluxtime.clip": ["ftc"], "application/vnd.framemaker": ["fm", "frame", "maker", "book"], "application/vnd.frogans.fnc": ["fnc"], "application/vnd.frogans.ltf": ["ltf"], "application/vnd.fsc.weblaunch": ["fsc"], "application/vnd.fujitsu.oasys": ["oas"], "application/vnd.fujitsu.oasys2": ["oa2"], "application/vnd.fujitsu.oasys3": ["oa3"], "application/vnd.fujitsu.oasysgp": ["fg5"], "application/vnd.fujitsu.oasysprs": ["bh2"], "application/vnd.fujixerox.ddd": ["ddd"], "application/vnd.fujixerox.docuworks": ["xdw"], "application/vnd.fujixerox.docuworks.binder": ["xbd"], "application/vnd.fuzzysheet": ["fzs"], "application/vnd.genomatix.tuxedo": ["txd"], "application/vnd.geogebra.file": ["ggb"], "application/vnd.geogebra.tool": ["ggt"], "application/vnd.geometry-explorer": ["gex", "gre"], "application/vnd.geonext": ["gxt"], "application/vnd.geoplan": ["g2w"], "application/vnd.geospace": ["g3w"], "application/vnd.gmx": ["gmx"], "application/vnd.google-apps.document": ["gdoc"], "application/vnd.google-apps.presentation": ["gslides"], "application/vnd.google-apps.spreadsheet": ["gsheet"], "application/vnd.google-earth.kml+xml": ["kml"], "application/vnd.google-earth.kmz": ["kmz"], "application/vnd.grafeq": ["gqf", "gqs"], "application/vnd.groove-account": ["gac"], "application/vnd.groove-help": ["ghf"], "application/vnd.groove-identity-message": ["gim"], "application/vnd.groove-injector": ["grv"], "application/vnd.groove-tool-message": ["gtm"], "application/vnd.groove-tool-template": ["tpl"], "application/vnd.groove-vcard": ["vcg"], "application/vnd.hal+xml": ["hal"], "application/vnd.handheld-entertainment+xml": ["zmm"], "application/vnd.hbci": ["hbci"], "application/vnd.hhe.lesson-player": ["les"], "application/vnd.hp-hpgl": ["hpgl"], "application/vnd.hp-hpid": ["hpid"], "application/vnd.hp-hps": ["hps"], "application/vnd.hp-jlyt": ["jlt"], "application/vnd.hp-pcl": ["pcl"], "application/vnd.hp-pclxl": ["pclxl"], "application/vnd.hydrostatix.sof-data": ["sfd-hdstx"], "application/vnd.ibm.minipay": ["mpy"], "application/vnd.ibm.modcap": ["afp", "listafp", "list3820"], "application/vnd.ibm.rights-management": ["irm"], "application/vnd.ibm.secure-container": ["sc"], "application/vnd.iccprofile": ["icc", "icm"], "application/vnd.igloader": ["igl"], "application/vnd.immervision-ivp": ["ivp"], "application/vnd.immervision-ivu": ["ivu"], "application/vnd.insors.igm": ["igm"], "application/vnd.intercon.formnet": ["xpw", "xpx"], "application/vnd.intergeo": ["i2g"], "application/vnd.intu.qbo": ["qbo"], "application/vnd.intu.qfx": ["qfx"], "application/vnd.ipunplugged.rcprofile": ["rcprofile"], "application/vnd.irepository.package+xml": ["irp"], "application/vnd.is-xpr": ["xpr"], "application/vnd.isac.fcs": ["fcs"], "application/vnd.jam": ["jam"], "application/vnd.jcp.javame.midlet-rms": ["rms"], "application/vnd.jisp": ["jisp"], "application/vnd.joost.joda-archive": ["joda"], "application/vnd.kahootz": ["ktz", "ktr"], "application/vnd.kde.karbon": ["karbon"], "application/vnd.kde.kchart": ["chrt"], "application/vnd.kde.kformula": ["kfo"], "application/vnd.kde.kivio": ["flw"], "application/vnd.kde.kontour": ["kon"], "application/vnd.kde.kpresenter": ["kpr", "kpt"], "application/vnd.kde.kspread": ["ksp"], "application/vnd.kde.kword": ["kwd", "kwt"], "application/vnd.kenameaapp": ["htke"], "application/vnd.kidspiration": ["kia"], "application/vnd.kinar": ["kne", "knp"], "application/vnd.koan": ["skp", "skd", "skt", "skm"], "application/vnd.kodak-descriptor": ["sse"], "application/vnd.las.las+xml": ["lasxml"], "application/vnd.llamagraphics.life-balance.desktop": ["lbd"], "application/vnd.llamagraphics.life-balance.exchange+xml": ["lbe"], "application/vnd.lotus-1-2-3": ["123"], "application/vnd.lotus-approach": ["apr"], "application/vnd.lotus-freelance": ["pre"], "application/vnd.lotus-notes": ["nsf"], "application/vnd.lotus-organizer": ["org"], "application/vnd.lotus-screencam": ["scm"], "application/vnd.lotus-wordpro": ["lwp"], "application/vnd.macports.portpkg": ["portpkg"], "application/vnd.mapbox-vector-tile": ["mvt"], "application/vnd.mcd": ["mcd"], "application/vnd.medcalcdata": ["mc1"], "application/vnd.mediastation.cdkey": ["cdkey"], "application/vnd.mfer": ["mwf"], "application/vnd.mfmp": ["mfm"], "application/vnd.micrografx.flo": ["flo"], "application/vnd.micrografx.igx": ["igx"], "application/vnd.mif": ["mif"], "application/vnd.mobius.daf": ["daf"], "application/vnd.mobius.dis": ["dis"], "application/vnd.mobius.mbk": ["mbk"], "application/vnd.mobius.mqy": ["mqy"], "application/vnd.mobius.msl": ["msl"], "application/vnd.mobius.plc": ["plc"], "application/vnd.mobius.txf": ["txf"], "application/vnd.mophun.application": ["mpn"], "application/vnd.mophun.certificate": ["mpc"], "application/vnd.mozilla.xul+xml": ["xul"], "application/vnd.ms-artgalry": ["cil"], "application/vnd.ms-cab-compressed": ["cab"], "application/vnd.ms-excel": ["xls", "xlm", "xla", "xlc", "xlt", "xlw"], "application/vnd.ms-excel.addin.macroenabled.12": ["xlam"], "application/vnd.ms-excel.sheet.binary.macroenabled.12": ["xlsb"], "application/vnd.ms-excel.sheet.macroenabled.12": ["xlsm"], "application/vnd.ms-excel.template.macroenabled.12": ["xltm"], "application/vnd.ms-fontobject": ["eot"], "application/vnd.ms-htmlhelp": ["chm"], "application/vnd.ms-ims": ["ims"], "application/vnd.ms-lrm": ["lrm"], "application/vnd.ms-officetheme": ["thmx"], "application/vnd.ms-outlook": ["msg"], "application/vnd.ms-pki.seccat": ["cat"], "application/vnd.ms-pki.stl": ["*stl"], "application/vnd.ms-powerpoint": ["ppt", "pps", "pot"], "application/vnd.ms-powerpoint.addin.macroenabled.12": ["ppam"], "application/vnd.ms-powerpoint.presentation.macroenabled.12": ["pptm"], "application/vnd.ms-powerpoint.slide.macroenabled.12": ["sldm"], "application/vnd.ms-powerpoint.slideshow.macroenabled.12": ["ppsm"], "application/vnd.ms-powerpoint.template.macroenabled.12": ["potm"], "application/vnd.ms-project": ["mpp", "mpt"], "application/vnd.ms-word.document.macroenabled.12": ["docm"], "application/vnd.ms-word.template.macroenabled.12": ["dotm"], "application/vnd.ms-works": ["wps", "wks", "wcm", "wdb"], "application/vnd.ms-wpl": ["wpl"], "application/vnd.ms-xpsdocument": ["xps"], "application/vnd.mseq": ["mseq"], "application/vnd.musician": ["mus"], "application/vnd.muvee.style": ["msty"], "application/vnd.mynfc": ["taglet"], "application/vnd.neurolanguage.nlu": ["nlu"], "application/vnd.nitf": ["ntf", "nitf"], "application/vnd.noblenet-directory": ["nnd"], "application/vnd.noblenet-sealer": ["nns"], "application/vnd.noblenet-web": ["nnw"], "application/vnd.nokia.n-gage.ac+xml": ["*ac"], "application/vnd.nokia.n-gage.data": ["ngdat"], "application/vnd.nokia.n-gage.symbian.install": ["n-gage"], "application/vnd.nokia.radio-preset": ["rpst"], "application/vnd.nokia.radio-presets": ["rpss"], "application/vnd.novadigm.edm": ["edm"], "application/vnd.novadigm.edx": ["edx"], "application/vnd.novadigm.ext": ["ext"], "application/vnd.oasis.opendocument.chart": ["odc"], "application/vnd.oasis.opendocument.chart-template": ["otc"], "application/vnd.oasis.opendocument.database": ["odb"], "application/vnd.oasis.opendocument.formula": ["odf"], "application/vnd.oasis.opendocument.formula-template": ["odft"], "application/vnd.oasis.opendocument.graphics": ["odg"], "application/vnd.oasis.opendocument.graphics-template": ["otg"], "application/vnd.oasis.opendocument.image": ["odi"], "application/vnd.oasis.opendocument.image-template": ["oti"], "application/vnd.oasis.opendocument.presentation": ["odp"], "application/vnd.oasis.opendocument.presentation-template": ["otp"], "application/vnd.oasis.opendocument.spreadsheet": ["ods"], "application/vnd.oasis.opendocument.spreadsheet-template": ["ots"], "application/vnd.oasis.opendocument.text": ["odt"], "application/vnd.oasis.opendocument.text-master": ["odm"], "application/vnd.oasis.opendocument.text-template": ["ott"], "application/vnd.oasis.opendocument.text-web": ["oth"], "application/vnd.olpc-sugar": ["xo"], "application/vnd.oma.dd2+xml": ["dd2"], "application/vnd.openblox.game+xml": ["obgx"], "application/vnd.openofficeorg.extension": ["oxt"], "application/vnd.openstreetmap.data+xml": ["osm"], "application/vnd.openxmlformats-officedocument.presentationml.presentation": ["pptx"], "application/vnd.openxmlformats-officedocument.presentationml.slide": ["sldx"], "application/vnd.openxmlformats-officedocument.presentationml.slideshow": ["ppsx"], "application/vnd.openxmlformats-officedocument.presentationml.template": ["potx"], "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet": ["xlsx"], "application/vnd.openxmlformats-officedocument.spreadsheetml.template": ["xltx"], "application/vnd.openxmlformats-officedocument.wordprocessingml.document": ["docx"], "application/vnd.openxmlformats-officedocument.wordprocessingml.template": ["dotx"], "application/vnd.osgeo.mapguide.package": ["mgp"], "application/vnd.osgi.dp": ["dp"], "application/vnd.osgi.subsystem": ["esa"], "application/vnd.palm": ["pdb", "pqa", "oprc"], "application/vnd.pawaafile": ["paw"], "application/vnd.pg.format": ["str"], "application/vnd.pg.osasli": ["ei6"], "application/vnd.picsel": ["efif"], "application/vnd.pmi.widget": ["wg"], "application/vnd.pocketlearn": ["plf"], "application/vnd.powerbuilder6": ["pbd"], "application/vnd.previewsystems.box": ["box"], "application/vnd.proteus.magazine": ["mgz"], "application/vnd.publishare-delta-tree": ["qps"], "application/vnd.pvi.ptid1": ["ptid"], "application/vnd.quark.quarkxpress": ["qxd", "qxt", "qwd", "qwt", "qxl", "qxb"], "application/vnd.rar": ["rar"], "application/vnd.realvnc.bed": ["bed"], "application/vnd.recordare.musicxml": ["mxl"], "application/vnd.recordare.musicxml+xml": ["musicxml"], "application/vnd.rig.cryptonote": ["cryptonote"], "application/vnd.rim.cod": ["cod"], "application/vnd.rn-realmedia": ["rm"], "application/vnd.rn-realmedia-vbr": ["rmvb"], "application/vnd.route66.link66+xml": ["link66"], "application/vnd.sailingtracker.track": ["st"], "application/vnd.seemail": ["see"], "application/vnd.sema": ["sema"], "application/vnd.semd": ["semd"], "application/vnd.semf": ["semf"], "application/vnd.shana.informed.formdata": ["ifm"], "application/vnd.shana.informed.formtemplate": ["itp"], "application/vnd.shana.informed.interchange": ["iif"], "application/vnd.shana.informed.package": ["ipk"], "application/vnd.simtech-mindmapper": ["twd", "twds"], "application/vnd.smaf": ["mmf"], "application/vnd.smart.teacher": ["teacher"], "application/vnd.software602.filler.form+xml": ["fo"], "application/vnd.solent.sdkm+xml": ["sdkm", "sdkd"], "application/vnd.spotfire.dxp": ["dxp"], "application/vnd.spotfire.sfs": ["sfs"], "application/vnd.stardivision.calc": ["sdc"], "application/vnd.stardivision.draw": ["sda"], "application/vnd.stardivision.impress": ["sdd"], "application/vnd.stardivision.math": ["smf"], "application/vnd.stardivision.writer": ["sdw", "vor"], "application/vnd.stardivision.writer-global": ["sgl"], "application/vnd.stepmania.package": ["smzip"], "application/vnd.stepmania.stepchart": ["sm"], "application/vnd.sun.wadl+xml": ["wadl"], "application/vnd.sun.xml.calc": ["sxc"], "application/vnd.sun.xml.calc.template": ["stc"], "application/vnd.sun.xml.draw": ["sxd"], "application/vnd.sun.xml.draw.template": ["std"], "application/vnd.sun.xml.impress": ["sxi"], "application/vnd.sun.xml.impress.template": ["sti"], "application/vnd.sun.xml.math": ["sxm"], "application/vnd.sun.xml.writer": ["sxw"], "application/vnd.sun.xml.writer.global": ["sxg"], "application/vnd.sun.xml.writer.template": ["stw"], "application/vnd.sus-calendar": ["sus", "susp"], "application/vnd.svd": ["svd"], "application/vnd.symbian.install": ["sis", "sisx"], "application/vnd.syncml+xml": ["xsm"], "application/vnd.syncml.dm+wbxml": ["bdm"], "application/vnd.syncml.dm+xml": ["xdm"], "application/vnd.syncml.dmddf+xml": ["ddf"], "application/vnd.tao.intent-module-archive": ["tao"], "application/vnd.tcpdump.pcap": ["pcap", "cap", "dmp"], "application/vnd.tmobile-livetv": ["tmo"], "application/vnd.trid.tpt": ["tpt"], "application/vnd.triscape.mxs": ["mxs"], "application/vnd.trueapp": ["tra"], "application/vnd.ufdl": ["ufd", "ufdl"], "application/vnd.uiq.theme": ["utz"], "application/vnd.umajin": ["umj"], "application/vnd.unity": ["unityweb"], "application/vnd.uoml+xml": ["uoml"], "application/vnd.vcx": ["vcx"], "application/vnd.visio": ["vsd", "vst", "vss", "vsw"], "application/vnd.visionary": ["vis"], "application/vnd.vsf": ["vsf"], "application/vnd.wap.wbxml": ["wbxml"], "application/vnd.wap.wmlc": ["wmlc"], "application/vnd.wap.wmlscriptc": ["wmlsc"], "application/vnd.webturbo": ["wtb"], "application/vnd.wolfram.player": ["nbp"], "application/vnd.wordperfect": ["wpd"], "application/vnd.wqd": ["wqd"], "application/vnd.wt.stf": ["stf"], "application/vnd.xara": ["xar"], "application/vnd.xfdl": ["xfdl"], "application/vnd.yamaha.hv-dic": ["hvd"], "application/vnd.yamaha.hv-script": ["hvs"], "application/vnd.yamaha.hv-voice": ["hvp"], "application/vnd.yamaha.openscoreformat": ["osf"], "application/vnd.yamaha.openscoreformat.osfpvg+xml": ["osfpvg"], "application/vnd.yamaha.smaf-audio": ["saf"], "application/vnd.yamaha.smaf-phrase": ["spf"], "application/vnd.yellowriver-custom-menu": ["cmp"], "application/vnd.zul": ["zir", "zirz"], "application/vnd.zzazz.deck+xml": ["zaz"], "application/x-7z-compressed": ["7z"], "application/x-abiword": ["abw"], "application/x-ace-compressed": ["ace"], "application/x-apple-diskimage": ["*dmg"], "application/x-arj": ["arj"], "application/x-authorware-bin": ["aab", "x32", "u32", "vox"], "application/x-authorware-map": ["aam"], "application/x-authorware-seg": ["aas"], "application/x-bcpio": ["bcpio"], "application/x-bdoc": ["*bdoc"], "application/x-bittorrent": ["torrent"], "application/x-blorb": ["blb", "blorb"], "application/x-bzip": ["bz"], "application/x-bzip2": ["bz2", "boz"], "application/x-cbr": ["cbr", "cba", "cbt", "cbz", "cb7"], "application/x-cdlink": ["vcd"], "application/x-cfs-compressed": ["cfs"], "application/x-chat": ["chat"], "application/x-chess-pgn": ["pgn"], "application/x-chrome-extension": ["crx"], "application/x-cocoa": ["cco"], "application/x-conference": ["nsc"], "application/x-cpio": ["cpio"], "application/x-csh": ["csh"], "application/x-debian-package": ["*deb", "udeb"], "application/x-dgc-compressed": ["dgc"], "application/x-director": ["dir", "dcr", "dxr", "cst", "cct", "cxt", "w3d", "fgd", "swa"], "application/x-doom": ["wad"], "application/x-dtbncx+xml": ["ncx"], "application/x-dtbook+xml": ["dtb"], "application/x-dtbresource+xml": ["res"], "application/x-dvi": ["dvi"], "application/x-envoy": ["evy"], "application/x-eva": ["eva"], "application/x-font-bdf": ["bdf"], "application/x-font-ghostscript": ["gsf"], "application/x-font-linux-psf": ["psf"], "application/x-font-pcf": ["pcf"], "application/x-font-snf": ["snf"], "application/x-font-type1": ["pfa", "pfb", "pfm", "afm"], "application/x-freearc": ["arc"], "application/x-futuresplash": ["spl"], "application/x-gca-compressed": ["gca"], "application/x-glulx": ["ulx"], "application/x-gnumeric": ["gnumeric"], "application/x-gramps-xml": ["gramps"], "application/x-gtar": ["gtar"], "application/x-hdf": ["hdf"], "application/x-httpd-php": ["php"], "application/x-install-instructions": ["install"], "application/x-iso9660-image": ["*iso"], "application/x-iwork-keynote-sffkey": ["*key"], "application/x-iwork-numbers-sffnumbers": ["*numbers"], "application/x-iwork-pages-sffpages": ["*pages"], "application/x-java-archive-diff": ["jardiff"], "application/x-java-jnlp-file": ["jnlp"], "application/x-keepass2": ["kdbx"], "application/x-latex": ["latex"], "application/x-lua-bytecode": ["luac"], "application/x-lzh-compressed": ["lzh", "lha"], "application/x-makeself": ["run"], "application/x-mie": ["mie"], "application/x-mobipocket-ebook": ["prc", "mobi"], "application/x-ms-application": ["application"], "application/x-ms-shortcut": ["lnk"], "application/x-ms-wmd": ["wmd"], "application/x-ms-wmz": ["wmz"], "application/x-ms-xbap": ["xbap"], "application/x-msaccess": ["mdb"], "application/x-msbinder": ["obd"], "application/x-mscardfile": ["crd"], "application/x-msclip": ["clp"], "application/x-msdos-program": ["*exe"], "application/x-msdownload": ["*exe", "*dll", "com", "bat", "*msi"], "application/x-msmediaview": ["mvb", "m13", "m14"], "application/x-msmetafile": ["*wmf", "*wmz", "*emf", "emz"], "application/x-msmoney": ["mny"], "application/x-mspublisher": ["pub"], "application/x-msschedule": ["scd"], "application/x-msterminal": ["trm"], "application/x-mswrite": ["wri"], "application/x-netcdf": ["nc", "cdf"], "application/x-ns-proxy-autoconfig": ["pac"], "application/x-nzb": ["nzb"], "application/x-perl": ["pl", "pm"], "application/x-pilot": ["*prc", "*pdb"], "application/x-pkcs12": ["p12", "pfx"], "application/x-pkcs7-certificates": ["p7b", "spc"], "application/x-pkcs7-certreqresp": ["p7r"], "application/x-rar-compressed": ["*rar"], "application/x-redhat-package-manager": ["rpm"], "application/x-research-info-systems": ["ris"], "application/x-sea": ["sea"], "application/x-sh": ["sh"], "application/x-shar": ["shar"], "application/x-shockwave-flash": ["swf"], "application/x-silverlight-app": ["xap"], "application/x-sql": ["sql"], "application/x-stuffit": ["sit"], "application/x-stuffitx": ["sitx"], "application/x-subrip": ["srt"], "application/x-sv4cpio": ["sv4cpio"], "application/x-sv4crc": ["sv4crc"], "application/x-t3vm-image": ["t3"], "application/x-tads": ["gam"], "application/x-tar": ["tar"], "application/x-tcl": ["tcl", "tk"], "application/x-tex": ["tex"], "application/x-tex-tfm": ["tfm"], "application/x-texinfo": ["texinfo", "texi"], "application/x-tgif": ["*obj"], "application/x-ustar": ["ustar"], "application/x-virtualbox-hdd": ["hdd"], "application/x-virtualbox-ova": ["ova"], "application/x-virtualbox-ovf": ["ovf"], "application/x-virtualbox-vbox": ["vbox"], "application/x-virtualbox-vbox-extpack": ["vbox-extpack"], "application/x-virtualbox-vdi": ["vdi"], "application/x-virtualbox-vhd": ["vhd"], "application/x-virtualbox-vmdk": ["vmdk"], "application/x-wais-source": ["src"], "application/x-web-app-manifest+json": ["webapp"], "application/x-x509-ca-cert": ["der", "crt", "pem"], "application/x-xfig": ["fig"], "application/x-xliff+xml": ["*xlf"], "application/x-xpinstall": ["xpi"], "application/x-xz": ["xz"], "application/x-zmachine": ["z1", "z2", "z3", "z4", "z5", "z6", "z7", "z8"], "audio/vnd.dece.audio": ["uva", "uvva"], "audio/vnd.digital-winds": ["eol"], "audio/vnd.dra": ["dra"], "audio/vnd.dts": ["dts"], "audio/vnd.dts.hd": ["dtshd"], "audio/vnd.lucent.voice": ["lvp"], "audio/vnd.ms-playready.media.pya": ["pya"], "audio/vnd.nuera.ecelp4800": ["ecelp4800"], "audio/vnd.nuera.ecelp7470": ["ecelp7470"], "audio/vnd.nuera.ecelp9600": ["ecelp9600"], "audio/vnd.rip": ["rip"], "audio/x-aac": ["aac"], "audio/x-aiff": ["aif", "aiff", "aifc"], "audio/x-caf": ["caf"], "audio/x-flac": ["flac"], "audio/x-m4a": ["*m4a"], "audio/x-matroska": ["mka"], "audio/x-mpegurl": ["m3u"], "audio/x-ms-wax": ["wax"], "audio/x-ms-wma": ["wma"], "audio/x-pn-realaudio": ["ram", "ra"], "audio/x-pn-realaudio-plugin": ["rmp"], "audio/x-realaudio": ["*ra"], "audio/x-wav": ["*wav"], "chemical/x-cdx": ["cdx"], "chemical/x-cif": ["cif"], "chemical/x-cmdf": ["cmdf"], "chemical/x-cml": ["cml"], "chemical/x-csml": ["csml"], "chemical/x-xyz": ["xyz"], "image/prs.btif": ["btif"], "image/prs.pti": ["pti"], "image/vnd.adobe.photoshop": ["psd"], "image/vnd.airzip.accelerator.azv": ["azv"], "image/vnd.dece.graphic": ["uvi", "uvvi", "uvg", "uvvg"], "image/vnd.djvu": ["djvu", "djv"], "image/vnd.dvb.subtitle": ["*sub"], "image/vnd.dwg": ["dwg"], "image/vnd.dxf": ["dxf"], "image/vnd.fastbidsheet": ["fbs"], "image/vnd.fpx": ["fpx"], "image/vnd.fst": ["fst"], "image/vnd.fujixerox.edmics-mmr": ["mmr"], "image/vnd.fujixerox.edmics-rlc": ["rlc"], "image/vnd.microsoft.icon": ["ico"], "image/vnd.ms-dds": ["dds"], "image/vnd.ms-modi": ["mdi"], "image/vnd.ms-photo": ["wdp"], "image/vnd.net-fpx": ["npx"], "image/vnd.pco.b16": ["b16"], "image/vnd.tencent.tap": ["tap"], "image/vnd.valve.source.texture": ["vtf"], "image/vnd.wap.wbmp": ["wbmp"], "image/vnd.xiff": ["xif"], "image/vnd.zbrush.pcx": ["pcx"], "image/x-3ds": ["3ds"], "image/x-cmu-raster": ["ras"], "image/x-cmx": ["cmx"], "image/x-freehand": ["fh", "fhc", "fh4", "fh5", "fh7"], "image/x-icon": ["*ico"], "image/x-jng": ["jng"], "image/x-mrsid-image": ["sid"], "image/x-ms-bmp": ["*bmp"], "image/x-pcx": ["*pcx"], "image/x-pict": ["pic", "pct"], "image/x-portable-anymap": ["pnm"], "image/x-portable-bitmap": ["pbm"], "image/x-portable-graymap": ["pgm"], "image/x-portable-pixmap": ["ppm"], "image/x-rgb": ["rgb"], "image/x-tga": ["tga"], "image/x-xbitmap": ["xbm"], "image/x-xpixmap": ["xpm"], "image/x-xwindowdump": ["xwd"], "message/vnd.wfa.wsc": ["wsc"], "model/vnd.collada+xml": ["dae"], "model/vnd.dwf": ["dwf"], "model/vnd.gdl": ["gdl"], "model/vnd.gtw": ["gtw"], "model/vnd.mts": ["mts"], "model/vnd.opengex": ["ogex"], "model/vnd.parasolid.transmit.binary": ["x_b"], "model/vnd.parasolid.transmit.text": ["x_t"], "model/vnd.sap.vds": ["vds"], "model/vnd.usdz+zip": ["usdz"], "model/vnd.valve.source.compiled-map": ["bsp"], "model/vnd.vtu": ["vtu"], "text/prs.lines.tag": ["dsc"], "text/vnd.curl": ["curl"], "text/vnd.curl.dcurl": ["dcurl"], "text/vnd.curl.mcurl": ["mcurl"], "text/vnd.curl.scurl": ["scurl"], "text/vnd.dvb.subtitle": ["sub"], "text/vnd.fly": ["fly"], "text/vnd.fmi.flexstor": ["flx"], "text/vnd.graphviz": ["gv"], "text/vnd.in3d.3dml": ["3dml"], "text/vnd.in3d.spot": ["spot"], "text/vnd.sun.j2me.app-descriptor": ["jad"], "text/vnd.wap.wml": ["wml"], "text/vnd.wap.wmlscript": ["wmls"], "text/x-asm": ["s", "asm"], "text/x-c": ["c", "cc", "cxx", "cpp", "h", "hh", "dic"], "text/x-component": ["htc"], "text/x-fortran": ["f", "for", "f77", "f90"], "text/x-handlebars-template": ["hbs"], "text/x-java-source": ["java"], "text/x-lua": ["lua"], "text/x-markdown": ["mkd"], "text/x-nfo": ["nfo"], "text/x-opml": ["opml"], "text/x-org": ["*org"], "text/x-pascal": ["p", "pas"], "text/x-processing": ["pde"], "text/x-sass": ["sass"], "text/x-scss": ["scss"], "text/x-setext": ["etx"], "text/x-sfv": ["sfv"], "text/x-suse-ymp": ["ymp"], "text/x-uuencode": ["uu"], "text/x-vcalendar": ["vcs"], "text/x-vcard": ["vcf"], "video/vnd.dece.hd": ["uvh", "uvvh"], "video/vnd.dece.mobile": ["uvm", "uvvm"], "video/vnd.dece.pd": ["uvp", "uvvp"], "video/vnd.dece.sd": ["uvs", "uvvs"], "video/vnd.dece.video": ["uvv", "uvvv"], "video/vnd.dvb.file": ["dvb"], "video/vnd.fvt": ["fvt"], "video/vnd.mpegurl": ["mxu", "m4u"], "video/vnd.ms-playready.media.pyv": ["pyv"], "video/vnd.uvvu.mp4": ["uvu", "uvvu"], "video/vnd.vivo": ["viv"], "video/x-f4v": ["f4v"], "video/x-fli": ["fli"], "video/x-flv": ["flv"], "video/x-m4v": ["m4v"], "video/x-matroska": ["mkv", "mk3d", "mks"], "video/x-mng": ["mng"], "video/x-ms-asf": ["asf", "asx"], "video/x-ms-vob": ["vob"], "video/x-ms-wm": ["wm"], "video/x-ms-wmv": ["wmv"], "video/x-ms-wmx": ["wmx"], "video/x-ms-wvx": ["wvx"], "video/x-msvideo": ["avi"], "video/x-sgi-movie": ["movie"], "video/x-smv": ["smv"], "x-conference/x-cooltalk": ["ice"] };
  }
});

// node_modules/mime/index.js
var require_mime = __commonJS({
  "node_modules/mime/index.js"(exports2, module2) {
    "use strict";
    var Mime = require_Mime();
    module2.exports = new Mime(require_standard(), require_other());
  }
});

// node_modules/escape-html/index.js
var require_escape_html = __commonJS({
  "node_modules/escape-html/index.js"(exports2, module2) {
    "use strict";
    var matchHtmlRegExp = /["'&<>]/;
    module2.exports = escapeHtml;
    function escapeHtml(string) {
      var str = "" + string;
      var match = matchHtmlRegExp.exec(str);
      if (!match) {
        return str;
      }
      var escape2;
      var html = "";
      var index = 0;
      var lastIndex = 0;
      for (index = match.index; index < str.length; index++) {
        switch (str.charCodeAt(index)) {
          case 34:
            escape2 = "&quot;";
            break;
          case 38:
            escape2 = "&amp;";
            break;
          case 39:
            escape2 = "&#39;";
            break;
          case 60:
            escape2 = "&lt;";
            break;
          case 62:
            escape2 = "&gt;";
            break;
          default:
            continue;
        }
        if (lastIndex !== index) {
          html += str.substring(lastIndex, index);
        }
        lastIndex = index + 1;
        html += escape2;
      }
      return lastIndex !== index ? html + str.substring(lastIndex, index) : html;
    }
  }
});

// node_modules/@lukeed/ms/dist/index.js
var require_dist5 = __commonJS({
  "node_modules/@lukeed/ms/dist/index.js"(exports2) {
    var RGX = /^(-?(?:\d+)?\.?\d+) *(m(?:illiseconds?|s(?:ecs?)?))?(s(?:ec(?:onds?|s)?)?)?(m(?:in(?:utes?|s)?)?)?(h(?:ours?|rs?)?)?(d(?:ays?)?)?(w(?:eeks?|ks?)?)?(y(?:ears?|rs?)?)?$/;
    var SEC = 1e3;
    var MIN = SEC * 60;
    var HOUR = MIN * 60;
    var DAY = HOUR * 24;
    var YEAR = DAY * 365.25;
    function parse(val) {
      var num, arr = val.toLowerCase().match(RGX);
      if (arr != null && (num = parseFloat(arr[1]))) {
        if (arr[3] != null) return num * SEC;
        if (arr[4] != null) return num * MIN;
        if (arr[5] != null) return num * HOUR;
        if (arr[6] != null) return num * DAY;
        if (arr[7] != null) return num * DAY * 7;
        if (arr[8] != null) return num * YEAR;
        return num;
      }
    }
    function fmt(val, pfx, str, long) {
      var num = (val | 0) === val ? val : ~~(val + 0.5);
      return pfx + num + (long ? " " + str + (num != 1 ? "s" : "") : str[0]);
    }
    function format(num, long) {
      var pfx = num < 0 ? "-" : "", abs = num < 0 ? -num : num;
      if (abs < SEC) return num + (long ? " ms" : "ms");
      if (abs < MIN) return fmt(abs / SEC, pfx, "second", long);
      if (abs < HOUR) return fmt(abs / MIN, pfx, "minute", long);
      if (abs < DAY) return fmt(abs / HOUR, pfx, "hour", long);
      if (abs < YEAR) return fmt(abs / DAY, pfx, "day", long);
      return fmt(abs / YEAR, pfx, "year", long);
    }
    exports2.format = format;
    exports2.parse = parse;
  }
});

// node_modules/@fastify/send/lib/collapseLeadingSlashes.js
var require_collapseLeadingSlashes = __commonJS({
  "node_modules/@fastify/send/lib/collapseLeadingSlashes.js"(exports2, module2) {
    "use strict";
    function collapseLeadingSlashes(str) {
      if (str[0] !== "/" || str[1] !== "/") {
        return str;
      }
      for (let i = 2, il2 = str.length; i < il2; ++i) {
        if (str[i] !== "/") {
          return str.slice(i - 1);
        }
      }
    }
    module2.exports.collapseLeadingSlashes = collapseLeadingSlashes;
  }
});

// node_modules/@fastify/send/lib/containsDotFile.js
var require_containsDotFile = __commonJS({
  "node_modules/@fastify/send/lib/containsDotFile.js"(exports2, module2) {
    "use strict";
    function containsDotFile(parts) {
      for (let i = 0, il2 = parts.length; i < il2; ++i) {
        if (parts[i].length !== 1 && parts[i][0] === ".") {
          return true;
        }
      }
      return false;
    }
    module2.exports.containsDotFile = containsDotFile;
  }
});

// node_modules/@fastify/send/lib/contentRange.js
var require_contentRange = __commonJS({
  "node_modules/@fastify/send/lib/contentRange.js"(exports2) {
    "use strict";
    function contentRange(type, size, range) {
      return type + " " + (range ? range.start + "-" + range.end : "*") + "/" + size;
    }
    exports2.contentRange = contentRange;
  }
});

// node_modules/@fastify/send/lib/createHtmlDocument.js
var require_createHtmlDocument = __commonJS({
  "node_modules/@fastify/send/lib/createHtmlDocument.js"(exports2) {
    "use strict";
    function createHtmlDocument(title, body) {
      const html = '<!DOCTYPE html>\n<html lang="en">\n<head>\n<meta charset="utf-8">\n<title>' + title + "</title>\n</head>\n<body>\n<pre>" + body + "</pre>\n</body>\n</html>\n";
      return [html, Buffer.byteLength(html)];
    }
    exports2.createHtmlDocument = createHtmlDocument;
  }
});

// node_modules/@fastify/send/lib/normalizeList.js
var require_normalizeList = __commonJS({
  "node_modules/@fastify/send/lib/normalizeList.js"(exports2, module2) {
    "use strict";
    function normalizeList(val, name) {
      if (typeof val === "string") {
        return [val];
      } else if (val === false) {
        return [];
      } else if (Array.isArray(val)) {
        for (let i = 0, il2 = val.length; i < il2; ++i) {
          if (typeof val[i] !== "string") {
            throw new TypeError(name + " must be array of strings or false");
          }
        }
        return val;
      } else {
        throw new TypeError(name + " must be array of strings or false");
      }
    }
    module2.exports.normalizeList = normalizeList;
  }
});

// node_modules/@fastify/send/lib/parseBytesRange.js
var require_parseBytesRange = __commonJS({
  "node_modules/@fastify/send/lib/parseBytesRange.js"(exports2, module2) {
    "use strict";
    function parseBytesRange(size, str) {
      const values = str.slice(str.indexOf("=") + 1);
      const ranges = [];
      const len = values.length;
      let i = 0;
      let il2 = 0;
      let j = 0;
      let start;
      let end;
      let commaIdx = values.indexOf(",");
      let dashIdx = values.indexOf("-");
      let prevIdx = -1;
      while (true) {
        commaIdx === -1 && (commaIdx = len);
        start = parseInt(values.slice(prevIdx + 1, dashIdx), 10);
        end = parseInt(values.slice(dashIdx + 1, commaIdx), 10);
        if (start !== start) {
          start = size - end;
          end = size - 1;
        } else if (end !== end) {
          end = size - 1;
        } else if (end > size - 1) {
          end = size - 1;
        }
        if (
          // eslint-disable-next-line no-self-compare
          start === start && // fast path of isNaN(number)
          // eslint-disable-next-line no-self-compare
          end === end && // fast path of isNaN(number)
          start > -1 && start <= end
        ) {
          ranges.push({
            start,
            end,
            index: j++
          });
        }
        if (commaIdx === len) {
          break;
        }
        prevIdx = commaIdx++;
        dashIdx = values.indexOf("-", commaIdx);
        commaIdx = values.indexOf(",", commaIdx);
      }
      if (j < 2) {
        return ranges;
      }
      ranges.sort(sortByRangeStart);
      il2 = j;
      j = 0;
      i = 1;
      while (i < il2) {
        const range = ranges[i++];
        const current = ranges[j];
        if (range.start > current.end + 1) {
          ranges[++j] = range;
        } else if (range.end > current.end) {
          current.end = range.end;
          current.index > range.index && (current.index = range.index);
        }
      }
      ranges.length = j + 1;
      ranges.sort(sortByRangeIndex);
      return ranges;
    }
    function sortByRangeIndex(a, b) {
      return a.index - b.index;
    }
    function sortByRangeStart(a, b) {
      return a.start - b.start;
    }
    module2.exports.parseBytesRange = parseBytesRange;
  }
});

// node_modules/@fastify/send/lib/parseTokenList.js
var require_parseTokenList = __commonJS({
  "node_modules/@fastify/send/lib/parseTokenList.js"(exports2, module2) {
    "use strict";
    var slice = String.prototype.slice;
    function parseTokenList(str, cb) {
      let end = 0;
      let start = 0;
      let result;
      for (let i = 0, len = str.length; i < len; i++) {
        switch (str.charCodeAt(i)) {
          case 32:
            if (start === end) {
              start = end = i + 1;
            }
            break;
          case 44:
            if (start !== end) {
              result = cb(slice.call(str, start, end));
              if (result !== void 0) {
                return result;
              }
            }
            start = end = i + 1;
            break;
          default:
            end = i + 1;
            break;
        }
      }
      if (start !== end) {
        return cb(slice.call(str, start, end));
      }
    }
    module2.exports.parseTokenList = parseTokenList;
  }
});

// node_modules/depd/index.js
var require_depd = __commonJS({
  "node_modules/depd/index.js"(exports2, module2) {
    var relative = require("path").relative;
    module2.exports = depd;
    var basePath = process.cwd();
    function containsNamespace(str, namespace) {
      var vals = str.split(/[ ,]+/);
      var ns = String(namespace).toLowerCase();
      for (var i = 0; i < vals.length; i++) {
        var val = vals[i];
        if (val && (val === "*" || val.toLowerCase() === ns)) {
          return true;
        }
      }
      return false;
    }
    function convertDataDescriptorToAccessor(obj, prop, message) {
      var descriptor = Object.getOwnPropertyDescriptor(obj, prop);
      var value = descriptor.value;
      descriptor.get = function getter() {
        return value;
      };
      if (descriptor.writable) {
        descriptor.set = function setter(val) {
          return value = val;
        };
      }
      delete descriptor.value;
      delete descriptor.writable;
      Object.defineProperty(obj, prop, descriptor);
      return descriptor;
    }
    function createArgumentsString(arity) {
      var str = "";
      for (var i = 0; i < arity; i++) {
        str += ", arg" + i;
      }
      return str.substr(2);
    }
    function createStackString(stack) {
      var str = this.name + ": " + this.namespace;
      if (this.message) {
        str += " deprecated " + this.message;
      }
      for (var i = 0; i < stack.length; i++) {
        str += "\n    at " + stack[i].toString();
      }
      return str;
    }
    function depd(namespace) {
      if (!namespace) {
        throw new TypeError("argument namespace is required");
      }
      var stack = getStack();
      var site = callSiteLocation(stack[1]);
      var file = site[0];
      function deprecate(message) {
        log2.call(deprecate, message);
      }
      deprecate._file = file;
      deprecate._ignored = isignored(namespace);
      deprecate._namespace = namespace;
      deprecate._traced = istraced(namespace);
      deprecate._warned = /* @__PURE__ */ Object.create(null);
      deprecate.function = wrapfunction;
      deprecate.property = wrapproperty;
      return deprecate;
    }
    function eehaslisteners(emitter, type) {
      var count = typeof emitter.listenerCount !== "function" ? emitter.listeners(type).length : emitter.listenerCount(type);
      return count > 0;
    }
    function isignored(namespace) {
      if (process.noDeprecation) {
        return true;
      }
      var str = process.env.NO_DEPRECATION || "";
      return containsNamespace(str, namespace);
    }
    function istraced(namespace) {
      if (process.traceDeprecation) {
        return true;
      }
      var str = process.env.TRACE_DEPRECATION || "";
      return containsNamespace(str, namespace);
    }
    function log2(message, site) {
      var haslisteners = eehaslisteners(process, "deprecation");
      if (!haslisteners && this._ignored) {
        return;
      }
      var caller;
      var callFile;
      var callSite;
      var depSite;
      var i = 0;
      var seen = false;
      var stack = getStack();
      var file = this._file;
      if (site) {
        depSite = site;
        callSite = callSiteLocation(stack[1]);
        callSite.name = depSite.name;
        file = callSite[0];
      } else {
        i = 2;
        depSite = callSiteLocation(stack[i]);
        callSite = depSite;
      }
      for (; i < stack.length; i++) {
        caller = callSiteLocation(stack[i]);
        callFile = caller[0];
        if (callFile === file) {
          seen = true;
        } else if (callFile === this._file) {
          file = this._file;
        } else if (seen) {
          break;
        }
      }
      var key = caller ? depSite.join(":") + "__" + caller.join(":") : void 0;
      if (key !== void 0 && key in this._warned) {
        return;
      }
      this._warned[key] = true;
      var msg = message;
      if (!msg) {
        msg = callSite === depSite || !callSite.name ? defaultMessage(depSite) : defaultMessage(callSite);
      }
      if (haslisteners) {
        var err = DeprecationError(this._namespace, msg, stack.slice(i));
        process.emit("deprecation", err);
        return;
      }
      var format = process.stderr.isTTY ? formatColor : formatPlain;
      var output = format.call(this, msg, caller, stack.slice(i));
      process.stderr.write(output + "\n", "utf8");
    }
    function callSiteLocation(callSite) {
      var file = callSite.getFileName() || "<anonymous>";
      var line = callSite.getLineNumber();
      var colm = callSite.getColumnNumber();
      if (callSite.isEval()) {
        file = callSite.getEvalOrigin() + ", " + file;
      }
      var site = [file, line, colm];
      site.callSite = callSite;
      site.name = callSite.getFunctionName();
      return site;
    }
    function defaultMessage(site) {
      var callSite = site.callSite;
      var funcName = site.name;
      if (!funcName) {
        funcName = "<anonymous@" + formatLocation(site) + ">";
      }
      var context = callSite.getThis();
      var typeName = context && callSite.getTypeName();
      if (typeName === "Object") {
        typeName = void 0;
      }
      if (typeName === "Function") {
        typeName = context.name || typeName;
      }
      return typeName && callSite.getMethodName() ? typeName + "." + funcName : funcName;
    }
    function formatPlain(msg, caller, stack) {
      var timestamp = (/* @__PURE__ */ new Date()).toUTCString();
      var formatted = timestamp + " " + this._namespace + " deprecated " + msg;
      if (this._traced) {
        for (var i = 0; i < stack.length; i++) {
          formatted += "\n    at " + stack[i].toString();
        }
        return formatted;
      }
      if (caller) {
        formatted += " at " + formatLocation(caller);
      }
      return formatted;
    }
    function formatColor(msg, caller, stack) {
      var formatted = "\x1B[36;1m" + this._namespace + "\x1B[22;39m \x1B[33;1mdeprecated\x1B[22;39m \x1B[0m" + msg + "\x1B[39m";
      if (this._traced) {
        for (var i = 0; i < stack.length; i++) {
          formatted += "\n    \x1B[36mat " + stack[i].toString() + "\x1B[39m";
        }
        return formatted;
      }
      if (caller) {
        formatted += " \x1B[36m" + formatLocation(caller) + "\x1B[39m";
      }
      return formatted;
    }
    function formatLocation(callSite) {
      return relative(basePath, callSite[0]) + ":" + callSite[1] + ":" + callSite[2];
    }
    function getStack() {
      var limit = Error.stackTraceLimit;
      var obj = {};
      var prep = Error.prepareStackTrace;
      Error.prepareStackTrace = prepareObjectStackTrace;
      Error.stackTraceLimit = Math.max(10, limit);
      Error.captureStackTrace(obj);
      var stack = obj.stack.slice(1);
      Error.prepareStackTrace = prep;
      Error.stackTraceLimit = limit;
      return stack;
    }
    function prepareObjectStackTrace(obj, stack) {
      return stack;
    }
    function wrapfunction(fn, message) {
      if (typeof fn !== "function") {
        throw new TypeError("argument fn must be a function");
      }
      var args = createArgumentsString(fn.length);
      var stack = getStack();
      var site = callSiteLocation(stack[1]);
      site.name = fn.name;
      var deprecatedfn = new Function(
        "fn",
        "log",
        "deprecate",
        "message",
        "site",
        '"use strict"\nreturn function (' + args + ") {log.call(deprecate, message, site)\nreturn fn.apply(this, arguments)\n}"
      )(fn, log2, this, message, site);
      return deprecatedfn;
    }
    function wrapproperty(obj, prop, message) {
      if (!obj || typeof obj !== "object" && typeof obj !== "function") {
        throw new TypeError("argument obj must be object");
      }
      var descriptor = Object.getOwnPropertyDescriptor(obj, prop);
      if (!descriptor) {
        throw new TypeError("must call property on owner object");
      }
      if (!descriptor.configurable) {
        throw new TypeError("property must be configurable");
      }
      var deprecate = this;
      var stack = getStack();
      var site = callSiteLocation(stack[1]);
      site.name = prop;
      if ("value" in descriptor) {
        descriptor = convertDataDescriptorToAccessor(obj, prop, message);
      }
      var get = descriptor.get;
      var set = descriptor.set;
      if (typeof get === "function") {
        descriptor.get = function getter() {
          log2.call(deprecate, message, site);
          return get.apply(this, arguments);
        };
      }
      if (typeof set === "function") {
        descriptor.set = function setter() {
          log2.call(deprecate, message, site);
          return set.apply(this, arguments);
        };
      }
      Object.defineProperty(obj, prop, descriptor);
    }
    function DeprecationError(namespace, message, stack) {
      var error = new Error();
      var stackString;
      Object.defineProperty(error, "constructor", {
        value: DeprecationError
      });
      Object.defineProperty(error, "message", {
        configurable: true,
        enumerable: false,
        value: message,
        writable: true
      });
      Object.defineProperty(error, "name", {
        enumerable: false,
        configurable: true,
        value: "DeprecationError",
        writable: true
      });
      Object.defineProperty(error, "namespace", {
        configurable: true,
        enumerable: false,
        value: namespace,
        writable: true
      });
      Object.defineProperty(error, "stack", {
        configurable: true,
        enumerable: false,
        get: function() {
          if (stackString !== void 0) {
            return stackString;
          }
          return stackString = createStackString.call(this, stack);
        },
        set: function setter(val) {
          stackString = val;
        }
      });
      return error;
    }
  }
});

// node_modules/setprototypeof/index.js
var require_setprototypeof = __commonJS({
  "node_modules/setprototypeof/index.js"(exports2, module2) {
    "use strict";
    module2.exports = Object.setPrototypeOf || ({ __proto__: [] } instanceof Array ? setProtoOf : mixinProperties);
    function setProtoOf(obj, proto) {
      obj.__proto__ = proto;
      return obj;
    }
    function mixinProperties(obj, proto) {
      for (var prop in proto) {
        if (!Object.prototype.hasOwnProperty.call(obj, prop)) {
          obj[prop] = proto[prop];
        }
      }
      return obj;
    }
  }
});

// node_modules/statuses/codes.json
var require_codes = __commonJS({
  "node_modules/statuses/codes.json"(exports2, module2) {
    module2.exports = {
      "100": "Continue",
      "101": "Switching Protocols",
      "102": "Processing",
      "103": "Early Hints",
      "200": "OK",
      "201": "Created",
      "202": "Accepted",
      "203": "Non-Authoritative Information",
      "204": "No Content",
      "205": "Reset Content",
      "206": "Partial Content",
      "207": "Multi-Status",
      "208": "Already Reported",
      "226": "IM Used",
      "300": "Multiple Choices",
      "301": "Moved Permanently",
      "302": "Found",
      "303": "See Other",
      "304": "Not Modified",
      "305": "Use Proxy",
      "307": "Temporary Redirect",
      "308": "Permanent Redirect",
      "400": "Bad Request",
      "401": "Unauthorized",
      "402": "Payment Required",
      "403": "Forbidden",
      "404": "Not Found",
      "405": "Method Not Allowed",
      "406": "Not Acceptable",
      "407": "Proxy Authentication Required",
      "408": "Request Timeout",
      "409": "Conflict",
      "410": "Gone",
      "411": "Length Required",
      "412": "Precondition Failed",
      "413": "Payload Too Large",
      "414": "URI Too Long",
      "415": "Unsupported Media Type",
      "416": "Range Not Satisfiable",
      "417": "Expectation Failed",
      "418": "I'm a Teapot",
      "421": "Misdirected Request",
      "422": "Unprocessable Entity",
      "423": "Locked",
      "424": "Failed Dependency",
      "425": "Too Early",
      "426": "Upgrade Required",
      "428": "Precondition Required",
      "429": "Too Many Requests",
      "431": "Request Header Fields Too Large",
      "451": "Unavailable For Legal Reasons",
      "500": "Internal Server Error",
      "501": "Not Implemented",
      "502": "Bad Gateway",
      "503": "Service Unavailable",
      "504": "Gateway Timeout",
      "505": "HTTP Version Not Supported",
      "506": "Variant Also Negotiates",
      "507": "Insufficient Storage",
      "508": "Loop Detected",
      "509": "Bandwidth Limit Exceeded",
      "510": "Not Extended",
      "511": "Network Authentication Required"
    };
  }
});

// node_modules/statuses/index.js
var require_statuses = __commonJS({
  "node_modules/statuses/index.js"(exports2, module2) {
    "use strict";
    var codes = require_codes();
    module2.exports = status;
    status.message = codes;
    status.code = createMessageToStatusCodeMap(codes);
    status.codes = createStatusCodeList(codes);
    status.redirect = {
      300: true,
      301: true,
      302: true,
      303: true,
      305: true,
      307: true,
      308: true
    };
    status.empty = {
      204: true,
      205: true,
      304: true
    };
    status.retry = {
      502: true,
      503: true,
      504: true
    };
    function createMessageToStatusCodeMap(codes2) {
      var map = {};
      Object.keys(codes2).forEach(function forEachCode(code) {
        var message = codes2[code];
        var status2 = Number(code);
        map[message.toLowerCase()] = status2;
      });
      return map;
    }
    function createStatusCodeList(codes2) {
      return Object.keys(codes2).map(function mapCode(code) {
        return Number(code);
      });
    }
    function getStatusCode(message) {
      var msg = message.toLowerCase();
      if (!Object.prototype.hasOwnProperty.call(status.code, msg)) {
        throw new Error('invalid status message: "' + message + '"');
      }
      return status.code[msg];
    }
    function getStatusMessage(code) {
      if (!Object.prototype.hasOwnProperty.call(status.message, code)) {
        throw new Error("invalid status code: " + code);
      }
      return status.message[code];
    }
    function status(code) {
      if (typeof code === "number") {
        return getStatusMessage(code);
      }
      if (typeof code !== "string") {
        throw new TypeError("code must be a number or string");
      }
      var n = parseInt(code, 10);
      if (!isNaN(n)) {
        return getStatusMessage(n);
      }
      return getStatusCode(code);
    }
  }
});

// node_modules/inherits/inherits_browser.js
var require_inherits_browser = __commonJS({
  "node_modules/inherits/inherits_browser.js"(exports2, module2) {
    if (typeof Object.create === "function") {
      module2.exports = function inherits(ctor, superCtor) {
        if (superCtor) {
          ctor.super_ = superCtor;
          ctor.prototype = Object.create(superCtor.prototype, {
            constructor: {
              value: ctor,
              enumerable: false,
              writable: true,
              configurable: true
            }
          });
        }
      };
    } else {
      module2.exports = function inherits(ctor, superCtor) {
        if (superCtor) {
          ctor.super_ = superCtor;
          var TempCtor = function() {
          };
          TempCtor.prototype = superCtor.prototype;
          ctor.prototype = new TempCtor();
          ctor.prototype.constructor = ctor;
        }
      };
    }
  }
});

// node_modules/inherits/inherits.js
var require_inherits = __commonJS({
  "node_modules/inherits/inherits.js"(exports2, module2) {
    try {
      util = require("util");
      if (typeof util.inherits !== "function") throw "";
      module2.exports = util.inherits;
    } catch (e) {
      module2.exports = require_inherits_browser();
    }
    var util;
  }
});

// node_modules/toidentifier/index.js
var require_toidentifier = __commonJS({
  "node_modules/toidentifier/index.js"(exports2, module2) {
    "use strict";
    module2.exports = toIdentifier;
    function toIdentifier(str) {
      return str.split(" ").map(function(token) {
        return token.slice(0, 1).toUpperCase() + token.slice(1);
      }).join("").replace(/[^ _0-9a-z]/gi, "");
    }
  }
});

// node_modules/http-errors/index.js
var require_http_errors = __commonJS({
  "node_modules/http-errors/index.js"(exports2, module2) {
    "use strict";
    var deprecate = require_depd()("http-errors");
    var setPrototypeOf = require_setprototypeof();
    var statuses = require_statuses();
    var inherits = require_inherits();
    var toIdentifier = require_toidentifier();
    module2.exports = createError;
    module2.exports.HttpError = createHttpErrorConstructor();
    module2.exports.isHttpError = createIsHttpErrorFunction(module2.exports.HttpError);
    populateConstructorExports(module2.exports, statuses.codes, module2.exports.HttpError);
    function codeClass(status) {
      return Number(String(status).charAt(0) + "00");
    }
    function createError() {
      var err;
      var msg;
      var status = 500;
      var props = {};
      for (var i = 0; i < arguments.length; i++) {
        var arg = arguments[i];
        var type = typeof arg;
        if (type === "object" && arg instanceof Error) {
          err = arg;
          status = err.status || err.statusCode || status;
        } else if (type === "number" && i === 0) {
          status = arg;
        } else if (type === "string") {
          msg = arg;
        } else if (type === "object") {
          props = arg;
        } else {
          throw new TypeError("argument #" + (i + 1) + " unsupported type " + type);
        }
      }
      if (typeof status === "number" && (status < 400 || status >= 600)) {
        deprecate("non-error status code; use only 4xx or 5xx status codes");
      }
      if (typeof status !== "number" || !statuses.message[status] && (status < 400 || status >= 600)) {
        status = 500;
      }
      var HttpError = createError[status] || createError[codeClass(status)];
      if (!err) {
        err = HttpError ? new HttpError(msg) : new Error(msg || statuses.message[status]);
        Error.captureStackTrace(err, createError);
      }
      if (!HttpError || !(err instanceof HttpError) || err.status !== status) {
        err.expose = status < 500;
        err.status = err.statusCode = status;
      }
      for (var key in props) {
        if (key !== "status" && key !== "statusCode") {
          err[key] = props[key];
        }
      }
      return err;
    }
    function createHttpErrorConstructor() {
      function HttpError() {
        throw new TypeError("cannot construct abstract class");
      }
      inherits(HttpError, Error);
      return HttpError;
    }
    function createClientErrorConstructor(HttpError, name, code) {
      var className = toClassName(name);
      function ClientError(message) {
        var msg = message != null ? message : statuses.message[code];
        var err = new Error(msg);
        Error.captureStackTrace(err, ClientError);
        setPrototypeOf(err, ClientError.prototype);
        Object.defineProperty(err, "message", {
          enumerable: true,
          configurable: true,
          value: msg,
          writable: true
        });
        Object.defineProperty(err, "name", {
          enumerable: false,
          configurable: true,
          value: className,
          writable: true
        });
        return err;
      }
      inherits(ClientError, HttpError);
      nameFunc(ClientError, className);
      ClientError.prototype.status = code;
      ClientError.prototype.statusCode = code;
      ClientError.prototype.expose = true;
      return ClientError;
    }
    function createIsHttpErrorFunction(HttpError) {
      return function isHttpError(val) {
        if (!val || typeof val !== "object") {
          return false;
        }
        if (val instanceof HttpError) {
          return true;
        }
        return val instanceof Error && typeof val.expose === "boolean" && typeof val.statusCode === "number" && val.status === val.statusCode;
      };
    }
    function createServerErrorConstructor(HttpError, name, code) {
      var className = toClassName(name);
      function ServerError(message) {
        var msg = message != null ? message : statuses.message[code];
        var err = new Error(msg);
        Error.captureStackTrace(err, ServerError);
        setPrototypeOf(err, ServerError.prototype);
        Object.defineProperty(err, "message", {
          enumerable: true,
          configurable: true,
          value: msg,
          writable: true
        });
        Object.defineProperty(err, "name", {
          enumerable: false,
          configurable: true,
          value: className,
          writable: true
        });
        return err;
      }
      inherits(ServerError, HttpError);
      nameFunc(ServerError, className);
      ServerError.prototype.status = code;
      ServerError.prototype.statusCode = code;
      ServerError.prototype.expose = false;
      return ServerError;
    }
    function nameFunc(func, name) {
      var desc = Object.getOwnPropertyDescriptor(func, "name");
      if (desc && desc.configurable) {
        desc.value = name;
        Object.defineProperty(func, "name", desc);
      }
    }
    function populateConstructorExports(exports3, codes, HttpError) {
      codes.forEach(function forEachCode(code) {
        var CodeError;
        var name = toIdentifier(statuses.message[code]);
        switch (codeClass(code)) {
          case 400:
            CodeError = createClientErrorConstructor(HttpError, name, code);
            break;
          case 500:
            CodeError = createServerErrorConstructor(HttpError, name, code);
            break;
        }
        if (CodeError) {
          exports3[code] = CodeError;
          exports3[name] = CodeError;
        }
      });
    }
    function toClassName(name) {
      return name.substr(-5) !== "Error" ? name + "Error" : name;
    }
  }
});

// node_modules/@fastify/send/lib/createHttpError.js
var require_createHttpError = __commonJS({
  "node_modules/@fastify/send/lib/createHttpError.js"(exports2, module2) {
    "use strict";
    var createError = require_http_errors();
    function createHttpError(status, err) {
      if (!err) {
        return createError(status);
      }
      return err instanceof Error ? createError(status, err, { expose: false }) : createError(status, err);
    }
    module2.exports.createHttpError = createHttpError;
  }
});

// node_modules/@fastify/send/lib/send.js
var require_send = __commonJS({
  "node_modules/@fastify/send/lib/send.js"(exports2, module2) {
    "use strict";
    var fs5 = require("node:fs");
    var path4 = require("node:path");
    var stream = require("node:stream");
    var debug = require("node:util").debuglog("send");
    var decode = require_fast_decode_uri_component();
    var escapeHtml = require_escape_html();
    var mime = require_mime();
    var ms = require_dist5();
    var { collapseLeadingSlashes } = require_collapseLeadingSlashes();
    var { containsDotFile } = require_containsDotFile();
    var { contentRange } = require_contentRange();
    var { createHtmlDocument } = require_createHtmlDocument();
    var { isUtf8MimeType } = require_isUtf8MimeType();
    var { normalizeList } = require_normalizeList();
    var { parseBytesRange } = require_parseBytesRange();
    var { parseTokenList } = require_parseTokenList();
    var { createHttpError } = require_createHttpError();
    var extname = path4.extname;
    var join5 = path4.join;
    var normalize = path4.normalize;
    var resolve = path4.resolve;
    var sep = path4.sep;
    var Readable = stream.Readable;
    var BYTES_RANGE_REGEXP = /^ *bytes=/;
    var MAX_MAXAGE = 60 * 60 * 24 * 365 * 1e3;
    var UP_PATH_REGEXP = /(?:^|[\\/])\.\.(?:[\\/]|$)/;
    var ERROR_RESPONSES = {
      400: createHtmlDocument("Error", "Bad Request"),
      403: createHtmlDocument("Error", "Forbidden"),
      404: createHtmlDocument("Error", "Not Found"),
      412: createHtmlDocument("Error", "Precondition Failed"),
      416: createHtmlDocument("Error", "Range Not Satisfiable"),
      500: createHtmlDocument("Error", "Internal Server Error")
    };
    var validDotFilesOptions = [
      "allow",
      "ignore",
      "deny"
    ];
    function normalizeMaxAge(_maxage) {
      let maxage;
      if (typeof _maxage === "string") {
        maxage = ms.parse(_maxage);
      } else {
        maxage = Number(_maxage);
      }
      if (maxage !== maxage) {
        return 0;
      }
      return Math.min(Math.max(0, maxage), MAX_MAXAGE);
    }
    function normalizeOptions(options) {
      options = options ?? {};
      const acceptRanges = options.acceptRanges !== void 0 ? Boolean(options.acceptRanges) : true;
      const cacheControl = options.cacheControl !== void 0 ? Boolean(options.cacheControl) : true;
      const contentType = options.contentType !== void 0 ? Boolean(options.contentType) : true;
      const etag = options.etag !== void 0 ? Boolean(options.etag) : true;
      const dotfiles = options.dotfiles !== void 0 ? validDotFilesOptions.indexOf(options.dotfiles) : 1;
      if (dotfiles === -1) {
        throw new TypeError('dotfiles option must be "allow", "deny", or "ignore"');
      }
      const extensions = options.extensions !== void 0 ? normalizeList(options.extensions, "extensions option") : [];
      const immutable = options.immutable !== void 0 ? Boolean(options.immutable) : false;
      const index = options.index !== void 0 ? normalizeList(options.index, "index option") : ["index.html"];
      const lastModified = options.lastModified !== void 0 ? Boolean(options.lastModified) : true;
      const maxage = normalizeMaxAge(options.maxAge ?? options.maxage);
      const maxContentRangeChunkSize = options.maxContentRangeChunkSize !== void 0 ? Number(options.maxContentRangeChunkSize) : null;
      const root = options.root ? resolve(options.root) : null;
      const highWaterMark = Number.isSafeInteger(options.highWaterMark) && options.highWaterMark > 0 ? options.highWaterMark : null;
      return {
        acceptRanges,
        cacheControl,
        contentType,
        etag,
        dotfiles,
        extensions,
        immutable,
        index,
        lastModified,
        maxage,
        maxContentRangeChunkSize,
        root,
        highWaterMark,
        start: options.start,
        end: options.end
      };
    }
    function normalizePath(_path, root) {
      let path5 = decode(_path);
      if (path5 == null) {
        return { statusCode: 400 };
      }
      if (~path5.indexOf("\0")) {
        return { statusCode: 400 };
      }
      let parts;
      if (root !== null) {
        if (path5) {
          path5 = normalize("." + sep + path5);
        }
        if (UP_PATH_REGEXP.test(path5)) {
          debug('malicious path "%s"', path5);
          return { statusCode: 403 };
        }
        parts = path5.split(sep);
        path5 = normalize(join5(root, path5));
      } else {
        if (UP_PATH_REGEXP.test(path5)) {
          debug('malicious path "%s"', path5);
          return { statusCode: 403 };
        }
        parts = normalize(path5).split(sep);
        path5 = resolve(path5);
      }
      return { path: path5, parts };
    }
    function hasTrailingSlash(path5) {
      return path5[path5.length - 1] === "/";
    }
    function isConditionalGET(request) {
      return request.headers["if-match"] || request.headers["if-unmodified-since"] || request.headers["if-none-match"] || request.headers["if-modified-since"];
    }
    function isNotModifiedFailure(request, headers) {
      if ("cache-control" in request.headers && request.headers["cache-control"].indexOf("no-cache") !== -1) {
        return false;
      }
      if ("if-none-match" in request.headers) {
        const ifNoneMatch = request.headers["if-none-match"];
        if (ifNoneMatch === "*") {
          return true;
        }
        const etag = headers.ETag;
        if (typeof etag !== "string") {
          return false;
        }
        const etagL = etag.length;
        const isMatching = parseTokenList(ifNoneMatch, function(match) {
          const mL = match.length;
          if (etagL === mL && match === etag || etagL > mL && "W/" + match === etag) {
            return true;
          }
        });
        if (isMatching) {
          return true;
        }
        return false;
      }
      if ("if-modified-since" in request.headers) {
        const ifModifiedSince = request.headers["if-modified-since"];
        const lastModified = headers["Last-Modified"];
        if (!lastModified || Date.parse(lastModified) <= Date.parse(ifModifiedSince)) {
          return true;
        }
      }
      return false;
    }
    function isPreconditionFailure(request, headers) {
      const ifMatch = request.headers["if-match"];
      if (ifMatch) {
        const etag = headers.ETag;
        if (ifMatch !== "*") {
          const isMatching = parseTokenList(ifMatch, function(match) {
            if (match === etag || "W/" + match === etag) {
              return true;
            }
          }) || false;
          if (isMatching !== true) {
            return true;
          }
        }
      }
      if ("if-unmodified-since" in request.headers) {
        const ifUnmodifiedSince = request.headers["if-unmodified-since"];
        const unmodifiedSince = Date.parse(ifUnmodifiedSince);
        if (unmodifiedSince === unmodifiedSince) {
          const lastModified = Date.parse(headers["Last-Modified"]);
          if (
            // eslint-disable-next-line no-self-compare
            lastModified !== lastModified || // fast path of isNaN(number)
            lastModified > unmodifiedSince
          ) {
            return true;
          }
        }
      }
      return false;
    }
    function isRangeFresh(request, headers) {
      if (!("if-range" in request.headers)) {
        return true;
      }
      const ifRange = request.headers["if-range"];
      if (ifRange.indexOf('"') !== -1) {
        const etag = headers.ETag;
        return etag && ifRange.indexOf(etag) !== -1 || false;
      }
      const ifRangeTimestamp = Date.parse(ifRange);
      if (ifRangeTimestamp !== ifRangeTimestamp) {
        return false;
      }
      const lastModified = Date.parse(headers["Last-Modified"]);
      return (
        // eslint-disable-next-line no-self-compare
        lastModified !== lastModified || // fast path of isNaN(number)
        lastModified <= ifRangeTimestamp
      );
    }
    function tryStat(path5) {
      return new Promise((resolve2) => {
        fs5.stat(path5, function onstat(error, stat) {
          resolve2({ error, stat });
        });
      });
    }
    function sendError(statusCode, err) {
      const headers = {};
      if (err && err.headers) {
        for (const headerName in err.headers) {
          headers[headerName] = err.headers[headerName];
        }
      }
      const doc = ERROR_RESPONSES[statusCode];
      headers["Content-Type"] = "text/html; charset=utf-8";
      headers["Content-Length"] = doc[1];
      headers["Content-Security-Policy"] = "default-src 'none'";
      headers["X-Content-Type-Options"] = "nosniff";
      return {
        statusCode,
        headers,
        stream: Readable.from(doc[0]),
        // metadata
        type: "error",
        metadata: { error: createHttpError(statusCode, err) }
      };
    }
    function sendStatError(err) {
      switch (err.code) {
        case "ENAMETOOLONG":
        case "ENOTDIR":
        case "ENOENT":
          return sendError(404, err);
        default:
          return sendError(500, err);
      }
    }
    function sendNotModified(headers, path5, stat) {
      debug("not modified");
      delete headers["Content-Encoding"];
      delete headers["Content-Language"];
      delete headers["Content-Length"];
      delete headers["Content-Range"];
      delete headers["Content-Type"];
      return {
        statusCode: 304,
        headers,
        stream: Readable.from(""),
        // metadata
        type: "file",
        metadata: { path: path5, stat }
      };
    }
    function sendFileDirectly(request, path5, stat, options) {
      let len = stat.size;
      let offset = options.start ?? 0;
      let statusCode = 200;
      const headers = {};
      debug('send "%s"', path5);
      if (options.acceptRanges) {
        debug("accept ranges");
        headers["Accept-Ranges"] = "bytes";
      }
      if (options.cacheControl) {
        let cacheControl = "public, max-age=" + Math.floor(options.maxage / 1e3);
        if (options.immutable) {
          cacheControl += ", immutable";
        }
        debug("cache-control %s", cacheControl);
        headers["Cache-Control"] = cacheControl;
      }
      if (options.lastModified) {
        const modified = stat.mtime.toUTCString();
        debug("modified %s", modified);
        headers["Last-Modified"] = modified;
      }
      if (options.etag) {
        const etag = 'W/"' + stat.size.toString(16) + "-" + stat.mtime.getTime().toString(16) + '"';
        debug("etag %s", etag);
        headers.ETag = etag;
      }
      if (options.contentType) {
        let type = mime.getType(path5) || mime.default_type;
        debug("content-type %s", type);
        if (type && isUtf8MimeType(type)) {
          type += "; charset=utf-8";
        }
        if (type) {
          headers["Content-Type"] = type;
        }
      }
      if (isConditionalGET(request)) {
        if (isPreconditionFailure(request, headers)) {
          return sendError(412);
        }
        if (isNotModifiedFailure(request, headers)) {
          return sendNotModified(headers, path5, stat);
        }
      }
      len = Math.max(0, len - offset);
      if (options.end !== void 0) {
        const bytes = options.end - offset + 1;
        if (len > bytes) len = bytes;
      }
      if (options.acceptRanges) {
        const rangeHeader = request.headers.range;
        if (rangeHeader !== void 0 && BYTES_RANGE_REGEXP.test(rangeHeader)) {
          if (isRangeFresh(request, headers)) {
            const ranges = parseBytesRange(len, rangeHeader);
            if (ranges.length === 0) {
              debug("range unsatisfiable");
              headers["Content-Range"] = contentRange("bytes", len);
              return sendError(416, {
                headers: { "Content-Range": headers["Content-Range"] }
              });
            } else if (ranges.length === 1) {
              debug("range %j", ranges);
              statusCode = 206;
              if (options.maxContentRangeChunkSize) {
                ranges[0].end = Math.min(ranges[0].end, ranges[0].start + options.maxContentRangeChunkSize - 1);
              }
              headers["Content-Range"] = contentRange("bytes", len, ranges[0]);
              offset += ranges[0].start;
              len = ranges[0].end - ranges[0].start + 1;
            }
          } else {
            debug("range stale");
          }
        }
      }
      headers["Content-Length"] = len;
      if (request.method === "HEAD") {
        return {
          statusCode,
          headers,
          stream: Readable.from(""),
          // metadata
          type: "file",
          metadata: { path: path5, stat }
        };
      }
      const stream2 = fs5.createReadStream(path5, {
        highWaterMark: options.highWaterMark,
        start: offset,
        end: Math.max(offset, offset + len - 1)
      });
      return {
        statusCode,
        headers,
        stream: stream2,
        // metadata
        type: "file",
        metadata: { path: path5, stat }
      };
    }
    function sendRedirect(path5, options) {
      if (hasTrailingSlash(options.path)) {
        return sendError(403);
      }
      const loc = encodeURI(collapseLeadingSlashes(options.path + "/"));
      const doc = createHtmlDocument("Redirecting", "Redirecting to " + escapeHtml(loc));
      const headers = {};
      headers["Content-Type"] = "text/html; charset=utf-8";
      headers["Content-Length"] = doc[1];
      headers["Content-Security-Policy"] = "default-src 'none'";
      headers["X-Content-Type-Options"] = "nosniff";
      headers.Location = loc;
      return {
        statusCode: 301,
        headers,
        stream: Readable.from(doc[0]),
        // metadata
        type: "directory",
        metadata: { requestPath: options.path, path: path5 }
      };
    }
    async function sendIndex(request, path5, options) {
      let err;
      for (let i = 0; i < options.index.length; i++) {
        const index = options.index[i];
        const p = join5(path5, index);
        const { error, stat } = await tryStat(p);
        if (error) {
          err = error;
          continue;
        }
        if (stat.isDirectory()) continue;
        return sendFileDirectly(request, p, stat, options);
      }
      if (err) {
        return sendStatError(err);
      }
      return sendError(404);
    }
    async function sendFile(request, path5, options) {
      const { error, stat } = await tryStat(path5);
      if (error && error.code === "ENOENT" && !extname(path5) && path5[path5.length - 1] !== sep) {
        let err = error;
        for (let i = 0; i < options.extensions.length; i++) {
          const extension = options.extensions[i];
          const p = path5 + "." + extension;
          const { error: error2, stat: stat2 } = await tryStat(p);
          if (error2) {
            err = error2;
            continue;
          }
          if (stat2.isDirectory()) {
            err = null;
            continue;
          }
          return sendFileDirectly(request, p, stat2, options);
        }
        if (err) {
          return sendStatError(err);
        }
        return sendError(404);
      }
      if (error) return sendStatError(error);
      if (stat.isDirectory()) return sendRedirect(path5, options);
      return sendFileDirectly(request, path5, stat, options);
    }
    async function send(request, _path, options) {
      const opts = normalizeOptions(options);
      opts.path = _path;
      const parsed = normalizePath(_path, opts.root);
      const { path: path5, parts } = parsed;
      if (parsed.statusCode !== void 0) {
        return sendError(parsed.statusCode);
      }
      if ((debug.enabled || // if debugging is enabled, then check for all cases to log allow case
      opts.dotfiles !== 0) && containsDotFile(parts)) {
        switch (opts.dotfiles) {
          /* c8 ignore start */
          /* unreachable, because NODE_DEBUG can not be set after process is running */
          case 0:
            debug('allow dotfile "%s"', path5);
            break;
          /* c8 ignore stop */
          case 2:
            debug('deny dotfile "%s"', path5);
            return sendError(403);
          case 1:
          // 'ignore'
          default:
            debug('ignore dotfile "%s"', path5);
            return sendError(404);
        }
      }
      if (opts.index.length && hasTrailingSlash(_path)) {
        return sendIndex(request, path5, opts);
      }
      return sendFile(request, path5, opts);
    }
    module2.exports.send = send;
  }
});

// node_modules/@fastify/send/index.js
var require_send2 = __commonJS({
  "node_modules/@fastify/send/index.js"(exports2, module2) {
    "use strict";
    var isUtf8MimeType = require_isUtf8MimeType().isUtf8MimeType;
    var mime = require_mime();
    var send = require_send().send;
    module2.exports = send;
    module2.exports.default = send;
    module2.exports.send = send;
    module2.exports.isUtf8MimeType = isUtf8MimeType;
    module2.exports.mime = mime;
  }
});

// node_modules/@fastify/accept-negotiator/index.js
var require_accept_negotiator = __commonJS({
  "node_modules/@fastify/accept-negotiator/index.js"(exports2, module2) {
    "use strict";
    function Negotiator(options) {
      if (!new.target) {
        return new Negotiator(options);
      }
      const {
        supportedValues = [],
        cache
      } = options && typeof options === "object" && options || {};
      this.supportedValues = supportedValues;
      this.cache = cache;
    }
    Negotiator.prototype.negotiate = function(header) {
      if (typeof header !== "string") {
        return null;
      }
      if (!this.cache) {
        return negotiate(header, this.supportedValues);
      }
      if (!this.cache.has(header)) {
        this.cache.set(header, negotiate(header, this.supportedValues));
      }
      return this.cache.get(header);
    };
    function negotiate(header, supportedValues) {
      if (!header || !Array.isArray(supportedValues) || supportedValues.length === 0) {
        return null;
      }
      if (header === "*") {
        return supportedValues[0];
      }
      let preferredEncoding = null;
      let preferredEncodingPriority = Infinity;
      let preferredEncodingQuality = 0;
      function processMatch(enc2, quality) {
        if (quality === 0 || preferredEncodingQuality > quality) {
          return false;
        }
        const encoding = enc2 === "*" && supportedValues[0] || enc2;
        const priority = supportedValues.indexOf(encoding);
        if (priority === -1) {
          return false;
        }
        if (priority === 0 && quality === 1) {
          preferredEncoding = encoding;
          return true;
        } else if (preferredEncodingQuality < quality) {
          preferredEncoding = encoding;
          preferredEncodingPriority = priority;
          preferredEncodingQuality = quality;
        } else if (preferredEncodingPriority > priority) {
          preferredEncoding = encoding;
          preferredEncodingPriority = priority;
          preferredEncodingQuality = quality;
        }
        return false;
      }
      parse(header, processMatch);
      return preferredEncoding;
    }
    var BEGIN = 0;
    var TOKEN = 1;
    var QUALITY = 2;
    var END = 3;
    function parse(header, processMatch) {
      let str = "";
      let quality;
      let state = BEGIN;
      for (let i = 0, il2 = header.length; i < il2; ++i) {
        const char = header[i];
        if (char === " " || char === "	") {
          continue;
        } else if (char === ";") {
          if (state === TOKEN) {
            state = QUALITY;
            quality = "";
          }
          continue;
        } else if (char === ",") {
          if (state === TOKEN) {
            if (processMatch(str, 1)) {
              state = END;
              break;
            }
            state = BEGIN;
            str = "";
          } else if (state === QUALITY) {
            if (processMatch(str, parseFloat(quality) || 0)) {
              state = END;
              break;
            }
            state = BEGIN;
            str = "";
            quality = "";
          }
          continue;
        } else if (state === QUALITY) {
          if (char === "q" || char === "=") {
            continue;
          } else if (char === "." || char === "1" || char === "0" || char === "2" || char === "3" || char === "4" || char === "5" || char === "6" || char === "7" || char === "8" || char === "9") {
            quality += char;
            continue;
          }
        } else if (state === BEGIN) {
          state = TOKEN;
          str += char;
          continue;
        }
        if (state === TOKEN) {
          const prevChar = header[i - 1];
          if (prevChar === " " || prevChar === "	") {
            str = "";
          }
          str += char;
          continue;
        }
        if (processMatch(str, parseFloat(quality) || 0)) {
          state = END;
          break;
        }
        state = BEGIN;
        str = char;
        quality = "";
      }
      if (state === TOKEN) {
        processMatch(str, 1);
      } else if (state === QUALITY) {
        processMatch(str, parseFloat(quality) || 0);
      }
    }
    module2.exports = negotiate;
    module2.exports.default = negotiate;
    module2.exports.negotiate = negotiate;
    module2.exports.Negotiator = Negotiator;
  }
});

// node_modules/safe-buffer/index.js
var require_safe_buffer = __commonJS({
  "node_modules/safe-buffer/index.js"(exports2, module2) {
    var buffer = require("buffer");
    var Buffer2 = buffer.Buffer;
    function copyProps(src, dst) {
      for (var key in src) {
        dst[key] = src[key];
      }
    }
    if (Buffer2.from && Buffer2.alloc && Buffer2.allocUnsafe && Buffer2.allocUnsafeSlow) {
      module2.exports = buffer;
    } else {
      copyProps(buffer, exports2);
      exports2.Buffer = SafeBuffer;
    }
    function SafeBuffer(arg, encodingOrOffset, length) {
      return Buffer2(arg, encodingOrOffset, length);
    }
    SafeBuffer.prototype = Object.create(Buffer2.prototype);
    copyProps(Buffer2, SafeBuffer);
    SafeBuffer.from = function(arg, encodingOrOffset, length) {
      if (typeof arg === "number") {
        throw new TypeError("Argument must not be a number");
      }
      return Buffer2(arg, encodingOrOffset, length);
    };
    SafeBuffer.alloc = function(size, fill, encoding) {
      if (typeof size !== "number") {
        throw new TypeError("Argument must be a number");
      }
      var buf = Buffer2(size);
      if (fill !== void 0) {
        if (typeof encoding === "string") {
          buf.fill(fill, encoding);
        } else {
          buf.fill(fill);
        }
      } else {
        buf.fill(0);
      }
      return buf;
    };
    SafeBuffer.allocUnsafe = function(size) {
      if (typeof size !== "number") {
        throw new TypeError("Argument must be a number");
      }
      return Buffer2(size);
    };
    SafeBuffer.allocUnsafeSlow = function(size) {
      if (typeof size !== "number") {
        throw new TypeError("Argument must be a number");
      }
      return buffer.SlowBuffer(size);
    };
  }
});

// node_modules/content-disposition/index.js
var require_content_disposition = __commonJS({
  "node_modules/content-disposition/index.js"(exports2, module2) {
    "use strict";
    module2.exports = contentDisposition;
    module2.exports.parse = parse;
    var basename = require("path").basename;
    var Buffer2 = require_safe_buffer().Buffer;
    var ENCODE_URL_ATTR_CHAR_REGEXP = /[\x00-\x20"'()*,/:;<=>?@[\\\]{}\x7f]/g;
    var HEX_ESCAPE_REGEXP = /%[0-9A-Fa-f]{2}/;
    var HEX_ESCAPE_REPLACE_REGEXP = /%([0-9A-Fa-f]{2})/g;
    var NON_LATIN1_REGEXP = /[^\x20-\x7e\xa0-\xff]/g;
    var QESC_REGEXP = /\\([\u0000-\u007f])/g;
    var QUOTE_REGEXP = /([\\"])/g;
    var PARAM_REGEXP = /;[\x09\x20]*([!#$%&'*+.0-9A-Z^_`a-z|~-]+)[\x09\x20]*=[\x09\x20]*("(?:[\x20!\x23-\x5b\x5d-\x7e\x80-\xff]|\\[\x20-\x7e])*"|[!#$%&'*+.0-9A-Z^_`a-z|~-]+)[\x09\x20]*/g;
    var TEXT_REGEXP = /^[\x20-\x7e\x80-\xff]+$/;
    var TOKEN_REGEXP = /^[!#$%&'*+.0-9A-Z^_`a-z|~-]+$/;
    var EXT_VALUE_REGEXP = /^([A-Za-z0-9!#$%&+\-^_`{}~]+)'(?:[A-Za-z]{2,3}(?:-[A-Za-z]{3}){0,3}|[A-Za-z]{4,8}|)'((?:%[0-9A-Fa-f]{2}|[A-Za-z0-9!#$&+.^_`|~-])+)$/;
    var DISPOSITION_TYPE_REGEXP = /^([!#$%&'*+.0-9A-Z^_`a-z|~-]+)[\x09\x20]*(?:$|;)/;
    function contentDisposition(filename, options) {
      var opts = options || {};
      var type = opts.type || "attachment";
      var params = createparams(filename, opts.fallback);
      return format(new ContentDisposition(type, params));
    }
    function createparams(filename, fallback) {
      if (filename === void 0) {
        return;
      }
      var params = {};
      if (typeof filename !== "string") {
        throw new TypeError("filename must be a string");
      }
      if (fallback === void 0) {
        fallback = true;
      }
      if (typeof fallback !== "string" && typeof fallback !== "boolean") {
        throw new TypeError("fallback must be a string or boolean");
      }
      if (typeof fallback === "string" && NON_LATIN1_REGEXP.test(fallback)) {
        throw new TypeError("fallback must be ISO-8859-1 string");
      }
      var name = basename(filename);
      var isQuotedString = TEXT_REGEXP.test(name);
      var fallbackName = typeof fallback !== "string" ? fallback && getlatin1(name) : basename(fallback);
      var hasFallback = typeof fallbackName === "string" && fallbackName !== name;
      if (hasFallback || !isQuotedString || HEX_ESCAPE_REGEXP.test(name)) {
        params["filename*"] = name;
      }
      if (isQuotedString || hasFallback) {
        params.filename = hasFallback ? fallbackName : name;
      }
      return params;
    }
    function format(obj) {
      var parameters = obj.parameters;
      var type = obj.type;
      if (!type || typeof type !== "string" || !TOKEN_REGEXP.test(type)) {
        throw new TypeError("invalid type");
      }
      var string = String(type).toLowerCase();
      if (parameters && typeof parameters === "object") {
        var param;
        var params = Object.keys(parameters).sort();
        for (var i = 0; i < params.length; i++) {
          param = params[i];
          var val = param.substr(-1) === "*" ? ustring(parameters[param]) : qstring(parameters[param]);
          string += "; " + param + "=" + val;
        }
      }
      return string;
    }
    function decodefield(str) {
      var match = EXT_VALUE_REGEXP.exec(str);
      if (!match) {
        throw new TypeError("invalid extended field value");
      }
      var charset = match[1].toLowerCase();
      var encoded = match[2];
      var value;
      var binary = encoded.replace(HEX_ESCAPE_REPLACE_REGEXP, pdecode);
      switch (charset) {
        case "iso-8859-1":
          value = getlatin1(binary);
          break;
        case "utf-8":
          value = Buffer2.from(binary, "binary").toString("utf8");
          break;
        default:
          throw new TypeError("unsupported charset in extended field");
      }
      return value;
    }
    function getlatin1(val) {
      return String(val).replace(NON_LATIN1_REGEXP, "?");
    }
    function parse(string) {
      if (!string || typeof string !== "string") {
        throw new TypeError("argument string is required");
      }
      var match = DISPOSITION_TYPE_REGEXP.exec(string);
      if (!match) {
        throw new TypeError("invalid type format");
      }
      var index = match[0].length;
      var type = match[1].toLowerCase();
      var key;
      var names = [];
      var params = {};
      var value;
      index = PARAM_REGEXP.lastIndex = match[0].substr(-1) === ";" ? index - 1 : index;
      while (match = PARAM_REGEXP.exec(string)) {
        if (match.index !== index) {
          throw new TypeError("invalid parameter format");
        }
        index += match[0].length;
        key = match[1].toLowerCase();
        value = match[2];
        if (names.indexOf(key) !== -1) {
          throw new TypeError("invalid duplicate parameter");
        }
        names.push(key);
        if (key.indexOf("*") + 1 === key.length) {
          key = key.slice(0, -1);
          value = decodefield(value);
          params[key] = value;
          continue;
        }
        if (typeof params[key] === "string") {
          continue;
        }
        if (value[0] === '"') {
          value = value.substr(1, value.length - 2).replace(QESC_REGEXP, "$1");
        }
        params[key] = value;
      }
      if (index !== -1 && index !== string.length) {
        throw new TypeError("invalid parameter format");
      }
      return new ContentDisposition(type, params);
    }
    function pdecode(str, hex) {
      return String.fromCharCode(parseInt(hex, 16));
    }
    function pencode(char) {
      return "%" + String(char).charCodeAt(0).toString(16).toUpperCase();
    }
    function qstring(val) {
      var str = String(val);
      return '"' + str.replace(QUOTE_REGEXP, "\\$1") + '"';
    }
    function ustring(val) {
      var str = String(val);
      var encoded = encodeURIComponent(str).replace(ENCODE_URL_ATTR_CHAR_REGEXP, pencode);
      return "UTF-8''" + encoded;
    }
    function ContentDisposition(type, parameters) {
      this.type = type;
      this.parameters = parameters;
    }
  }
});

// node_modules/@fastify/static/lib/dirList.js
var require_dirList = __commonJS({
  "node_modules/@fastify/static/lib/dirList.js"(exports2, module2) {
    "use strict";
    var os2 = require("node:os");
    var path4 = require("node:path");
    var fs5 = require("node:fs/promises");
    var fastq = require_queue();
    var fastqConcurrency = Math.max(1, os2.cpus().length - 1);
    var dirList = {
      _getExtendedInfo: async function(dir, info) {
        const depth = dir.split(path4.sep).length;
        const files = await fs5.readdir(dir);
        const worker = async (filename) => {
          const filePath = path4.join(dir, filename);
          let stats;
          try {
            stats = await fs5.stat(filePath);
          } catch {
            return;
          }
          if (stats.isDirectory()) {
            info.totalFolderCount++;
            filePath.split(path4.sep).length === depth + 1 && info.folderCount++;
            await dirList._getExtendedInfo(filePath, info);
          } else {
            info.totalSize += stats.size;
            info.totalFileCount++;
            filePath.split(path4.sep).length === depth + 1 && info.fileCount++;
            info.lastModified = Math.max(info.lastModified, stats.mtimeMs);
          }
        };
        const queue = fastq.promise(worker, fastqConcurrency);
        await Promise.all(files.map((filename) => queue.push(filename)));
      },
      /**
       * get extended info about a folder
       * @param {string} folderPath full path fs dir
       * @return {Promise<ExtendedInfo>}
       */
      getExtendedInfo: async function(folderPath) {
        const info = {
          totalSize: 0,
          fileCount: 0,
          totalFileCount: 0,
          folderCount: 0,
          totalFolderCount: 0,
          lastModified: 0
        };
        await dirList._getExtendedInfo(folderPath, info);
        return info;
      },
      /**
       * get files and dirs from dir, or error
       * @param {string} dir full path fs dir
       * @param {(boolean | ListOptionsJsonFormat | ListOptionsHtmlFormat)} options
       * @param {string} dotfiles
       * note: can't use glob because don't get error on non existing dir
       */
      list: async function(dir, options, dotfiles) {
        const entries = { dirs: [], files: [] };
        let files = await fs5.readdir(dir);
        if (dotfiles === "deny" || dotfiles === "ignore") {
          files = files.filter((file) => file.charAt(0) !== ".");
        }
        if (files.length < 1) {
          return entries;
        }
        const worker = async (filename) => {
          let stats;
          try {
            stats = await fs5.stat(path4.join(dir, filename));
          } catch {
            return;
          }
          const entry = { name: filename, stats };
          if (stats.isDirectory()) {
            if (options.extendedFolderInfo) {
              entry.extendedInfo = await dirList.getExtendedInfo(path4.join(dir, filename));
            }
            entries.dirs.push(entry);
          } else {
            entries.files.push(entry);
          }
        };
        const queue = fastq.promise(worker, fastqConcurrency);
        await Promise.all(files.map((filename) => queue.push(filename)));
        entries.dirs.sort((a, b) => a.name.localeCompare(b.name));
        entries.files.sort((a, b) => a.name.localeCompare(b.name));
        return entries;
      },
      /**
       * send dir list content, or 404 on error
       * @param {Fastify.Reply} reply
       * @param {string} dir full path fs dir
       * @param {(boolean | ListOptionsJsonFormat | ListOptionsHtmlFormat)} options
       * @param {string} route request route
       * @param {string} dotfiles
       */
      send: async function({ reply, dir, options, route, prefix, dotfiles }) {
        if (reply.request.query.format === "html" && typeof options.render !== "function") {
          throw new TypeError("The `list.render` option must be a function and is required with the URL parameter `format=html`");
        }
        let entries;
        try {
          entries = await dirList.list(dir, options, dotfiles);
        } catch {
          return reply.callNotFound();
        }
        const format = reply.request.query.format || options.format;
        if (format !== "html") {
          if (options.jsonFormat !== "extended") {
            const nameEntries = { dirs: [], files: [] };
            entries.dirs.forEach((entry) => nameEntries.dirs.push(entry.name));
            entries.files.forEach((entry) => nameEntries.files.push(entry.name));
            await reply.send(nameEntries);
          } else {
            await reply.send(entries);
          }
          return;
        }
        const html = options.render(
          entries.dirs.map((entry) => dirList.htmlInfo(entry, route, prefix, options)),
          entries.files.map((entry) => dirList.htmlInfo(entry, route, prefix, options))
        );
        await reply.type("text/html").send(html);
      },
      /**
       * provide the html information about entry and route, to get name and full route
       * @param entry file or dir name and stats
       * @param {string} route request route
       * @return {ListFile}
       */
      htmlInfo: function(entry, route, prefix, options) {
        if (options.names?.includes(path4.basename(route))) {
          route = path4.normalize(path4.join(route, ".."));
        }
        return {
          href: encodeURI(path4.join(prefix, route, entry.name).replace(/\\/gu, "/")),
          name: entry.name,
          stats: entry.stats,
          extendedInfo: entry.extendedInfo
        };
      },
      /**
       * say if the route can be handled by dir list or not
       * @param {string} route request route
       * @param {(boolean | ListOptionsJsonFormat | ListOptionsHtmlFormat)} options
       * @return {boolean}
       */
      handle: function(route, options) {
        return options.names?.includes(path4.basename(route)) || // match trailing slash
        ((options.names?.includes("/") && route[route.length - 1] === "/") ?? false);
      },
      /**
       * get path from route and fs root paths, considering trailing slash
       * @param {string} root fs root path
       * @param {string} route request route
       */
      path: function(root, route) {
        const _route = route[route.length - 1] === "/" ? route + "none" : route;
        return path4.dirname(path4.join(root, _route));
      },
      /**
       * validate options
       * @return {Error}
       */
      validateOptions: function(options) {
        if (!options.list) {
          return;
        }
        if (Array.isArray(options.root)) {
          return new TypeError("multi-root with list option is not supported");
        }
        if (options.list.format && options.list.format !== "json" && options.list.format !== "html") {
          return new TypeError("The `list.format` option must be json or html");
        }
        if (options.list.names && !Array.isArray(options.list.names)) {
          return new TypeError("The `list.names` option must be an array");
        }
        if (options.list.jsonFormat != null && options.list.jsonFormat !== "names" && options.list.jsonFormat !== "extended") {
          return new TypeError("The `list.jsonFormat` option must be name or extended");
        }
        if (options.list.format === "html" && typeof options.list.render !== "function") {
          return new TypeError("The `list.render` option must be a function and is required with html format");
        }
      }
    };
    module2.exports = dirList;
  }
});

// node_modules/@fastify/static/index.js
var require_static = __commonJS({
  "node_modules/@fastify/static/index.js"(exports2, module2) {
    "use strict";
    var path4 = require("node:path");
    var { fileURLToPath } = require("node:url");
    var { statSync } = require("node:fs");
    var { glob } = require_commonjs7();
    var fp = require_plugin2();
    var send = require_send2();
    var encodingNegotiator = require_accept_negotiator();
    var contentDisposition = require_content_disposition();
    var dirList = require_dirList();
    var endForwardSlashRegex = /\/$/u;
    var asteriskRegex = /\*/gu;
    var supportedEncodings = ["br", "gzip", "deflate"];
    send.mime.default_type = "application/octet-stream";
    async function fastifyStatic2(fastify, opts) {
      opts.root = normalizeRoot(opts.root);
      checkRootPathForErrors(fastify, opts.root);
      const setHeaders = opts.setHeaders;
      if (setHeaders !== void 0 && typeof setHeaders !== "function") {
        throw new TypeError("The `setHeaders` option must be a function");
      }
      const invalidDirListOpts = dirList.validateOptions(opts);
      if (invalidDirListOpts) {
        throw invalidDirListOpts;
      }
      if (opts.dotfiles === void 0) {
        opts.dotfiles = "allow";
      }
      const sendOptions = {
        root: opts.root,
        acceptRanges: opts.acceptRanges,
        contentType: opts.contentType,
        cacheControl: opts.cacheControl,
        dotfiles: opts.dotfiles,
        etag: opts.etag,
        extensions: opts.extensions,
        immutable: opts.immutable,
        index: opts.index,
        lastModified: opts.lastModified,
        maxAge: opts.maxAge
      };
      let prefix = opts.prefix ?? (opts.prefix = "/");
      if (!opts.prefixAvoidTrailingSlash) {
        prefix = prefix[prefix.length - 1] === "/" ? prefix : prefix + "/";
      }
      const routeOpts = {
        constraints: opts.constraints,
        schema: {
          hide: opts.schemaHide !== void 0 ? opts.schemaHide : true
        },
        logLevel: opts.logLevel,
        errorHandler(error, request, reply) {
          if (error?.code === "ERR_STREAM_PREMATURE_CLOSE") {
            reply.request.raw.destroy();
            return;
          }
          fastify.errorHandler(error, request, reply);
        }
      };
      if (opts.decorateReply !== false) {
        fastify.decorateReply("sendFile", function(filePath, rootPath, options) {
          const opts2 = typeof rootPath === "object" ? rootPath : options;
          const root = typeof rootPath === "string" ? rootPath : opts2?.root;
          pumpSendToReply(
            this.request,
            this,
            filePath,
            root || sendOptions.root,
            0,
            opts2
          );
          return this;
        });
        fastify.decorateReply(
          "download",
          function(filePath, fileName, options = {}) {
            const { root, ...opts2 } = typeof fileName === "object" ? fileName : options;
            fileName = typeof fileName === "string" ? fileName : filePath;
            this.header("content-disposition", contentDisposition(fileName));
            pumpSendToReply(this.request, this, filePath, root, 0, opts2);
            return this;
          }
        );
      }
      if (opts.serve !== false) {
        if (opts.wildcard && typeof opts.wildcard !== "boolean") {
          throw new TypeError('"wildcard" option must be a boolean');
        }
        if (opts.wildcard === void 0 || opts.wildcard === true) {
          fastify.route({
            ...routeOpts,
            method: ["HEAD", "GET"],
            path: prefix + "*",
            handler(req, reply) {
              pumpSendToReply(req, reply, "/" + req.params["*"], sendOptions.root);
            }
          });
          if (opts.redirect === true && prefix !== opts.prefix) {
            fastify.get(opts.prefix, routeOpts, (req, reply) => {
              reply.redirect(getRedirectUrl(req.raw.url), 301);
            });
          }
        } else {
          const indexes = opts.index === void 0 ? ["index.html"] : [].concat(opts.index);
          const indexDirs = /* @__PURE__ */ new Map();
          const routes = /* @__PURE__ */ new Set();
          const roots = Array.isArray(sendOptions.root) ? sendOptions.root : [sendOptions.root];
          for (let rootPath of roots) {
            rootPath = rootPath.split(path4.win32.sep).join(path4.posix.sep);
            !rootPath.endsWith("/") && (rootPath += "/");
            const files = await glob("**/**", {
              cwd: rootPath,
              absolute: false,
              follow: true,
              nodir: true,
              dot: opts.serveDotFiles,
              ignore: opts.globIgnore
            });
            for (let file of files) {
              file = file.split(path4.win32.sep).join(path4.posix.sep);
              const route = prefix + file;
              if (routes.has(route)) {
                continue;
              }
              routes.add(route);
              setUpHeadAndGet(routeOpts, route, `/${file}`, rootPath);
              const key = path4.posix.basename(route);
              if (indexes.includes(key) && !indexDirs.has(key)) {
                indexDirs.set(path4.posix.dirname(route), rootPath);
              }
            }
          }
          for (const [dirname, rootPath] of indexDirs.entries()) {
            const pathname = dirname + (dirname.endsWith("/") ? "" : "/");
            const file = "/" + pathname.replace(prefix, "");
            setUpHeadAndGet(routeOpts, pathname, file, rootPath);
            if (opts.redirect === true) {
              setUpHeadAndGet(routeOpts, pathname.replace(endForwardSlashRegex, ""), file.replace(endForwardSlashRegex, ""), rootPath);
            }
          }
        }
      }
      const allowedPath = opts.allowedPath;
      async function pumpSendToReply(request, reply, pathname, rootPath, rootPathOffset = 0, pumpOptions, checkedEncodings) {
        const pathnameOrig = pathname;
        const options = Object.assign({}, sendOptions, pumpOptions);
        if (rootPath) {
          if (Array.isArray(rootPath)) {
            options.root = rootPath[rootPathOffset];
          } else {
            options.root = rootPath;
          }
        }
        if (allowedPath && !allowedPath(pathname, options.root, request)) {
          return reply.callNotFound();
        }
        let encoding;
        let pathnameForSend = pathname;
        if (opts.preCompressed) {
          if (!checkedEncodings) {
            checkedEncodings = /* @__PURE__ */ new Set();
          }
          encoding = getEncodingHeader(request.headers, checkedEncodings);
          if (encoding) {
            if (pathname.endsWith("/")) {
              pathname = findIndexFile(pathname, options.root, options.index);
              if (!pathname) {
                return reply.callNotFound();
              }
              pathnameForSend = pathnameForSend + pathname + "." + getEncodingExtension(encoding);
            } else {
              pathnameForSend = pathname + "." + getEncodingExtension(encoding);
            }
          }
        }
        const {
          statusCode,
          headers,
          stream,
          type,
          metadata
        } = await send(request.raw, encodeURI(pathnameForSend), options);
        switch (type) {
          case "directory": {
            const path5 = metadata.path;
            if (opts.list) {
              await dirList.send({
                reply,
                dir: path5,
                options: opts.list,
                route: pathname,
                prefix,
                dotfiles: opts.dotfiles
              }).catch((err) => reply.send(err));
            }
            if (opts.redirect === true) {
              try {
                reply.redirect(getRedirectUrl(request.raw.url), 301);
              } catch (error) {
                await reply.send(error);
              }
            } else {
              if (!pathname.endsWith("/") && findIndexFile(pathname, options.root, options.index)) {
                return pumpSendToReply(
                  request,
                  reply,
                  pathname + "/",
                  rootPath,
                  void 0,
                  void 0,
                  checkedEncodings
                );
              }
              reply.callNotFound();
            }
            break;
          }
          case "error": {
            if (statusCode === 403 && (!options.index || !options.index.length) && pathnameForSend[pathnameForSend.length - 1] === "/") {
              if (opts.list) {
                await dirList.send({
                  reply,
                  dir: dirList.path(opts.root, pathname),
                  options: opts.list,
                  route: pathname,
                  prefix,
                  dotfiles: opts.dotfiles
                }).catch((err) => reply.send(err));
                return;
              }
            }
            if (metadata.error.code === "ENOENT") {
              if (opts.preCompressed && encoding) {
                if (opts.redirect !== true) {
                  const indexPathname = findIndexFile(pathname, options.root, options.index);
                  if (indexPathname) {
                    return pumpSendToReply(
                      request,
                      reply,
                      pathname + "/",
                      rootPath,
                      void 0,
                      void 0,
                      checkedEncodings
                    );
                  }
                }
              }
              if (opts.list && dirList.handle(pathname, opts.list)) {
                await dirList.send({
                  reply,
                  dir: dirList.path(opts.root, pathname),
                  options: opts.list,
                  route: pathname,
                  prefix,
                  dotfiles: opts.dotfiles
                }).catch((err) => reply.send(err));
                return;
              }
              if (Array.isArray(rootPath) && rootPathOffset < rootPath.length - 1) {
                return pumpSendToReply(request, reply, pathname, rootPath, rootPathOffset + 1);
              }
              if (opts.preCompressed && !checkedEncodings.has(encoding)) {
                checkedEncodings.add(encoding);
                return pumpSendToReply(
                  request,
                  reply,
                  pathnameOrig,
                  rootPath,
                  rootPathOffset,
                  void 0,
                  checkedEncodings
                );
              }
              return reply.callNotFound();
            }
            if (metadata.error.status === 404) {
              return reply.callNotFound();
            }
            await reply.send(metadata.error);
            break;
          }
          case "file": {
            const newStatusCode = reply.statusCode !== 200 ? reply.statusCode : statusCode;
            reply.code(newStatusCode);
            if (setHeaders !== void 0) {
              setHeaders(reply.raw, metadata.path, metadata.stat);
            }
            reply.headers(headers);
            if (encoding) {
              reply.header("content-type", getContentType(pathname));
              reply.header("content-encoding", encoding);
            }
            await reply.send(stream);
            break;
          }
        }
      }
      function setUpHeadAndGet(routeOpts2, route, file, rootPath) {
        const toSetUp = Object.assign({}, routeOpts2, {
          method: ["HEAD", "GET"],
          url: route,
          handler: serveFileHandler
        });
        toSetUp.config = toSetUp.config || {};
        toSetUp.config.file = file;
        toSetUp.config.rootPath = rootPath;
        fastify.route(toSetUp);
      }
      async function serveFileHandler(req, reply) {
        const routeConfig = req.routeOptions?.config || req.routeConfig;
        return pumpSendToReply(req, reply, routeConfig.file, routeConfig.rootPath);
      }
    }
    function normalizeRoot(root) {
      if (root === void 0) {
        return root;
      }
      if (root instanceof URL && root.protocol === "file:") {
        return fileURLToPath(root);
      }
      if (Array.isArray(root)) {
        const result = [];
        for (let i = 0, il2 = root.length; i < il2; ++i) {
          if (root[i] instanceof URL && root[i].protocol === "file:") {
            result.push(fileURLToPath(root[i]));
          } else {
            result.push(root[i]);
          }
        }
        return result;
      }
      return root;
    }
    function checkRootPathForErrors(fastify, rootPath) {
      if (rootPath === void 0) {
        throw new Error('"root" option is required');
      }
      if (Array.isArray(rootPath)) {
        if (!rootPath.length) {
          throw new Error('"root" option array requires one or more paths');
        }
        if (new Set(rootPath).size !== rootPath.length) {
          throw new Error(
            '"root" option array contains one or more duplicate paths'
          );
        }
        rootPath.map((path5) => checkPath(fastify, path5));
        return;
      }
      if (typeof rootPath === "string") {
        return checkPath(fastify, rootPath);
      }
      throw new Error('"root" option must be a string or array of strings');
    }
    function checkPath(fastify, rootPath) {
      if (typeof rootPath !== "string") {
        throw new TypeError('"root" option must be a string');
      }
      if (path4.isAbsolute(rootPath) === false) {
        throw new Error('"root" option must be an absolute path');
      }
      let pathStat;
      try {
        pathStat = statSync(rootPath);
      } catch (e) {
        if (e.code === "ENOENT") {
          fastify.log.warn(`"root" path "${rootPath}" must exist`);
          return;
        }
        throw e;
      }
      if (pathStat.isDirectory() === false) {
        throw new Error('"root" option must point to a directory');
      }
    }
    function getContentType(path5) {
      const type = send.mime.getType(path5) || send.mime.default_type;
      if (!send.isUtf8MimeType(type)) {
        return type;
      }
      return `${type}; charset=utf-8`;
    }
    function findIndexFile(pathname, root, indexFiles = ["index.html"]) {
      if (Array.isArray(indexFiles)) {
        return indexFiles.find((filename) => {
          const p = path4.join(root, pathname, filename);
          try {
            const stats = statSync(p);
            return !stats.isDirectory();
          } catch {
            return false;
          }
        });
      }
      return false;
    }
    function getEncodingHeader(headers, checked) {
      if (!("accept-encoding" in headers)) return;
      const header = headers["accept-encoding"].toLowerCase().replace(asteriskRegex, "gzip");
      return encodingNegotiator.negotiate(
        header,
        supportedEncodings.filter((enc2) => !checked.has(enc2))
      );
    }
    function getEncodingExtension(encoding) {
      switch (encoding) {
        case "br":
          return "br";
        case "gzip":
          return "gz";
      }
    }
    function getRedirectUrl(url) {
      let i = 0;
      for (; i < url.length; ++i) {
        if (url[i] !== "/" && url[i] !== "\\") break;
      }
      url = "/" + url.substr(i);
      try {
        const parsed = new URL(url, "http://localhost.com/");
        const parsedPathname = parsed.pathname;
        return parsedPathname + (parsedPathname[parsedPathname.length - 1] !== "/" ? "/" : "") + (parsed.search || "");
      } catch {
        const err = new Error(`Invalid redirect URL: ${url}`);
        err.statusCode = 400;
        throw err;
      }
    }
    module2.exports = fp(fastifyStatic2, {
      fastify: "5.x",
      name: "@fastify/static"
    });
    module2.exports.default = fastifyStatic2;
    module2.exports.fastifyStatic = fastifyStatic2;
  }
});

// node_modules/tiktoken/tiktoken_bg.cjs
var require_tiktoken_bg = __commonJS({
  "node_modules/tiktoken/tiktoken_bg.cjs"(exports2, module2) {
    var wasm;
    module2.exports.__wbg_set_wasm = function(val) {
      wasm = val;
    };
    var lTextDecoder = typeof TextDecoder === "undefined" ? (0, module2.require)("util").TextDecoder : TextDecoder;
    var cachedTextDecoder = new lTextDecoder("utf-8", { ignoreBOM: true, fatal: true });
    cachedTextDecoder.decode();
    var cachedUint8ArrayMemory0 = null;
    function getUint8ArrayMemory0() {
      if (cachedUint8ArrayMemory0 === null || cachedUint8ArrayMemory0.byteLength === 0) {
        cachedUint8ArrayMemory0 = new Uint8Array(wasm.memory.buffer);
      }
      return cachedUint8ArrayMemory0;
    }
    function getStringFromWasm0(ptr, len) {
      ptr = ptr >>> 0;
      return cachedTextDecoder.decode(getUint8ArrayMemory0().subarray(ptr, ptr + len));
    }
    var heap = new Array(128).fill(void 0);
    heap.push(void 0, null, true, false);
    var heap_next = heap.length;
    function addHeapObject(obj) {
      if (heap_next === heap.length) heap.push(heap.length + 1);
      const idx = heap_next;
      heap_next = heap[idx];
      heap[idx] = obj;
      return idx;
    }
    function handleError(f, args) {
      try {
        return f.apply(this, args);
      } catch (e) {
        wasm.__wbindgen_export_0(addHeapObject(e));
      }
    }
    function getObject(idx) {
      return heap[idx];
    }
    function dropObject(idx) {
      if (idx < 132) return;
      heap[idx] = heap_next;
      heap_next = idx;
    }
    function takeObject(idx) {
      const ret = getObject(idx);
      dropObject(idx);
      return ret;
    }
    var WASM_VECTOR_LEN = 0;
    var lTextEncoder = typeof TextEncoder === "undefined" ? (0, module2.require)("util").TextEncoder : TextEncoder;
    var cachedTextEncoder = new lTextEncoder("utf-8");
    var encodeString = typeof cachedTextEncoder.encodeInto === "function" ? function(arg, view) {
      return cachedTextEncoder.encodeInto(arg, view);
    } : function(arg, view) {
      const buf = cachedTextEncoder.encode(arg);
      view.set(buf);
      return {
        read: arg.length,
        written: buf.length
      };
    };
    function passStringToWasm0(arg, malloc, realloc) {
      if (realloc === void 0) {
        const buf = cachedTextEncoder.encode(arg);
        const ptr2 = malloc(buf.length, 1) >>> 0;
        getUint8ArrayMemory0().subarray(ptr2, ptr2 + buf.length).set(buf);
        WASM_VECTOR_LEN = buf.length;
        return ptr2;
      }
      let len = arg.length;
      let ptr = malloc(len, 1) >>> 0;
      const mem = getUint8ArrayMemory0();
      let offset = 0;
      for (; offset < len; offset++) {
        const code = arg.charCodeAt(offset);
        if (code > 127) break;
        mem[ptr + offset] = code;
      }
      if (offset !== len) {
        if (offset !== 0) {
          arg = arg.slice(offset);
        }
        ptr = realloc(ptr, len, len = offset + arg.length * 3, 1) >>> 0;
        const view = getUint8ArrayMemory0().subarray(ptr + offset, ptr + len);
        const ret = encodeString(arg, view);
        offset += ret.written;
        ptr = realloc(ptr, len, offset, 1) >>> 0;
      }
      WASM_VECTOR_LEN = offset;
      return ptr;
    }
    function isLikeNone(x) {
      return x === void 0 || x === null;
    }
    var cachedDataViewMemory0 = null;
    function getDataViewMemory0() {
      if (cachedDataViewMemory0 === null || cachedDataViewMemory0.buffer.detached === true || cachedDataViewMemory0.buffer.detached === void 0 && cachedDataViewMemory0.buffer !== wasm.memory.buffer) {
        cachedDataViewMemory0 = new DataView(wasm.memory.buffer);
      }
      return cachedDataViewMemory0;
    }
    var cachedUint32ArrayMemory0 = null;
    function getUint32ArrayMemory0() {
      if (cachedUint32ArrayMemory0 === null || cachedUint32ArrayMemory0.byteLength === 0) {
        cachedUint32ArrayMemory0 = new Uint32Array(wasm.memory.buffer);
      }
      return cachedUint32ArrayMemory0;
    }
    function getArrayU32FromWasm0(ptr, len) {
      ptr = ptr >>> 0;
      return getUint32ArrayMemory0().subarray(ptr / 4, ptr / 4 + len);
    }
    function passArray8ToWasm0(arg, malloc) {
      const ptr = malloc(arg.length * 1, 1) >>> 0;
      getUint8ArrayMemory0().set(arg, ptr / 1);
      WASM_VECTOR_LEN = arg.length;
      return ptr;
    }
    function passArray32ToWasm0(arg, malloc) {
      const ptr = malloc(arg.length * 4, 4) >>> 0;
      getUint32ArrayMemory0().set(arg, ptr / 4);
      WASM_VECTOR_LEN = arg.length;
      return ptr;
    }
    function getArrayU8FromWasm0(ptr, len) {
      ptr = ptr >>> 0;
      return getUint8ArrayMemory0().subarray(ptr / 1, ptr / 1 + len);
    }
    module2.exports.get_encoding = function(encoding, extend_special_tokens) {
      if (wasm == null) throw new Error("tiktoken: WASM binary has not been propery initialized.");
      try {
        const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
        const ptr0 = passStringToWasm0(encoding, wasm.__wbindgen_export_1, wasm.__wbindgen_export_2);
        const len0 = WASM_VECTOR_LEN;
        wasm.get_encoding(retptr, ptr0, len0, addHeapObject(extend_special_tokens));
        var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);
        var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);
        var r2 = getDataViewMemory0().getInt32(retptr + 4 * 2, true);
        if (r2) {
          throw takeObject(r1);
        }
        return Tiktoken.__wrap(r0);
      } finally {
        wasm.__wbindgen_add_to_stack_pointer(16);
      }
    };
    module2.exports.encoding_for_model = function(model, extend_special_tokens) {
      if (wasm == null) throw new Error("tiktoken: WASM binary has not been propery initialized.");
      try {
        const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
        const ptr0 = passStringToWasm0(model, wasm.__wbindgen_export_1, wasm.__wbindgen_export_2);
        const len0 = WASM_VECTOR_LEN;
        wasm.encoding_for_model(retptr, ptr0, len0, addHeapObject(extend_special_tokens));
        var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);
        var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);
        var r2 = getDataViewMemory0().getInt32(retptr + 4 * 2, true);
        if (r2) {
          throw takeObject(r1);
        }
        return Tiktoken.__wrap(r0);
      } finally {
        wasm.__wbindgen_add_to_stack_pointer(16);
      }
    };
    var TiktokenFinalization = typeof FinalizationRegistry === "undefined" ? { register: () => {
    }, unregister: () => {
    } } : new FinalizationRegistry((ptr) => wasm.__wbg_tiktoken_free(ptr >>> 0, 1));
    var Tiktoken = class _Tiktoken {
      /**
       * @param {string} tiktoken_bfe
       * @param {any} special_tokens
       * @param {string} pat_str
       */
      constructor(tiktoken_bfe, special_tokens, pat_str) {
        if (wasm == null) throw new Error("tiktoken: WASM binary has not been propery initialized.");
        const ptr0 = passStringToWasm0(tiktoken_bfe, wasm.__wbindgen_export_1, wasm.__wbindgen_export_2);
        const len0 = WASM_VECTOR_LEN;
        const ptr1 = passStringToWasm0(pat_str, wasm.__wbindgen_export_1, wasm.__wbindgen_export_2);
        const len1 = WASM_VECTOR_LEN;
        const ret = wasm.tiktoken_new(ptr0, len0, addHeapObject(special_tokens), ptr1, len1);
        this.__wbg_ptr = ret >>> 0;
        TiktokenFinalization.register(this, this.__wbg_ptr, this);
        return this;
      }
      /** @returns {string | undefined} */
      get name() {
        try {
          const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
          wasm.tiktoken_name(retptr, this.__wbg_ptr);
          var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);
          var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);
          let v1;
          if (r0 !== 0) {
            v1 = getStringFromWasm0(r0, r1).slice();
            wasm.__wbindgen_export_3(r0, r1 * 1, 1);
          }
          return v1;
        } finally {
          wasm.__wbindgen_add_to_stack_pointer(16);
        }
      }
      static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(_Tiktoken.prototype);
        obj.__wbg_ptr = ptr;
        TiktokenFinalization.register(obj, obj.__wbg_ptr, obj);
        return obj;
      }
      __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        TiktokenFinalization.unregister(this);
        return ptr;
      }
      free() {
        if (wasm == null) throw new Error("tiktoken: WASM binary has not been propery initialized.");
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_tiktoken_free(ptr, 0);
      }
      /**
       * @param {string} text
       * @param {any} allowed_special
       * @param {any} disallowed_special
       * @returns {Uint32Array}
       */
      encode(text, allowed_special, disallowed_special) {
        if (wasm == null) throw new Error("tiktoken: WASM binary has not been propery initialized.");
        try {
          const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
          const ptr0 = passStringToWasm0(text, wasm.__wbindgen_export_1, wasm.__wbindgen_export_2);
          const len0 = WASM_VECTOR_LEN;
          wasm.tiktoken_encode(retptr, this.__wbg_ptr, ptr0, len0, addHeapObject(allowed_special), addHeapObject(disallowed_special));
          var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);
          var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);
          var r2 = getDataViewMemory0().getInt32(retptr + 4 * 2, true);
          var r3 = getDataViewMemory0().getInt32(retptr + 4 * 3, true);
          if (r3) {
            throw takeObject(r2);
          }
          var v2 = getArrayU32FromWasm0(r0, r1).slice();
          wasm.__wbindgen_export_3(r0, r1 * 4, 4);
          return v2;
        } finally {
          wasm.__wbindgen_add_to_stack_pointer(16);
        }
      }
      /**
       * @param {string} text
       * @returns {Uint32Array}
       */
      encode_ordinary(text) {
        if (wasm == null) throw new Error("tiktoken: WASM binary has not been propery initialized.");
        try {
          const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
          const ptr0 = passStringToWasm0(text, wasm.__wbindgen_export_1, wasm.__wbindgen_export_2);
          const len0 = WASM_VECTOR_LEN;
          wasm.tiktoken_encode_ordinary(retptr, this.__wbg_ptr, ptr0, len0);
          var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);
          var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);
          var v2 = getArrayU32FromWasm0(r0, r1).slice();
          wasm.__wbindgen_export_3(r0, r1 * 4, 4);
          return v2;
        } finally {
          wasm.__wbindgen_add_to_stack_pointer(16);
        }
      }
      /**
       * @param {string} text
       * @param {any} allowed_special
       * @param {any} disallowed_special
       * @returns {any}
       */
      encode_with_unstable(text, allowed_special, disallowed_special) {
        if (wasm == null) throw new Error("tiktoken: WASM binary has not been propery initialized.");
        try {
          const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
          const ptr0 = passStringToWasm0(text, wasm.__wbindgen_export_1, wasm.__wbindgen_export_2);
          const len0 = WASM_VECTOR_LEN;
          wasm.tiktoken_encode_with_unstable(retptr, this.__wbg_ptr, ptr0, len0, addHeapObject(allowed_special), addHeapObject(disallowed_special));
          var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);
          var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);
          var r2 = getDataViewMemory0().getInt32(retptr + 4 * 2, true);
          if (r2) {
            throw takeObject(r1);
          }
          return takeObject(r0);
        } finally {
          wasm.__wbindgen_add_to_stack_pointer(16);
        }
      }
      /**
       * @param {Uint8Array} bytes
       * @returns {number}
       */
      encode_single_token(bytes) {
        if (wasm == null) throw new Error("tiktoken: WASM binary has not been propery initialized.");
        const ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_export_1);
        const len0 = WASM_VECTOR_LEN;
        const ret = wasm.tiktoken_encode_single_token(this.__wbg_ptr, ptr0, len0);
        return ret >>> 0;
      }
      /**
       * @param {Uint32Array} tokens
       * @returns {Uint8Array}
       */
      decode(tokens) {
        if (wasm == null) throw new Error("tiktoken: WASM binary has not been propery initialized.");
        try {
          const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
          const ptr0 = passArray32ToWasm0(tokens, wasm.__wbindgen_export_1);
          const len0 = WASM_VECTOR_LEN;
          wasm.tiktoken_decode(retptr, this.__wbg_ptr, ptr0, len0);
          var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);
          var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);
          var v2 = getArrayU8FromWasm0(r0, r1).slice();
          wasm.__wbindgen_export_3(r0, r1 * 1, 1);
          return v2;
        } finally {
          wasm.__wbindgen_add_to_stack_pointer(16);
        }
      }
      /**
       * @param {number} token
       * @returns {Uint8Array}
       */
      decode_single_token_bytes(token) {
        if (wasm == null) throw new Error("tiktoken: WASM binary has not been propery initialized.");
        try {
          const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
          wasm.tiktoken_decode_single_token_bytes(retptr, this.__wbg_ptr, token);
          var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);
          var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);
          var v1 = getArrayU8FromWasm0(r0, r1).slice();
          wasm.__wbindgen_export_3(r0, r1 * 1, 1);
          return v1;
        } finally {
          wasm.__wbindgen_add_to_stack_pointer(16);
        }
      }
      /** @returns {any} */
      token_byte_values() {
        if (wasm == null) throw new Error("tiktoken: WASM binary has not been propery initialized.");
        const ret = wasm.tiktoken_token_byte_values(this.__wbg_ptr);
        return takeObject(ret);
      }
    };
    module2.exports.Tiktoken = Tiktoken;
    module2.exports.__wbg_parse_def2e24ef1252aff = function() {
      return handleError(function(arg0, arg1) {
        const ret = JSON.parse(getStringFromWasm0(arg0, arg1));
        return addHeapObject(ret);
      }, arguments);
    };
    module2.exports.__wbg_stringify_f7ed6987935b4a24 = function() {
      return handleError(function(arg0) {
        const ret = JSON.stringify(getObject(arg0));
        return addHeapObject(ret);
      }, arguments);
    };
    module2.exports.__wbindgen_error_new = function(arg0, arg1) {
      const ret = new Error(getStringFromWasm0(arg0, arg1));
      return addHeapObject(ret);
    };
    module2.exports.__wbindgen_is_undefined = function(arg0) {
      const ret = getObject(arg0) === void 0;
      return ret;
    };
    module2.exports.__wbindgen_object_drop_ref = function(arg0) {
      takeObject(arg0);
    };
    module2.exports.__wbindgen_string_get = function(arg0, arg1) {
      if (wasm == null) throw new Error("tiktoken: WASM binary has not been propery initialized.");
      const obj = getObject(arg1);
      const ret = typeof obj === "string" ? obj : void 0;
      var ptr1 = isLikeNone(ret) ? 0 : passStringToWasm0(ret, wasm.__wbindgen_export_1, wasm.__wbindgen_export_2);
      var len1 = WASM_VECTOR_LEN;
      getDataViewMemory0().setInt32(arg0 + 4 * 1, len1, true);
      getDataViewMemory0().setInt32(arg0 + 4 * 0, ptr1, true);
    };
    module2.exports.__wbindgen_throw = function(arg0, arg1) {
      throw new Error(getStringFromWasm0(arg0, arg1));
    };
  }
});

// node_modules/tiktoken/tiktoken.cjs
var require_tiktoken = __commonJS({
  "node_modules/tiktoken/tiktoken.cjs"(exports2) {
    var wasm = require_tiktoken_bg();
    var imports = {};
    imports["./tiktoken_bg.js"] = wasm;
    var path4 = require("path");
    var fs5 = require("fs");
    var candidates = __dirname.split(path4.sep).reduce((memo, _, index, array) => {
      const prefix = array.slice(0, index + 1).join(path4.sep) + path4.sep;
      if (!prefix.includes("node_modules" + path4.sep)) {
        memo.unshift(
          path4.join(
            prefix,
            "node_modules",
            "tiktoken",
            "",
            "./tiktoken_bg.wasm"
          )
        );
      }
      return memo;
    }, []);
    candidates.unshift(path4.join(__dirname, "./tiktoken_bg.wasm"));
    var bytes = null;
    for (const candidate of candidates) {
      try {
        bytes = fs5.readFileSync(candidate);
        break;
      } catch {
      }
    }
    if (bytes == null) throw new Error("Missing tiktoken_bg.wasm");
    var wasmModule = new WebAssembly.Module(bytes);
    var wasmInstance = new WebAssembly.Instance(wasmModule, imports);
    wasm.__wbg_set_wasm(wasmInstance.exports);
    exports2["get_encoding"] = wasm["get_encoding"];
    exports2["encoding_for_model"] = wasm["encoding_for_model"];
    exports2["Tiktoken"] = wasm["Tiktoken"];
  }
});

// src/index.ts
var import_fs3 = require("fs");
var import_promises2 = require("fs/promises");
var import_os = require("os");
var import_path3 = require("path");
init_utils();

// node_modules/@musistudio/llms/dist/esm/server.mjs
var import_node_fs = require("node:fs");
var import_node_path3 = require("node:path");
var import_node_stream = __toESM(require("node:stream"), 1);
var import_node_util = require("node:util");
var import_node_buffer = require("node:buffer");
var import_node_util2 = require("node:util");
var import_node_http = __toESM(require("node:http"), 1);
var import_node_net = require("node:net");
var import_node_url = require("node:url");
var import_node_util3 = require("node:util");
var import_node_http2 = __toESM(require("node:http"), 1);
var import_node_https = __toESM(require("node:https"), 1);
var import_node_zlib = __toESM(require("node:zlib"), 1);
var import_node_stream2 = __toESM(require("node:stream"), 1);
var import_node_buffer2 = require("node:buffer");
var import_fastify = __toESM(require_fastify(), 1);
var import_cors = __toESM(require_cors(), 1);
var import_fs = require("fs");
var import_path = require("path");
var import_dotenv = __toESM(require_main(), 1);
var import_node_fs2 = __toESM(require("node:fs"), 1);
var import_undici = __toESM(require_undici(), 1);
var import_crypto = require("crypto");
var import_crypto2 = require("crypto");
var import_node_module = __toESM(require("node:module"), 1);
var jy = Object.create;
var Fa = Object.defineProperty;
var Ly = Object.getOwnPropertyDescriptor;
var Uy = Object.getOwnPropertyNames;
var My = Object.getPrototypeOf;
var $y = Object.prototype.hasOwnProperty;
var Y = ((r) => typeof require < "u" ? require : typeof Proxy < "u" ? new Proxy(r, { get: (e, t) => (typeof require < "u" ? require : e)[t] }) : r)(function(r) {
  if (typeof require < "u") return require.apply(this, arguments);
  throw Error('Dynamic require of "' + r + '" is not supported');
});
var Me = (r, e) => () => (r && (e = r(r = 0)), e);
var z = (r, e) => () => (e || r((e = { exports: {} }).exports, e), e.exports);
var wf = (r, e) => {
  for (var t in e) Fa(r, t, { get: e[t], enumerable: true });
};
var Hy = (r, e, t, n) => {
  if (e && typeof e == "object" || typeof e == "function") for (let o of Uy(e)) !$y.call(r, o) && o !== t && Fa(r, o, { get: () => e[o], enumerable: !(n = Ly(e, o)) || n.enumerable });
  return r;
};
var Jr = (r, e, t) => (t = r != null ? jy(My(r)) : {}, Hy(e || !r || !r.__esModule ? Fa(t, "default", { value: r, enumerable: true }) : t, r));
var Af = z((eA, co) => {
  co.exports.Space_Separator = /[\u1680\u2000-\u200A\u202F\u205F\u3000]/;
  co.exports.ID_Start = /[\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u05D0-\u05EA\u05F0-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u0860-\u086A\u08A0-\u08B4\u08B6-\u08BD\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u09FC\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0AF9\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C58-\u0C5A\u0C60\u0C61\u0C80\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D54-\u0D56\u0D5F-\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1877\u1880-\u1884\u1887-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4B\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1C80-\u1C88\u1CE9-\u1CEC\u1CEE-\u1CF1\u1CF5\u1CF6\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u212F-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2E2F\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303C\u3041-\u3096\u309D-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312E\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FEA\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA69D\uA6A0-\uA6EF\uA717-\uA71F\uA722-\uA788\uA78B-\uA7AE\uA7B0-\uA7B7\uA7F7-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA8FD\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uA9E0-\uA9E4\uA9E6-\uA9EF\uA9FA-\uA9FE\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA7E-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB65\uAB70-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]|\uD800[\uDC00-\uDC0B\uDC0D-\uDC26\uDC28-\uDC3A\uDC3C\uDC3D\uDC3F-\uDC4D\uDC50-\uDC5D\uDC80-\uDCFA\uDD40-\uDD74\uDE80-\uDE9C\uDEA0-\uDED0\uDF00-\uDF1F\uDF2D-\uDF4A\uDF50-\uDF75\uDF80-\uDF9D\uDFA0-\uDFC3\uDFC8-\uDFCF\uDFD1-\uDFD5]|\uD801[\uDC00-\uDC9D\uDCB0-\uDCD3\uDCD8-\uDCFB\uDD00-\uDD27\uDD30-\uDD63\uDE00-\uDF36\uDF40-\uDF55\uDF60-\uDF67]|\uD802[\uDC00-\uDC05\uDC08\uDC0A-\uDC35\uDC37\uDC38\uDC3C\uDC3F-\uDC55\uDC60-\uDC76\uDC80-\uDC9E\uDCE0-\uDCF2\uDCF4\uDCF5\uDD00-\uDD15\uDD20-\uDD39\uDD80-\uDDB7\uDDBE\uDDBF\uDE00\uDE10-\uDE13\uDE15-\uDE17\uDE19-\uDE33\uDE60-\uDE7C\uDE80-\uDE9C\uDEC0-\uDEC7\uDEC9-\uDEE4\uDF00-\uDF35\uDF40-\uDF55\uDF60-\uDF72\uDF80-\uDF91]|\uD803[\uDC00-\uDC48\uDC80-\uDCB2\uDCC0-\uDCF2]|\uD804[\uDC03-\uDC37\uDC83-\uDCAF\uDCD0-\uDCE8\uDD03-\uDD26\uDD50-\uDD72\uDD76\uDD83-\uDDB2\uDDC1-\uDDC4\uDDDA\uDDDC\uDE00-\uDE11\uDE13-\uDE2B\uDE80-\uDE86\uDE88\uDE8A-\uDE8D\uDE8F-\uDE9D\uDE9F-\uDEA8\uDEB0-\uDEDE\uDF05-\uDF0C\uDF0F\uDF10\uDF13-\uDF28\uDF2A-\uDF30\uDF32\uDF33\uDF35-\uDF39\uDF3D\uDF50\uDF5D-\uDF61]|\uD805[\uDC00-\uDC34\uDC47-\uDC4A\uDC80-\uDCAF\uDCC4\uDCC5\uDCC7\uDD80-\uDDAE\uDDD8-\uDDDB\uDE00-\uDE2F\uDE44\uDE80-\uDEAA\uDF00-\uDF19]|\uD806[\uDCA0-\uDCDF\uDCFF\uDE00\uDE0B-\uDE32\uDE3A\uDE50\uDE5C-\uDE83\uDE86-\uDE89\uDEC0-\uDEF8]|\uD807[\uDC00-\uDC08\uDC0A-\uDC2E\uDC40\uDC72-\uDC8F\uDD00-\uDD06\uDD08\uDD09\uDD0B-\uDD30\uDD46]|\uD808[\uDC00-\uDF99]|\uD809[\uDC00-\uDC6E\uDC80-\uDD43]|[\uD80C\uD81C-\uD820\uD840-\uD868\uD86A-\uD86C\uD86F-\uD872\uD874-\uD879][\uDC00-\uDFFF]|\uD80D[\uDC00-\uDC2E]|\uD811[\uDC00-\uDE46]|\uD81A[\uDC00-\uDE38\uDE40-\uDE5E\uDED0-\uDEED\uDF00-\uDF2F\uDF40-\uDF43\uDF63-\uDF77\uDF7D-\uDF8F]|\uD81B[\uDF00-\uDF44\uDF50\uDF93-\uDF9F\uDFE0\uDFE1]|\uD821[\uDC00-\uDFEC]|\uD822[\uDC00-\uDEF2]|\uD82C[\uDC00-\uDD1E\uDD70-\uDEFB]|\uD82F[\uDC00-\uDC6A\uDC70-\uDC7C\uDC80-\uDC88\uDC90-\uDC99]|\uD835[\uDC00-\uDC54\uDC56-\uDC9C\uDC9E\uDC9F\uDCA2\uDCA5\uDCA6\uDCA9-\uDCAC\uDCAE-\uDCB9\uDCBB\uDCBD-\uDCC3\uDCC5-\uDD05\uDD07-\uDD0A\uDD0D-\uDD14\uDD16-\uDD1C\uDD1E-\uDD39\uDD3B-\uDD3E\uDD40-\uDD44\uDD46\uDD4A-\uDD50\uDD52-\uDEA5\uDEA8-\uDEC0\uDEC2-\uDEDA\uDEDC-\uDEFA\uDEFC-\uDF14\uDF16-\uDF34\uDF36-\uDF4E\uDF50-\uDF6E\uDF70-\uDF88\uDF8A-\uDFA8\uDFAA-\uDFC2\uDFC4-\uDFCB]|\uD83A[\uDC00-\uDCC4\uDD00-\uDD43]|\uD83B[\uDE00-\uDE03\uDE05-\uDE1F\uDE21\uDE22\uDE24\uDE27\uDE29-\uDE32\uDE34-\uDE37\uDE39\uDE3B\uDE42\uDE47\uDE49\uDE4B\uDE4D-\uDE4F\uDE51\uDE52\uDE54\uDE57\uDE59\uDE5B\uDE5D\uDE5F\uDE61\uDE62\uDE64\uDE67-\uDE6A\uDE6C-\uDE72\uDE74-\uDE77\uDE79-\uDE7C\uDE7E\uDE80-\uDE89\uDE8B-\uDE9B\uDEA1-\uDEA3\uDEA5-\uDEA9\uDEAB-\uDEBB]|\uD869[\uDC00-\uDED6\uDF00-\uDFFF]|\uD86D[\uDC00-\uDF34\uDF40-\uDFFF]|\uD86E[\uDC00-\uDC1D\uDC20-\uDFFF]|\uD873[\uDC00-\uDEA1\uDEB0-\uDFFF]|\uD87A[\uDC00-\uDFE0]|\uD87E[\uDC00-\uDE1D]/;
  co.exports.ID_Continue = /[\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0300-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u0483-\u0487\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u05D0-\u05EA\u05F0-\u05F2\u0610-\u061A\u0620-\u0669\u066E-\u06D3\u06D5-\u06DC\u06DF-\u06E8\u06EA-\u06FC\u06FF\u0710-\u074A\u074D-\u07B1\u07C0-\u07F5\u07FA\u0800-\u082D\u0840-\u085B\u0860-\u086A\u08A0-\u08B4\u08B6-\u08BD\u08D4-\u08E1\u08E3-\u0963\u0966-\u096F\u0971-\u0983\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BC-\u09C4\u09C7\u09C8\u09CB-\u09CE\u09D7\u09DC\u09DD\u09DF-\u09E3\u09E6-\u09F1\u09FC\u0A01-\u0A03\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A3C\u0A3E-\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A59-\u0A5C\u0A5E\u0A66-\u0A75\u0A81-\u0A83\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABC-\u0AC5\u0AC7-\u0AC9\u0ACB-\u0ACD\u0AD0\u0AE0-\u0AE3\u0AE6-\u0AEF\u0AF9-\u0AFF\u0B01-\u0B03\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3C-\u0B44\u0B47\u0B48\u0B4B-\u0B4D\u0B56\u0B57\u0B5C\u0B5D\u0B5F-\u0B63\u0B66-\u0B6F\u0B71\u0B82\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BBE-\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCD\u0BD0\u0BD7\u0BE6-\u0BEF\u0C00-\u0C03\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D-\u0C44\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C58-\u0C5A\u0C60-\u0C63\u0C66-\u0C6F\u0C80-\u0C83\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBC-\u0CC4\u0CC6-\u0CC8\u0CCA-\u0CCD\u0CD5\u0CD6\u0CDE\u0CE0-\u0CE3\u0CE6-\u0CEF\u0CF1\u0CF2\u0D00-\u0D03\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D44\u0D46-\u0D48\u0D4A-\u0D4E\u0D54-\u0D57\u0D5F-\u0D63\u0D66-\u0D6F\u0D7A-\u0D7F\u0D82\u0D83\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0DCA\u0DCF-\u0DD4\u0DD6\u0DD8-\u0DDF\u0DE6-\u0DEF\u0DF2\u0DF3\u0E01-\u0E3A\u0E40-\u0E4E\u0E50-\u0E59\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB9\u0EBB-\u0EBD\u0EC0-\u0EC4\u0EC6\u0EC8-\u0ECD\u0ED0-\u0ED9\u0EDC-\u0EDF\u0F00\u0F18\u0F19\u0F20-\u0F29\u0F35\u0F37\u0F39\u0F3E-\u0F47\u0F49-\u0F6C\u0F71-\u0F84\u0F86-\u0F97\u0F99-\u0FBC\u0FC6\u1000-\u1049\u1050-\u109D\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u135D-\u135F\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1714\u1720-\u1734\u1740-\u1753\u1760-\u176C\u176E-\u1770\u1772\u1773\u1780-\u17D3\u17D7\u17DC\u17DD\u17E0-\u17E9\u180B-\u180D\u1810-\u1819\u1820-\u1877\u1880-\u18AA\u18B0-\u18F5\u1900-\u191E\u1920-\u192B\u1930-\u193B\u1946-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u19D0-\u19D9\u1A00-\u1A1B\u1A20-\u1A5E\u1A60-\u1A7C\u1A7F-\u1A89\u1A90-\u1A99\u1AA7\u1AB0-\u1ABD\u1B00-\u1B4B\u1B50-\u1B59\u1B6B-\u1B73\u1B80-\u1BF3\u1C00-\u1C37\u1C40-\u1C49\u1C4D-\u1C7D\u1C80-\u1C88\u1CD0-\u1CD2\u1CD4-\u1CF9\u1D00-\u1DF9\u1DFB-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u203F\u2040\u2054\u2071\u207F\u2090-\u209C\u20D0-\u20DC\u20E1\u20E5-\u20F0\u2102\u2107\u210A-\u2113\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u212F-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D7F-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2DE0-\u2DFF\u2E2F\u3005-\u3007\u3021-\u302F\u3031-\u3035\u3038-\u303C\u3041-\u3096\u3099\u309A\u309D-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312E\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FEA\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA62B\uA640-\uA66F\uA674-\uA67D\uA67F-\uA6F1\uA717-\uA71F\uA722-\uA788\uA78B-\uA7AE\uA7B0-\uA7B7\uA7F7-\uA827\uA840-\uA873\uA880-\uA8C5\uA8D0-\uA8D9\uA8E0-\uA8F7\uA8FB\uA8FD\uA900-\uA92D\uA930-\uA953\uA960-\uA97C\uA980-\uA9C0\uA9CF-\uA9D9\uA9E0-\uA9FE\uAA00-\uAA36\uAA40-\uAA4D\uAA50-\uAA59\uAA60-\uAA76\uAA7A-\uAAC2\uAADB-\uAADD\uAAE0-\uAAEF\uAAF2-\uAAF6\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB65\uAB70-\uABEA\uABEC\uABED\uABF0-\uABF9\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE00-\uFE0F\uFE20-\uFE2F\uFE33\uFE34\uFE4D-\uFE4F\uFE70-\uFE74\uFE76-\uFEFC\uFF10-\uFF19\uFF21-\uFF3A\uFF3F\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]|\uD800[\uDC00-\uDC0B\uDC0D-\uDC26\uDC28-\uDC3A\uDC3C\uDC3D\uDC3F-\uDC4D\uDC50-\uDC5D\uDC80-\uDCFA\uDD40-\uDD74\uDDFD\uDE80-\uDE9C\uDEA0-\uDED0\uDEE0\uDF00-\uDF1F\uDF2D-\uDF4A\uDF50-\uDF7A\uDF80-\uDF9D\uDFA0-\uDFC3\uDFC8-\uDFCF\uDFD1-\uDFD5]|\uD801[\uDC00-\uDC9D\uDCA0-\uDCA9\uDCB0-\uDCD3\uDCD8-\uDCFB\uDD00-\uDD27\uDD30-\uDD63\uDE00-\uDF36\uDF40-\uDF55\uDF60-\uDF67]|\uD802[\uDC00-\uDC05\uDC08\uDC0A-\uDC35\uDC37\uDC38\uDC3C\uDC3F-\uDC55\uDC60-\uDC76\uDC80-\uDC9E\uDCE0-\uDCF2\uDCF4\uDCF5\uDD00-\uDD15\uDD20-\uDD39\uDD80-\uDDB7\uDDBE\uDDBF\uDE00-\uDE03\uDE05\uDE06\uDE0C-\uDE13\uDE15-\uDE17\uDE19-\uDE33\uDE38-\uDE3A\uDE3F\uDE60-\uDE7C\uDE80-\uDE9C\uDEC0-\uDEC7\uDEC9-\uDEE6\uDF00-\uDF35\uDF40-\uDF55\uDF60-\uDF72\uDF80-\uDF91]|\uD803[\uDC00-\uDC48\uDC80-\uDCB2\uDCC0-\uDCF2]|\uD804[\uDC00-\uDC46\uDC66-\uDC6F\uDC7F-\uDCBA\uDCD0-\uDCE8\uDCF0-\uDCF9\uDD00-\uDD34\uDD36-\uDD3F\uDD50-\uDD73\uDD76\uDD80-\uDDC4\uDDCA-\uDDCC\uDDD0-\uDDDA\uDDDC\uDE00-\uDE11\uDE13-\uDE37\uDE3E\uDE80-\uDE86\uDE88\uDE8A-\uDE8D\uDE8F-\uDE9D\uDE9F-\uDEA8\uDEB0-\uDEEA\uDEF0-\uDEF9\uDF00-\uDF03\uDF05-\uDF0C\uDF0F\uDF10\uDF13-\uDF28\uDF2A-\uDF30\uDF32\uDF33\uDF35-\uDF39\uDF3C-\uDF44\uDF47\uDF48\uDF4B-\uDF4D\uDF50\uDF57\uDF5D-\uDF63\uDF66-\uDF6C\uDF70-\uDF74]|\uD805[\uDC00-\uDC4A\uDC50-\uDC59\uDC80-\uDCC5\uDCC7\uDCD0-\uDCD9\uDD80-\uDDB5\uDDB8-\uDDC0\uDDD8-\uDDDD\uDE00-\uDE40\uDE44\uDE50-\uDE59\uDE80-\uDEB7\uDEC0-\uDEC9\uDF00-\uDF19\uDF1D-\uDF2B\uDF30-\uDF39]|\uD806[\uDCA0-\uDCE9\uDCFF\uDE00-\uDE3E\uDE47\uDE50-\uDE83\uDE86-\uDE99\uDEC0-\uDEF8]|\uD807[\uDC00-\uDC08\uDC0A-\uDC36\uDC38-\uDC40\uDC50-\uDC59\uDC72-\uDC8F\uDC92-\uDCA7\uDCA9-\uDCB6\uDD00-\uDD06\uDD08\uDD09\uDD0B-\uDD36\uDD3A\uDD3C\uDD3D\uDD3F-\uDD47\uDD50-\uDD59]|\uD808[\uDC00-\uDF99]|\uD809[\uDC00-\uDC6E\uDC80-\uDD43]|[\uD80C\uD81C-\uD820\uD840-\uD868\uD86A-\uD86C\uD86F-\uD872\uD874-\uD879][\uDC00-\uDFFF]|\uD80D[\uDC00-\uDC2E]|\uD811[\uDC00-\uDE46]|\uD81A[\uDC00-\uDE38\uDE40-\uDE5E\uDE60-\uDE69\uDED0-\uDEED\uDEF0-\uDEF4\uDF00-\uDF36\uDF40-\uDF43\uDF50-\uDF59\uDF63-\uDF77\uDF7D-\uDF8F]|\uD81B[\uDF00-\uDF44\uDF50-\uDF7E\uDF8F-\uDF9F\uDFE0\uDFE1]|\uD821[\uDC00-\uDFEC]|\uD822[\uDC00-\uDEF2]|\uD82C[\uDC00-\uDD1E\uDD70-\uDEFB]|\uD82F[\uDC00-\uDC6A\uDC70-\uDC7C\uDC80-\uDC88\uDC90-\uDC99\uDC9D\uDC9E]|\uD834[\uDD65-\uDD69\uDD6D-\uDD72\uDD7B-\uDD82\uDD85-\uDD8B\uDDAA-\uDDAD\uDE42-\uDE44]|\uD835[\uDC00-\uDC54\uDC56-\uDC9C\uDC9E\uDC9F\uDCA2\uDCA5\uDCA6\uDCA9-\uDCAC\uDCAE-\uDCB9\uDCBB\uDCBD-\uDCC3\uDCC5-\uDD05\uDD07-\uDD0A\uDD0D-\uDD14\uDD16-\uDD1C\uDD1E-\uDD39\uDD3B-\uDD3E\uDD40-\uDD44\uDD46\uDD4A-\uDD50\uDD52-\uDEA5\uDEA8-\uDEC0\uDEC2-\uDEDA\uDEDC-\uDEFA\uDEFC-\uDF14\uDF16-\uDF34\uDF36-\uDF4E\uDF50-\uDF6E\uDF70-\uDF88\uDF8A-\uDFA8\uDFAA-\uDFC2\uDFC4-\uDFCB\uDFCE-\uDFFF]|\uD836[\uDE00-\uDE36\uDE3B-\uDE6C\uDE75\uDE84\uDE9B-\uDE9F\uDEA1-\uDEAF]|\uD838[\uDC00-\uDC06\uDC08-\uDC18\uDC1B-\uDC21\uDC23\uDC24\uDC26-\uDC2A]|\uD83A[\uDC00-\uDCC4\uDCD0-\uDCD6\uDD00-\uDD4A\uDD50-\uDD59]|\uD83B[\uDE00-\uDE03\uDE05-\uDE1F\uDE21\uDE22\uDE24\uDE27\uDE29-\uDE32\uDE34-\uDE37\uDE39\uDE3B\uDE42\uDE47\uDE49\uDE4B\uDE4D-\uDE4F\uDE51\uDE52\uDE54\uDE57\uDE59\uDE5B\uDE5D\uDE5F\uDE61\uDE62\uDE64\uDE67-\uDE6A\uDE6C-\uDE72\uDE74-\uDE77\uDE79-\uDE7C\uDE7E\uDE80-\uDE89\uDE8B-\uDE9B\uDEA1-\uDEA3\uDEA5-\uDEA9\uDEAB-\uDEBB]|\uD869[\uDC00-\uDED6\uDF00-\uDFFF]|\uD86D[\uDC00-\uDF34\uDF40-\uDFFF]|\uD86E[\uDC00-\uDC1D\uDC20-\uDFFF]|\uD873[\uDC00-\uDEA1\uDEB0-\uDFFF]|\uD87A[\uDC00-\uDFE0]|\uD87E[\uDC00-\uDE1D]|\uDB40[\uDD00-\uDDEF]/;
});
var Oa = z((tA, Df) => {
  var ka = Af();
  Df.exports = { isSpaceSeparator(r) {
    return typeof r == "string" && ka.Space_Separator.test(r);
  }, isIdStartChar(r) {
    return typeof r == "string" && (r >= "a" && r <= "z" || r >= "A" && r <= "Z" || r === "$" || r === "_" || ka.ID_Start.test(r));
  }, isIdContinueChar(r) {
    return typeof r == "string" && (r >= "a" && r <= "z" || r >= "A" && r <= "Z" || r >= "0" && r <= "9" || r === "$" || r === "_" || r === "\u200C" || r === "\u200D" || ka.ID_Continue.test(r));
  }, isDigit(r) {
    return typeof r == "string" && /[0-9]/.test(r);
  }, isHexDigit(r) {
    return typeof r == "string" && /[0-9A-Fa-f]/.test(r);
  } };
});
var Ff = z((rA, Rf) => {
  var $e = Oa(), xa, et, lr, fo, Tr, xt, He, Na, os2;
  Rf.exports = function(e, t) {
    xa = String(e), et = "start", lr = [], fo = 0, Tr = 1, xt = 0, He = void 0, Na = void 0, os2 = void 0;
    do
      He = Gy(), Jy[et]();
    while (He.type !== "eof");
    return typeof t == "function" ? Ba({ "": os2 }, "", t) : os2;
  };
  function Ba(r, e, t) {
    let n = r[e];
    if (n != null && typeof n == "object") if (Array.isArray(n)) for (let o = 0; o < n.length; o++) {
      let a = String(o), u = Ba(n, a, t);
      u === void 0 ? delete n[a] : Object.defineProperty(n, a, { value: u, writable: true, enumerable: true, configurable: true });
    }
    else for (let o in n) {
      let a = Ba(n, o, t);
      a === void 0 ? delete n[o] : Object.defineProperty(n, o, { value: a, writable: true, enumerable: true, configurable: true });
    }
    return t.call(r, e, n);
  }
  var me, de, ss, cr, Ce;
  function Gy() {
    for (me = "default", de = "", ss = false, cr = 1; ; ) {
      Ce = fr();
      let r = vf[me]();
      if (r) return r;
    }
  }
  function fr() {
    if (xa[fo]) return String.fromCodePoint(xa.codePointAt(fo));
  }
  function $() {
    let r = fr();
    return r === `
` ? (Tr++, xt = 0) : r ? xt += r.length : xt++, r && (fo += r.length), r;
  }
  var vf = { default() {
    switch (Ce) {
      case "	":
      case "\v":
      case "\f":
      case " ":
      case "\xA0":
      case "\uFEFF":
      case `
`:
      case "\r":
      case "\u2028":
      case "\u2029":
        $();
        return;
      case "/":
        $(), me = "comment";
        return;
      case void 0:
        return $(), Pe("eof");
    }
    if ($e.isSpaceSeparator(Ce)) {
      $();
      return;
    }
    return vf[et]();
  }, comment() {
    switch (Ce) {
      case "*":
        $(), me = "multiLineComment";
        return;
      case "/":
        $(), me = "singleLineComment";
        return;
    }
    throw xe($());
  }, multiLineComment() {
    switch (Ce) {
      case "*":
        $(), me = "multiLineCommentAsterisk";
        return;
      case void 0:
        throw xe($());
    }
    $();
  }, multiLineCommentAsterisk() {
    switch (Ce) {
      case "*":
        $();
        return;
      case "/":
        $(), me = "default";
        return;
      case void 0:
        throw xe($());
    }
    $(), me = "multiLineComment";
  }, singleLineComment() {
    switch (Ce) {
      case `
`:
      case "\r":
      case "\u2028":
      case "\u2029":
        $(), me = "default";
        return;
      case void 0:
        return $(), Pe("eof");
    }
    $();
  }, value() {
    switch (Ce) {
      case "{":
      case "[":
        return Pe("punctuator", $());
      case "n":
        return $(), Vr("ull"), Pe("null", null);
      case "t":
        return $(), Vr("rue"), Pe("boolean", true);
      case "f":
        return $(), Vr("alse"), Pe("boolean", false);
      case "-":
      case "+":
        $() === "-" && (cr = -1), me = "sign";
        return;
      case ".":
        de = $(), me = "decimalPointLeading";
        return;
      case "0":
        de = $(), me = "zero";
        return;
      case "1":
      case "2":
      case "3":
      case "4":
      case "5":
      case "6":
      case "7":
      case "8":
      case "9":
        de = $(), me = "decimalInteger";
        return;
      case "I":
        return $(), Vr("nfinity"), Pe("numeric", 1 / 0);
      case "N":
        return $(), Vr("aN"), Pe("numeric", NaN);
      case '"':
      case "'":
        ss = $() === '"', de = "", me = "string";
        return;
    }
    throw xe($());
  }, identifierNameStartEscape() {
    if (Ce !== "u") throw xe($());
    $();
    let r = Ia();
    switch (r) {
      case "$":
      case "_":
        break;
      default:
        if (!$e.isIdStartChar(r)) throw Sf();
        break;
    }
    de += r, me = "identifierName";
  }, identifierName() {
    switch (Ce) {
      case "$":
      case "_":
      case "\u200C":
      case "\u200D":
        de += $();
        return;
      case "\\":
        $(), me = "identifierNameEscape";
        return;
    }
    if ($e.isIdContinueChar(Ce)) {
      de += $();
      return;
    }
    return Pe("identifier", de);
  }, identifierNameEscape() {
    if (Ce !== "u") throw xe($());
    $();
    let r = Ia();
    switch (r) {
      case "$":
      case "_":
      case "\u200C":
      case "\u200D":
        break;
      default:
        if (!$e.isIdContinueChar(r)) throw Sf();
        break;
    }
    de += r, me = "identifierName";
  }, sign() {
    switch (Ce) {
      case ".":
        de = $(), me = "decimalPointLeading";
        return;
      case "0":
        de = $(), me = "zero";
        return;
      case "1":
      case "2":
      case "3":
      case "4":
      case "5":
      case "6":
      case "7":
      case "8":
      case "9":
        de = $(), me = "decimalInteger";
        return;
      case "I":
        return $(), Vr("nfinity"), Pe("numeric", cr * (1 / 0));
      case "N":
        return $(), Vr("aN"), Pe("numeric", NaN);
    }
    throw xe($());
  }, zero() {
    switch (Ce) {
      case ".":
        de += $(), me = "decimalPoint";
        return;
      case "e":
      case "E":
        de += $(), me = "decimalExponent";
        return;
      case "x":
      case "X":
        de += $(), me = "hexadecimal";
        return;
    }
    return Pe("numeric", cr * 0);
  }, decimalInteger() {
    switch (Ce) {
      case ".":
        de += $(), me = "decimalPoint";
        return;
      case "e":
      case "E":
        de += $(), me = "decimalExponent";
        return;
    }
    if ($e.isDigit(Ce)) {
      de += $();
      return;
    }
    return Pe("numeric", cr * Number(de));
  }, decimalPointLeading() {
    if ($e.isDigit(Ce)) {
      de += $(), me = "decimalFraction";
      return;
    }
    throw xe($());
  }, decimalPoint() {
    switch (Ce) {
      case "e":
      case "E":
        de += $(), me = "decimalExponent";
        return;
    }
    if ($e.isDigit(Ce)) {
      de += $(), me = "decimalFraction";
      return;
    }
    return Pe("numeric", cr * Number(de));
  }, decimalFraction() {
    switch (Ce) {
      case "e":
      case "E":
        de += $(), me = "decimalExponent";
        return;
    }
    if ($e.isDigit(Ce)) {
      de += $();
      return;
    }
    return Pe("numeric", cr * Number(de));
  }, decimalExponent() {
    switch (Ce) {
      case "+":
      case "-":
        de += $(), me = "decimalExponentSign";
        return;
    }
    if ($e.isDigit(Ce)) {
      de += $(), me = "decimalExponentInteger";
      return;
    }
    throw xe($());
  }, decimalExponentSign() {
    if ($e.isDigit(Ce)) {
      de += $(), me = "decimalExponentInteger";
      return;
    }
    throw xe($());
  }, decimalExponentInteger() {
    if ($e.isDigit(Ce)) {
      de += $();
      return;
    }
    return Pe("numeric", cr * Number(de));
  }, hexadecimal() {
    if ($e.isHexDigit(Ce)) {
      de += $(), me = "hexadecimalInteger";
      return;
    }
    throw xe($());
  }, hexadecimalInteger() {
    if ($e.isHexDigit(Ce)) {
      de += $();
      return;
    }
    return Pe("numeric", cr * Number(de));
  }, string() {
    switch (Ce) {
      case "\\":
        $(), de += Wy();
        return;
      case '"':
        if (ss) return $(), Pe("string", de);
        de += $();
        return;
      case "'":
        if (!ss) return $(), Pe("string", de);
        de += $();
        return;
      case `
`:
      case "\r":
        throw xe($());
      case "\u2028":
      case "\u2029":
        Vy(Ce);
        break;
      case void 0:
        throw xe($());
    }
    de += $();
  }, start() {
    switch (Ce) {
      case "{":
      case "[":
        return Pe("punctuator", $());
    }
    me = "value";
  }, beforePropertyName() {
    switch (Ce) {
      case "$":
      case "_":
        de = $(), me = "identifierName";
        return;
      case "\\":
        $(), me = "identifierNameStartEscape";
        return;
      case "}":
        return Pe("punctuator", $());
      case '"':
      case "'":
        ss = $() === '"', me = "string";
        return;
    }
    if ($e.isIdStartChar(Ce)) {
      de += $(), me = "identifierName";
      return;
    }
    throw xe($());
  }, afterPropertyName() {
    if (Ce === ":") return Pe("punctuator", $());
    throw xe($());
  }, beforePropertyValue() {
    me = "value";
  }, afterPropertyValue() {
    switch (Ce) {
      case ",":
      case "}":
        return Pe("punctuator", $());
    }
    throw xe($());
  }, beforeArrayValue() {
    if (Ce === "]") return Pe("punctuator", $());
    me = "value";
  }, afterArrayValue() {
    switch (Ce) {
      case ",":
      case "]":
        return Pe("punctuator", $());
    }
    throw xe($());
  }, end() {
    throw xe($());
  } };
  function Pe(r, e) {
    return { type: r, value: e, line: Tr, column: xt };
  }
  function Vr(r) {
    for (let e of r) {
      if (fr() !== e) throw xe($());
      $();
    }
  }
  function Wy() {
    switch (fr()) {
      case "b":
        return $(), "\b";
      case "f":
        return $(), "\f";
      case "n":
        return $(), `
`;
      case "r":
        return $(), "\r";
      case "t":
        return $(), "	";
      case "v":
        return $(), "\v";
      case "0":
        if ($(), $e.isDigit(fr())) throw xe($());
        return "\0";
      case "x":
        return $(), zy();
      case "u":
        return $(), Ia();
      case `
`:
      case "\u2028":
      case "\u2029":
        return $(), "";
      case "\r":
        return $(), fr() === `
` && $(), "";
      case "1":
      case "2":
      case "3":
      case "4":
      case "5":
      case "6":
      case "7":
      case "8":
      case "9":
        throw xe($());
      case void 0:
        throw xe($());
    }
    return $();
  }
  function zy() {
    let r = "", e = fr();
    if (!$e.isHexDigit(e) || (r += $(), e = fr(), !$e.isHexDigit(e))) throw xe($());
    return r += $(), String.fromCodePoint(parseInt(r, 16));
  }
  function Ia() {
    let r = "", e = 4;
    for (; e-- > 0; ) {
      let t = fr();
      if (!$e.isHexDigit(t)) throw xe($());
      r += $();
    }
    return String.fromCodePoint(parseInt(r, 16));
  }
  var Jy = { start() {
    if (He.type === "eof") throw Kr();
    Pa();
  }, beforePropertyName() {
    switch (He.type) {
      case "identifier":
      case "string":
        Na = He.value, et = "afterPropertyName";
        return;
      case "punctuator":
        lo();
        return;
      case "eof":
        throw Kr();
    }
  }, afterPropertyName() {
    if (He.type === "eof") throw Kr();
    et = "beforePropertyValue";
  }, beforePropertyValue() {
    if (He.type === "eof") throw Kr();
    Pa();
  }, beforeArrayValue() {
    if (He.type === "eof") throw Kr();
    if (He.type === "punctuator" && He.value === "]") {
      lo();
      return;
    }
    Pa();
  }, afterPropertyValue() {
    if (He.type === "eof") throw Kr();
    switch (He.value) {
      case ",":
        et = "beforePropertyName";
        return;
      case "}":
        lo();
    }
  }, afterArrayValue() {
    if (He.type === "eof") throw Kr();
    switch (He.value) {
      case ",":
        et = "beforeArrayValue";
        return;
      case "]":
        lo();
    }
  }, end() {
  } };
  function Pa() {
    let r;
    switch (He.type) {
      case "punctuator":
        switch (He.value) {
          case "{":
            r = {};
            break;
          case "[":
            r = [];
            break;
        }
        break;
      case "null":
      case "boolean":
      case "numeric":
      case "string":
        r = He.value;
        break;
    }
    if (os2 === void 0) os2 = r;
    else {
      let e = lr[lr.length - 1];
      Array.isArray(e) ? e.push(r) : Object.defineProperty(e, Na, { value: r, writable: true, enumerable: true, configurable: true });
    }
    if (r !== null && typeof r == "object") lr.push(r), Array.isArray(r) ? et = "beforeArrayValue" : et = "beforePropertyName";
    else {
      let e = lr[lr.length - 1];
      e == null ? et = "end" : Array.isArray(e) ? et = "afterArrayValue" : et = "afterPropertyValue";
    }
  }
  function lo() {
    lr.pop();
    let r = lr[lr.length - 1];
    r == null ? et = "end" : Array.isArray(r) ? et = "afterArrayValue" : et = "afterPropertyValue";
  }
  function xe(r) {
    return ho(r === void 0 ? `JSON5: invalid end of input at ${Tr}:${xt}` : `JSON5: invalid character '${Tf(r)}' at ${Tr}:${xt}`);
  }
  function Kr() {
    return ho(`JSON5: invalid end of input at ${Tr}:${xt}`);
  }
  function Sf() {
    return xt -= 5, ho(`JSON5: invalid identifier character at ${Tr}:${xt}`);
  }
  function Vy(r) {
    console.warn(`JSON5: '${Tf(r)}' in strings is not valid ECMAScript; consider escaping`);
  }
  function Tf(r) {
    let e = { "'": "\\'", '"': '\\"', "\\": "\\\\", "\b": "\\b", "\f": "\\f", "\n": "\\n", "\r": "\\r", "	": "\\t", "\v": "\\v", "\0": "\\0", "\u2028": "\\u2028", "\u2029": "\\u2029" };
    if (e[r]) return e[r];
    if (r < " ") {
      let t = r.charCodeAt(0).toString(16);
      return "\\x" + ("00" + t).substring(t.length);
    }
    return r;
  }
  function ho(r) {
    let e = new SyntaxError(r);
    return e.lineNumber = Tr, e.columnNumber = xt, e;
  }
});
var Of = z((nA, kf) => {
  var qa = Oa();
  kf.exports = function(e, t, n) {
    let o = [], a = "", u, l, f = "", d;
    if (t != null && typeof t == "object" && !Array.isArray(t) && (n = t.space, d = t.quote, t = t.replacer), typeof t == "function") l = t;
    else if (Array.isArray(t)) {
      u = [];
      for (let b of t) {
        let _;
        typeof b == "string" ? _ = b : (typeof b == "number" || b instanceof String || b instanceof Number) && (_ = String(b)), _ !== void 0 && u.indexOf(_) < 0 && u.push(_);
      }
    }
    return n instanceof Number ? n = Number(n) : n instanceof String && (n = String(n)), typeof n == "number" ? n > 0 && (n = Math.min(10, Math.floor(n)), f = "          ".substr(0, n)) : typeof n == "string" && (f = n.substr(0, 10)), h("", { "": e });
    function h(b, _) {
      let y = _[b];
      switch (y != null && (typeof y.toJSON5 == "function" ? y = y.toJSON5(b) : typeof y.toJSON == "function" && (y = y.toJSON(b))), l && (y = l.call(_, b, y)), y instanceof Number ? y = Number(y) : y instanceof String ? y = String(y) : y instanceof Boolean && (y = y.valueOf()), y) {
        case null:
          return "null";
        case true:
          return "true";
        case false:
          return "false";
      }
      if (typeof y == "string") return C(y, false);
      if (typeof y == "number") return String(y);
      if (typeof y == "object") return Array.isArray(y) ? S(y) : w(y);
    }
    function C(b) {
      let _ = { "'": 0.1, '"': 0.2 }, y = { "'": "\\'", '"': '\\"', "\\": "\\\\", "\b": "\\b", "\f": "\\f", "\n": "\\n", "\r": "\\r", "	": "\\t", "\v": "\\v", "\0": "\\0", "\u2028": "\\u2028", "\u2029": "\\u2029" }, T = "";
      for (let L = 0; L < b.length; L++) {
        let P = b[L];
        switch (P) {
          case "'":
          case '"':
            _[P]++, T += P;
            continue;
          case "\0":
            if (qa.isDigit(b[L + 1])) {
              T += "\\x00";
              continue;
            }
        }
        if (y[P]) {
          T += y[P];
          continue;
        }
        if (P < " ") {
          let j = P.charCodeAt(0).toString(16);
          T += "\\x" + ("00" + j).substring(j.length);
          continue;
        }
        T += P;
      }
      let k = d || Object.keys(_).reduce((L, P) => _[L] < _[P] ? L : P);
      return T = T.replace(new RegExp(k, "g"), y[k]), k + T + k;
    }
    function w(b) {
      if (o.indexOf(b) >= 0) throw TypeError("Converting circular structure to JSON5");
      o.push(b);
      let _ = a;
      a = a + f;
      let y = u || Object.keys(b), T = [];
      for (let L of y) {
        let P = h(L, b);
        if (P !== void 0) {
          let j = I(L) + ":";
          f !== "" && (j += " "), j += P, T.push(j);
        }
      }
      let k;
      if (T.length === 0) k = "{}";
      else {
        let L;
        if (f === "") L = T.join(","), k = "{" + L + "}";
        else {
          let P = `,
` + a;
          L = T.join(P), k = `{
` + a + L + `,
` + _ + "}";
        }
      }
      return o.pop(), a = _, k;
    }
    function I(b) {
      if (b.length === 0) return C(b, true);
      let _ = String.fromCodePoint(b.codePointAt(0));
      if (!qa.isIdStartChar(_)) return C(b, true);
      for (let y = _.length; y < b.length; y++) if (!qa.isIdContinueChar(String.fromCodePoint(b.codePointAt(y)))) return C(b, true);
      return b;
    }
    function S(b) {
      if (o.indexOf(b) >= 0) throw TypeError("Converting circular structure to JSON5");
      o.push(b);
      let _ = a;
      a = a + f;
      let y = [];
      for (let k = 0; k < b.length; k++) {
        let L = h(String(k), b);
        y.push(L !== void 0 ? L : "null");
      }
      let T;
      if (y.length === 0) T = "[]";
      else if (f === "") T = "[" + y.join(",") + "]";
      else {
        let k = `,
` + a, L = y.join(k);
        T = `[
` + a + L + `,
` + _ + "]";
      }
      return o.pop(), a = _, T;
    }
  };
});
var ja = z((sA, Pf) => {
  var Ky = Ff(), Yy = Of(), Xy = { parse: Ky, stringify: Yy };
  Pf.exports = Xy;
});
var $a = z(($A, Vf) => {
  "use strict";
  var Do = Object.prototype.hasOwnProperty, Jf = Object.prototype.toString, Mf = Object.defineProperty, $f = Object.getOwnPropertyDescriptor, Hf = function(e) {
    return typeof Array.isArray == "function" ? Array.isArray(e) : Jf.call(e) === "[object Array]";
  }, Gf = function(e) {
    if (!e || Jf.call(e) !== "[object Object]") return false;
    var t = Do.call(e, "constructor"), n = e.constructor && e.constructor.prototype && Do.call(e.constructor.prototype, "isPrototypeOf");
    if (e.constructor && !t && !n) return false;
    var o;
    for (o in e) ;
    return typeof o > "u" || Do.call(e, o);
  }, Wf = function(e, t) {
    Mf && t.name === "__proto__" ? Mf(e, t.name, { enumerable: true, configurable: true, value: t.newValue, writable: true }) : e[t.name] = t.newValue;
  }, zf = function(e, t) {
    if (t === "__proto__") if (Do.call(e, t)) {
      if ($f) return $f(e, t).value;
    } else return;
    return e[t];
  };
  Vf.exports = function r() {
    var e, t, n, o, a, u, l = arguments[0], f = 1, d = arguments.length, h = false;
    for (typeof l == "boolean" && (h = l, l = arguments[1] || {}, f = 2), (l == null || typeof l != "object" && typeof l != "function") && (l = {}); f < d; ++f) if (e = arguments[f], e != null) for (t in e) n = zf(l, t), o = zf(e, t), l !== o && (h && o && (Gf(o) || (a = Hf(o))) ? (a ? (a = false, u = n && Hf(n) ? n : []) : u = n && Gf(n) ? n : {}, Wf(l, { name: t, newValue: r(h, u, o) })) : typeof o < "u" && Wf(l, { name: t, newValue: o }));
    return l;
  };
});
var Kf = z((HA, h0) => {
  h0.exports = { name: "gaxios", version: "7.1.1", description: "A simple common HTTP client specifically for Google APIs and services.", main: "build/cjs/src/index.js", types: "build/cjs/src/index.d.ts", files: ["build/"], exports: { ".": { import: { types: "./build/esm/src/index.d.ts", default: "./build/esm/src/index.js" }, require: { types: "./build/cjs/src/index.d.ts", default: "./build/cjs/src/index.js" } } }, scripts: { lint: "gts check --no-inline-config", test: "c8 mocha build/esm/test", "presystem-test": "npm run compile", "system-test": "mocha build/esm/system-test --timeout 80000", compile: "tsc -b ./tsconfig.json ./tsconfig.cjs.json && node utils/enable-esm.mjs", fix: "gts fix", prepare: "npm run compile", pretest: "npm run compile", webpack: "webpack", "prebrowser-test": "npm run compile", "browser-test": "node build/browser-test/browser-test-runner.js", docs: "jsdoc -c .jsdoc.js", "docs-test": "linkinator docs", "predocs-test": "npm run docs", "samples-test": "cd samples/ && npm link ../ && npm test && cd ../", prelint: "cd samples; npm link ../; npm install", clean: "gts clean" }, repository: "googleapis/gaxios", keywords: ["google"], engines: { node: ">=18" }, author: "Google, LLC", license: "Apache-2.0", devDependencies: { "@babel/plugin-proposal-private-methods": "^7.18.6", "@types/cors": "^2.8.6", "@types/express": "^5.0.0", "@types/extend": "^3.0.1", "@types/mocha": "^10.0.10", "@types/multiparty": "4.2.1", "@types/mv": "^2.1.0", "@types/ncp": "^2.0.1", "@types/node": "^22.0.0", "@types/sinon": "^17.0.0", "@types/tmp": "0.2.6", assert: "^2.0.0", browserify: "^17.0.0", c8: "^10.0.0", cors: "^2.8.5", express: "^5.0.0", gts: "^6.0.0", "is-docker": "^3.0.0", jsdoc: "^4.0.0", "jsdoc-fresh": "^4.0.0", "jsdoc-region-tag": "^3.0.0", karma: "^6.0.0", "karma-chrome-launcher": "^3.0.0", "karma-coverage": "^2.0.0", "karma-firefox-launcher": "^2.0.0", "karma-mocha": "^2.0.0", "karma-remap-coverage": "^0.1.5", "karma-sourcemap-loader": "^0.4.0", "karma-webpack": "^5.0.1", linkinator: "^6.1.2", mocha: "^11.1.0", multiparty: "^4.2.1", mv: "^2.1.1", ncp: "^2.0.0", nock: "^14.0.0-beta.13", "null-loader": "^4.0.0", "pack-n-play": "^3.0.0", puppeteer: "^24.0.0", sinon: "^20.0.0", "stream-browserify": "^3.0.0", tmp: "0.2.3", "ts-loader": "^9.5.2", typescript: "^5.8.3", webpack: "^5.35.0", "webpack-cli": "^6.0.1" }, dependencies: { extend: "^3.0.2", "https-proxy-agent": "^7.0.1", "node-fetch": "^3.3.2" } };
});
var Xf = z((GA, Yf) => {
  "use strict";
  var p0 = Kf();
  Yf.exports = { pkg: p0 };
});
var Wa = z((wt) => {
  "use strict";
  var Zf = wt && wt.__importDefault || function(r) {
    return r && r.__esModule ? r : { default: r };
  };
  Object.defineProperty(wt, "__esModule", { value: true });
  wt.GaxiosError = wt.GAXIOS_ERROR_SYMBOL = void 0;
  wt.defaultErrorRedactor = ed;
  var Qf = Zf($a()), m0 = Zf(Xf()), Ha = m0.default.pkg;
  wt.GAXIOS_ERROR_SYMBOL = Symbol.for(`${Ha.name}-gaxios-error`);
  var Ga = class r extends Error {
    config;
    response;
    code;
    status;
    error;
    [wt.GAXIOS_ERROR_SYMBOL] = Ha.version;
    static [Symbol.hasInstance](e) {
      return e && typeof e == "object" && wt.GAXIOS_ERROR_SYMBOL in e && e[wt.GAXIOS_ERROR_SYMBOL] === Ha.version ? true : Function.prototype[Symbol.hasInstance].call(r, e);
    }
    constructor(e, t, n, o) {
      if (super(e, { cause: o }), this.config = t, this.response = n, this.error = o instanceof Error ? o : void 0, this.config = (0, Qf.default)(true, {}, t), this.response && (this.response.config = (0, Qf.default)(true, {}, this.response.config)), this.response) {
        try {
          this.response.data = g0(this.config.responseType, this.response?.bodyUsed ? this.response?.data : void 0);
        } catch {
        }
        this.status = this.response.status;
      }
      o instanceof DOMException ? this.code = o.name : o && typeof o == "object" && "code" in o && (typeof o.code == "string" || typeof o.code == "number") && (this.code = o.code);
    }
    static extractAPIErrorFromResponse(e, t = "The request failed") {
      let n = t;
      if (typeof e.data == "string" && (n = e.data), e.data && typeof e.data == "object" && "error" in e.data && e.data.error && !e.ok) {
        if (typeof e.data.error == "string") return { message: e.data.error, code: e.status, status: e.statusText };
        if (typeof e.data.error == "object") {
          n = "message" in e.data.error && typeof e.data.error.message == "string" ? e.data.error.message : n;
          let o = "status" in e.data.error && typeof e.data.error.status == "string" ? e.data.error.status : e.statusText, a = "code" in e.data.error && typeof e.data.error.code == "number" ? e.data.error.code : e.status;
          if ("errors" in e.data.error && Array.isArray(e.data.error.errors)) {
            let u = [];
            for (let l of e.data.error.errors) typeof l == "object" && "message" in l && typeof l.message == "string" && u.push(l.message);
            return Object.assign({ message: u.join(`
`) || n, code: a, status: o }, e.data.error);
          }
          return Object.assign({ message: n, code: a, status: o }, e.data.error);
        }
      }
      return { message: n, code: e.status, status: e.statusText };
    }
  };
  wt.GaxiosError = Ga;
  function g0(r, e) {
    switch (r) {
      case "stream":
        return e;
      case "json":
        return JSON.parse(JSON.stringify(e));
      case "arraybuffer":
        return JSON.parse(Buffer.from(e).toString("utf8"));
      case "blob":
        return JSON.parse(e.text());
      default:
        return e;
    }
  }
  function ed(r) {
    let e = "<<REDACTED> - See `errorRedactor` option in `gaxios` for configuration>.";
    function t(a) {
      a && a.forEach((u, l) => {
        (/^authentication$/i.test(l) || /^authorization$/i.test(l) || /secret/i.test(l)) && a.set(l, e);
      });
    }
    function n(a, u) {
      if (typeof a == "object" && a !== null && typeof a[u] == "string") {
        let l = a[u];
        (/grant_type=/i.test(l) || /assertion=/i.test(l) || /secret/i.test(l)) && (a[u] = e);
      }
    }
    function o(a) {
      !a || typeof a != "object" || (a instanceof FormData || a instanceof URLSearchParams || "forEach" in a && "set" in a ? a.forEach((u, l) => {
        (["grant_type", "assertion"].includes(l) || /secret/.test(l)) && a.set(l, e);
      }) : ("grant_type" in a && (a.grant_type = e), "assertion" in a && (a.assertion = e), "client_secret" in a && (a.client_secret = e)));
    }
    return r.config && (t(r.config.headers), n(r.config, "data"), o(r.config.data), n(r.config, "body"), o(r.config.body), r.config.url.searchParams.has("token") && r.config.url.searchParams.set("token", e), r.config.url.searchParams.has("client_secret") && r.config.url.searchParams.set("client_secret", e)), r.response && (ed({ config: r.response.config }), t(r.response.headers), r.response.bodyUsed && (n(r.response, "data"), o(r.response.data))), r;
  }
});
var rd = z((za) => {
  "use strict";
  Object.defineProperty(za, "__esModule", { value: true });
  za.getRetryConfig = y0;
  async function y0(r) {
    let e = td(r);
    if (!r || !r.config || !e && !r.config.retry) return { shouldRetry: false };
    e = e || {}, e.currentRetryAttempt = e.currentRetryAttempt || 0, e.retry = e.retry === void 0 || e.retry === null ? 3 : e.retry, e.httpMethodsToRetry = e.httpMethodsToRetry || ["GET", "HEAD", "PUT", "OPTIONS", "DELETE"], e.noResponseRetries = e.noResponseRetries === void 0 || e.noResponseRetries === null ? 2 : e.noResponseRetries, e.retryDelayMultiplier = e.retryDelayMultiplier ? e.retryDelayMultiplier : 2, e.timeOfFirstRequest = e.timeOfFirstRequest ? e.timeOfFirstRequest : Date.now(), e.totalTimeout = e.totalTimeout ? e.totalTimeout : Number.MAX_SAFE_INTEGER, e.maxRetryDelay = e.maxRetryDelay ? e.maxRetryDelay : Number.MAX_SAFE_INTEGER;
    let t = [[100, 199], [408, 408], [429, 429], [500, 599]];
    if (e.statusCodesToRetry = e.statusCodesToRetry || t, r.config.retryConfig = e, !await (e.shouldRetry || _0)(r)) return { shouldRetry: false, config: r.config };
    let o = C0(e);
    r.config.retryConfig.currentRetryAttempt += 1;
    let a = e.retryBackoff ? e.retryBackoff(r, o) : new Promise((u) => {
      setTimeout(u, o);
    });
    return e.onRetryAttempt && await e.onRetryAttempt(r), await a, { shouldRetry: true, config: r.config };
  }
  function _0(r) {
    let e = td(r);
    if (r.config.signal?.aborted && r.code !== "TimeoutError" || r.code === "AbortError" || !e || e.retry === 0 || !r.response && (e.currentRetryAttempt || 0) >= e.noResponseRetries || !e.httpMethodsToRetry || !e.httpMethodsToRetry.includes(r.config.method?.toUpperCase() || "GET")) return false;
    if (r.response && r.response.status) {
      let t = false;
      for (let [n, o] of e.statusCodesToRetry) {
        let a = r.response.status;
        if (a >= n && a <= o) {
          t = true;
          break;
        }
      }
      if (!t) return false;
    }
    return e.currentRetryAttempt = e.currentRetryAttempt || 0, !(e.currentRetryAttempt >= e.retry);
  }
  function td(r) {
    if (r && r.config && r.config.retryConfig) return r.config.retryConfig;
  }
  function C0(r) {
    let t = (r.currentRetryAttempt ? 0 : r.retryDelay ?? 100) + (Math.pow(r.retryDelayMultiplier, r.currentRetryAttempt) - 1) / 2 * 1e3, n = r.totalTimeout - (Date.now() - r.timeOfFirstRequest);
    return Math.min(t, n, r.maxRetryDelay);
  }
});
var Va = z((So) => {
  "use strict";
  Object.defineProperty(So, "__esModule", { value: true });
  So.GaxiosInterceptorManager = void 0;
  var Ja = class extends Set {
  };
  So.GaxiosInterceptorManager = Ja;
});
var sd = z((VA, nd) => {
  var bn = 1e3, En = bn * 60, wn = En * 60, Yr = wn * 24, b0 = Yr * 7, E0 = Yr * 365.25;
  nd.exports = function(r, e) {
    e = e || {};
    var t = typeof r;
    if (t === "string" && r.length > 0) return w0(r);
    if (t === "number" && isFinite(r)) return e.long ? D0(r) : A0(r);
    throw new Error("val is not a non-empty string or a valid number. val=" + JSON.stringify(r));
  };
  function w0(r) {
    if (r = String(r), !(r.length > 100)) {
      var e = /^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(r);
      if (e) {
        var t = parseFloat(e[1]), n = (e[2] || "ms").toLowerCase();
        switch (n) {
          case "years":
          case "year":
          case "yrs":
          case "yr":
          case "y":
            return t * E0;
          case "weeks":
          case "week":
          case "w":
            return t * b0;
          case "days":
          case "day":
          case "d":
            return t * Yr;
          case "hours":
          case "hour":
          case "hrs":
          case "hr":
          case "h":
            return t * wn;
          case "minutes":
          case "minute":
          case "mins":
          case "min":
          case "m":
            return t * En;
          case "seconds":
          case "second":
          case "secs":
          case "sec":
          case "s":
            return t * bn;
          case "milliseconds":
          case "millisecond":
          case "msecs":
          case "msec":
          case "ms":
            return t;
          default:
            return;
        }
      }
    }
  }
  function A0(r) {
    var e = Math.abs(r);
    return e >= Yr ? Math.round(r / Yr) + "d" : e >= wn ? Math.round(r / wn) + "h" : e >= En ? Math.round(r / En) + "m" : e >= bn ? Math.round(r / bn) + "s" : r + "ms";
  }
  function D0(r) {
    var e = Math.abs(r);
    return e >= Yr ? vo(r, e, Yr, "day") : e >= wn ? vo(r, e, wn, "hour") : e >= En ? vo(r, e, En, "minute") : e >= bn ? vo(r, e, bn, "second") : r + " ms";
  }
  function vo(r, e, t, n) {
    var o = e >= t * 1.5;
    return Math.round(r / t) + " " + n + (o ? "s" : "");
  }
});
var Ka = z((KA, od) => {
  function S0(r) {
    t.debug = t, t.default = t, t.coerce = f, t.disable = u, t.enable = o, t.enabled = l, t.humanize = sd(), t.destroy = d, Object.keys(r).forEach((h) => {
      t[h] = r[h];
    }), t.names = [], t.skips = [], t.formatters = {};
    function e(h) {
      let C = 0;
      for (let w = 0; w < h.length; w++) C = (C << 5) - C + h.charCodeAt(w), C |= 0;
      return t.colors[Math.abs(C) % t.colors.length];
    }
    t.selectColor = e;
    function t(h) {
      let C, w = null, I, S;
      function b(..._) {
        if (!b.enabled) return;
        let y = b, T = Number(/* @__PURE__ */ new Date()), k = T - (C || T);
        y.diff = k, y.prev = C, y.curr = T, C = T, _[0] = t.coerce(_[0]), typeof _[0] != "string" && _.unshift("%O");
        let L = 0;
        _[0] = _[0].replace(/%([a-zA-Z%])/g, (j, G) => {
          if (j === "%%") return "%";
          L++;
          let re = t.formatters[G];
          if (typeof re == "function") {
            let W = _[L];
            j = re.call(y, W), _.splice(L, 1), L--;
          }
          return j;
        }), t.formatArgs.call(y, _), (y.log || t.log).apply(y, _);
      }
      return b.namespace = h, b.useColors = t.useColors(), b.color = t.selectColor(h), b.extend = n, b.destroy = t.destroy, Object.defineProperty(b, "enabled", { enumerable: true, configurable: false, get: () => w !== null ? w : (I !== t.namespaces && (I = t.namespaces, S = t.enabled(h)), S), set: (_) => {
        w = _;
      } }), typeof t.init == "function" && t.init(b), b;
    }
    function n(h, C) {
      let w = t(this.namespace + (typeof C > "u" ? ":" : C) + h);
      return w.log = this.log, w;
    }
    function o(h) {
      t.save(h), t.namespaces = h, t.names = [], t.skips = [];
      let C = (typeof h == "string" ? h : "").trim().replace(/\s+/g, ",").split(",").filter(Boolean);
      for (let w of C) w[0] === "-" ? t.skips.push(w.slice(1)) : t.names.push(w);
    }
    function a(h, C) {
      let w = 0, I = 0, S = -1, b = 0;
      for (; w < h.length; ) if (I < C.length && (C[I] === h[w] || C[I] === "*")) C[I] === "*" ? (S = I, b = w, I++) : (w++, I++);
      else if (S !== -1) I = S + 1, b++, w = b;
      else return false;
      for (; I < C.length && C[I] === "*"; ) I++;
      return I === C.length;
    }
    function u() {
      let h = [...t.names, ...t.skips.map((C) => "-" + C)].join(",");
      return t.enable(""), h;
    }
    function l(h) {
      for (let C of t.skips) if (a(h, C)) return false;
      for (let C of t.names) if (a(h, C)) return true;
      return false;
    }
    function f(h) {
      return h instanceof Error ? h.stack || h.message : h;
    }
    function d() {
      console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
    }
    return t.enable(t.load()), t;
  }
  od.exports = S0;
});
var id = z((st, To) => {
  st.formatArgs = T0;
  st.save = R0;
  st.load = F0;
  st.useColors = v0;
  st.storage = k0();
  st.destroy = /* @__PURE__ */ (() => {
    let r = false;
    return () => {
      r || (r = true, console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`."));
    };
  })();
  st.colors = ["#0000CC", "#0000FF", "#0033CC", "#0033FF", "#0066CC", "#0066FF", "#0099CC", "#0099FF", "#00CC00", "#00CC33", "#00CC66", "#00CC99", "#00CCCC", "#00CCFF", "#3300CC", "#3300FF", "#3333CC", "#3333FF", "#3366CC", "#3366FF", "#3399CC", "#3399FF", "#33CC00", "#33CC33", "#33CC66", "#33CC99", "#33CCCC", "#33CCFF", "#6600CC", "#6600FF", "#6633CC", "#6633FF", "#66CC00", "#66CC33", "#9900CC", "#9900FF", "#9933CC", "#9933FF", "#99CC00", "#99CC33", "#CC0000", "#CC0033", "#CC0066", "#CC0099", "#CC00CC", "#CC00FF", "#CC3300", "#CC3333", "#CC3366", "#CC3399", "#CC33CC", "#CC33FF", "#CC6600", "#CC6633", "#CC9900", "#CC9933", "#CCCC00", "#CCCC33", "#FF0000", "#FF0033", "#FF0066", "#FF0099", "#FF00CC", "#FF00FF", "#FF3300", "#FF3333", "#FF3366", "#FF3399", "#FF33CC", "#FF33FF", "#FF6600", "#FF6633", "#FF9900", "#FF9933", "#FFCC00", "#FFCC33"];
  function v0() {
    if (typeof window < "u" && window.process && (window.process.type === "renderer" || window.process.__nwjs)) return true;
    if (typeof navigator < "u" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/)) return false;
    let r;
    return typeof document < "u" && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance || typeof window < "u" && window.console && (window.console.firebug || window.console.exception && window.console.table) || typeof navigator < "u" && navigator.userAgent && (r = navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/)) && parseInt(r[1], 10) >= 31 || typeof navigator < "u" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/);
  }
  function T0(r) {
    if (r[0] = (this.useColors ? "%c" : "") + this.namespace + (this.useColors ? " %c" : " ") + r[0] + (this.useColors ? "%c " : " ") + "+" + To.exports.humanize(this.diff), !this.useColors) return;
    let e = "color: " + this.color;
    r.splice(1, 0, e, "color: inherit");
    let t = 0, n = 0;
    r[0].replace(/%[a-zA-Z%]/g, (o) => {
      o !== "%%" && (t++, o === "%c" && (n = t));
    }), r.splice(n, 0, e);
  }
  st.log = console.debug || console.log || (() => {
  });
  function R0(r) {
    try {
      r ? st.storage.setItem("debug", r) : st.storage.removeItem("debug");
    } catch {
    }
  }
  function F0() {
    let r;
    try {
      r = st.storage.getItem("debug") || st.storage.getItem("DEBUG");
    } catch {
    }
    return !r && typeof process < "u" && "env" in process && (r = process.env.DEBUG), r;
  }
  function k0() {
    try {
      return localStorage;
    } catch {
    }
  }
  To.exports = Ka()(st);
  var { formatters: O0 } = To.exports;
  O0.j = function(r) {
    try {
      return JSON.stringify(r);
    } catch (e) {
      return "[UnexpectedJSONParseError]: " + e.message;
    }
  };
});
var ud = z((YA, ad) => {
  "use strict";
  ad.exports = (r, e) => {
    e = e || process.argv;
    let t = r.startsWith("-") ? "" : r.length === 1 ? "-" : "--", n = e.indexOf(t + r), o = e.indexOf("--");
    return n !== -1 && (o === -1 ? true : n < o);
  };
});
var ld = z((XA, cd) => {
  "use strict";
  var P0 = Y("os"), Bt = ud(), Xe = process.env, An;
  Bt("no-color") || Bt("no-colors") || Bt("color=false") ? An = false : (Bt("color") || Bt("colors") || Bt("color=true") || Bt("color=always")) && (An = true);
  "FORCE_COLOR" in Xe && (An = Xe.FORCE_COLOR.length === 0 || parseInt(Xe.FORCE_COLOR, 10) !== 0);
  function x0(r) {
    return r === 0 ? false : { level: r, hasBasic: true, has256: r >= 2, has16m: r >= 3 };
  }
  function B0(r) {
    if (An === false) return 0;
    if (Bt("color=16m") || Bt("color=full") || Bt("color=truecolor")) return 3;
    if (Bt("color=256")) return 2;
    if (r && !r.isTTY && An !== true) return 0;
    let e = An ? 1 : 0;
    if (process.platform === "win32") {
      let t = P0.release().split(".");
      return Number(process.versions.node.split(".")[0]) >= 8 && Number(t[0]) >= 10 && Number(t[2]) >= 10586 ? Number(t[2]) >= 14931 ? 3 : 2 : 1;
    }
    if ("CI" in Xe) return ["TRAVIS", "CIRCLECI", "APPVEYOR", "GITLAB_CI"].some((t) => t in Xe) || Xe.CI_NAME === "codeship" ? 1 : e;
    if ("TEAMCITY_VERSION" in Xe) return /^(9\.(0*[1-9]\d*)\.|\d{2,}\.)/.test(Xe.TEAMCITY_VERSION) ? 1 : 0;
    if (Xe.COLORTERM === "truecolor") return 3;
    if ("TERM_PROGRAM" in Xe) {
      let t = parseInt((Xe.TERM_PROGRAM_VERSION || "").split(".")[0], 10);
      switch (Xe.TERM_PROGRAM) {
        case "iTerm.app":
          return t >= 3 ? 3 : 2;
        case "Apple_Terminal":
          return 2;
      }
    }
    return /-256(color)?$/i.test(Xe.TERM) ? 2 : /^screen|^xterm|^vt100|^vt220|^rxvt|color|ansi|cygwin|linux/i.test(Xe.TERM) || "COLORTERM" in Xe ? 1 : (Xe.TERM === "dumb", e);
  }
  function Ya(r) {
    let e = B0(r);
    return x0(e);
  }
  cd.exports = { supportsColor: Ya, stdout: Ya(process.stdout), stderr: Ya(process.stderr) };
});
var dd = z((Ge, Fo) => {
  var I0 = Y("tty"), Ro = Y("util");
  Ge.init = $0;
  Ge.log = L0;
  Ge.formatArgs = q0;
  Ge.save = U0;
  Ge.load = M0;
  Ge.useColors = N0;
  Ge.destroy = Ro.deprecate(() => {
  }, "Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
  Ge.colors = [6, 2, 3, 4, 5, 1];
  try {
    let r = ld();
    r && (r.stderr || r).level >= 2 && (Ge.colors = [20, 21, 26, 27, 32, 33, 38, 39, 40, 41, 42, 43, 44, 45, 56, 57, 62, 63, 68, 69, 74, 75, 76, 77, 78, 79, 80, 81, 92, 93, 98, 99, 112, 113, 128, 129, 134, 135, 148, 149, 160, 161, 162, 163, 164, 165, 166, 167, 168, 169, 170, 171, 172, 173, 178, 179, 184, 185, 196, 197, 198, 199, 200, 201, 202, 203, 204, 205, 206, 207, 208, 209, 214, 215, 220, 221]);
  } catch {
  }
  Ge.inspectOpts = Object.keys(process.env).filter((r) => /^debug_/i.test(r)).reduce((r, e) => {
    let t = e.substring(6).toLowerCase().replace(/_([a-z])/g, (o, a) => a.toUpperCase()), n = process.env[e];
    return /^(yes|on|true|enabled)$/i.test(n) ? n = true : /^(no|off|false|disabled)$/i.test(n) ? n = false : n === "null" ? n = null : n = Number(n), r[t] = n, r;
  }, {});
  function N0() {
    return "colors" in Ge.inspectOpts ? !!Ge.inspectOpts.colors : I0.isatty(process.stderr.fd);
  }
  function q0(r) {
    let { namespace: e, useColors: t } = this;
    if (t) {
      let n = this.color, o = "\x1B[3" + (n < 8 ? n : "8;5;" + n), a = `  ${o};1m${e} \x1B[0m`;
      r[0] = a + r[0].split(`
`).join(`
` + a), r.push(o + "m+" + Fo.exports.humanize(this.diff) + "\x1B[0m");
    } else r[0] = j0() + e + " " + r[0];
  }
  function j0() {
    return Ge.inspectOpts.hideDate ? "" : (/* @__PURE__ */ new Date()).toISOString() + " ";
  }
  function L0(...r) {
    return process.stderr.write(Ro.formatWithOptions(Ge.inspectOpts, ...r) + `
`);
  }
  function U0(r) {
    r ? process.env.DEBUG = r : delete process.env.DEBUG;
  }
  function M0() {
    return process.env.DEBUG;
  }
  function $0(r) {
    r.inspectOpts = {};
    let e = Object.keys(Ge.inspectOpts);
    for (let t = 0; t < e.length; t++) r.inspectOpts[e[t]] = Ge.inspectOpts[e[t]];
  }
  Fo.exports = Ka()(Ge);
  var { formatters: fd } = Fo.exports;
  fd.o = function(r) {
    return this.inspectOpts.colors = this.useColors, Ro.inspect(r, this.inspectOpts).split(`
`).map((e) => e.trim()).join(" ");
  };
  fd.O = function(r) {
    return this.inspectOpts.colors = this.useColors, Ro.inspect(r, this.inspectOpts);
  };
});
var Qa = z((QA, Xa) => {
  typeof process > "u" || process.type === "renderer" || process.browser === true || process.__nwjs ? Xa.exports = id() : Xa.exports = dd();
});
var md = z((ot) => {
  "use strict";
  var H0 = ot && ot.__createBinding || (Object.create ? function(r, e, t, n) {
    n === void 0 && (n = t);
    var o = Object.getOwnPropertyDescriptor(e, t);
    (!o || ("get" in o ? !e.__esModule : o.writable || o.configurable)) && (o = { enumerable: true, get: function() {
      return e[t];
    } }), Object.defineProperty(r, n, o);
  } : function(r, e, t, n) {
    n === void 0 && (n = t), r[n] = e[t];
  }), G0 = ot && ot.__setModuleDefault || (Object.create ? function(r, e) {
    Object.defineProperty(r, "default", { enumerable: true, value: e });
  } : function(r, e) {
    r.default = e;
  }), hd = ot && ot.__importStar || function(r) {
    if (r && r.__esModule) return r;
    var e = {};
    if (r != null) for (var t in r) t !== "default" && Object.prototype.hasOwnProperty.call(r, t) && H0(e, r, t);
    return G0(e, r), e;
  };
  Object.defineProperty(ot, "__esModule", { value: true });
  ot.req = ot.json = ot.toBuffer = void 0;
  var W0 = hd(Y("http")), z0 = hd(Y("https"));
  async function pd(r) {
    let e = 0, t = [];
    for await (let n of r) e += n.length, t.push(n);
    return Buffer.concat(t, e);
  }
  ot.toBuffer = pd;
  async function J0(r) {
    let t = (await pd(r)).toString("utf8");
    try {
      return JSON.parse(t);
    } catch (n) {
      let o = n;
      throw o.message += ` (input: ${t})`, o;
    }
  }
  ot.json = J0;
  function V0(r, e = {}) {
    let n = ((typeof r == "string" ? r : r.href).startsWith("https:") ? z0 : W0).request(r, e), o = new Promise((a, u) => {
      n.once("response", a).once("error", u).end();
    });
    return n.then = o.then.bind(o), n;
  }
  ot.req = V0;
});
var Cd = z((lt) => {
  "use strict";
  var yd = lt && lt.__createBinding || (Object.create ? function(r, e, t, n) {
    n === void 0 && (n = t);
    var o = Object.getOwnPropertyDescriptor(e, t);
    (!o || ("get" in o ? !e.__esModule : o.writable || o.configurable)) && (o = { enumerable: true, get: function() {
      return e[t];
    } }), Object.defineProperty(r, n, o);
  } : function(r, e, t, n) {
    n === void 0 && (n = t), r[n] = e[t];
  }), K0 = lt && lt.__setModuleDefault || (Object.create ? function(r, e) {
    Object.defineProperty(r, "default", { enumerable: true, value: e });
  } : function(r, e) {
    r.default = e;
  }), _d = lt && lt.__importStar || function(r) {
    if (r && r.__esModule) return r;
    var e = {};
    if (r != null) for (var t in r) t !== "default" && Object.prototype.hasOwnProperty.call(r, t) && yd(e, r, t);
    return K0(e, r), e;
  }, Y0 = lt && lt.__exportStar || function(r, e) {
    for (var t in r) t !== "default" && !Object.prototype.hasOwnProperty.call(e, t) && yd(e, r, t);
  };
  Object.defineProperty(lt, "__esModule", { value: true });
  lt.Agent = void 0;
  var X0 = _d(Y("net")), gd = _d(Y("http")), Q0 = Y("https");
  Y0(md(), lt);
  var Wt = Symbol("AgentBaseInternalState"), Za = class extends gd.Agent {
    constructor(e) {
      super(e), this[Wt] = {};
    }
    isSecureEndpoint(e) {
      if (e) {
        if (typeof e.secureEndpoint == "boolean") return e.secureEndpoint;
        if (typeof e.protocol == "string") return e.protocol === "https:";
      }
      let { stack: t } = new Error();
      return typeof t != "string" ? false : t.split(`
`).some((n) => n.indexOf("(https.js:") !== -1 || n.indexOf("node:https:") !== -1);
    }
    incrementSockets(e) {
      if (this.maxSockets === 1 / 0 && this.maxTotalSockets === 1 / 0) return null;
      this.sockets[e] || (this.sockets[e] = []);
      let t = new X0.Socket({ writable: false });
      return this.sockets[e].push(t), this.totalSocketCount++, t;
    }
    decrementSockets(e, t) {
      if (!this.sockets[e] || t === null) return;
      let n = this.sockets[e], o = n.indexOf(t);
      o !== -1 && (n.splice(o, 1), this.totalSocketCount--, n.length === 0 && delete this.sockets[e]);
    }
    getName(e) {
      return this.isSecureEndpoint(e) ? Q0.Agent.prototype.getName.call(this, e) : super.getName(e);
    }
    createSocket(e, t, n) {
      let o = { ...t, secureEndpoint: this.isSecureEndpoint(t) }, a = this.getName(o), u = this.incrementSockets(a);
      Promise.resolve().then(() => this.connect(e, o)).then((l) => {
        if (this.decrementSockets(a, u), l instanceof gd.Agent) try {
          return l.addRequest(e, o);
        } catch (f) {
          return n(f);
        }
        this[Wt].currentSocket = l, super.createSocket(e, t, n);
      }, (l) => {
        this.decrementSockets(a, u), n(l);
      });
    }
    createConnection() {
      let e = this[Wt].currentSocket;
      if (this[Wt].currentSocket = void 0, !e) throw new Error("No socket was returned in the `connect()` function");
      return e;
    }
    get defaultPort() {
      return this[Wt].defaultPort ?? (this.protocol === "https:" ? 443 : 80);
    }
    set defaultPort(e) {
      this[Wt] && (this[Wt].defaultPort = e);
    }
    get protocol() {
      return this[Wt].protocol ?? (this.isSecureEndpoint() ? "https:" : "http:");
    }
    set protocol(e) {
      this[Wt] && (this[Wt].protocol = e);
    }
  };
  lt.Agent = Za;
});
var bd = z((Dn) => {
  "use strict";
  var Z0 = Dn && Dn.__importDefault || function(r) {
    return r && r.__esModule ? r : { default: r };
  };
  Object.defineProperty(Dn, "__esModule", { value: true });
  Dn.parseProxyResponse = void 0;
  var e_ = Z0(Qa()), ko = (0, e_.default)("https-proxy-agent:parse-proxy-response");
  function t_(r) {
    return new Promise((e, t) => {
      let n = 0, o = [];
      function a() {
        let h = r.read();
        h ? d(h) : r.once("readable", a);
      }
      function u() {
        r.removeListener("end", l), r.removeListener("error", f), r.removeListener("readable", a);
      }
      function l() {
        u(), ko("onend"), t(new Error("Proxy connection ended before receiving CONNECT response"));
      }
      function f(h) {
        u(), ko("onerror %o", h), t(h);
      }
      function d(h) {
        o.push(h), n += h.length;
        let C = Buffer.concat(o, n), w = C.indexOf(`\r
\r
`);
        if (w === -1) {
          ko("have not received end of HTTP headers yet..."), a();
          return;
        }
        let I = C.slice(0, w).toString("ascii").split(`\r
`), S = I.shift();
        if (!S) return r.destroy(), t(new Error("No header received from proxy CONNECT response"));
        let b = S.split(" "), _ = +b[1], y = b.slice(2).join(" "), T = {};
        for (let k of I) {
          if (!k) continue;
          let L = k.indexOf(":");
          if (L === -1) return r.destroy(), t(new Error(`Invalid header from proxy CONNECT response: "${k}"`));
          let P = k.slice(0, L).toLowerCase(), j = k.slice(L + 1).trimStart(), G = T[P];
          typeof G == "string" ? T[P] = [G, j] : Array.isArray(G) ? G.push(j) : T[P] = j;
        }
        ko("got proxy server response: %o %o", S, T), u(), e({ connect: { statusCode: _, statusText: y, headers: T }, buffered: C });
      }
      r.on("error", f), r.on("end", l), a();
    });
  }
  Dn.parseProxyResponse = t_;
});
var vd = z((At) => {
  "use strict";
  var r_ = At && At.__createBinding || (Object.create ? function(r, e, t, n) {
    n === void 0 && (n = t);
    var o = Object.getOwnPropertyDescriptor(e, t);
    (!o || ("get" in o ? !e.__esModule : o.writable || o.configurable)) && (o = { enumerable: true, get: function() {
      return e[t];
    } }), Object.defineProperty(r, n, o);
  } : function(r, e, t, n) {
    n === void 0 && (n = t), r[n] = e[t];
  }), n_ = At && At.__setModuleDefault || (Object.create ? function(r, e) {
    Object.defineProperty(r, "default", { enumerable: true, value: e });
  } : function(r, e) {
    r.default = e;
  }), Dd = At && At.__importStar || function(r) {
    if (r && r.__esModule) return r;
    var e = {};
    if (r != null) for (var t in r) t !== "default" && Object.prototype.hasOwnProperty.call(r, t) && r_(e, r, t);
    return n_(e, r), e;
  }, Sd = At && At.__importDefault || function(r) {
    return r && r.__esModule ? r : { default: r };
  };
  Object.defineProperty(At, "__esModule", { value: true });
  At.HttpsProxyAgent = void 0;
  var Oo = Dd(Y("net")), Ed = Dd(Y("tls")), s_ = Sd(Y("assert")), o_ = Sd(Qa()), i_ = Cd(), a_ = Y("url"), u_ = bd(), is = (0, o_.default)("https-proxy-agent"), wd = (r) => r.servername === void 0 && r.host && !Oo.isIP(r.host) ? { ...r, servername: r.host } : r, Po = class extends i_.Agent {
    constructor(e, t) {
      super(t), this.options = { path: void 0 }, this.proxy = typeof e == "string" ? new a_.URL(e) : e, this.proxyHeaders = t?.headers ?? {}, is("Creating new HttpsProxyAgent instance: %o", this.proxy.href);
      let n = (this.proxy.hostname || this.proxy.host).replace(/^\[|\]$/g, ""), o = this.proxy.port ? parseInt(this.proxy.port, 10) : this.proxy.protocol === "https:" ? 443 : 80;
      this.connectOpts = { ALPNProtocols: ["http/1.1"], ...t ? Ad(t, "headers") : null, host: n, port: o };
    }
    async connect(e, t) {
      let { proxy: n } = this;
      if (!t.host) throw new TypeError('No "host" provided');
      let o;
      n.protocol === "https:" ? (is("Creating `tls.Socket`: %o", this.connectOpts), o = Ed.connect(wd(this.connectOpts))) : (is("Creating `net.Socket`: %o", this.connectOpts), o = Oo.connect(this.connectOpts));
      let a = typeof this.proxyHeaders == "function" ? this.proxyHeaders() : { ...this.proxyHeaders }, u = Oo.isIPv6(t.host) ? `[${t.host}]` : t.host, l = `CONNECT ${u}:${t.port} HTTP/1.1\r
`;
      if (n.username || n.password) {
        let w = `${decodeURIComponent(n.username)}:${decodeURIComponent(n.password)}`;
        a["Proxy-Authorization"] = `Basic ${Buffer.from(w).toString("base64")}`;
      }
      a.Host = `${u}:${t.port}`, a["Proxy-Connection"] || (a["Proxy-Connection"] = this.keepAlive ? "Keep-Alive" : "close");
      for (let w of Object.keys(a)) l += `${w}: ${a[w]}\r
`;
      let f = (0, u_.parseProxyResponse)(o);
      o.write(`${l}\r
`);
      let { connect: d, buffered: h } = await f;
      if (e.emit("proxyConnect", d), this.emit("proxyConnect", d, e), d.statusCode === 200) return e.once("socket", c_), t.secureEndpoint ? (is("Upgrading socket connection to TLS"), Ed.connect({ ...Ad(wd(t), "host", "path", "port"), socket: o })) : o;
      o.destroy();
      let C = new Oo.Socket({ writable: false });
      return C.readable = true, e.once("socket", (w) => {
        is("Replaying proxy buffer for failed request"), (0, s_.default)(w.listenerCount("data") > 0), w.push(h), w.push(null);
      }), C;
    }
  };
  Po.protocols = ["http", "https"];
  At.HttpsProxyAgent = Po;
  function c_(r) {
    r.resume();
  }
  function Ad(r, ...e) {
    let t = {}, n;
    for (n in r) e.includes(n) || (t[n] = r[n]);
    return t;
  }
});
function l_(r) {
  if (!/^data:/i.test(r)) throw new TypeError('`uri` does not appear to be a Data URI (must begin with "data:")');
  r = r.replace(/\r?\n/g, "");
  let e = r.indexOf(",");
  if (e === -1 || e <= 4) throw new TypeError("malformed data: URI");
  let t = r.substring(5, e).split(";"), n = "", o = false, a = t[0] || "text/plain", u = a;
  for (let h = 1; h < t.length; h++) t[h] === "base64" ? o = true : t[h] && (u += `;${t[h]}`, t[h].indexOf("charset=") === 0 && (n = t[h].substring(8)));
  !t[0] && !n.length && (u += ";charset=US-ASCII", n = "US-ASCII");
  let l = o ? "base64" : "ascii", f = unescape(r.substring(e + 1)), d = Buffer.from(f, l);
  return d.type = a, d.typeFull = u, d.charset = n, d;
}
var Td;
var Rd = Me(() => {
  Td = l_;
});
var kd = z((xo, Fd) => {
  (function(r, e) {
    typeof xo == "object" && typeof Fd < "u" ? e(xo) : typeof define == "function" && define.amd ? define(["exports"], e) : (r = typeof globalThis < "u" ? globalThis : r || self, e(r.WebStreamsPolyfill = {}));
  })(xo, function(r) {
    "use strict";
    function e() {
    }
    function t(s) {
      return typeof s == "object" && s !== null || typeof s == "function";
    }
    let n = e;
    function o(s, i) {
      try {
        Object.defineProperty(s, "name", { value: i, configurable: true });
      } catch {
      }
    }
    let a = Promise, u = Promise.prototype.then, l = Promise.reject.bind(a);
    function f(s) {
      return new a(s);
    }
    function d(s) {
      return f((i) => i(s));
    }
    function h(s) {
      return l(s);
    }
    function C(s, i, c) {
      return u.call(s, i, c);
    }
    function w(s, i, c) {
      C(C(s, i, c), void 0, n);
    }
    function I(s, i) {
      w(s, i);
    }
    function S(s, i) {
      w(s, void 0, i);
    }
    function b(s, i, c) {
      return C(s, i, c);
    }
    function _(s) {
      C(s, void 0, n);
    }
    let y = (s) => {
      if (typeof queueMicrotask == "function") y = queueMicrotask;
      else {
        let i = d(void 0);
        y = (c) => C(i, c);
      }
      return y(s);
    };
    function T(s, i, c) {
      if (typeof s != "function") throw new TypeError("Argument is not a function");
      return Function.prototype.apply.call(s, i, c);
    }
    function k(s, i, c) {
      try {
        return d(T(s, i, c));
      } catch (m) {
        return h(m);
      }
    }
    let L = 16384;
    class P {
      constructor() {
        this._cursor = 0, this._size = 0, this._front = { _elements: [], _next: void 0 }, this._back = this._front, this._cursor = 0, this._size = 0;
      }
      get length() {
        return this._size;
      }
      push(i) {
        let c = this._back, m = c;
        c._elements.length === L - 1 && (m = { _elements: [], _next: void 0 }), c._elements.push(i), m !== c && (this._back = m, c._next = m), ++this._size;
      }
      shift() {
        let i = this._front, c = i, m = this._cursor, A = m + 1, N = i._elements, U = N[m];
        return A === L && (c = i._next, A = 0), --this._size, this._cursor = A, i !== c && (this._front = c), N[m] = void 0, U;
      }
      forEach(i) {
        let c = this._cursor, m = this._front, A = m._elements;
        for (; (c !== A.length || m._next !== void 0) && !(c === A.length && (m = m._next, A = m._elements, c = 0, A.length === 0)); ) i(A[c]), ++c;
      }
      peek() {
        let i = this._front, c = this._cursor;
        return i._elements[c];
      }
    }
    let j = Symbol("[[AbortSteps]]"), G = Symbol("[[ErrorSteps]]"), re = Symbol("[[CancelSteps]]"), W = Symbol("[[PullSteps]]"), Ee = Symbol("[[ReleaseSteps]]");
    function he(s, i) {
      s._ownerReadableStream = i, i._reader = s, i._state === "readable" ? ce(s) : i._state === "closed" ? Te(s) : pe(s, i._storedError);
    }
    function oe(s, i) {
      let c = s._ownerReadableStream;
      return Ot(c, i);
    }
    function ue(s) {
      let i = s._ownerReadableStream;
      i._state === "readable" ? J(s, new TypeError("Reader was released and can no longer be used to monitor the stream's closedness")) : X(s, new TypeError("Reader was released and can no longer be used to monitor the stream's closedness")), i._readableStreamController[Ee](), i._reader = void 0, s._ownerReadableStream = void 0;
    }
    function Z(s) {
      return new TypeError("Cannot " + s + " a stream using a released reader");
    }
    function ce(s) {
      s._closedPromise = f((i, c) => {
        s._closedPromise_resolve = i, s._closedPromise_reject = c;
      });
    }
    function pe(s, i) {
      ce(s), J(s, i);
    }
    function Te(s) {
      ce(s), le(s);
    }
    function J(s, i) {
      s._closedPromise_reject !== void 0 && (_(s._closedPromise), s._closedPromise_reject(i), s._closedPromise_resolve = void 0, s._closedPromise_reject = void 0);
    }
    function X(s, i) {
      pe(s, i);
    }
    function le(s) {
      s._closedPromise_resolve !== void 0 && (s._closedPromise_resolve(void 0), s._closedPromise_resolve = void 0, s._closedPromise_reject = void 0);
    }
    let qe = Number.isFinite || function(s) {
      return typeof s == "number" && isFinite(s);
    }, ze = Math.trunc || function(s) {
      return s < 0 ? Math.ceil(s) : Math.floor(s);
    };
    function H(s) {
      return typeof s == "object" || typeof s == "function";
    }
    function ye(s, i) {
      if (s !== void 0 && !H(s)) throw new TypeError(`${i} is not an object.`);
    }
    function Ae(s, i) {
      if (typeof s != "function") throw new TypeError(`${i} is not a function.`);
    }
    function tr(s) {
      return typeof s == "object" && s !== null || typeof s == "function";
    }
    function Be(s, i) {
      if (!tr(s)) throw new TypeError(`${i} is not an object.`);
    }
    function Ne(s, i, c) {
      if (s === void 0) throw new TypeError(`Parameter ${i} is required in '${c}'.`);
    }
    function p(s, i, c) {
      if (s === void 0) throw new TypeError(`${i} is required in '${c}'.`);
    }
    function g(s) {
      return Number(s);
    }
    function E(s) {
      return s === 0 ? 0 : s;
    }
    function x(s) {
      return E(ze(s));
    }
    function v(s, i) {
      let m = Number.MAX_SAFE_INTEGER, A = Number(s);
      if (A = E(A), !qe(A)) throw new TypeError(`${i} is not a finite number`);
      if (A = x(A), A < 0 || A > m) throw new TypeError(`${i} is outside the accepted range of 0 to ${m}, inclusive`);
      return !qe(A) || A === 0 ? 0 : A;
    }
    function F(s, i) {
      if (!Ar(s)) throw new TypeError(`${i} is not a ReadableStream.`);
    }
    function q(s) {
      return new M(s);
    }
    function D(s, i) {
      s._reader._readRequests.push(i);
    }
    function R(s, i, c) {
      let A = s._reader._readRequests.shift();
      c ? A._closeSteps() : A._chunkSteps(i);
    }
    function B(s) {
      return s._reader._readRequests.length;
    }
    function O(s) {
      let i = s._reader;
      return !(i === void 0 || !K(i));
    }
    class M {
      constructor(i) {
        if (Ne(i, 1, "ReadableStreamDefaultReader"), F(i, "First parameter"), Dr(i)) throw new TypeError("This stream has already been locked for exclusive reading by another reader");
        he(this, i), this._readRequests = new P();
      }
      get closed() {
        return K(this) ? this._closedPromise : h(Ie("closed"));
      }
      cancel(i = void 0) {
        return K(this) ? this._ownerReadableStream === void 0 ? h(Z("cancel")) : oe(this, i) : h(Ie("cancel"));
      }
      read() {
        if (!K(this)) return h(Ie("read"));
        if (this._ownerReadableStream === void 0) return h(Z("read from"));
        let i, c, m = f((N, U) => {
          i = N, c = U;
        });
        return Q(this, { _chunkSteps: (N) => i({ value: N, done: false }), _closeSteps: () => i({ value: void 0, done: true }), _errorSteps: (N) => c(N) }), m;
      }
      releaseLock() {
        if (!K(this)) throw Ie("releaseLock");
        this._ownerReadableStream !== void 0 && we(this);
      }
    }
    Object.defineProperties(M.prototype, { cancel: { enumerable: true }, read: { enumerable: true }, releaseLock: { enumerable: true }, closed: { enumerable: true } }), o(M.prototype.cancel, "cancel"), o(M.prototype.read, "read"), o(M.prototype.releaseLock, "releaseLock"), typeof Symbol.toStringTag == "symbol" && Object.defineProperty(M.prototype, Symbol.toStringTag, { value: "ReadableStreamDefaultReader", configurable: true });
    function K(s) {
      return !t(s) || !Object.prototype.hasOwnProperty.call(s, "_readRequests") ? false : s instanceof M;
    }
    function Q(s, i) {
      let c = s._ownerReadableStream;
      c._disturbed = true, c._state === "closed" ? i._closeSteps() : c._state === "errored" ? i._errorSteps(c._storedError) : c._readableStreamController[W](i);
    }
    function we(s) {
      ue(s);
      let i = new TypeError("Reader was released");
      Oe(s, i);
    }
    function Oe(s, i) {
      let c = s._readRequests;
      s._readRequests = new P(), c.forEach((m) => {
        m._errorSteps(i);
      });
    }
    function Ie(s) {
      return new TypeError(`ReadableStreamDefaultReader.prototype.${s} can only be used on a ReadableStreamDefaultReader`);
    }
    let be = Object.getPrototypeOf(Object.getPrototypeOf(async function* () {
    }).prototype);
    class De {
      constructor(i, c) {
        this._ongoingPromise = void 0, this._isFinished = false, this._reader = i, this._preventCancel = c;
      }
      next() {
        let i = () => this._nextSteps();
        return this._ongoingPromise = this._ongoingPromise ? b(this._ongoingPromise, i, i) : i(), this._ongoingPromise;
      }
      return(i) {
        let c = () => this._returnSteps(i);
        return this._ongoingPromise ? b(this._ongoingPromise, c, c) : c();
      }
      _nextSteps() {
        if (this._isFinished) return Promise.resolve({ value: void 0, done: true });
        let i = this._reader, c, m, A = f((U, V) => {
          c = U, m = V;
        });
        return Q(i, { _chunkSteps: (U) => {
          this._ongoingPromise = void 0, y(() => c({ value: U, done: false }));
        }, _closeSteps: () => {
          this._ongoingPromise = void 0, this._isFinished = true, ue(i), c({ value: void 0, done: true });
        }, _errorSteps: (U) => {
          this._ongoingPromise = void 0, this._isFinished = true, ue(i), m(U);
        } }), A;
      }
      _returnSteps(i) {
        if (this._isFinished) return Promise.resolve({ value: i, done: true });
        this._isFinished = true;
        let c = this._reader;
        if (!this._preventCancel) {
          let m = oe(c, i);
          return ue(c), b(m, () => ({ value: i, done: true }));
        }
        return ue(c), d({ value: i, done: true });
      }
    }
    let Le = { next() {
      return an(this) ? this._asyncIteratorImpl.next() : h(un("next"));
    }, return(s) {
      return an(this) ? this._asyncIteratorImpl.return(s) : h(un("return"));
    } };
    Object.setPrototypeOf(Le, be);
    function on(s, i) {
      let c = q(s), m = new De(c, i), A = Object.create(Le);
      return A._asyncIteratorImpl = m, A;
    }
    function an(s) {
      if (!t(s) || !Object.prototype.hasOwnProperty.call(s, "_asyncIteratorImpl")) return false;
      try {
        return s._asyncIteratorImpl instanceof De;
      } catch {
        return false;
      }
    }
    function un(s) {
      return new TypeError(`ReadableStreamAsyncIterator.${s} can only be used on a ReadableSteamAsyncIterator`);
    }
    let ut = Number.isNaN || function(s) {
      return s !== s;
    };
    var rr, Ke, Ue;
    function Se(s) {
      return s.slice();
    }
    function Cl(s, i, c, m, A) {
      new Uint8Array(s).set(new Uint8Array(c, m, A), i);
    }
    let nr = (s) => (typeof s.transfer == "function" ? nr = (i) => i.transfer() : typeof structuredClone == "function" ? nr = (i) => structuredClone(i, { transfer: [i] }) : nr = (i) => i, nr(s)), Cr = (s) => (typeof s.detached == "boolean" ? Cr = (i) => i.detached : Cr = (i) => i.byteLength === 0, Cr(s));
    function bl(s, i, c) {
      if (s.slice) return s.slice(i, c);
      let m = c - i, A = new ArrayBuffer(m);
      return Cl(A, 0, s, i, m), A;
    }
    function Ns(s, i) {
      let c = s[i];
      if (c != null) {
        if (typeof c != "function") throw new TypeError(`${String(i)} is not a function`);
        return c;
      }
    }
    function ng(s) {
      let i = { [Symbol.iterator]: () => s.iterator }, c = async function* () {
        return yield* i;
      }(), m = c.next;
      return { iterator: c, nextMethod: m, done: false };
    }
    let ra = (Ue = (rr = Symbol.asyncIterator) !== null && rr !== void 0 ? rr : (Ke = Symbol.for) === null || Ke === void 0 ? void 0 : Ke.call(Symbol, "Symbol.asyncIterator")) !== null && Ue !== void 0 ? Ue : "@@asyncIterator";
    function El(s, i = "sync", c) {
      if (c === void 0) if (i === "async") {
        if (c = Ns(s, ra), c === void 0) {
          let N = Ns(s, Symbol.iterator), U = El(s, "sync", N);
          return ng(U);
        }
      } else c = Ns(s, Symbol.iterator);
      if (c === void 0) throw new TypeError("The object is not iterable");
      let m = T(c, s, []);
      if (!t(m)) throw new TypeError("The iterator method must return an object");
      let A = m.next;
      return { iterator: m, nextMethod: A, done: false };
    }
    function sg(s) {
      let i = T(s.nextMethod, s.iterator, []);
      if (!t(i)) throw new TypeError("The iterator.next() method must return an object");
      return i;
    }
    function og(s) {
      return !!s.done;
    }
    function ig(s) {
      return s.value;
    }
    function ag(s) {
      return !(typeof s != "number" || ut(s) || s < 0);
    }
    function wl(s) {
      let i = bl(s.buffer, s.byteOffset, s.byteOffset + s.byteLength);
      return new Uint8Array(i);
    }
    function na(s) {
      let i = s._queue.shift();
      return s._queueTotalSize -= i.size, s._queueTotalSize < 0 && (s._queueTotalSize = 0), i.value;
    }
    function sa(s, i, c) {
      if (!ag(c) || c === 1 / 0) throw new RangeError("Size must be a finite, non-NaN, non-negative number.");
      s._queue.push({ value: i, size: c }), s._queueTotalSize += c;
    }
    function ug(s) {
      return s._queue.peek().value;
    }
    function br(s) {
      s._queue = new P(), s._queueTotalSize = 0;
    }
    function Al(s) {
      return s === DataView;
    }
    function cg(s) {
      return Al(s.constructor);
    }
    function lg(s) {
      return Al(s) ? 1 : s.BYTES_PER_ELEMENT;
    }
    class Lr {
      constructor() {
        throw new TypeError("Illegal constructor");
      }
      get view() {
        if (!oa(this)) throw la("view");
        return this._view;
      }
      respond(i) {
        if (!oa(this)) throw la("respond");
        if (Ne(i, 1, "respond"), i = v(i, "First parameter"), this._associatedReadableByteStreamController === void 0) throw new TypeError("This BYOB request has been invalidated");
        if (Cr(this._view.buffer)) throw new TypeError("The BYOB request's buffer has been detached and so cannot be used as a response");
        Us(this._associatedReadableByteStreamController, i);
      }
      respondWithNewView(i) {
        if (!oa(this)) throw la("respondWithNewView");
        if (Ne(i, 1, "respondWithNewView"), !ArrayBuffer.isView(i)) throw new TypeError("You can only respond with array buffer views");
        if (this._associatedReadableByteStreamController === void 0) throw new TypeError("This BYOB request has been invalidated");
        if (Cr(i.buffer)) throw new TypeError("The given view's buffer has been detached and so cannot be used as a response");
        Ms(this._associatedReadableByteStreamController, i);
      }
    }
    Object.defineProperties(Lr.prototype, { respond: { enumerable: true }, respondWithNewView: { enumerable: true }, view: { enumerable: true } }), o(Lr.prototype.respond, "respond"), o(Lr.prototype.respondWithNewView, "respondWithNewView"), typeof Symbol.toStringTag == "symbol" && Object.defineProperty(Lr.prototype, Symbol.toStringTag, { value: "ReadableStreamBYOBRequest", configurable: true });
    class sr {
      constructor() {
        throw new TypeError("Illegal constructor");
      }
      get byobRequest() {
        if (!Ur(this)) throw Xn("byobRequest");
        return ca(this);
      }
      get desiredSize() {
        if (!Ur(this)) throw Xn("desiredSize");
        return xl(this);
      }
      close() {
        if (!Ur(this)) throw Xn("close");
        if (this._closeRequested) throw new TypeError("The stream has already been closed; do not close it again!");
        let i = this._controlledReadableByteStream._state;
        if (i !== "readable") throw new TypeError(`The stream (in ${i} state) is not in the readable state and cannot be closed`);
        Yn(this);
      }
      enqueue(i) {
        if (!Ur(this)) throw Xn("enqueue");
        if (Ne(i, 1, "enqueue"), !ArrayBuffer.isView(i)) throw new TypeError("chunk must be an array buffer view");
        if (i.byteLength === 0) throw new TypeError("chunk must have non-zero byteLength");
        if (i.buffer.byteLength === 0) throw new TypeError("chunk's buffer must have non-zero byteLength");
        if (this._closeRequested) throw new TypeError("stream is closed or draining");
        let c = this._controlledReadableByteStream._state;
        if (c !== "readable") throw new TypeError(`The stream (in ${c} state) is not in the readable state and cannot be enqueued to`);
        Ls(this, i);
      }
      error(i = void 0) {
        if (!Ur(this)) throw Xn("error");
        Ct(this, i);
      }
      [re](i) {
        Dl(this), br(this);
        let c = this._cancelAlgorithm(i);
        return js(this), c;
      }
      [W](i) {
        let c = this._controlledReadableByteStream;
        if (this._queueTotalSize > 0) {
          Pl(this, i);
          return;
        }
        let m = this._autoAllocateChunkSize;
        if (m !== void 0) {
          let A;
          try {
            A = new ArrayBuffer(m);
          } catch (U) {
            i._errorSteps(U);
            return;
          }
          let N = { buffer: A, bufferByteLength: m, byteOffset: 0, byteLength: m, bytesFilled: 0, minimumFill: 1, elementSize: 1, viewConstructor: Uint8Array, readerType: "default" };
          this._pendingPullIntos.push(N);
        }
        D(c, i), Mr(this);
      }
      [Ee]() {
        if (this._pendingPullIntos.length > 0) {
          let i = this._pendingPullIntos.peek();
          i.readerType = "none", this._pendingPullIntos = new P(), this._pendingPullIntos.push(i);
        }
      }
    }
    Object.defineProperties(sr.prototype, { close: { enumerable: true }, enqueue: { enumerable: true }, error: { enumerable: true }, byobRequest: { enumerable: true }, desiredSize: { enumerable: true } }), o(sr.prototype.close, "close"), o(sr.prototype.enqueue, "enqueue"), o(sr.prototype.error, "error"), typeof Symbol.toStringTag == "symbol" && Object.defineProperty(sr.prototype, Symbol.toStringTag, { value: "ReadableByteStreamController", configurable: true });
    function Ur(s) {
      return !t(s) || !Object.prototype.hasOwnProperty.call(s, "_controlledReadableByteStream") ? false : s instanceof sr;
    }
    function oa(s) {
      return !t(s) || !Object.prototype.hasOwnProperty.call(s, "_associatedReadableByteStreamController") ? false : s instanceof Lr;
    }
    function Mr(s) {
      if (!mg(s)) return;
      if (s._pulling) {
        s._pullAgain = true;
        return;
      }
      s._pulling = true;
      let c = s._pullAlgorithm();
      w(c, () => (s._pulling = false, s._pullAgain && (s._pullAgain = false, Mr(s)), null), (m) => (Ct(s, m), null));
    }
    function Dl(s) {
      aa(s), s._pendingPullIntos = new P();
    }
    function ia(s, i) {
      let c = false;
      s._state === "closed" && (c = true);
      let m = Sl(i);
      i.readerType === "default" ? R(s, m, c) : Eg(s, m, c);
    }
    function Sl(s) {
      let i = s.bytesFilled, c = s.elementSize;
      return new s.viewConstructor(s.buffer, s.byteOffset, i / c);
    }
    function qs(s, i, c, m) {
      s._queue.push({ buffer: i, byteOffset: c, byteLength: m }), s._queueTotalSize += m;
    }
    function vl(s, i, c, m) {
      let A;
      try {
        A = bl(i, c, c + m);
      } catch (N) {
        throw Ct(s, N), N;
      }
      qs(s, A, 0, m);
    }
    function Tl(s, i) {
      i.bytesFilled > 0 && vl(s, i.buffer, i.byteOffset, i.bytesFilled), cn(s);
    }
    function Rl(s, i) {
      let c = Math.min(s._queueTotalSize, i.byteLength - i.bytesFilled), m = i.bytesFilled + c, A = c, N = false, U = m % i.elementSize, V = m - U;
      V >= i.minimumFill && (A = V - i.bytesFilled, N = true);
      let ae = s._queue;
      for (; A > 0; ) {
        let te = ae.peek(), fe = Math.min(A, te.byteLength), ge = i.byteOffset + i.bytesFilled;
        Cl(i.buffer, ge, te.buffer, te.byteOffset, fe), te.byteLength === fe ? ae.shift() : (te.byteOffset += fe, te.byteLength -= fe), s._queueTotalSize -= fe, Fl(s, fe, i), A -= fe;
      }
      return N;
    }
    function Fl(s, i, c) {
      c.bytesFilled += i;
    }
    function kl(s) {
      s._queueTotalSize === 0 && s._closeRequested ? (js(s), ns(s._controlledReadableByteStream)) : Mr(s);
    }
    function aa(s) {
      s._byobRequest !== null && (s._byobRequest._associatedReadableByteStreamController = void 0, s._byobRequest._view = null, s._byobRequest = null);
    }
    function ua(s) {
      for (; s._pendingPullIntos.length > 0; ) {
        if (s._queueTotalSize === 0) return;
        let i = s._pendingPullIntos.peek();
        Rl(s, i) && (cn(s), ia(s._controlledReadableByteStream, i));
      }
    }
    function fg(s) {
      let i = s._controlledReadableByteStream._reader;
      for (; i._readRequests.length > 0; ) {
        if (s._queueTotalSize === 0) return;
        let c = i._readRequests.shift();
        Pl(s, c);
      }
    }
    function dg(s, i, c, m) {
      let A = s._controlledReadableByteStream, N = i.constructor, U = lg(N), { byteOffset: V, byteLength: ae } = i, te = c * U, fe;
      try {
        fe = nr(i.buffer);
      } catch (Re) {
        m._errorSteps(Re);
        return;
      }
      let ge = { buffer: fe, bufferByteLength: fe.byteLength, byteOffset: V, byteLength: ae, bytesFilled: 0, minimumFill: te, elementSize: U, viewConstructor: N, readerType: "byob" };
      if (s._pendingPullIntos.length > 0) {
        s._pendingPullIntos.push(ge), Nl(A, m);
        return;
      }
      if (A._state === "closed") {
        let Re = new N(ge.buffer, ge.byteOffset, 0);
        m._closeSteps(Re);
        return;
      }
      if (s._queueTotalSize > 0) {
        if (Rl(s, ge)) {
          let Re = Sl(ge);
          kl(s), m._chunkSteps(Re);
          return;
        }
        if (s._closeRequested) {
          let Re = new TypeError("Insufficient bytes to fill elements in the given buffer");
          Ct(s, Re), m._errorSteps(Re);
          return;
        }
      }
      s._pendingPullIntos.push(ge), Nl(A, m), Mr(s);
    }
    function hg(s, i) {
      i.readerType === "none" && cn(s);
      let c = s._controlledReadableByteStream;
      if (fa(c)) for (; ql(c) > 0; ) {
        let m = cn(s);
        ia(c, m);
      }
    }
    function pg(s, i, c) {
      if (Fl(s, i, c), c.readerType === "none") {
        Tl(s, c), ua(s);
        return;
      }
      if (c.bytesFilled < c.minimumFill) return;
      cn(s);
      let m = c.bytesFilled % c.elementSize;
      if (m > 0) {
        let A = c.byteOffset + c.bytesFilled;
        vl(s, c.buffer, A - m, m);
      }
      c.bytesFilled -= m, ia(s._controlledReadableByteStream, c), ua(s);
    }
    function Ol(s, i) {
      let c = s._pendingPullIntos.peek();
      aa(s), s._controlledReadableByteStream._state === "closed" ? hg(s, c) : pg(s, i, c), Mr(s);
    }
    function cn(s) {
      return s._pendingPullIntos.shift();
    }
    function mg(s) {
      let i = s._controlledReadableByteStream;
      return i._state !== "readable" || s._closeRequested || !s._started ? false : !!(O(i) && B(i) > 0 || fa(i) && ql(i) > 0 || xl(s) > 0);
    }
    function js(s) {
      s._pullAlgorithm = void 0, s._cancelAlgorithm = void 0;
    }
    function Yn(s) {
      let i = s._controlledReadableByteStream;
      if (!(s._closeRequested || i._state !== "readable")) {
        if (s._queueTotalSize > 0) {
          s._closeRequested = true;
          return;
        }
        if (s._pendingPullIntos.length > 0) {
          let c = s._pendingPullIntos.peek();
          if (c.bytesFilled % c.elementSize !== 0) {
            let m = new TypeError("Insufficient bytes to fill elements in the given buffer");
            throw Ct(s, m), m;
          }
        }
        js(s), ns(i);
      }
    }
    function Ls(s, i) {
      let c = s._controlledReadableByteStream;
      if (s._closeRequested || c._state !== "readable") return;
      let { buffer: m, byteOffset: A, byteLength: N } = i;
      if (Cr(m)) throw new TypeError("chunk's buffer is detached and so cannot be enqueued");
      let U = nr(m);
      if (s._pendingPullIntos.length > 0) {
        let V = s._pendingPullIntos.peek();
        if (Cr(V.buffer)) throw new TypeError("The BYOB request's buffer has been detached and so cannot be filled with an enqueued chunk");
        aa(s), V.buffer = nr(V.buffer), V.readerType === "none" && Tl(s, V);
      }
      if (O(c)) if (fg(s), B(c) === 0) qs(s, U, A, N);
      else {
        s._pendingPullIntos.length > 0 && cn(s);
        let V = new Uint8Array(U, A, N);
        R(c, V, false);
      }
      else fa(c) ? (qs(s, U, A, N), ua(s)) : qs(s, U, A, N);
      Mr(s);
    }
    function Ct(s, i) {
      let c = s._controlledReadableByteStream;
      c._state === "readable" && (Dl(s), br(s), js(s), uf(c, i));
    }
    function Pl(s, i) {
      let c = s._queue.shift();
      s._queueTotalSize -= c.byteLength, kl(s);
      let m = new Uint8Array(c.buffer, c.byteOffset, c.byteLength);
      i._chunkSteps(m);
    }
    function ca(s) {
      if (s._byobRequest === null && s._pendingPullIntos.length > 0) {
        let i = s._pendingPullIntos.peek(), c = new Uint8Array(i.buffer, i.byteOffset + i.bytesFilled, i.byteLength - i.bytesFilled), m = Object.create(Lr.prototype);
        yg(m, s, c), s._byobRequest = m;
      }
      return s._byobRequest;
    }
    function xl(s) {
      let i = s._controlledReadableByteStream._state;
      return i === "errored" ? null : i === "closed" ? 0 : s._strategyHWM - s._queueTotalSize;
    }
    function Us(s, i) {
      let c = s._pendingPullIntos.peek();
      if (s._controlledReadableByteStream._state === "closed") {
        if (i !== 0) throw new TypeError("bytesWritten must be 0 when calling respond() on a closed stream");
      } else {
        if (i === 0) throw new TypeError("bytesWritten must be greater than 0 when calling respond() on a readable stream");
        if (c.bytesFilled + i > c.byteLength) throw new RangeError("bytesWritten out of range");
      }
      c.buffer = nr(c.buffer), Ol(s, i);
    }
    function Ms(s, i) {
      let c = s._pendingPullIntos.peek();
      if (s._controlledReadableByteStream._state === "closed") {
        if (i.byteLength !== 0) throw new TypeError("The view's length must be 0 when calling respondWithNewView() on a closed stream");
      } else if (i.byteLength === 0) throw new TypeError("The view's length must be greater than 0 when calling respondWithNewView() on a readable stream");
      if (c.byteOffset + c.bytesFilled !== i.byteOffset) throw new RangeError("The region specified by view does not match byobRequest");
      if (c.bufferByteLength !== i.buffer.byteLength) throw new RangeError("The buffer of view has different capacity than byobRequest");
      if (c.bytesFilled + i.byteLength > c.byteLength) throw new RangeError("The region specified by view is larger than byobRequest");
      let A = i.byteLength;
      c.buffer = nr(i.buffer), Ol(s, A);
    }
    function Bl(s, i, c, m, A, N, U) {
      i._controlledReadableByteStream = s, i._pullAgain = false, i._pulling = false, i._byobRequest = null, i._queue = i._queueTotalSize = void 0, br(i), i._closeRequested = false, i._started = false, i._strategyHWM = N, i._pullAlgorithm = m, i._cancelAlgorithm = A, i._autoAllocateChunkSize = U, i._pendingPullIntos = new P(), s._readableStreamController = i;
      let V = c();
      w(d(V), () => (i._started = true, Mr(i), null), (ae) => (Ct(i, ae), null));
    }
    function gg(s, i, c) {
      let m = Object.create(sr.prototype), A, N, U;
      i.start !== void 0 ? A = () => i.start(m) : A = () => {
      }, i.pull !== void 0 ? N = () => i.pull(m) : N = () => d(void 0), i.cancel !== void 0 ? U = (ae) => i.cancel(ae) : U = () => d(void 0);
      let V = i.autoAllocateChunkSize;
      if (V === 0) throw new TypeError("autoAllocateChunkSize must be greater than 0");
      Bl(s, m, A, N, U, c, V);
    }
    function yg(s, i, c) {
      s._associatedReadableByteStreamController = i, s._view = c;
    }
    function la(s) {
      return new TypeError(`ReadableStreamBYOBRequest.prototype.${s} can only be used on a ReadableStreamBYOBRequest`);
    }
    function Xn(s) {
      return new TypeError(`ReadableByteStreamController.prototype.${s} can only be used on a ReadableByteStreamController`);
    }
    function _g(s, i) {
      ye(s, i);
      let c = s?.mode;
      return { mode: c === void 0 ? void 0 : Cg(c, `${i} has member 'mode' that`) };
    }
    function Cg(s, i) {
      if (s = `${s}`, s !== "byob") throw new TypeError(`${i} '${s}' is not a valid enumeration value for ReadableStreamReaderMode`);
      return s;
    }
    function bg(s, i) {
      var c;
      ye(s, i);
      let m = (c = s?.min) !== null && c !== void 0 ? c : 1;
      return { min: v(m, `${i} has member 'min' that`) };
    }
    function Il(s) {
      return new Er(s);
    }
    function Nl(s, i) {
      s._reader._readIntoRequests.push(i);
    }
    function Eg(s, i, c) {
      let A = s._reader._readIntoRequests.shift();
      c ? A._closeSteps(i) : A._chunkSteps(i);
    }
    function ql(s) {
      return s._reader._readIntoRequests.length;
    }
    function fa(s) {
      let i = s._reader;
      return !(i === void 0 || !$r(i));
    }
    class Er {
      constructor(i) {
        if (Ne(i, 1, "ReadableStreamBYOBReader"), F(i, "First parameter"), Dr(i)) throw new TypeError("This stream has already been locked for exclusive reading by another reader");
        if (!Ur(i._readableStreamController)) throw new TypeError("Cannot construct a ReadableStreamBYOBReader for a stream not constructed with a byte source");
        he(this, i), this._readIntoRequests = new P();
      }
      get closed() {
        return $r(this) ? this._closedPromise : h($s("closed"));
      }
      cancel(i = void 0) {
        return $r(this) ? this._ownerReadableStream === void 0 ? h(Z("cancel")) : oe(this, i) : h($s("cancel"));
      }
      read(i, c = {}) {
        if (!$r(this)) return h($s("read"));
        if (!ArrayBuffer.isView(i)) return h(new TypeError("view must be an array buffer view"));
        if (i.byteLength === 0) return h(new TypeError("view must have non-zero byteLength"));
        if (i.buffer.byteLength === 0) return h(new TypeError("view's buffer must have non-zero byteLength"));
        if (Cr(i.buffer)) return h(new TypeError("view's buffer has been detached"));
        let m;
        try {
          m = bg(c, "options");
        } catch (te) {
          return h(te);
        }
        let A = m.min;
        if (A === 0) return h(new TypeError("options.min must be greater than 0"));
        if (cg(i)) {
          if (A > i.byteLength) return h(new RangeError("options.min must be less than or equal to view's byteLength"));
        } else if (A > i.length) return h(new RangeError("options.min must be less than or equal to view's length"));
        if (this._ownerReadableStream === void 0) return h(Z("read from"));
        let N, U, V = f((te, fe) => {
          N = te, U = fe;
        });
        return jl(this, i, A, { _chunkSteps: (te) => N({ value: te, done: false }), _closeSteps: (te) => N({ value: te, done: true }), _errorSteps: (te) => U(te) }), V;
      }
      releaseLock() {
        if (!$r(this)) throw $s("releaseLock");
        this._ownerReadableStream !== void 0 && wg(this);
      }
    }
    Object.defineProperties(Er.prototype, { cancel: { enumerable: true }, read: { enumerable: true }, releaseLock: { enumerable: true }, closed: { enumerable: true } }), o(Er.prototype.cancel, "cancel"), o(Er.prototype.read, "read"), o(Er.prototype.releaseLock, "releaseLock"), typeof Symbol.toStringTag == "symbol" && Object.defineProperty(Er.prototype, Symbol.toStringTag, { value: "ReadableStreamBYOBReader", configurable: true });
    function $r(s) {
      return !t(s) || !Object.prototype.hasOwnProperty.call(s, "_readIntoRequests") ? false : s instanceof Er;
    }
    function jl(s, i, c, m) {
      let A = s._ownerReadableStream;
      A._disturbed = true, A._state === "errored" ? m._errorSteps(A._storedError) : dg(A._readableStreamController, i, c, m);
    }
    function wg(s) {
      ue(s);
      let i = new TypeError("Reader was released");
      Ll(s, i);
    }
    function Ll(s, i) {
      let c = s._readIntoRequests;
      s._readIntoRequests = new P(), c.forEach((m) => {
        m._errorSteps(i);
      });
    }
    function $s(s) {
      return new TypeError(`ReadableStreamBYOBReader.prototype.${s} can only be used on a ReadableStreamBYOBReader`);
    }
    function Qn(s, i) {
      let { highWaterMark: c } = s;
      if (c === void 0) return i;
      if (ut(c) || c < 0) throw new RangeError("Invalid highWaterMark");
      return c;
    }
    function Hs(s) {
      let { size: i } = s;
      return i || (() => 1);
    }
    function Gs(s, i) {
      ye(s, i);
      let c = s?.highWaterMark, m = s?.size;
      return { highWaterMark: c === void 0 ? void 0 : g(c), size: m === void 0 ? void 0 : Ag(m, `${i} has member 'size' that`) };
    }
    function Ag(s, i) {
      return Ae(s, i), (c) => g(s(c));
    }
    function Dg(s, i) {
      ye(s, i);
      let c = s?.abort, m = s?.close, A = s?.start, N = s?.type, U = s?.write;
      return { abort: c === void 0 ? void 0 : Sg(c, s, `${i} has member 'abort' that`), close: m === void 0 ? void 0 : vg(m, s, `${i} has member 'close' that`), start: A === void 0 ? void 0 : Tg(A, s, `${i} has member 'start' that`), write: U === void 0 ? void 0 : Rg(U, s, `${i} has member 'write' that`), type: N };
    }
    function Sg(s, i, c) {
      return Ae(s, c), (m) => k(s, i, [m]);
    }
    function vg(s, i, c) {
      return Ae(s, c), () => k(s, i, []);
    }
    function Tg(s, i, c) {
      return Ae(s, c), (m) => T(s, i, [m]);
    }
    function Rg(s, i, c) {
      return Ae(s, c), (m, A) => k(s, i, [m, A]);
    }
    function Ul(s, i) {
      if (!ln(s)) throw new TypeError(`${i} is not a WritableStream.`);
    }
    function Fg(s) {
      if (typeof s != "object" || s === null) return false;
      try {
        return typeof s.aborted == "boolean";
      } catch {
        return false;
      }
    }
    let kg = typeof AbortController == "function";
    function Og() {
      if (kg) return new AbortController();
    }
    class wr {
      constructor(i = {}, c = {}) {
        i === void 0 ? i = null : Be(i, "First parameter");
        let m = Gs(c, "Second parameter"), A = Dg(i, "First parameter");
        if ($l(this), A.type !== void 0) throw new RangeError("Invalid type is specified");
        let U = Hs(m), V = Qn(m, 1);
        Wg(this, A, V, U);
      }
      get locked() {
        if (!ln(this)) throw Ks("locked");
        return fn(this);
      }
      abort(i = void 0) {
        return ln(this) ? fn(this) ? h(new TypeError("Cannot abort a stream that already has a writer")) : Ws(this, i) : h(Ks("abort"));
      }
      close() {
        return ln(this) ? fn(this) ? h(new TypeError("Cannot close a stream that already has a writer")) : Gt(this) ? h(new TypeError("Cannot close an already-closing stream")) : Hl(this) : h(Ks("close"));
      }
      getWriter() {
        if (!ln(this)) throw Ks("getWriter");
        return Ml(this);
      }
    }
    Object.defineProperties(wr.prototype, { abort: { enumerable: true }, close: { enumerable: true }, getWriter: { enumerable: true }, locked: { enumerable: true } }), o(wr.prototype.abort, "abort"), o(wr.prototype.close, "close"), o(wr.prototype.getWriter, "getWriter"), typeof Symbol.toStringTag == "symbol" && Object.defineProperty(wr.prototype, Symbol.toStringTag, { value: "WritableStream", configurable: true });
    function Ml(s) {
      return new or(s);
    }
    function Pg(s, i, c, m, A = 1, N = () => 1) {
      let U = Object.create(wr.prototype);
      $l(U);
      let V = Object.create(dn.prototype);
      return Kl(U, V, s, i, c, m, A, N), U;
    }
    function $l(s) {
      s._state = "writable", s._storedError = void 0, s._writer = void 0, s._writableStreamController = void 0, s._writeRequests = new P(), s._inFlightWriteRequest = void 0, s._closeRequest = void 0, s._inFlightCloseRequest = void 0, s._pendingAbortRequest = void 0, s._backpressure = false;
    }
    function ln(s) {
      return !t(s) || !Object.prototype.hasOwnProperty.call(s, "_writableStreamController") ? false : s instanceof wr;
    }
    function fn(s) {
      return s._writer !== void 0;
    }
    function Ws(s, i) {
      var c;
      if (s._state === "closed" || s._state === "errored") return d(void 0);
      s._writableStreamController._abortReason = i, (c = s._writableStreamController._abortController) === null || c === void 0 || c.abort(i);
      let m = s._state;
      if (m === "closed" || m === "errored") return d(void 0);
      if (s._pendingAbortRequest !== void 0) return s._pendingAbortRequest._promise;
      let A = false;
      m === "erroring" && (A = true, i = void 0);
      let N = f((U, V) => {
        s._pendingAbortRequest = { _promise: void 0, _resolve: U, _reject: V, _reason: i, _wasAlreadyErroring: A };
      });
      return s._pendingAbortRequest._promise = N, A || ha(s, i), N;
    }
    function Hl(s) {
      let i = s._state;
      if (i === "closed" || i === "errored") return h(new TypeError(`The stream (in ${i} state) is not in the writable state and cannot be closed`));
      let c = f((A, N) => {
        let U = { _resolve: A, _reject: N };
        s._closeRequest = U;
      }), m = s._writer;
      return m !== void 0 && s._backpressure && i === "writable" && Ea(m), zg(s._writableStreamController), c;
    }
    function xg(s) {
      return f((c, m) => {
        let A = { _resolve: c, _reject: m };
        s._writeRequests.push(A);
      });
    }
    function da(s, i) {
      if (s._state === "writable") {
        ha(s, i);
        return;
      }
      pa(s);
    }
    function ha(s, i) {
      let c = s._writableStreamController;
      s._state = "erroring", s._storedError = i;
      let m = s._writer;
      m !== void 0 && Wl(m, i), !jg(s) && c._started && pa(s);
    }
    function pa(s) {
      s._state = "errored", s._writableStreamController[G]();
      let i = s._storedError;
      if (s._writeRequests.forEach((A) => {
        A._reject(i);
      }), s._writeRequests = new P(), s._pendingAbortRequest === void 0) {
        zs(s);
        return;
      }
      let c = s._pendingAbortRequest;
      if (s._pendingAbortRequest = void 0, c._wasAlreadyErroring) {
        c._reject(i), zs(s);
        return;
      }
      let m = s._writableStreamController[j](c._reason);
      w(m, () => (c._resolve(), zs(s), null), (A) => (c._reject(A), zs(s), null));
    }
    function Bg(s) {
      s._inFlightWriteRequest._resolve(void 0), s._inFlightWriteRequest = void 0;
    }
    function Ig(s, i) {
      s._inFlightWriteRequest._reject(i), s._inFlightWriteRequest = void 0, da(s, i);
    }
    function Ng(s) {
      s._inFlightCloseRequest._resolve(void 0), s._inFlightCloseRequest = void 0, s._state === "erroring" && (s._storedError = void 0, s._pendingAbortRequest !== void 0 && (s._pendingAbortRequest._resolve(), s._pendingAbortRequest = void 0)), s._state = "closed";
      let c = s._writer;
      c !== void 0 && Zl(c);
    }
    function qg(s, i) {
      s._inFlightCloseRequest._reject(i), s._inFlightCloseRequest = void 0, s._pendingAbortRequest !== void 0 && (s._pendingAbortRequest._reject(i), s._pendingAbortRequest = void 0), da(s, i);
    }
    function Gt(s) {
      return !(s._closeRequest === void 0 && s._inFlightCloseRequest === void 0);
    }
    function jg(s) {
      return !(s._inFlightWriteRequest === void 0 && s._inFlightCloseRequest === void 0);
    }
    function Lg(s) {
      s._inFlightCloseRequest = s._closeRequest, s._closeRequest = void 0;
    }
    function Ug(s) {
      s._inFlightWriteRequest = s._writeRequests.shift();
    }
    function zs(s) {
      s._closeRequest !== void 0 && (s._closeRequest._reject(s._storedError), s._closeRequest = void 0);
      let i = s._writer;
      i !== void 0 && Ca(i, s._storedError);
    }
    function ma(s, i) {
      let c = s._writer;
      c !== void 0 && i !== s._backpressure && (i ? Zg(c) : Ea(c)), s._backpressure = i;
    }
    class or {
      constructor(i) {
        if (Ne(i, 1, "WritableStreamDefaultWriter"), Ul(i, "First parameter"), fn(i)) throw new TypeError("This stream has already been locked for exclusive writing by another writer");
        this._ownerWritableStream = i, i._writer = this;
        let c = i._state;
        if (c === "writable") !Gt(i) && i._backpressure ? Xs(this) : ef(this), Ys(this);
        else if (c === "erroring") ba(this, i._storedError), Ys(this);
        else if (c === "closed") ef(this), Xg(this);
        else {
          let m = i._storedError;
          ba(this, m), Ql(this, m);
        }
      }
      get closed() {
        return Hr(this) ? this._closedPromise : h(Gr("closed"));
      }
      get desiredSize() {
        if (!Hr(this)) throw Gr("desiredSize");
        if (this._ownerWritableStream === void 0) throw es("desiredSize");
        return Gg(this);
      }
      get ready() {
        return Hr(this) ? this._readyPromise : h(Gr("ready"));
      }
      abort(i = void 0) {
        return Hr(this) ? this._ownerWritableStream === void 0 ? h(es("abort")) : Mg(this, i) : h(Gr("abort"));
      }
      close() {
        if (!Hr(this)) return h(Gr("close"));
        let i = this._ownerWritableStream;
        return i === void 0 ? h(es("close")) : Gt(i) ? h(new TypeError("Cannot close an already-closing stream")) : Gl(this);
      }
      releaseLock() {
        if (!Hr(this)) throw Gr("releaseLock");
        this._ownerWritableStream !== void 0 && zl(this);
      }
      write(i = void 0) {
        return Hr(this) ? this._ownerWritableStream === void 0 ? h(es("write to")) : Jl(this, i) : h(Gr("write"));
      }
    }
    Object.defineProperties(or.prototype, { abort: { enumerable: true }, close: { enumerable: true }, releaseLock: { enumerable: true }, write: { enumerable: true }, closed: { enumerable: true }, desiredSize: { enumerable: true }, ready: { enumerable: true } }), o(or.prototype.abort, "abort"), o(or.prototype.close, "close"), o(or.prototype.releaseLock, "releaseLock"), o(or.prototype.write, "write"), typeof Symbol.toStringTag == "symbol" && Object.defineProperty(or.prototype, Symbol.toStringTag, { value: "WritableStreamDefaultWriter", configurable: true });
    function Hr(s) {
      return !t(s) || !Object.prototype.hasOwnProperty.call(s, "_ownerWritableStream") ? false : s instanceof or;
    }
    function Mg(s, i) {
      let c = s._ownerWritableStream;
      return Ws(c, i);
    }
    function Gl(s) {
      let i = s._ownerWritableStream;
      return Hl(i);
    }
    function $g(s) {
      let i = s._ownerWritableStream, c = i._state;
      return Gt(i) || c === "closed" ? d(void 0) : c === "errored" ? h(i._storedError) : Gl(s);
    }
    function Hg(s, i) {
      s._closedPromiseState === "pending" ? Ca(s, i) : Qg(s, i);
    }
    function Wl(s, i) {
      s._readyPromiseState === "pending" ? tf(s, i) : ey(s, i);
    }
    function Gg(s) {
      let i = s._ownerWritableStream, c = i._state;
      return c === "errored" || c === "erroring" ? null : c === "closed" ? 0 : Yl(i._writableStreamController);
    }
    function zl(s) {
      let i = s._ownerWritableStream, c = new TypeError("Writer was released and can no longer be used to monitor the stream's closedness");
      Wl(s, c), Hg(s, c), i._writer = void 0, s._ownerWritableStream = void 0;
    }
    function Jl(s, i) {
      let c = s._ownerWritableStream, m = c._writableStreamController, A = Jg(m, i);
      if (c !== s._ownerWritableStream) return h(es("write to"));
      let N = c._state;
      if (N === "errored") return h(c._storedError);
      if (Gt(c) || N === "closed") return h(new TypeError("The stream is closing or closed and cannot be written to"));
      if (N === "erroring") return h(c._storedError);
      let U = xg(c);
      return Vg(m, i, A), U;
    }
    let Vl = {};
    class dn {
      constructor() {
        throw new TypeError("Illegal constructor");
      }
      get abortReason() {
        if (!ga(this)) throw _a("abortReason");
        return this._abortReason;
      }
      get signal() {
        if (!ga(this)) throw _a("signal");
        if (this._abortController === void 0) throw new TypeError("WritableStreamDefaultController.prototype.signal is not supported");
        return this._abortController.signal;
      }
      error(i = void 0) {
        if (!ga(this)) throw _a("error");
        this._controlledWritableStream._state === "writable" && Xl(this, i);
      }
      [j](i) {
        let c = this._abortAlgorithm(i);
        return Js(this), c;
      }
      [G]() {
        br(this);
      }
    }
    Object.defineProperties(dn.prototype, { abortReason: { enumerable: true }, signal: { enumerable: true }, error: { enumerable: true } }), typeof Symbol.toStringTag == "symbol" && Object.defineProperty(dn.prototype, Symbol.toStringTag, { value: "WritableStreamDefaultController", configurable: true });
    function ga(s) {
      return !t(s) || !Object.prototype.hasOwnProperty.call(s, "_controlledWritableStream") ? false : s instanceof dn;
    }
    function Kl(s, i, c, m, A, N, U, V) {
      i._controlledWritableStream = s, s._writableStreamController = i, i._queue = void 0, i._queueTotalSize = void 0, br(i), i._abortReason = void 0, i._abortController = Og(), i._started = false, i._strategySizeAlgorithm = V, i._strategyHWM = U, i._writeAlgorithm = m, i._closeAlgorithm = A, i._abortAlgorithm = N;
      let ae = ya(i);
      ma(s, ae);
      let te = c(), fe = d(te);
      w(fe, () => (i._started = true, Vs(i), null), (ge) => (i._started = true, da(s, ge), null));
    }
    function Wg(s, i, c, m) {
      let A = Object.create(dn.prototype), N, U, V, ae;
      i.start !== void 0 ? N = () => i.start(A) : N = () => {
      }, i.write !== void 0 ? U = (te) => i.write(te, A) : U = () => d(void 0), i.close !== void 0 ? V = () => i.close() : V = () => d(void 0), i.abort !== void 0 ? ae = (te) => i.abort(te) : ae = () => d(void 0), Kl(s, A, N, U, V, ae, c, m);
    }
    function Js(s) {
      s._writeAlgorithm = void 0, s._closeAlgorithm = void 0, s._abortAlgorithm = void 0, s._strategySizeAlgorithm = void 0;
    }
    function zg(s) {
      sa(s, Vl, 0), Vs(s);
    }
    function Jg(s, i) {
      try {
        return s._strategySizeAlgorithm(i);
      } catch (c) {
        return Zn(s, c), 1;
      }
    }
    function Yl(s) {
      return s._strategyHWM - s._queueTotalSize;
    }
    function Vg(s, i, c) {
      try {
        sa(s, i, c);
      } catch (A) {
        Zn(s, A);
        return;
      }
      let m = s._controlledWritableStream;
      if (!Gt(m) && m._state === "writable") {
        let A = ya(s);
        ma(m, A);
      }
      Vs(s);
    }
    function Vs(s) {
      let i = s._controlledWritableStream;
      if (!s._started || i._inFlightWriteRequest !== void 0) return;
      if (i._state === "erroring") {
        pa(i);
        return;
      }
      if (s._queue.length === 0) return;
      let m = ug(s);
      m === Vl ? Kg(s) : Yg(s, m);
    }
    function Zn(s, i) {
      s._controlledWritableStream._state === "writable" && Xl(s, i);
    }
    function Kg(s) {
      let i = s._controlledWritableStream;
      Lg(i), na(s);
      let c = s._closeAlgorithm();
      Js(s), w(c, () => (Ng(i), null), (m) => (qg(i, m), null));
    }
    function Yg(s, i) {
      let c = s._controlledWritableStream;
      Ug(c);
      let m = s._writeAlgorithm(i);
      w(m, () => {
        Bg(c);
        let A = c._state;
        if (na(s), !Gt(c) && A === "writable") {
          let N = ya(s);
          ma(c, N);
        }
        return Vs(s), null;
      }, (A) => (c._state === "writable" && Js(s), Ig(c, A), null));
    }
    function ya(s) {
      return Yl(s) <= 0;
    }
    function Xl(s, i) {
      let c = s._controlledWritableStream;
      Js(s), ha(c, i);
    }
    function Ks(s) {
      return new TypeError(`WritableStream.prototype.${s} can only be used on a WritableStream`);
    }
    function _a(s) {
      return new TypeError(`WritableStreamDefaultController.prototype.${s} can only be used on a WritableStreamDefaultController`);
    }
    function Gr(s) {
      return new TypeError(`WritableStreamDefaultWriter.prototype.${s} can only be used on a WritableStreamDefaultWriter`);
    }
    function es(s) {
      return new TypeError("Cannot " + s + " a stream using a released writer");
    }
    function Ys(s) {
      s._closedPromise = f((i, c) => {
        s._closedPromise_resolve = i, s._closedPromise_reject = c, s._closedPromiseState = "pending";
      });
    }
    function Ql(s, i) {
      Ys(s), Ca(s, i);
    }
    function Xg(s) {
      Ys(s), Zl(s);
    }
    function Ca(s, i) {
      s._closedPromise_reject !== void 0 && (_(s._closedPromise), s._closedPromise_reject(i), s._closedPromise_resolve = void 0, s._closedPromise_reject = void 0, s._closedPromiseState = "rejected");
    }
    function Qg(s, i) {
      Ql(s, i);
    }
    function Zl(s) {
      s._closedPromise_resolve !== void 0 && (s._closedPromise_resolve(void 0), s._closedPromise_resolve = void 0, s._closedPromise_reject = void 0, s._closedPromiseState = "resolved");
    }
    function Xs(s) {
      s._readyPromise = f((i, c) => {
        s._readyPromise_resolve = i, s._readyPromise_reject = c;
      }), s._readyPromiseState = "pending";
    }
    function ba(s, i) {
      Xs(s), tf(s, i);
    }
    function ef(s) {
      Xs(s), Ea(s);
    }
    function tf(s, i) {
      s._readyPromise_reject !== void 0 && (_(s._readyPromise), s._readyPromise_reject(i), s._readyPromise_resolve = void 0, s._readyPromise_reject = void 0, s._readyPromiseState = "rejected");
    }
    function Zg(s) {
      Xs(s);
    }
    function ey(s, i) {
      ba(s, i);
    }
    function Ea(s) {
      s._readyPromise_resolve !== void 0 && (s._readyPromise_resolve(void 0), s._readyPromise_resolve = void 0, s._readyPromise_reject = void 0, s._readyPromiseState = "fulfilled");
    }
    function ty() {
      if (typeof globalThis < "u") return globalThis;
      if (typeof self < "u") return self;
      if (typeof global < "u") return global;
    }
    let wa = ty();
    function ry(s) {
      if (!(typeof s == "function" || typeof s == "object") || s.name !== "DOMException") return false;
      try {
        return new s(), true;
      } catch {
        return false;
      }
    }
    function ny() {
      let s = wa?.DOMException;
      return ry(s) ? s : void 0;
    }
    function sy() {
      let s = function(c, m) {
        this.message = c || "", this.name = m || "Error", Error.captureStackTrace && Error.captureStackTrace(this, this.constructor);
      };
      return o(s, "DOMException"), s.prototype = Object.create(Error.prototype), Object.defineProperty(s.prototype, "constructor", { value: s, writable: true, configurable: true }), s;
    }
    let oy = ny() || sy();
    function rf(s, i, c, m, A, N) {
      let U = q(s), V = Ml(i);
      s._disturbed = true;
      let ae = false, te = d(void 0);
      return f((fe, ge) => {
        let Re;
        if (N !== void 0) {
          if (Re = () => {
            let se = N.reason !== void 0 ? N.reason : new oy("Aborted", "AbortError"), _e = [];
            m || _e.push(() => i._state === "writable" ? Ws(i, se) : d(void 0)), A || _e.push(() => s._state === "readable" ? Ot(s, se) : d(void 0)), nt(() => Promise.all(_e.map((Fe) => Fe())), true, se);
          }, N.aborted) {
            Re();
            return;
          }
          N.addEventListener("abort", Re);
        }
        function Pt() {
          return f((se, _e) => {
            function Fe(ct) {
              ct ? se() : C(gn(), Fe, _e);
            }
            Fe(false);
          });
        }
        function gn() {
          return ae ? d(true) : C(V._readyPromise, () => f((se, _e) => {
            Q(U, { _chunkSteps: (Fe) => {
              te = C(Jl(V, Fe), void 0, e), se(false);
            }, _closeSteps: () => se(true), _errorSteps: _e });
          }));
        }
        if (ar(s, U._closedPromise, (se) => (m ? bt(true, se) : nt(() => Ws(i, se), true, se), null)), ar(i, V._closedPromise, (se) => (A ? bt(true, se) : nt(() => Ot(s, se), true, se), null)), Ze(s, U._closedPromise, () => (c ? bt() : nt(() => $g(V)), null)), Gt(i) || i._state === "closed") {
          let se = new TypeError("the destination writable stream closed before all data could be piped to it");
          A ? bt(true, se) : nt(() => Ot(s, se), true, se);
        }
        _(Pt());
        function vr() {
          let se = te;
          return C(te, () => se !== te ? vr() : void 0);
        }
        function ar(se, _e, Fe) {
          se._state === "errored" ? Fe(se._storedError) : S(_e, Fe);
        }
        function Ze(se, _e, Fe) {
          se._state === "closed" ? Fe() : I(_e, Fe);
        }
        function nt(se, _e, Fe) {
          if (ae) return;
          ae = true, i._state === "writable" && !Gt(i) ? I(vr(), ct) : ct();
          function ct() {
            return w(se(), () => ur(_e, Fe), (yn) => ur(true, yn)), null;
          }
        }
        function bt(se, _e) {
          ae || (ae = true, i._state === "writable" && !Gt(i) ? I(vr(), () => ur(se, _e)) : ur(se, _e));
        }
        function ur(se, _e) {
          return zl(V), ue(U), N !== void 0 && N.removeEventListener("abort", Re), se ? ge(_e) : fe(void 0), null;
        }
      });
    }
    class ir {
      constructor() {
        throw new TypeError("Illegal constructor");
      }
      get desiredSize() {
        if (!Qs(this)) throw eo("desiredSize");
        return Aa(this);
      }
      close() {
        if (!Qs(this)) throw eo("close");
        if (!pn(this)) throw new TypeError("The stream is not in a state that permits close");
        Wr(this);
      }
      enqueue(i = void 0) {
        if (!Qs(this)) throw eo("enqueue");
        if (!pn(this)) throw new TypeError("The stream is not in a state that permits enqueue");
        return hn(this, i);
      }
      error(i = void 0) {
        if (!Qs(this)) throw eo("error");
        kt(this, i);
      }
      [re](i) {
        br(this);
        let c = this._cancelAlgorithm(i);
        return Zs(this), c;
      }
      [W](i) {
        let c = this._controlledReadableStream;
        if (this._queue.length > 0) {
          let m = na(this);
          this._closeRequested && this._queue.length === 0 ? (Zs(this), ns(c)) : ts(this), i._chunkSteps(m);
        } else D(c, i), ts(this);
      }
      [Ee]() {
      }
    }
    Object.defineProperties(ir.prototype, { close: { enumerable: true }, enqueue: { enumerable: true }, error: { enumerable: true }, desiredSize: { enumerable: true } }), o(ir.prototype.close, "close"), o(ir.prototype.enqueue, "enqueue"), o(ir.prototype.error, "error"), typeof Symbol.toStringTag == "symbol" && Object.defineProperty(ir.prototype, Symbol.toStringTag, { value: "ReadableStreamDefaultController", configurable: true });
    function Qs(s) {
      return !t(s) || !Object.prototype.hasOwnProperty.call(s, "_controlledReadableStream") ? false : s instanceof ir;
    }
    function ts(s) {
      if (!nf(s)) return;
      if (s._pulling) {
        s._pullAgain = true;
        return;
      }
      s._pulling = true;
      let c = s._pullAlgorithm();
      w(c, () => (s._pulling = false, s._pullAgain && (s._pullAgain = false, ts(s)), null), (m) => (kt(s, m), null));
    }
    function nf(s) {
      let i = s._controlledReadableStream;
      return !pn(s) || !s._started ? false : !!(Dr(i) && B(i) > 0 || Aa(s) > 0);
    }
    function Zs(s) {
      s._pullAlgorithm = void 0, s._cancelAlgorithm = void 0, s._strategySizeAlgorithm = void 0;
    }
    function Wr(s) {
      if (!pn(s)) return;
      let i = s._controlledReadableStream;
      s._closeRequested = true, s._queue.length === 0 && (Zs(s), ns(i));
    }
    function hn(s, i) {
      if (!pn(s)) return;
      let c = s._controlledReadableStream;
      if (Dr(c) && B(c) > 0) R(c, i, false);
      else {
        let m;
        try {
          m = s._strategySizeAlgorithm(i);
        } catch (A) {
          throw kt(s, A), A;
        }
        try {
          sa(s, i, m);
        } catch (A) {
          throw kt(s, A), A;
        }
      }
      ts(s);
    }
    function kt(s, i) {
      let c = s._controlledReadableStream;
      c._state === "readable" && (br(s), Zs(s), uf(c, i));
    }
    function Aa(s) {
      let i = s._controlledReadableStream._state;
      return i === "errored" ? null : i === "closed" ? 0 : s._strategyHWM - s._queueTotalSize;
    }
    function iy(s) {
      return !nf(s);
    }
    function pn(s) {
      let i = s._controlledReadableStream._state;
      return !s._closeRequested && i === "readable";
    }
    function sf(s, i, c, m, A, N, U) {
      i._controlledReadableStream = s, i._queue = void 0, i._queueTotalSize = void 0, br(i), i._started = false, i._closeRequested = false, i._pullAgain = false, i._pulling = false, i._strategySizeAlgorithm = U, i._strategyHWM = N, i._pullAlgorithm = m, i._cancelAlgorithm = A, s._readableStreamController = i;
      let V = c();
      w(d(V), () => (i._started = true, ts(i), null), (ae) => (kt(i, ae), null));
    }
    function ay(s, i, c, m) {
      let A = Object.create(ir.prototype), N, U, V;
      i.start !== void 0 ? N = () => i.start(A) : N = () => {
      }, i.pull !== void 0 ? U = () => i.pull(A) : U = () => d(void 0), i.cancel !== void 0 ? V = (ae) => i.cancel(ae) : V = () => d(void 0), sf(s, A, N, U, V, c, m);
    }
    function eo(s) {
      return new TypeError(`ReadableStreamDefaultController.prototype.${s} can only be used on a ReadableStreamDefaultController`);
    }
    function uy(s, i) {
      return Ur(s._readableStreamController) ? ly(s) : cy(s);
    }
    function cy(s, i) {
      let c = q(s), m = false, A = false, N = false, U = false, V, ae, te, fe, ge, Re = f((Ze) => {
        ge = Ze;
      });
      function Pt() {
        return m ? (A = true, d(void 0)) : (m = true, Q(c, { _chunkSteps: (nt) => {
          y(() => {
            A = false;
            let bt = nt, ur = nt;
            N || hn(te._readableStreamController, bt), U || hn(fe._readableStreamController, ur), m = false, A && Pt();
          });
        }, _closeSteps: () => {
          m = false, N || Wr(te._readableStreamController), U || Wr(fe._readableStreamController), (!N || !U) && ge(void 0);
        }, _errorSteps: () => {
          m = false;
        } }), d(void 0));
      }
      function gn(Ze) {
        if (N = true, V = Ze, U) {
          let nt = Se([V, ae]), bt = Ot(s, nt);
          ge(bt);
        }
        return Re;
      }
      function vr(Ze) {
        if (U = true, ae = Ze, N) {
          let nt = Se([V, ae]), bt = Ot(s, nt);
          ge(bt);
        }
        return Re;
      }
      function ar() {
      }
      return te = rs(ar, Pt, gn), fe = rs(ar, Pt, vr), S(c._closedPromise, (Ze) => (kt(te._readableStreamController, Ze), kt(fe._readableStreamController, Ze), (!N || !U) && ge(void 0), null)), [te, fe];
    }
    function ly(s) {
      let i = q(s), c = false, m = false, A = false, N = false, U = false, V, ae, te, fe, ge, Re = f((se) => {
        ge = se;
      });
      function Pt(se) {
        S(se._closedPromise, (_e) => (se !== i || (Ct(te._readableStreamController, _e), Ct(fe._readableStreamController, _e), (!N || !U) && ge(void 0)), null));
      }
      function gn() {
        $r(i) && (ue(i), i = q(s), Pt(i)), Q(i, { _chunkSteps: (_e) => {
          y(() => {
            m = false, A = false;
            let Fe = _e, ct = _e;
            if (!N && !U) try {
              ct = wl(_e);
            } catch (yn) {
              Ct(te._readableStreamController, yn), Ct(fe._readableStreamController, yn), ge(Ot(s, yn));
              return;
            }
            N || Ls(te._readableStreamController, Fe), U || Ls(fe._readableStreamController, ct), c = false, m ? ar() : A && Ze();
          });
        }, _closeSteps: () => {
          c = false, N || Yn(te._readableStreamController), U || Yn(fe._readableStreamController), te._readableStreamController._pendingPullIntos.length > 0 && Us(te._readableStreamController, 0), fe._readableStreamController._pendingPullIntos.length > 0 && Us(fe._readableStreamController, 0), (!N || !U) && ge(void 0);
        }, _errorSteps: () => {
          c = false;
        } });
      }
      function vr(se, _e) {
        K(i) && (ue(i), i = Il(s), Pt(i));
        let Fe = _e ? fe : te, ct = _e ? te : fe;
        jl(i, se, 1, { _chunkSteps: (_n) => {
          y(() => {
            m = false, A = false;
            let Cn = _e ? U : N;
            if (_e ? N : U) Cn || Ms(Fe._readableStreamController, _n);
            else {
              let Ef;
              try {
                Ef = wl(_n);
              } catch (Ra) {
                Ct(Fe._readableStreamController, Ra), Ct(ct._readableStreamController, Ra), ge(Ot(s, Ra));
                return;
              }
              Cn || Ms(Fe._readableStreamController, _n), Ls(ct._readableStreamController, Ef);
            }
            c = false, m ? ar() : A && Ze();
          });
        }, _closeSteps: (_n) => {
          c = false;
          let Cn = _e ? U : N, uo = _e ? N : U;
          Cn || Yn(Fe._readableStreamController), uo || Yn(ct._readableStreamController), _n !== void 0 && (Cn || Ms(Fe._readableStreamController, _n), !uo && ct._readableStreamController._pendingPullIntos.length > 0 && Us(ct._readableStreamController, 0)), (!Cn || !uo) && ge(void 0);
        }, _errorSteps: () => {
          c = false;
        } });
      }
      function ar() {
        if (c) return m = true, d(void 0);
        c = true;
        let se = ca(te._readableStreamController);
        return se === null ? gn() : vr(se._view, false), d(void 0);
      }
      function Ze() {
        if (c) return A = true, d(void 0);
        c = true;
        let se = ca(fe._readableStreamController);
        return se === null ? gn() : vr(se._view, true), d(void 0);
      }
      function nt(se) {
        if (N = true, V = se, U) {
          let _e = Se([V, ae]), Fe = Ot(s, _e);
          ge(Fe);
        }
        return Re;
      }
      function bt(se) {
        if (U = true, ae = se, N) {
          let _e = Se([V, ae]), Fe = Ot(s, _e);
          ge(Fe);
        }
        return Re;
      }
      function ur() {
      }
      return te = af(ur, ar, nt), fe = af(ur, Ze, bt), Pt(i), [te, fe];
    }
    function fy(s) {
      return t(s) && typeof s.getReader < "u";
    }
    function dy(s) {
      return fy(s) ? py(s.getReader()) : hy(s);
    }
    function hy(s) {
      let i, c = El(s, "async"), m = e;
      function A() {
        let U;
        try {
          U = sg(c);
        } catch (ae) {
          return h(ae);
        }
        let V = d(U);
        return b(V, (ae) => {
          if (!t(ae)) throw new TypeError("The promise returned by the iterator.next() method must fulfill with an object");
          if (og(ae)) Wr(i._readableStreamController);
          else {
            let fe = ig(ae);
            hn(i._readableStreamController, fe);
          }
        });
      }
      function N(U) {
        let V = c.iterator, ae;
        try {
          ae = Ns(V, "return");
        } catch (ge) {
          return h(ge);
        }
        if (ae === void 0) return d(void 0);
        let te;
        try {
          te = T(ae, V, [U]);
        } catch (ge) {
          return h(ge);
        }
        let fe = d(te);
        return b(fe, (ge) => {
          if (!t(ge)) throw new TypeError("The promise returned by the iterator.return() method must fulfill with an object");
        });
      }
      return i = rs(m, A, N, 0), i;
    }
    function py(s) {
      let i, c = e;
      function m() {
        let N;
        try {
          N = s.read();
        } catch (U) {
          return h(U);
        }
        return b(N, (U) => {
          if (!t(U)) throw new TypeError("The promise returned by the reader.read() method must fulfill with an object");
          if (U.done) Wr(i._readableStreamController);
          else {
            let V = U.value;
            hn(i._readableStreamController, V);
          }
        });
      }
      function A(N) {
        try {
          return d(s.cancel(N));
        } catch (U) {
          return h(U);
        }
      }
      return i = rs(c, m, A, 0), i;
    }
    function my(s, i) {
      ye(s, i);
      let c = s, m = c?.autoAllocateChunkSize, A = c?.cancel, N = c?.pull, U = c?.start, V = c?.type;
      return { autoAllocateChunkSize: m === void 0 ? void 0 : v(m, `${i} has member 'autoAllocateChunkSize' that`), cancel: A === void 0 ? void 0 : gy(A, c, `${i} has member 'cancel' that`), pull: N === void 0 ? void 0 : yy(N, c, `${i} has member 'pull' that`), start: U === void 0 ? void 0 : _y(U, c, `${i} has member 'start' that`), type: V === void 0 ? void 0 : Cy(V, `${i} has member 'type' that`) };
    }
    function gy(s, i, c) {
      return Ae(s, c), (m) => k(s, i, [m]);
    }
    function yy(s, i, c) {
      return Ae(s, c), (m) => k(s, i, [m]);
    }
    function _y(s, i, c) {
      return Ae(s, c), (m) => T(s, i, [m]);
    }
    function Cy(s, i) {
      if (s = `${s}`, s !== "bytes") throw new TypeError(`${i} '${s}' is not a valid enumeration value for ReadableStreamType`);
      return s;
    }
    function by(s, i) {
      return ye(s, i), { preventCancel: !!s?.preventCancel };
    }
    function of(s, i) {
      ye(s, i);
      let c = s?.preventAbort, m = s?.preventCancel, A = s?.preventClose, N = s?.signal;
      return N !== void 0 && Ey(N, `${i} has member 'signal' that`), { preventAbort: !!c, preventCancel: !!m, preventClose: !!A, signal: N };
    }
    function Ey(s, i) {
      if (!Fg(s)) throw new TypeError(`${i} is not an AbortSignal.`);
    }
    function wy(s, i) {
      ye(s, i);
      let c = s?.readable;
      p(c, "readable", "ReadableWritablePair"), F(c, `${i} has member 'readable' that`);
      let m = s?.writable;
      return p(m, "writable", "ReadableWritablePair"), Ul(m, `${i} has member 'writable' that`), { readable: c, writable: m };
    }
    class Ye {
      constructor(i = {}, c = {}) {
        i === void 0 ? i = null : Be(i, "First parameter");
        let m = Gs(c, "Second parameter"), A = my(i, "First parameter");
        if (Da(this), A.type === "bytes") {
          if (m.size !== void 0) throw new RangeError("The strategy for a byte stream cannot have a size function");
          let N = Qn(m, 0);
          gg(this, A, N);
        } else {
          let N = Hs(m), U = Qn(m, 1);
          ay(this, A, U, N);
        }
      }
      get locked() {
        if (!Ar(this)) throw zr("locked");
        return Dr(this);
      }
      cancel(i = void 0) {
        return Ar(this) ? Dr(this) ? h(new TypeError("Cannot cancel a stream that already has a reader")) : Ot(this, i) : h(zr("cancel"));
      }
      getReader(i = void 0) {
        if (!Ar(this)) throw zr("getReader");
        return _g(i, "First parameter").mode === void 0 ? q(this) : Il(this);
      }
      pipeThrough(i, c = {}) {
        if (!Ar(this)) throw zr("pipeThrough");
        Ne(i, 1, "pipeThrough");
        let m = wy(i, "First parameter"), A = of(c, "Second parameter");
        if (Dr(this)) throw new TypeError("ReadableStream.prototype.pipeThrough cannot be used on a locked ReadableStream");
        if (fn(m.writable)) throw new TypeError("ReadableStream.prototype.pipeThrough cannot be used on a locked WritableStream");
        let N = rf(this, m.writable, A.preventClose, A.preventAbort, A.preventCancel, A.signal);
        return _(N), m.readable;
      }
      pipeTo(i, c = {}) {
        if (!Ar(this)) return h(zr("pipeTo"));
        if (i === void 0) return h("Parameter 1 is required in 'pipeTo'.");
        if (!ln(i)) return h(new TypeError("ReadableStream.prototype.pipeTo's first argument must be a WritableStream"));
        let m;
        try {
          m = of(c, "Second parameter");
        } catch (A) {
          return h(A);
        }
        return Dr(this) ? h(new TypeError("ReadableStream.prototype.pipeTo cannot be used on a locked ReadableStream")) : fn(i) ? h(new TypeError("ReadableStream.prototype.pipeTo cannot be used on a locked WritableStream")) : rf(this, i, m.preventClose, m.preventAbort, m.preventCancel, m.signal);
      }
      tee() {
        if (!Ar(this)) throw zr("tee");
        let i = uy(this);
        return Se(i);
      }
      values(i = void 0) {
        if (!Ar(this)) throw zr("values");
        let c = by(i, "First parameter");
        return on(this, c.preventCancel);
      }
      [ra](i) {
        return this.values(i);
      }
      static from(i) {
        return dy(i);
      }
    }
    Object.defineProperties(Ye, { from: { enumerable: true } }), Object.defineProperties(Ye.prototype, { cancel: { enumerable: true }, getReader: { enumerable: true }, pipeThrough: { enumerable: true }, pipeTo: { enumerable: true }, tee: { enumerable: true }, values: { enumerable: true }, locked: { enumerable: true } }), o(Ye.from, "from"), o(Ye.prototype.cancel, "cancel"), o(Ye.prototype.getReader, "getReader"), o(Ye.prototype.pipeThrough, "pipeThrough"), o(Ye.prototype.pipeTo, "pipeTo"), o(Ye.prototype.tee, "tee"), o(Ye.prototype.values, "values"), typeof Symbol.toStringTag == "symbol" && Object.defineProperty(Ye.prototype, Symbol.toStringTag, { value: "ReadableStream", configurable: true }), Object.defineProperty(Ye.prototype, ra, { value: Ye.prototype.values, writable: true, configurable: true });
    function rs(s, i, c, m = 1, A = () => 1) {
      let N = Object.create(Ye.prototype);
      Da(N);
      let U = Object.create(ir.prototype);
      return sf(N, U, s, i, c, m, A), N;
    }
    function af(s, i, c) {
      let m = Object.create(Ye.prototype);
      Da(m);
      let A = Object.create(sr.prototype);
      return Bl(m, A, s, i, c, 0, void 0), m;
    }
    function Da(s) {
      s._state = "readable", s._reader = void 0, s._storedError = void 0, s._disturbed = false;
    }
    function Ar(s) {
      return !t(s) || !Object.prototype.hasOwnProperty.call(s, "_readableStreamController") ? false : s instanceof Ye;
    }
    function Dr(s) {
      return s._reader !== void 0;
    }
    function Ot(s, i) {
      if (s._disturbed = true, s._state === "closed") return d(void 0);
      if (s._state === "errored") return h(s._storedError);
      ns(s);
      let c = s._reader;
      if (c !== void 0 && $r(c)) {
        let A = c._readIntoRequests;
        c._readIntoRequests = new P(), A.forEach((N) => {
          N._closeSteps(void 0);
        });
      }
      let m = s._readableStreamController[re](i);
      return b(m, e);
    }
    function ns(s) {
      s._state = "closed";
      let i = s._reader;
      if (i !== void 0 && (le(i), K(i))) {
        let c = i._readRequests;
        i._readRequests = new P(), c.forEach((m) => {
          m._closeSteps();
        });
      }
    }
    function uf(s, i) {
      s._state = "errored", s._storedError = i;
      let c = s._reader;
      c !== void 0 && (J(c, i), K(c) ? Oe(c, i) : Ll(c, i));
    }
    function zr(s) {
      return new TypeError(`ReadableStream.prototype.${s} can only be used on a ReadableStream`);
    }
    function cf(s, i) {
      ye(s, i);
      let c = s?.highWaterMark;
      return p(c, "highWaterMark", "QueuingStrategyInit"), { highWaterMark: g(c) };
    }
    let lf = (s) => s.byteLength;
    o(lf, "size");
    class to {
      constructor(i) {
        Ne(i, 1, "ByteLengthQueuingStrategy"), i = cf(i, "First parameter"), this._byteLengthQueuingStrategyHighWaterMark = i.highWaterMark;
      }
      get highWaterMark() {
        if (!df(this)) throw ff("highWaterMark");
        return this._byteLengthQueuingStrategyHighWaterMark;
      }
      get size() {
        if (!df(this)) throw ff("size");
        return lf;
      }
    }
    Object.defineProperties(to.prototype, { highWaterMark: { enumerable: true }, size: { enumerable: true } }), typeof Symbol.toStringTag == "symbol" && Object.defineProperty(to.prototype, Symbol.toStringTag, { value: "ByteLengthQueuingStrategy", configurable: true });
    function ff(s) {
      return new TypeError(`ByteLengthQueuingStrategy.prototype.${s} can only be used on a ByteLengthQueuingStrategy`);
    }
    function df(s) {
      return !t(s) || !Object.prototype.hasOwnProperty.call(s, "_byteLengthQueuingStrategyHighWaterMark") ? false : s instanceof to;
    }
    let hf = () => 1;
    o(hf, "size");
    class ro {
      constructor(i) {
        Ne(i, 1, "CountQueuingStrategy"), i = cf(i, "First parameter"), this._countQueuingStrategyHighWaterMark = i.highWaterMark;
      }
      get highWaterMark() {
        if (!mf(this)) throw pf("highWaterMark");
        return this._countQueuingStrategyHighWaterMark;
      }
      get size() {
        if (!mf(this)) throw pf("size");
        return hf;
      }
    }
    Object.defineProperties(ro.prototype, { highWaterMark: { enumerable: true }, size: { enumerable: true } }), typeof Symbol.toStringTag == "symbol" && Object.defineProperty(ro.prototype, Symbol.toStringTag, { value: "CountQueuingStrategy", configurable: true });
    function pf(s) {
      return new TypeError(`CountQueuingStrategy.prototype.${s} can only be used on a CountQueuingStrategy`);
    }
    function mf(s) {
      return !t(s) || !Object.prototype.hasOwnProperty.call(s, "_countQueuingStrategyHighWaterMark") ? false : s instanceof ro;
    }
    function Ay(s, i) {
      ye(s, i);
      let c = s?.cancel, m = s?.flush, A = s?.readableType, N = s?.start, U = s?.transform, V = s?.writableType;
      return { cancel: c === void 0 ? void 0 : Ty(c, s, `${i} has member 'cancel' that`), flush: m === void 0 ? void 0 : Dy(m, s, `${i} has member 'flush' that`), readableType: A, start: N === void 0 ? void 0 : Sy(N, s, `${i} has member 'start' that`), transform: U === void 0 ? void 0 : vy(U, s, `${i} has member 'transform' that`), writableType: V };
    }
    function Dy(s, i, c) {
      return Ae(s, c), (m) => k(s, i, [m]);
    }
    function Sy(s, i, c) {
      return Ae(s, c), (m) => T(s, i, [m]);
    }
    function vy(s, i, c) {
      return Ae(s, c), (m, A) => k(s, i, [m, A]);
    }
    function Ty(s, i, c) {
      return Ae(s, c), (m) => k(s, i, [m]);
    }
    class no {
      constructor(i = {}, c = {}, m = {}) {
        i === void 0 && (i = null);
        let A = Gs(c, "Second parameter"), N = Gs(m, "Third parameter"), U = Ay(i, "First parameter");
        if (U.readableType !== void 0) throw new RangeError("Invalid readableType specified");
        if (U.writableType !== void 0) throw new RangeError("Invalid writableType specified");
        let V = Qn(N, 0), ae = Hs(N), te = Qn(A, 1), fe = Hs(A), ge, Re = f((Pt) => {
          ge = Pt;
        });
        Ry(this, Re, te, fe, V, ae), ky(this, U), U.start !== void 0 ? ge(U.start(this._transformStreamController)) : ge(void 0);
      }
      get readable() {
        if (!gf(this)) throw bf("readable");
        return this._readable;
      }
      get writable() {
        if (!gf(this)) throw bf("writable");
        return this._writable;
      }
    }
    Object.defineProperties(no.prototype, { readable: { enumerable: true }, writable: { enumerable: true } }), typeof Symbol.toStringTag == "symbol" && Object.defineProperty(no.prototype, Symbol.toStringTag, { value: "TransformStream", configurable: true });
    function Ry(s, i, c, m, A, N) {
      function U() {
        return i;
      }
      function V(Re) {
        return xy(s, Re);
      }
      function ae(Re) {
        return By(s, Re);
      }
      function te() {
        return Iy(s);
      }
      s._writable = Pg(U, V, te, ae, c, m);
      function fe() {
        return Ny(s);
      }
      function ge(Re) {
        return qy(s, Re);
      }
      s._readable = rs(U, fe, ge, A, N), s._backpressure = void 0, s._backpressureChangePromise = void 0, s._backpressureChangePromise_resolve = void 0, so(s, true), s._transformStreamController = void 0;
    }
    function gf(s) {
      return !t(s) || !Object.prototype.hasOwnProperty.call(s, "_transformStreamController") ? false : s instanceof no;
    }
    function yf(s, i) {
      kt(s._readable._readableStreamController, i), Sa(s, i);
    }
    function Sa(s, i) {
      io(s._transformStreamController), Zn(s._writable._writableStreamController, i), va(s);
    }
    function va(s) {
      s._backpressure && so(s, false);
    }
    function so(s, i) {
      s._backpressureChangePromise !== void 0 && s._backpressureChangePromise_resolve(), s._backpressureChangePromise = f((c) => {
        s._backpressureChangePromise_resolve = c;
      }), s._backpressure = i;
    }
    class Sr {
      constructor() {
        throw new TypeError("Illegal constructor");
      }
      get desiredSize() {
        if (!oo(this)) throw ao("desiredSize");
        let i = this._controlledTransformStream._readable._readableStreamController;
        return Aa(i);
      }
      enqueue(i = void 0) {
        if (!oo(this)) throw ao("enqueue");
        _f(this, i);
      }
      error(i = void 0) {
        if (!oo(this)) throw ao("error");
        Oy(this, i);
      }
      terminate() {
        if (!oo(this)) throw ao("terminate");
        Py(this);
      }
    }
    Object.defineProperties(Sr.prototype, { enqueue: { enumerable: true }, error: { enumerable: true }, terminate: { enumerable: true }, desiredSize: { enumerable: true } }), o(Sr.prototype.enqueue, "enqueue"), o(Sr.prototype.error, "error"), o(Sr.prototype.terminate, "terminate"), typeof Symbol.toStringTag == "symbol" && Object.defineProperty(Sr.prototype, Symbol.toStringTag, { value: "TransformStreamDefaultController", configurable: true });
    function oo(s) {
      return !t(s) || !Object.prototype.hasOwnProperty.call(s, "_controlledTransformStream") ? false : s instanceof Sr;
    }
    function Fy(s, i, c, m, A) {
      i._controlledTransformStream = s, s._transformStreamController = i, i._transformAlgorithm = c, i._flushAlgorithm = m, i._cancelAlgorithm = A, i._finishPromise = void 0, i._finishPromise_resolve = void 0, i._finishPromise_reject = void 0;
    }
    function ky(s, i) {
      let c = Object.create(Sr.prototype), m, A, N;
      i.transform !== void 0 ? m = (U) => i.transform(U, c) : m = (U) => {
        try {
          return _f(c, U), d(void 0);
        } catch (V) {
          return h(V);
        }
      }, i.flush !== void 0 ? A = () => i.flush(c) : A = () => d(void 0), i.cancel !== void 0 ? N = (U) => i.cancel(U) : N = () => d(void 0), Fy(s, c, m, A, N);
    }
    function io(s) {
      s._transformAlgorithm = void 0, s._flushAlgorithm = void 0, s._cancelAlgorithm = void 0;
    }
    function _f(s, i) {
      let c = s._controlledTransformStream, m = c._readable._readableStreamController;
      if (!pn(m)) throw new TypeError("Readable side is not in a state that permits enqueue");
      try {
        hn(m, i);
      } catch (N) {
        throw Sa(c, N), c._readable._storedError;
      }
      iy(m) !== c._backpressure && so(c, true);
    }
    function Oy(s, i) {
      yf(s._controlledTransformStream, i);
    }
    function Cf(s, i) {
      let c = s._transformAlgorithm(i);
      return b(c, void 0, (m) => {
        throw yf(s._controlledTransformStream, m), m;
      });
    }
    function Py(s) {
      let i = s._controlledTransformStream, c = i._readable._readableStreamController;
      Wr(c);
      let m = new TypeError("TransformStream terminated");
      Sa(i, m);
    }
    function xy(s, i) {
      let c = s._transformStreamController;
      if (s._backpressure) {
        let m = s._backpressureChangePromise;
        return b(m, () => {
          let A = s._writable;
          if (A._state === "erroring") throw A._storedError;
          return Cf(c, i);
        });
      }
      return Cf(c, i);
    }
    function By(s, i) {
      let c = s._transformStreamController;
      if (c._finishPromise !== void 0) return c._finishPromise;
      let m = s._readable;
      c._finishPromise = f((N, U) => {
        c._finishPromise_resolve = N, c._finishPromise_reject = U;
      });
      let A = c._cancelAlgorithm(i);
      return io(c), w(A, () => (m._state === "errored" ? mn(c, m._storedError) : (kt(m._readableStreamController, i), Ta(c)), null), (N) => (kt(m._readableStreamController, N), mn(c, N), null)), c._finishPromise;
    }
    function Iy(s) {
      let i = s._transformStreamController;
      if (i._finishPromise !== void 0) return i._finishPromise;
      let c = s._readable;
      i._finishPromise = f((A, N) => {
        i._finishPromise_resolve = A, i._finishPromise_reject = N;
      });
      let m = i._flushAlgorithm();
      return io(i), w(m, () => (c._state === "errored" ? mn(i, c._storedError) : (Wr(c._readableStreamController), Ta(i)), null), (A) => (kt(c._readableStreamController, A), mn(i, A), null)), i._finishPromise;
    }
    function Ny(s) {
      return so(s, false), s._backpressureChangePromise;
    }
    function qy(s, i) {
      let c = s._transformStreamController;
      if (c._finishPromise !== void 0) return c._finishPromise;
      let m = s._writable;
      c._finishPromise = f((N, U) => {
        c._finishPromise_resolve = N, c._finishPromise_reject = U;
      });
      let A = c._cancelAlgorithm(i);
      return io(c), w(A, () => (m._state === "errored" ? mn(c, m._storedError) : (Zn(m._writableStreamController, i), va(s), Ta(c)), null), (N) => (Zn(m._writableStreamController, N), va(s), mn(c, N), null)), c._finishPromise;
    }
    function ao(s) {
      return new TypeError(`TransformStreamDefaultController.prototype.${s} can only be used on a TransformStreamDefaultController`);
    }
    function Ta(s) {
      s._finishPromise_resolve !== void 0 && (s._finishPromise_resolve(), s._finishPromise_resolve = void 0, s._finishPromise_reject = void 0);
    }
    function mn(s, i) {
      s._finishPromise_reject !== void 0 && (_(s._finishPromise), s._finishPromise_reject(i), s._finishPromise_resolve = void 0, s._finishPromise_reject = void 0);
    }
    function bf(s) {
      return new TypeError(`TransformStream.prototype.${s} can only be used on a TransformStream`);
    }
    r.ByteLengthQueuingStrategy = to, r.CountQueuingStrategy = ro, r.ReadableByteStreamController = sr, r.ReadableStream = Ye, r.ReadableStreamBYOBReader = Er, r.ReadableStreamBYOBRequest = Lr, r.ReadableStreamDefaultController = ir, r.ReadableStreamDefaultReader = M, r.TransformStream = no, r.TransformStreamDefaultController = Sr, r.WritableStream = wr, r.WritableStreamDefaultController = dn, r.WritableStreamDefaultWriter = or;
  });
});
var Od = z(() => {
  if (!globalThis.ReadableStream) try {
    let r = Y("node:process"), { emitWarning: e } = r;
    try {
      r.emitWarning = () => {
      }, Object.assign(globalThis, Y("node:stream/web")), r.emitWarning = e;
    } catch (t) {
      throw r.emitWarning = e, t;
    }
  } catch {
    Object.assign(globalThis, kd());
  }
  try {
    let { Blob: r } = Y("buffer");
    r && !r.prototype.stream && (r.prototype.stream = function(t) {
      let n = 0, o = this;
      return new ReadableStream({ type: "bytes", async pull(a) {
        let l = await o.slice(n, Math.min(o.size, n + 65536)).arrayBuffer();
        n += l.byteLength, a.enqueue(new Uint8Array(l)), n === o.size && a.close();
      } });
    });
  } catch {
  }
});
async function* eu(r, e = true) {
  for (let t of r) if ("stream" in t) yield* t.stream();
  else if (ArrayBuffer.isView(t)) if (e) {
    let n = t.byteOffset, o = t.byteOffset + t.byteLength;
    for (; n !== o; ) {
      let a = Math.min(o - n, Pd), u = t.buffer.slice(n, n + a);
      n += u.byteLength, yield new Uint8Array(u);
    }
  } else yield t;
  else {
    let n = 0, o = t;
    for (; n !== o.size; ) {
      let u = await o.slice(n, Math.min(o.size, n + Pd)).arrayBuffer();
      n += u.byteLength, yield new Uint8Array(u);
    }
  }
}
var iD;
var Pd;
var xd;
var f_;
var It;
var as = Me(() => {
  iD = Jr(Od(), 1);
  Pd = 65536;
  xd = class tu {
    #e = [];
    #t = "";
    #r = 0;
    #n = "transparent";
    constructor(e = [], t = {}) {
      if (typeof e != "object" || e === null) throw new TypeError("Failed to construct 'Blob': The provided value cannot be converted to a sequence.");
      if (typeof e[Symbol.iterator] != "function") throw new TypeError("Failed to construct 'Blob': The object must have a callable @@iterator property.");
      if (typeof t != "object" && typeof t != "function") throw new TypeError("Failed to construct 'Blob': parameter 2 cannot convert to dictionary.");
      t === null && (t = {});
      let n = new TextEncoder();
      for (let a of e) {
        let u;
        ArrayBuffer.isView(a) ? u = new Uint8Array(a.buffer.slice(a.byteOffset, a.byteOffset + a.byteLength)) : a instanceof ArrayBuffer ? u = new Uint8Array(a.slice(0)) : a instanceof tu ? u = a : u = n.encode(`${a}`), this.#r += ArrayBuffer.isView(u) ? u.byteLength : u.size, this.#e.push(u);
      }
      this.#n = `${t.endings === void 0 ? "transparent" : t.endings}`;
      let o = t.type === void 0 ? "" : String(t.type);
      this.#t = /^[\x20-\x7E]*$/.test(o) ? o : "";
    }
    get size() {
      return this.#r;
    }
    get type() {
      return this.#t;
    }
    async text() {
      let e = new TextDecoder(), t = "";
      for await (let n of eu(this.#e, false)) t += e.decode(n, { stream: true });
      return t += e.decode(), t;
    }
    async arrayBuffer() {
      let e = new Uint8Array(this.size), t = 0;
      for await (let n of eu(this.#e, false)) e.set(n, t), t += n.length;
      return e.buffer;
    }
    stream() {
      let e = eu(this.#e, true);
      return new globalThis.ReadableStream({ type: "bytes", async pull(t) {
        let n = await e.next();
        n.done ? t.close() : t.enqueue(n.value);
      }, async cancel() {
        await e.return();
      } });
    }
    slice(e = 0, t = this.size, n = "") {
      let { size: o } = this, a = e < 0 ? Math.max(o + e, 0) : Math.min(e, o), u = t < 0 ? Math.max(o + t, 0) : Math.min(t, o), l = Math.max(u - a, 0), f = this.#e, d = [], h = 0;
      for (let w of f) {
        if (h >= l) break;
        let I = ArrayBuffer.isView(w) ? w.byteLength : w.size;
        if (a && I <= a) a -= I, u -= I;
        else {
          let S;
          ArrayBuffer.isView(w) ? (S = w.subarray(a, Math.min(I, u)), h += S.byteLength) : (S = w.slice(a, Math.min(I, u)), h += S.size), u -= I, d.push(S), a = 0;
        }
      }
      let C = new tu([], { type: String(n).toLowerCase() });
      return C.#r = l, C.#e = d, C;
    }
    get [Symbol.toStringTag]() {
      return "Blob";
    }
    static [Symbol.hasInstance](e) {
      return e && typeof e == "object" && typeof e.constructor == "function" && (typeof e.stream == "function" || typeof e.arrayBuffer == "function") && /^(Blob|File)$/.test(e[Symbol.toStringTag]);
    }
  };
  Object.defineProperties(xd.prototype, { size: { enumerable: true }, type: { enumerable: true }, slice: { enumerable: true } });
  f_ = xd, It = f_;
});
var d_;
var h_;
var Fr;
var ru = Me(() => {
  as();
  d_ = class extends It {
    #e = 0;
    #t = "";
    constructor(e, t, n = {}) {
      if (arguments.length < 2) throw new TypeError(`Failed to construct 'File': 2 arguments required, but only ${arguments.length} present.`);
      super(e, n), n === null && (n = {});
      let o = n.lastModified === void 0 ? Date.now() : Number(n.lastModified);
      Number.isNaN(o) || (this.#e = o), this.#t = String(t);
    }
    get name() {
      return this.#t;
    }
    get lastModified() {
      return this.#e;
    }
    get [Symbol.toStringTag]() {
      return "File";
    }
    static [Symbol.hasInstance](e) {
      return !!e && e instanceof It && /^(File)$/.test(e[Symbol.toStringTag]);
    }
  }, h_ = d_, Fr = h_;
});
function Nd(r, e = It) {
  var t = `${Bd()}${Bd()}`.replace(/\./g, "").slice(-28).padStart(32, "-"), n = [], o = `--${t}\r
Content-Disposition: form-data; name="`;
  return r.forEach((a, u) => typeof a == "string" ? n.push(o + nu(u) + `"\r
\r
${a.replace(/\r(?!\n)|(?<!\r)\n/g, `\r
`)}\r
`) : n.push(o + nu(u) + `"; filename="${nu(a.name, 1)}"\r
Content-Type: ${a.type || "application/octet-stream"}\r
\r
`, a, `\r
`)), n.push(`--${t}--`), new e(n, { type: "multipart/form-data; boundary=" + t });
}
var us;
var p_;
var m_;
var Bd;
var g_;
var Id;
var nu;
var Xr;
var kr;
var Bo = Me(() => {
  as();
  ru();
  ({ toStringTag: us, iterator: p_, hasInstance: m_ } = Symbol), Bd = Math.random, g_ = "append,set,get,getAll,delete,keys,values,entries,forEach,constructor".split(","), Id = (r, e, t) => (r += "", /^(Blob|File)$/.test(e && e[us]) ? [(t = t !== void 0 ? t + "" : e[us] == "File" ? e.name : "blob", r), e.name !== t || e[us] == "blob" ? new Fr([e], t, e) : e] : [r, e + ""]), nu = (r, e) => (e ? r : r.replace(/\r?\n|\r/g, `\r
`)).replace(/\n/g, "%0A").replace(/\r/g, "%0D").replace(/"/g, "%22"), Xr = (r, e, t) => {
    if (e.length < t) throw new TypeError(`Failed to execute '${r}' on 'FormData': ${t} arguments required, but only ${e.length} present.`);
  }, kr = class {
    #e = [];
    constructor(...e) {
      if (e.length) throw new TypeError("Failed to construct 'FormData': parameter 1 is not of type 'HTMLFormElement'.");
    }
    get [us]() {
      return "FormData";
    }
    [p_]() {
      return this.entries();
    }
    static [m_](e) {
      return e && typeof e == "object" && e[us] === "FormData" && !g_.some((t) => typeof e[t] != "function");
    }
    append(...e) {
      Xr("append", arguments, 2), this.#e.push(Id(...e));
    }
    delete(e) {
      Xr("delete", arguments, 1), e += "", this.#e = this.#e.filter(([t]) => t !== e);
    }
    get(e) {
      Xr("get", arguments, 1), e += "";
      for (var t = this.#e, n = t.length, o = 0; o < n; o++) if (t[o][0] === e) return t[o][1];
      return null;
    }
    getAll(e, t) {
      return Xr("getAll", arguments, 1), t = [], e += "", this.#e.forEach((n) => n[0] === e && t.push(n[1])), t;
    }
    has(e) {
      return Xr("has", arguments, 1), e += "", this.#e.some((t) => t[0] === e);
    }
    forEach(e, t) {
      Xr("forEach", arguments, 1);
      for (var [n, o] of this) e.call(t, o, n, this);
    }
    set(...e) {
      Xr("set", arguments, 2);
      var t = [], n = true;
      e = Id(...e), this.#e.forEach((o) => {
        o[0] === e[0] ? n && (n = !t.push(e)) : t.push(o);
      }), n && t.push(e), this.#e = t;
    }
    *entries() {
      yield* this.#e;
    }
    *keys() {
      for (var [e] of this) yield e;
    }
    *values() {
      for (var [, e] of this) yield e;
    }
  };
});
var dr;
var Io = Me(() => {
  dr = class extends Error {
    constructor(e, t) {
      super(e), Error.captureStackTrace(this, this.constructor), this.type = t;
    }
    get name() {
      return this.constructor.name;
    }
    get [Symbol.toStringTag]() {
      return this.constructor.name;
    }
  };
});
var tt;
var su = Me(() => {
  Io();
  tt = class extends dr {
    constructor(e, t, n) {
      super(e, t), n && (this.code = this.errno = n.code, this.erroredSysCall = n.syscall);
    }
  };
});
var No;
var ou;
var cs;
var qd;
var jd;
var Ld;
var qo = Me(() => {
  No = Symbol.toStringTag, ou = (r) => typeof r == "object" && typeof r.append == "function" && typeof r.delete == "function" && typeof r.get == "function" && typeof r.getAll == "function" && typeof r.has == "function" && typeof r.set == "function" && typeof r.sort == "function" && r[No] === "URLSearchParams", cs = (r) => r && typeof r == "object" && typeof r.arrayBuffer == "function" && typeof r.type == "string" && typeof r.stream == "function" && typeof r.constructor == "function" && /^(Blob|File)$/.test(r[No]), qd = (r) => typeof r == "object" && (r[No] === "AbortSignal" || r[No] === "EventTarget"), jd = (r, e) => {
    let t = new URL(e).hostname, n = new URL(r).hostname;
    return t === n || t.endsWith(`.${n}`);
  }, Ld = (r, e) => {
    let t = new URL(e).protocol, n = new URL(r).protocol;
    return t === n;
  };
});
var Md = z((CD, Ud) => {
  if (!globalThis.DOMException) try {
    let { MessageChannel: r } = Y("worker_threads"), e = new r().port1, t = new ArrayBuffer();
    e.postMessage(t, [t, t]);
  } catch (r) {
    r.constructor.name === "DOMException" && (globalThis.DOMException = r.constructor);
  }
  Ud.exports = globalThis.DOMException;
});
var Hd;
var iu;
var Gd;
var Wd;
var zd;
var Jd;
var Vd;
var Kd;
var jo;
var au = Me(() => {
  Hd = Jr(Md(), 1);
  ru();
  as();
  ({ stat: iu } = import_node_fs.promises), Gd = (r, e) => Vd((0, import_node_fs.statSync)(r), r, e), Wd = (r, e) => iu(r).then((t) => Vd(t, r, e)), zd = (r, e) => iu(r).then((t) => Kd(t, r, e)), Jd = (r, e) => Kd((0, import_node_fs.statSync)(r), r, e), Vd = (r, e, t = "") => new It([new jo({ path: e, size: r.size, lastModified: r.mtimeMs, start: 0 })], { type: t }), Kd = (r, e, t = "") => new Fr([new jo({ path: e, size: r.size, lastModified: r.mtimeMs, start: 0 })], (0, import_node_path3.basename)(e), { type: t, lastModified: r.mtimeMs }), jo = class r {
    #e;
    #t;
    constructor(e) {
      this.#e = e.path, this.#t = e.start, this.size = e.size, this.lastModified = e.lastModified;
    }
    slice(e, t) {
      return new r({ path: this.#e, lastModified: this.lastModified, size: t - e, start: this.#t + e });
    }
    async *stream() {
      let { mtimeMs: e } = await iu(this.#e);
      if (e > this.lastModified) throw new Hd.default("The requested file could not be read, typically due to permission problems that have occurred after a reference to a file was acquired.", "NotReadableError");
      yield* (0, import_node_fs.createReadStream)(this.#e, { start: this.#t, end: this.#t + this.size - 1 });
    }
    get [Symbol.toStringTag]() {
      return "Blob";
    }
  };
});
var Xd = {};
wf(Xd, { toFormData: () => v_ });
function S_(r) {
  let e = r.match(/\bfilename=("(.*?)"|([^()<>@,;:\\"/[\]?={}\s\t]+))($|;\s)/i);
  if (!e) return;
  let t = e[2] || e[3] || "", n = t.slice(t.lastIndexOf("\\") + 1);
  return n = n.replace(/%22/g, '"'), n = n.replace(/&#(\d{4});/g, (o, a) => String.fromCharCode(a)), n;
}
async function v_(r, e) {
  if (!/multipart/i.test(e)) throw new TypeError("Failed to fetch");
  let t = e.match(/boundary=(?:"([^"]+)"|([^;]+))/i);
  if (!t) throw new TypeError("no or bad content-type header, no multipart boundary");
  let n = new uu(t[1] || t[2]), o, a, u, l, f, d, h = [], C = new kr(), w = (y) => {
    u += _.decode(y, { stream: true });
  }, I = (y) => {
    h.push(y);
  }, S = () => {
    let y = new Fr(h, d, { type: f });
    C.append(l, y);
  }, b = () => {
    C.append(l, u);
  }, _ = new TextDecoder("utf-8");
  _.decode(), n.onPartBegin = function() {
    n.onPartData = w, n.onPartEnd = b, o = "", a = "", u = "", l = "", f = "", d = null, h.length = 0;
  }, n.onHeaderField = function(y) {
    o += _.decode(y, { stream: true });
  }, n.onHeaderValue = function(y) {
    a += _.decode(y, { stream: true });
  }, n.onHeaderEnd = function() {
    if (a += _.decode(), o = o.toLowerCase(), o === "content-disposition") {
      let y = a.match(/\bname=("([^"]*)"|([^()<>@,;:\\"/[\]?={}\s\t]+))/i);
      y && (l = y[2] || y[3] || ""), d = S_(a), d && (n.onPartData = I, n.onPartEnd = S);
    } else o === "content-type" && (f = a);
    a = "", o = "";
  };
  for await (let y of r) n.write(y);
  return n.end(), C;
}
var zt;
var ke;
var Yd;
var Or;
var Lo;
var Uo;
var b_;
var ls;
var E_;
var w_;
var A_;
var D_;
var Qr;
var uu;
var Qd = Me(() => {
  au();
  Bo();
  zt = 0, ke = { START_BOUNDARY: zt++, HEADER_FIELD_START: zt++, HEADER_FIELD: zt++, HEADER_VALUE_START: zt++, HEADER_VALUE: zt++, HEADER_VALUE_ALMOST_DONE: zt++, HEADERS_ALMOST_DONE: zt++, PART_DATA_START: zt++, PART_DATA: zt++, END: zt++ }, Yd = 1, Or = { PART_BOUNDARY: Yd, LAST_BOUNDARY: Yd *= 2 }, Lo = 10, Uo = 13, b_ = 32, ls = 45, E_ = 58, w_ = 97, A_ = 122, D_ = (r) => r | 32, Qr = () => {
  }, uu = class {
    constructor(e) {
      this.index = 0, this.flags = 0, this.onHeaderEnd = Qr, this.onHeaderField = Qr, this.onHeadersEnd = Qr, this.onHeaderValue = Qr, this.onPartBegin = Qr, this.onPartData = Qr, this.onPartEnd = Qr, this.boundaryChars = {}, e = `\r
--` + e;
      let t = new Uint8Array(e.length);
      for (let n = 0; n < e.length; n++) t[n] = e.charCodeAt(n), this.boundaryChars[t[n]] = true;
      this.boundary = t, this.lookbehind = new Uint8Array(this.boundary.length + 8), this.state = ke.START_BOUNDARY;
    }
    write(e) {
      let t = 0, n = e.length, o = this.index, { lookbehind: a, boundary: u, boundaryChars: l, index: f, state: d, flags: h } = this, C = this.boundary.length, w = C - 1, I = e.length, S, b, _ = (L) => {
        this[L + "Mark"] = t;
      }, y = (L) => {
        delete this[L + "Mark"];
      }, T = (L, P, j, G) => {
        (P === void 0 || P !== j) && this[L](G && G.subarray(P, j));
      }, k = (L, P) => {
        let j = L + "Mark";
        j in this && (P ? (T(L, this[j], t, e), delete this[j]) : (T(L, this[j], e.length, e), this[j] = 0));
      };
      for (t = 0; t < n; t++) switch (S = e[t], d) {
        case ke.START_BOUNDARY:
          if (f === u.length - 2) {
            if (S === ls) h |= Or.LAST_BOUNDARY;
            else if (S !== Uo) return;
            f++;
            break;
          } else if (f - 1 === u.length - 2) {
            if (h & Or.LAST_BOUNDARY && S === ls) d = ke.END, h = 0;
            else if (!(h & Or.LAST_BOUNDARY) && S === Lo) f = 0, T("onPartBegin"), d = ke.HEADER_FIELD_START;
            else return;
            break;
          }
          S !== u[f + 2] && (f = -2), S === u[f + 2] && f++;
          break;
        case ke.HEADER_FIELD_START:
          d = ke.HEADER_FIELD, _("onHeaderField"), f = 0;
        case ke.HEADER_FIELD:
          if (S === Uo) {
            y("onHeaderField"), d = ke.HEADERS_ALMOST_DONE;
            break;
          }
          if (f++, S === ls) break;
          if (S === E_) {
            if (f === 1) return;
            k("onHeaderField", true), d = ke.HEADER_VALUE_START;
            break;
          }
          if (b = D_(S), b < w_ || b > A_) return;
          break;
        case ke.HEADER_VALUE_START:
          if (S === b_) break;
          _("onHeaderValue"), d = ke.HEADER_VALUE;
        case ke.HEADER_VALUE:
          S === Uo && (k("onHeaderValue", true), T("onHeaderEnd"), d = ke.HEADER_VALUE_ALMOST_DONE);
          break;
        case ke.HEADER_VALUE_ALMOST_DONE:
          if (S !== Lo) return;
          d = ke.HEADER_FIELD_START;
          break;
        case ke.HEADERS_ALMOST_DONE:
          if (S !== Lo) return;
          T("onHeadersEnd"), d = ke.PART_DATA_START;
          break;
        case ke.PART_DATA_START:
          d = ke.PART_DATA, _("onPartData");
        case ke.PART_DATA:
          if (o = f, f === 0) {
            for (t += w; t < I && !(e[t] in l); ) t += C;
            t -= w, S = e[t];
          }
          if (f < u.length) u[f] === S ? (f === 0 && k("onPartData", true), f++) : f = 0;
          else if (f === u.length) f++, S === Uo ? h |= Or.PART_BOUNDARY : S === ls ? h |= Or.LAST_BOUNDARY : f = 0;
          else if (f - 1 === u.length) if (h & Or.PART_BOUNDARY) {
            if (f = 0, S === Lo) {
              h &= ~Or.PART_BOUNDARY, T("onPartEnd"), T("onPartBegin"), d = ke.HEADER_FIELD_START;
              break;
            }
          } else h & Or.LAST_BOUNDARY && S === ls ? (T("onPartEnd"), d = ke.END, h = 0) : f = 0;
          if (f > 0) a[f - 1] = S;
          else if (o > 0) {
            let L = new Uint8Array(a.buffer, a.byteOffset, a.byteLength);
            T("onPartData", 0, o, L), o = 0, _("onPartData"), t--;
          }
          break;
        case ke.END:
          break;
        default:
          throw new Error(`Unexpected state entered: ${d}`);
      }
      k("onHeaderField"), k("onHeaderValue"), k("onPartData"), this.index = f, this.state = d, this.flags = h;
    }
    end() {
      if (this.state === ke.HEADER_FIELD_START && this.index === 0 || this.state === ke.PART_DATA && this.index === this.boundary.length) this.onPartEnd();
      else if (this.state !== ke.END) throw new Error("MultipartParser.end(): stream ended unexpectedly");
    }
  };
});
async function cu(r) {
  if (r[it].disturbed) throw new TypeError(`body used already for: ${r.url}`);
  if (r[it].disturbed = true, r[it].error) throw r[it].error;
  let { body: e } = r;
  if (e === null) return import_node_buffer.Buffer.alloc(0);
  if (!(e instanceof import_node_stream.default)) return import_node_buffer.Buffer.alloc(0);
  let t = [], n = 0;
  try {
    for await (let o of e) {
      if (r.size > 0 && n + o.length > r.size) {
        let a = new tt(`content size at ${r.url} over limit: ${r.size}`, "max-size");
        throw e.destroy(a), a;
      }
      n += o.length, t.push(o);
    }
  } catch (o) {
    throw o instanceof dr ? o : new tt(`Invalid response body while trying to fetch ${r.url}: ${o.message}`, "system", o);
  }
  if (e.readableEnded === true || e._readableState.ended === true) try {
    return t.every((o) => typeof o == "string") ? import_node_buffer.Buffer.from(t.join("")) : import_node_buffer.Buffer.concat(t, n);
  } catch (o) {
    throw new tt(`Could not create Buffer from response body for ${r.url}: ${o.message}`, "system", o);
  }
  else throw new tt(`Premature close of server response while trying to fetch ${r.url}`);
}
var R_;
var it;
var Jt;
var Sn;
var F_;
var Mo;
var th;
var rh;
var $o = Me(() => {
  as();
  Bo();
  su();
  Io();
  qo();
  R_ = (0, import_node_util.promisify)(import_node_stream.default.pipeline), it = Symbol("Body internals"), Jt = class {
    constructor(e, { size: t = 0 } = {}) {
      let n = null;
      e === null ? e = null : ou(e) ? e = import_node_buffer.Buffer.from(e.toString()) : cs(e) || import_node_buffer.Buffer.isBuffer(e) || (import_node_util.types.isAnyArrayBuffer(e) ? e = import_node_buffer.Buffer.from(e) : ArrayBuffer.isView(e) ? e = import_node_buffer.Buffer.from(e.buffer, e.byteOffset, e.byteLength) : e instanceof import_node_stream.default || (e instanceof kr ? (e = Nd(e), n = e.type.split("=")[1]) : e = import_node_buffer.Buffer.from(String(e))));
      let o = e;
      import_node_buffer.Buffer.isBuffer(e) ? o = import_node_stream.default.Readable.from(e) : cs(e) && (o = import_node_stream.default.Readable.from(e.stream())), this[it] = { body: e, stream: o, boundary: n, disturbed: false, error: null }, this.size = t, e instanceof import_node_stream.default && e.on("error", (a) => {
        let u = a instanceof dr ? a : new tt(`Invalid response body while trying to fetch ${this.url}: ${a.message}`, "system", a);
        this[it].error = u;
      });
    }
    get body() {
      return this[it].stream;
    }
    get bodyUsed() {
      return this[it].disturbed;
    }
    async arrayBuffer() {
      let { buffer: e, byteOffset: t, byteLength: n } = await cu(this);
      return e.slice(t, t + n);
    }
    async formData() {
      let e = this.headers.get("content-type");
      if (e.startsWith("application/x-www-form-urlencoded")) {
        let n = new kr(), o = new URLSearchParams(await this.text());
        for (let [a, u] of o) n.append(a, u);
        return n;
      }
      let { toFormData: t } = await Promise.resolve().then(() => (Qd(), Xd));
      return t(this.body, e);
    }
    async blob() {
      let e = this.headers && this.headers.get("content-type") || this[it].body && this[it].body.type || "", t = await this.arrayBuffer();
      return new It([t], { type: e });
    }
    async json() {
      let e = await this.text();
      return JSON.parse(e);
    }
    async text() {
      let e = await cu(this);
      return new TextDecoder().decode(e);
    }
    buffer() {
      return cu(this);
    }
  };
  Jt.prototype.buffer = (0, import_node_util.deprecate)(Jt.prototype.buffer, "Please use 'response.arrayBuffer()' instead of 'response.buffer()'", "node-fetch#buffer");
  Object.defineProperties(Jt.prototype, { body: { enumerable: true }, bodyUsed: { enumerable: true }, arrayBuffer: { enumerable: true }, blob: { enumerable: true }, json: { enumerable: true }, text: { enumerable: true }, data: { get: (0, import_node_util.deprecate)(() => {
  }, "data doesn't exist, use json(), text(), arrayBuffer(), or body instead", "https://github.com/node-fetch/node-fetch/issues/1000 (response)") } });
  Sn = (r, e) => {
    let t, n, { body: o } = r[it];
    if (r.bodyUsed) throw new Error("cannot clone body after it is used");
    return o instanceof import_node_stream.default && typeof o.getBoundary != "function" && (t = new import_node_stream.PassThrough({ highWaterMark: e }), n = new import_node_stream.PassThrough({ highWaterMark: e }), o.pipe(t), o.pipe(n), r[it].stream = t, o = n), o;
  }, F_ = (0, import_node_util.deprecate)((r) => r.getBoundary(), "form-data doesn't follow the spec and requires special treatment. Use alternative package", "https://github.com/node-fetch/node-fetch/issues/1167"), Mo = (r, e) => r === null ? null : typeof r == "string" ? "text/plain;charset=UTF-8" : ou(r) ? "application/x-www-form-urlencoded;charset=UTF-8" : cs(r) ? r.type || null : import_node_buffer.Buffer.isBuffer(r) || import_node_util.types.isAnyArrayBuffer(r) || ArrayBuffer.isView(r) ? null : r instanceof kr ? `multipart/form-data; boundary=${e[it].boundary}` : r && typeof r.getBoundary == "function" ? `multipart/form-data;boundary=${F_(r)}` : r instanceof import_node_stream.default ? null : "text/plain;charset=UTF-8", th = (r) => {
    let { body: e } = r[it];
    return e === null ? 0 : cs(e) ? e.size : import_node_buffer.Buffer.isBuffer(e) ? e.length : e && typeof e.getLengthSync == "function" && e.hasKnownLength && e.hasKnownLength() ? e.getLengthSync() : null;
  }, rh = async (r, { body: e }) => {
    e === null ? r.end() : await R_(e, r);
  };
});
function sh(r = []) {
  return new at(r.reduce((e, t, n, o) => (n % 2 === 0 && e.push(o.slice(n, n + 2)), e), []).filter(([e, t]) => {
    try {
      return Ho(e), fu(e, String(t)), true;
    } catch {
      return false;
    }
  }));
}
var Ho;
var fu;
var at;
var Wo = Me(() => {
  Ho = typeof import_node_http.default.validateHeaderName == "function" ? import_node_http.default.validateHeaderName : (r) => {
    if (!/^[\^`\-\w!#$%&'*+.|~]+$/.test(r)) {
      let e = new TypeError(`Header name must be a valid HTTP token [${r}]`);
      throw Object.defineProperty(e, "code", { value: "ERR_INVALID_HTTP_TOKEN" }), e;
    }
  }, fu = typeof import_node_http.default.validateHeaderValue == "function" ? import_node_http.default.validateHeaderValue : (r, e) => {
    if (/[^\t\u0020-\u007E\u0080-\u00FF]/.test(e)) {
      let t = new TypeError(`Invalid character in header content ["${r}"]`);
      throw Object.defineProperty(t, "code", { value: "ERR_INVALID_CHAR" }), t;
    }
  }, at = class r extends URLSearchParams {
    constructor(e) {
      let t = [];
      if (e instanceof r) {
        let n = e.raw();
        for (let [o, a] of Object.entries(n)) t.push(...a.map((u) => [o, u]));
      } else if (e != null) if (typeof e == "object" && !import_node_util2.types.isBoxedPrimitive(e)) {
        let n = e[Symbol.iterator];
        if (n == null) t.push(...Object.entries(e));
        else {
          if (typeof n != "function") throw new TypeError("Header pairs must be iterable");
          t = [...e].map((o) => {
            if (typeof o != "object" || import_node_util2.types.isBoxedPrimitive(o)) throw new TypeError("Each header pair must be an iterable object");
            return [...o];
          }).map((o) => {
            if (o.length !== 2) throw new TypeError("Each header pair must be a name/value tuple");
            return [...o];
          });
        }
      } else throw new TypeError("Failed to construct 'Headers': The provided value is not of type '(sequence<sequence<ByteString>> or record<ByteString, ByteString>)");
      return t = t.length > 0 ? t.map(([n, o]) => (Ho(n), fu(n, String(o)), [String(n).toLowerCase(), String(o)])) : void 0, super(t), new Proxy(this, { get(n, o, a) {
        switch (o) {
          case "append":
          case "set":
            return (u, l) => (Ho(u), fu(u, String(l)), URLSearchParams.prototype[o].call(n, String(u).toLowerCase(), String(l)));
          case "delete":
          case "has":
          case "getAll":
            return (u) => (Ho(u), URLSearchParams.prototype[o].call(n, String(u).toLowerCase()));
          case "keys":
            return () => (n.sort(), new Set(URLSearchParams.prototype.keys.call(n)).keys());
          default:
            return Reflect.get(n, o, a);
        }
      } });
    }
    get [Symbol.toStringTag]() {
      return this.constructor.name;
    }
    toString() {
      return Object.prototype.toString.call(this);
    }
    get(e) {
      let t = this.getAll(e);
      if (t.length === 0) return null;
      let n = t.join(", ");
      return /^content-encoding$/i.test(e) && (n = n.toLowerCase()), n;
    }
    forEach(e, t = void 0) {
      for (let n of this.keys()) Reflect.apply(e, t, [this.get(n), n, this]);
    }
    *values() {
      for (let e of this.keys()) yield this.get(e);
    }
    *entries() {
      for (let e of this.keys()) yield [e, this.get(e)];
    }
    [Symbol.iterator]() {
      return this.entries();
    }
    raw() {
      return [...this.keys()].reduce((e, t) => (e[t] = this.getAll(t), e), {});
    }
    [Symbol.for("nodejs.util.inspect.custom")]() {
      return [...this.keys()].reduce((e, t) => {
        let n = this.getAll(t);
        return t === "host" ? e[t] = n[0] : e[t] = n.length > 1 ? n : n[0], e;
      }, {});
    }
  };
  Object.defineProperties(at.prototype, ["get", "entries", "forEach", "values"].reduce((r, e) => (r[e] = { enumerable: true }, r), {}));
});
var k_;
var fs2;
var du = Me(() => {
  k_ = /* @__PURE__ */ new Set([301, 302, 303, 307, 308]), fs2 = (r) => k_.has(r);
});
var Nt;
var ft;
var oh = Me(() => {
  Wo();
  $o();
  du();
  Nt = Symbol("Response internals"), ft = class r extends Jt {
    constructor(e = null, t = {}) {
      super(e, t);
      let n = t.status != null ? t.status : 200, o = new at(t.headers);
      if (e !== null && !o.has("Content-Type")) {
        let a = Mo(e, this);
        a && o.append("Content-Type", a);
      }
      this[Nt] = { type: "default", url: t.url, status: n, statusText: t.statusText || "", headers: o, counter: t.counter, highWaterMark: t.highWaterMark };
    }
    get type() {
      return this[Nt].type;
    }
    get url() {
      return this[Nt].url || "";
    }
    get status() {
      return this[Nt].status;
    }
    get ok() {
      return this[Nt].status >= 200 && this[Nt].status < 300;
    }
    get redirected() {
      return this[Nt].counter > 0;
    }
    get statusText() {
      return this[Nt].statusText;
    }
    get headers() {
      return this[Nt].headers;
    }
    get highWaterMark() {
      return this[Nt].highWaterMark;
    }
    clone() {
      return new r(Sn(this, this.highWaterMark), { type: this.type, url: this.url, status: this.status, statusText: this.statusText, headers: this.headers, ok: this.ok, redirected: this.redirected, size: this.size, highWaterMark: this.highWaterMark });
    }
    static redirect(e, t = 302) {
      if (!fs2(t)) throw new RangeError('Failed to execute "redirect" on "response": Invalid status code');
      return new r(null, { headers: { location: new URL(e).toString() }, status: t });
    }
    static error() {
      let e = new r(null, { status: 0, statusText: "" });
      return e[Nt].type = "error", e;
    }
    static json(e = void 0, t = {}) {
      let n = JSON.stringify(e);
      if (n === void 0) throw new TypeError("data is not JSON serializable");
      let o = new at(t && t.headers);
      return o.has("content-type") || o.set("content-type", "application/json"), new r(n, { ...t, headers: o });
    }
    get [Symbol.toStringTag]() {
      return "Response";
    }
  };
  Object.defineProperties(ft.prototype, { type: { enumerable: true }, url: { enumerable: true }, status: { enumerable: true }, ok: { enumerable: true }, redirected: { enumerable: true }, statusText: { enumerable: true }, headers: { enumerable: true }, clone: { enumerable: true } });
});
var ih;
var ah = Me(() => {
  ih = (r) => {
    if (r.search) return r.search;
    let e = r.href.length - 1, t = r.hash || (r.href[e] === "#" ? "#" : "");
    return r.href[e - t.length] === "?" ? "?" : "";
  };
});
function uh(r, e = false) {
  return r == null || (r = new URL(r), /^(about|blob|data):$/.test(r.protocol)) ? "no-referrer" : (r.username = "", r.password = "", r.hash = "", e && (r.pathname = "", r.search = ""), r);
}
function fh(r) {
  if (!ch.has(r)) throw new TypeError(`Invalid referrerPolicy: ${r}`);
  return r;
}
function P_(r) {
  if (/^(http|ws)s:$/.test(r.protocol)) return true;
  let e = r.host.replace(/(^\[)|(]$)/g, ""), t = (0, import_node_net.isIP)(e);
  return t === 4 && /^127\./.test(e) || t === 6 && /^(((0+:){7})|(::(0+:){0,6}))0*1$/.test(e) ? true : r.host === "localhost" || r.host.endsWith(".localhost") ? false : r.protocol === "file:";
}
function vn(r) {
  return /^about:(blank|srcdoc)$/.test(r) || r.protocol === "data:" || /^(blob|filesystem):$/.test(r.protocol) ? true : P_(r);
}
function dh(r, { referrerURLCallback: e, referrerOriginCallback: t } = {}) {
  if (r.referrer === "no-referrer" || r.referrerPolicy === "") return null;
  let n = r.referrerPolicy;
  if (r.referrer === "about:client") return "no-referrer";
  let o = r.referrer, a = uh(o), u = uh(o, true);
  a.toString().length > 4096 && (a = u), e && (a = e(a)), t && (u = t(u));
  let l = new URL(r.url);
  switch (n) {
    case "no-referrer":
      return "no-referrer";
    case "origin":
      return u;
    case "unsafe-url":
      return a;
    case "strict-origin":
      return vn(a) && !vn(l) ? "no-referrer" : u.toString();
    case "strict-origin-when-cross-origin":
      return a.origin === l.origin ? a : vn(a) && !vn(l) ? "no-referrer" : u;
    case "same-origin":
      return a.origin === l.origin ? a : "no-referrer";
    case "origin-when-cross-origin":
      return a.origin === l.origin ? a : u;
    case "no-referrer-when-downgrade":
      return vn(a) && !vn(l) ? "no-referrer" : a;
    default:
      throw new TypeError(`Invalid referrerPolicy: ${n}`);
  }
}
function hh(r) {
  let e = (r.get("referrer-policy") || "").split(/[,\s]+/), t = "";
  for (let n of e) n && ch.has(n) && (t = n);
  return t;
}
var ch;
var lh;
var hu = Me(() => {
  ch = /* @__PURE__ */ new Set(["", "no-referrer", "no-referrer-when-downgrade", "same-origin", "origin", "strict-origin", "origin-when-cross-origin", "strict-origin-when-cross-origin", "unsafe-url"]), lh = "strict-origin-when-cross-origin";
});
var We;
var ds;
var I_;
var xr;
var ph;
var mh = Me(() => {
  Wo();
  $o();
  qo();
  ah();
  hu();
  We = Symbol("Request internals"), ds = (r) => typeof r == "object" && typeof r[We] == "object", I_ = (0, import_node_util3.deprecate)(() => {
  }, ".data is not a valid RequestInit property, use .body instead", "https://github.com/node-fetch/node-fetch/issues/1000 (request)"), xr = class r extends Jt {
    constructor(e, t = {}) {
      let n;
      if (ds(e) ? n = new URL(e.url) : (n = new URL(e), e = {}), n.username !== "" || n.password !== "") throw new TypeError(`${n} is an url with embedded credentials.`);
      let o = t.method || e.method || "GET";
      if (/^(delete|get|head|options|post|put)$/i.test(o) && (o = o.toUpperCase()), !ds(t) && "data" in t && I_(), (t.body != null || ds(e) && e.body !== null) && (o === "GET" || o === "HEAD")) throw new TypeError("Request with GET/HEAD method cannot have body");
      let a = t.body ? t.body : ds(e) && e.body !== null ? Sn(e) : null;
      super(a, { size: t.size || e.size || 0 });
      let u = new at(t.headers || e.headers || {});
      if (a !== null && !u.has("Content-Type")) {
        let d = Mo(a, this);
        d && u.set("Content-Type", d);
      }
      let l = ds(e) ? e.signal : null;
      if ("signal" in t && (l = t.signal), l != null && !qd(l)) throw new TypeError("Expected signal to be an instanceof AbortSignal or EventTarget");
      let f = t.referrer == null ? e.referrer : t.referrer;
      if (f === "") f = "no-referrer";
      else if (f) {
        let d = new URL(f);
        f = /^about:(\/\/)?client$/.test(d) ? "client" : d;
      } else f = void 0;
      this[We] = { method: o, redirect: t.redirect || e.redirect || "follow", headers: u, parsedURL: n, signal: l, referrer: f }, this.follow = t.follow === void 0 ? e.follow === void 0 ? 20 : e.follow : t.follow, this.compress = t.compress === void 0 ? e.compress === void 0 ? true : e.compress : t.compress, this.counter = t.counter || e.counter || 0, this.agent = t.agent || e.agent, this.highWaterMark = t.highWaterMark || e.highWaterMark || 16384, this.insecureHTTPParser = t.insecureHTTPParser || e.insecureHTTPParser || false, this.referrerPolicy = t.referrerPolicy || e.referrerPolicy || "";
    }
    get method() {
      return this[We].method;
    }
    get url() {
      return (0, import_node_url.format)(this[We].parsedURL);
    }
    get headers() {
      return this[We].headers;
    }
    get redirect() {
      return this[We].redirect;
    }
    get signal() {
      return this[We].signal;
    }
    get referrer() {
      if (this[We].referrer === "no-referrer") return "";
      if (this[We].referrer === "client") return "about:client";
      if (this[We].referrer) return this[We].referrer.toString();
    }
    get referrerPolicy() {
      return this[We].referrerPolicy;
    }
    set referrerPolicy(e) {
      this[We].referrerPolicy = fh(e);
    }
    clone() {
      return new r(this);
    }
    get [Symbol.toStringTag]() {
      return "Request";
    }
  };
  Object.defineProperties(xr.prototype, { method: { enumerable: true }, url: { enumerable: true }, headers: { enumerable: true }, redirect: { enumerable: true }, clone: { enumerable: true }, signal: { enumerable: true }, referrer: { enumerable: true }, referrerPolicy: { enumerable: true } });
  ph = (r) => {
    let { parsedURL: e } = r[We], t = new at(r[We].headers);
    t.has("Accept") || t.set("Accept", "*/*");
    let n = null;
    if (r.body === null && /^(post|put)$/i.test(r.method) && (n = "0"), r.body !== null) {
      let l = th(r);
      typeof l == "number" && !Number.isNaN(l) && (n = String(l));
    }
    n && t.set("Content-Length", n), r.referrerPolicy === "" && (r.referrerPolicy = lh), r.referrer && r.referrer !== "no-referrer" ? r[We].referrer = dh(r) : r[We].referrer = "no-referrer", r[We].referrer instanceof URL && t.set("Referer", r.referrer), t.has("User-Agent") || t.set("User-Agent", "node-fetch"), r.compress && !t.has("Accept-Encoding") && t.set("Accept-Encoding", "gzip, deflate, br");
    let { agent: o } = r;
    typeof o == "function" && (o = o(e));
    let a = ih(e), u = { path: e.pathname + a, method: r.method, headers: t[Symbol.for("nodejs.util.inspect.custom")](), insecureHTTPParser: r.insecureHTTPParser, agent: o };
    return { parsedURL: e, options: u };
  };
});
var hs;
var gh = Me(() => {
  Io();
  hs = class extends dr {
    constructor(e, t = "aborted") {
      super(e, t);
    }
  };
});
var Ch = {};
wf(Ch, { AbortError: () => hs, Blob: () => It, FetchError: () => tt, File: () => Fr, FormData: () => kr, Headers: () => at, Request: () => xr, Response: () => ft, blobFrom: () => Wd, blobFromSync: () => Gd, default: () => pu, fileFrom: () => zd, fileFromSync: () => Jd, isRedirect: () => fs2 });
async function pu(r, e) {
  return new Promise((t, n) => {
    let o = new xr(r, e), { parsedURL: a, options: u } = ph(o);
    if (!j_.has(a.protocol)) throw new TypeError(`node-fetch cannot load ${r}. URL scheme "${a.protocol.replace(/:$/, "")}" is not supported.`);
    if (a.protocol === "data:") {
      let S = Td(o.url), b = new ft(S, { headers: { "Content-Type": S.typeFull } });
      t(b);
      return;
    }
    let l = (a.protocol === "https:" ? import_node_https.default : import_node_http2.default).request, { signal: f } = o, d = null, h = () => {
      let S = new hs("The operation was aborted.");
      n(S), o.body && o.body instanceof import_node_stream2.default.Readable && o.body.destroy(S), !(!d || !d.body) && d.body.emit("error", S);
    };
    if (f && f.aborted) {
      h();
      return;
    }
    let C = () => {
      h(), I();
    }, w = l(a.toString(), u);
    f && f.addEventListener("abort", C);
    let I = () => {
      w.abort(), f && f.removeEventListener("abort", C);
    };
    w.on("error", (S) => {
      n(new tt(`request to ${o.url} failed, reason: ${S.message}`, "system", S)), I();
    }), L_(w, (S) => {
      d && d.body && d.body.destroy(S);
    }), process.version < "v14" && w.on("socket", (S) => {
      let b;
      S.prependListener("end", () => {
        b = S._eventsCount;
      }), S.prependListener("close", (_) => {
        if (d && b < S._eventsCount && !_) {
          let y = new Error("Premature close");
          y.code = "ERR_STREAM_PREMATURE_CLOSE", d.body.emit("error", y);
        }
      });
    }), w.on("response", (S) => {
      w.setTimeout(0);
      let b = sh(S.rawHeaders);
      if (fs2(S.statusCode)) {
        let L = b.get("Location"), P = null;
        try {
          P = L === null ? null : new URL(L, o.url);
        } catch {
          if (o.redirect !== "manual") {
            n(new tt(`uri requested responds with an invalid redirect URL: ${L}`, "invalid-redirect")), I();
            return;
          }
        }
        switch (o.redirect) {
          case "error":
            n(new tt(`uri requested responds with a redirect, redirect mode is set to error: ${o.url}`, "no-redirect")), I();
            return;
          case "manual":
            break;
          case "follow": {
            if (P === null) break;
            if (o.counter >= o.follow) {
              n(new tt(`maximum redirect reached at: ${o.url}`, "max-redirect")), I();
              return;
            }
            let j = { headers: new at(o.headers), follow: o.follow, counter: o.counter + 1, agent: o.agent, compress: o.compress, method: o.method, body: Sn(o), signal: o.signal, size: o.size, referrer: o.referrer, referrerPolicy: o.referrerPolicy };
            if (!jd(o.url, P) || !Ld(o.url, P)) for (let re of ["authorization", "www-authenticate", "cookie", "cookie2"]) j.headers.delete(re);
            if (S.statusCode !== 303 && o.body && e.body instanceof import_node_stream2.default.Readable) {
              n(new tt("Cannot follow redirect with body being a readable stream", "unsupported-redirect")), I();
              return;
            }
            (S.statusCode === 303 || (S.statusCode === 301 || S.statusCode === 302) && o.method === "POST") && (j.method = "GET", j.body = void 0, j.headers.delete("content-length"));
            let G = hh(b);
            G && (j.referrerPolicy = G), t(pu(new xr(P, j))), I();
            return;
          }
          default:
            return n(new TypeError(`Redirect option '${o.redirect}' is not a valid value of RequestRedirect`));
        }
      }
      f && S.once("end", () => {
        f.removeEventListener("abort", C);
      });
      let _ = (0, import_node_stream2.pipeline)(S, new import_node_stream2.PassThrough(), (L) => {
        L && n(L);
      });
      process.version < "v12.10" && S.on("aborted", C);
      let y = { url: o.url, status: S.statusCode, statusText: S.statusMessage, headers: b, size: o.size, counter: o.counter, highWaterMark: o.highWaterMark }, T = b.get("Content-Encoding");
      if (!o.compress || o.method === "HEAD" || T === null || S.statusCode === 204 || S.statusCode === 304) {
        d = new ft(_, y), t(d);
        return;
      }
      let k = { flush: import_node_zlib.default.Z_SYNC_FLUSH, finishFlush: import_node_zlib.default.Z_SYNC_FLUSH };
      if (T === "gzip" || T === "x-gzip") {
        _ = (0, import_node_stream2.pipeline)(_, import_node_zlib.default.createGunzip(k), (L) => {
          L && n(L);
        }), d = new ft(_, y), t(d);
        return;
      }
      if (T === "deflate" || T === "x-deflate") {
        let L = (0, import_node_stream2.pipeline)(S, new import_node_stream2.PassThrough(), (P) => {
          P && n(P);
        });
        L.once("data", (P) => {
          (P[0] & 15) === 8 ? _ = (0, import_node_stream2.pipeline)(_, import_node_zlib.default.createInflate(), (j) => {
            j && n(j);
          }) : _ = (0, import_node_stream2.pipeline)(_, import_node_zlib.default.createInflateRaw(), (j) => {
            j && n(j);
          }), d = new ft(_, y), t(d);
        }), L.once("end", () => {
          d || (d = new ft(_, y), t(d));
        });
        return;
      }
      if (T === "br") {
        _ = (0, import_node_stream2.pipeline)(_, import_node_zlib.default.createBrotliDecompress(), (L) => {
          L && n(L);
        }), d = new ft(_, y), t(d);
        return;
      }
      d = new ft(_, y), t(d);
    }), rh(w, o).catch(n);
  });
}
function L_(r, e) {
  let t = import_node_buffer2.Buffer.from(`0\r
\r
`), n = false, o = false, a;
  r.on("response", (u) => {
    let { headers: l } = u;
    n = l["transfer-encoding"] === "chunked" && !l["content-length"];
  }), r.on("socket", (u) => {
    let l = () => {
      if (n && !o) {
        let d = new Error("Premature close");
        d.code = "ERR_STREAM_PREMATURE_CLOSE", e(d);
      }
    }, f = (d) => {
      o = import_node_buffer2.Buffer.compare(d.slice(-5), t) === 0, !o && a && (o = import_node_buffer2.Buffer.compare(a.slice(-3), t.slice(0, 3)) === 0 && import_node_buffer2.Buffer.compare(d.slice(-2), t.slice(3)) === 0), a = d;
    };
    u.prependListener("close", l), u.on("data", f), r.on("close", () => {
      u.removeListener("close", l), u.removeListener("data", f);
    });
  });
}
var j_;
var bh = Me(() => {
  Rd();
  $o();
  oh();
  Wo();
  mh();
  su();
  gh();
  du();
  Bo();
  qo();
  hu();
  au();
  j_ = /* @__PURE__ */ new Set(["data:", "http:", "https:"]);
});
var Ah = z((kn) => {
  "use strict";
  var U_ = kn && kn.__importDefault || function(r) {
    return r && r.__esModule ? r : { default: r };
  }, Fn;
  Object.defineProperty(kn, "__esModule", { value: true });
  kn.Gaxios = void 0;
  var M_ = U_($a()), $_ = Y("https"), Zr = Wa(), H_ = rd(), Eh = Y("stream"), wh = Va(), G_ = async () => globalThis.crypto?.randomUUID() || (await import("crypto")).randomUUID(), Jo = class {
    agentCache = /* @__PURE__ */ new Map();
    defaults;
    interceptors;
    constructor(e) {
      this.defaults = e || {}, this.interceptors = { request: new wh.GaxiosInterceptorManager(), response: new wh.GaxiosInterceptorManager() };
    }
    fetch(...e) {
      let t = e[0], n = e[1], o, a = new Headers();
      return typeof t == "string" ? o = new URL(t) : t instanceof URL ? o = t : t && t.url && (o = new URL(t.url)), t && typeof t == "object" && "headers" in t && Fn.mergeHeaders(a, t.headers), n && Fn.mergeHeaders(a, new Headers(n.headers)), typeof t == "object" && !(t instanceof URL) ? this.request({ ...n, ...t, headers: a, url: o }) : this.request({ ...n, headers: a, url: o });
    }
    async request(e = {}) {
      let t = await this.#n(e);
      return t = await this.#t(t), this.#r(this._request(t));
    }
    async _defaultAdapter(e) {
      let t = e.fetchImplementation || this.defaults.fetchImplementation || await Fn.#u(), n = { ...e };
      delete n.data;
      let o = await t(e.url, n), a = await this.getResponseData(e, o);
      return Object.getOwnPropertyDescriptor(o, "data")?.configurable || Object.defineProperties(o, { data: { configurable: true, writable: true, enumerable: true, value: a } }), Object.assign(o, { config: e, data: a });
    }
    async _request(e) {
      try {
        let t;
        if (e.adapter ? t = await e.adapter(e, this._defaultAdapter.bind(this)) : t = await this._defaultAdapter(e), !e.validateStatus(t.status)) {
          if (e.responseType === "stream") {
            let o = [];
            for await (let a of e.data ?? []) o.push(a);
            t.data = o;
          }
          let n = Zr.GaxiosError.extractAPIErrorFromResponse(t, `Request failed with status code ${t.status}`);
          throw new Zr.GaxiosError(n?.message, e, t, n);
        }
        return t;
      } catch (t) {
        let n;
        t instanceof Zr.GaxiosError ? n = t : t instanceof Error ? n = new Zr.GaxiosError(t.message, e, void 0, t) : n = new Zr.GaxiosError("Unexpected Gaxios Error", e, void 0, t);
        let { shouldRetry: o, config: a } = await (0, H_.getRetryConfig)(n);
        if (o && a) return n.config.retryConfig.currentRetryAttempt = a.retryConfig.currentRetryAttempt, e.retryConfig = n.config?.retryConfig, this.#s(e), this._request(e);
        throw e.errorRedactor && e.errorRedactor(n), n;
      }
    }
    async getResponseData(e, t) {
      if (e.maxContentLength && t.headers.has("content-length") && e.maxContentLength < Number.parseInt(t.headers?.get("content-length") || "")) throw new Zr.GaxiosError("Response's `Content-Length` is over the limit.", e, Object.assign(t, { config: e }));
      switch (e.responseType) {
        case "stream":
          return t.body;
        case "json":
          return t.json();
        case "arraybuffer":
          return t.arrayBuffer();
        case "blob":
          return t.blob();
        case "text":
          return t.text();
        default:
          return this.getResponseDataFromContentType(t);
      }
    }
    #e(e, t = []) {
      let n = new URL(e), o = [...t], a = (process.env.NO_PROXY ?? process.env.no_proxy)?.split(",") || [];
      for (let u of a) o.push(u.trim());
      for (let u of o) if (u instanceof RegExp) {
        if (u.test(n.toString())) return false;
      } else if (u instanceof URL) {
        if (u.origin === n.origin) return false;
      } else if (u.startsWith("*.") || u.startsWith(".")) {
        let l = u.replace(/^\*\./, ".");
        if (n.hostname.endsWith(l)) return false;
      } else if (u === n.origin || u === n.hostname || u === n.href) return false;
      return true;
    }
    async #t(e) {
      let t = Promise.resolve(e);
      for (let n of this.interceptors.request.values()) n && (t = t.then(n.resolved, n.rejected));
      return t;
    }
    async #r(e) {
      let t = Promise.resolve(e);
      for (let n of this.interceptors.response.values()) n && (t = t.then(n.resolved, n.rejected));
      return t;
    }
    async #n(e) {
      let t = new Headers(this.defaults.headers);
      Fn.mergeHeaders(t, e.headers);
      let n = (0, M_.default)(true, {}, this.defaults, e);
      if (!n.url) throw new Error("URL is required.");
      if (n.baseURL && (n.url = new URL(n.url, n.baseURL)), n.url = new URL(n.url), n.params) if (n.paramsSerializer) {
        let u = n.paramsSerializer(n.params);
        u.startsWith("?") && (u = u.slice(1));
        let l = n.url.toString().includes("?") ? "&" : "?";
        n.url = n.url + l + u;
      } else {
        let u = n.url instanceof URL ? n.url : new URL(n.url);
        for (let [l, f] of new URLSearchParams(n.params)) u.searchParams.append(l, f);
        n.url = u;
      }
      typeof e.maxContentLength == "number" && (n.size = e.maxContentLength), typeof e.maxRedirects == "number" && (n.follow = e.maxRedirects);
      let o = typeof n.data == "string" || n.data instanceof ArrayBuffer || n.data instanceof Blob || globalThis.File && n.data instanceof File || n.data instanceof FormData || n.data instanceof Eh.Readable || n.data instanceof ReadableStream || n.data instanceof String || n.data instanceof URLSearchParams || ArrayBuffer.isView(n.data) || ["Blob", "File", "FormData"].includes(n.data?.constructor?.name || "");
      if (n.multipart?.length) {
        let u = await G_();
        t.set("content-type", `multipart/related; boundary=${u}`), n.body = Eh.Readable.from(this.getMultipartRequest(n.multipart, u));
      } else o ? n.body = n.data : typeof n.data == "object" ? t.get("Content-Type") === "application/x-www-form-urlencoded" ? n.body = n.paramsSerializer ? n.paramsSerializer(n.data) : new URLSearchParams(n.data) : (t.has("content-type") || t.set("content-type", "application/json"), n.body = JSON.stringify(n.data)) : n.data && (n.body = n.data);
      n.validateStatus = n.validateStatus || this.validateStatus, n.responseType = n.responseType || "unknown", !t.has("accept") && n.responseType === "json" && t.set("accept", "application/json");
      let a = n.proxy || process?.env?.HTTPS_PROXY || process?.env?.https_proxy || process?.env?.HTTP_PROXY || process?.env?.http_proxy;
      if (!n.agent) if (a && this.#e(n.url, n.noProxy)) {
        let u = await Fn.#a();
        this.agentCache.has(a) ? n.agent = this.agentCache.get(a) : (n.agent = new u(a, { cert: n.cert, key: n.key }), this.agentCache.set(a, n.agent));
      } else n.cert && n.key && (this.agentCache.has(n.key) ? n.agent = this.agentCache.get(n.key) : (n.agent = new $_.Agent({ cert: n.cert, key: n.key }), this.agentCache.set(n.key, n.agent)));
      return typeof n.errorRedactor != "function" && n.errorRedactor !== false && (n.errorRedactor = Zr.defaultErrorRedactor), n.body && !("duplex" in n) && (n.duplex = "half"), this.#s(n), Object.assign(n, { headers: t, url: n.url instanceof URL ? n.url : new URL(n.url) });
    }
    #s(e) {
      if (e.timeout) {
        let t = AbortSignal.timeout(e.timeout);
        e.signal && !e.signal.aborted ? e.signal = AbortSignal.any([e.signal, t]) : e.signal = t;
      }
    }
    validateStatus(e) {
      return e >= 200 && e < 300;
    }
    async getResponseDataFromContentType(e) {
      let t = e.headers.get("Content-Type");
      if (t === null) return e.text();
      if (t = t.toLowerCase(), t.includes("application/json")) {
        let n = await e.text();
        try {
          n = JSON.parse(n);
        } catch {
        }
        return n;
      } else return t.match(/^text\//) ? e.text() : e.blob();
    }
    async *getMultipartRequest(e, t) {
      let n = `--${t}--`;
      for (let o of e) {
        let a = o.headers.get("Content-Type") || "application/octet-stream";
        yield `--${t}\r
Content-Type: ${a}\r
\r
`, typeof o.content == "string" ? yield o.content : yield* o.content, yield `\r
`;
      }
      yield n;
    }
    static #o;
    static #i;
    static async #a() {
      return this.#o ||= (await Promise.resolve().then(() => Jr(vd()))).HttpsProxyAgent, this.#o;
    }
    static async #u() {
      let e = typeof window < "u" && !!window;
      return this.#i ||= e ? window.fetch : (await Promise.resolve().then(() => (bh(), Ch))).default, this.#i;
    }
    static mergeHeaders(e, ...t) {
      e = e instanceof Headers ? e : new Headers(e);
      for (let n of t) (n instanceof Headers ? n : new Headers(n)).forEach((a, u) => {
        u === "set-cookie" ? e.append(u, a) : e.set(u, a);
      });
      return e;
    }
  };
  kn.Gaxios = Jo;
  Fn = Jo;
});
var Ve = z((rt) => {
  "use strict";
  var W_ = rt && rt.__createBinding || (Object.create ? function(r, e, t, n) {
    n === void 0 && (n = t);
    var o = Object.getOwnPropertyDescriptor(e, t);
    (!o || ("get" in o ? !e.__esModule : o.writable || o.configurable)) && (o = { enumerable: true, get: function() {
      return e[t];
    } }), Object.defineProperty(r, n, o);
  } : function(r, e, t, n) {
    n === void 0 && (n = t), r[n] = e[t];
  }), z_ = rt && rt.__exportStar || function(r, e) {
    for (var t in r) t !== "default" && !Object.prototype.hasOwnProperty.call(e, t) && W_(e, r, t);
  };
  Object.defineProperty(rt, "__esModule", { value: true });
  rt.instance = rt.Gaxios = rt.GaxiosError = void 0;
  rt.request = V_;
  var Dh = Ah();
  Object.defineProperty(rt, "Gaxios", { enumerable: true, get: function() {
    return Dh.Gaxios;
  } });
  var J_ = Wa();
  Object.defineProperty(rt, "GaxiosError", { enumerable: true, get: function() {
    return J_.GaxiosError;
  } });
  z_(Va(), rt);
  rt.instance = new Dh.Gaxios();
  async function V_(r) {
    return rt.instance.request(r);
  }
});
var mu = z((Sh, Vo) => {
  (function(r) {
    "use strict";
    var e, t = /^-?(?:\d+(?:\.\d*)?|\.\d+)(?:e[+-]?\d+)?$/i, n = Math.ceil, o = Math.floor, a = "[BigNumber Error] ", u = a + "Number primitive has more than 15 significant digits: ", l = 1e14, f = 14, d = 9007199254740991, h = [1, 10, 100, 1e3, 1e4, 1e5, 1e6, 1e7, 1e8, 1e9, 1e10, 1e11, 1e12, 1e13], C = 1e7, w = 1e9;
    function I(P) {
      var j, G, re, W = H.prototype = { constructor: H, toString: null, valueOf: null }, Ee = new H(1), he = 20, oe = 4, ue = -7, Z = 21, ce = -1e7, pe = 1e7, Te = false, J = 1, X = 0, le = { prefix: "", groupSize: 3, secondaryGroupSize: 0, groupSeparator: ",", decimalSeparator: ".", fractionGroupSize: 0, fractionGroupSeparator: "\xA0", suffix: "" }, qe = "0123456789abcdefghijklmnopqrstuvwxyz", ze = true;
      function H(p, g) {
        var E, x, v, F, q, D, R, B, O = this;
        if (!(O instanceof H)) return new H(p, g);
        if (g == null) {
          if (p && p._isBigNumber === true) {
            O.s = p.s, !p.c || p.e > pe ? O.c = O.e = null : p.e < ce ? O.c = [O.e = 0] : (O.e = p.e, O.c = p.c.slice());
            return;
          }
          if ((D = typeof p == "number") && p * 0 == 0) {
            if (O.s = 1 / p < 0 ? (p = -p, -1) : 1, p === ~~p) {
              for (F = 0, q = p; q >= 10; q /= 10, F++) ;
              F > pe ? O.c = O.e = null : (O.e = F, O.c = [p]);
              return;
            }
            B = String(p);
          } else {
            if (!t.test(B = String(p))) return re(O, B, D);
            O.s = B.charCodeAt(0) == 45 ? (B = B.slice(1), -1) : 1;
          }
          (F = B.indexOf(".")) > -1 && (B = B.replace(".", "")), (q = B.search(/e/i)) > 0 ? (F < 0 && (F = q), F += +B.slice(q + 1), B = B.substring(0, q)) : F < 0 && (F = B.length);
        } else {
          if (y(g, 2, qe.length, "Base"), g == 10 && ze) return O = new H(p), Be(O, he + O.e + 1, oe);
          if (B = String(p), D = typeof p == "number") {
            if (p * 0 != 0) return re(O, B, D, g);
            if (O.s = 1 / p < 0 ? (B = B.slice(1), -1) : 1, H.DEBUG && B.replace(/^0\.0*|\./, "").length > 15) throw Error(u + p);
          } else O.s = B.charCodeAt(0) === 45 ? (B = B.slice(1), -1) : 1;
          for (E = qe.slice(0, g), F = q = 0, R = B.length; q < R; q++) if (E.indexOf(x = B.charAt(q)) < 0) {
            if (x == ".") {
              if (q > F) {
                F = R;
                continue;
              }
            } else if (!v && (B == B.toUpperCase() && (B = B.toLowerCase()) || B == B.toLowerCase() && (B = B.toUpperCase()))) {
              v = true, q = -1, F = 0;
              continue;
            }
            return re(O, String(p), D, g);
          }
          D = false, B = G(B, g, 10, O.s), (F = B.indexOf(".")) > -1 ? B = B.replace(".", "") : F = B.length;
        }
        for (q = 0; B.charCodeAt(q) === 48; q++) ;
        for (R = B.length; B.charCodeAt(--R) === 48; ) ;
        if (B = B.slice(q, ++R)) {
          if (R -= q, D && H.DEBUG && R > 15 && (p > d || p !== o(p))) throw Error(u + O.s * p);
          if ((F = F - q - 1) > pe) O.c = O.e = null;
          else if (F < ce) O.c = [O.e = 0];
          else {
            if (O.e = F, O.c = [], q = (F + 1) % f, F < 0 && (q += f), q < R) {
              for (q && O.c.push(+B.slice(0, q)), R -= f; q < R; ) O.c.push(+B.slice(q, q += f));
              q = f - (B = B.slice(q)).length;
            } else q -= R;
            for (; q--; B += "0") ;
            O.c.push(+B);
          }
        } else O.c = [O.e = 0];
      }
      H.clone = I, H.ROUND_UP = 0, H.ROUND_DOWN = 1, H.ROUND_CEIL = 2, H.ROUND_FLOOR = 3, H.ROUND_HALF_UP = 4, H.ROUND_HALF_DOWN = 5, H.ROUND_HALF_EVEN = 6, H.ROUND_HALF_CEIL = 7, H.ROUND_HALF_FLOOR = 8, H.EUCLID = 9, H.config = H.set = function(p) {
        var g, E;
        if (p != null) if (typeof p == "object") {
          if (p.hasOwnProperty(g = "DECIMAL_PLACES") && (E = p[g], y(E, 0, w, g), he = E), p.hasOwnProperty(g = "ROUNDING_MODE") && (E = p[g], y(E, 0, 8, g), oe = E), p.hasOwnProperty(g = "EXPONENTIAL_AT") && (E = p[g], E && E.pop ? (y(E[0], -w, 0, g), y(E[1], 0, w, g), ue = E[0], Z = E[1]) : (y(E, -w, w, g), ue = -(Z = E < 0 ? -E : E))), p.hasOwnProperty(g = "RANGE")) if (E = p[g], E && E.pop) y(E[0], -w, -1, g), y(E[1], 1, w, g), ce = E[0], pe = E[1];
          else if (y(E, -w, w, g), E) ce = -(pe = E < 0 ? -E : E);
          else throw Error(a + g + " cannot be zero: " + E);
          if (p.hasOwnProperty(g = "CRYPTO")) if (E = p[g], E === !!E) if (E) if (typeof crypto < "u" && crypto && (crypto.getRandomValues || crypto.randomBytes)) Te = E;
          else throw Te = !E, Error(a + "crypto unavailable");
          else Te = E;
          else throw Error(a + g + " not true or false: " + E);
          if (p.hasOwnProperty(g = "MODULO_MODE") && (E = p[g], y(E, 0, 9, g), J = E), p.hasOwnProperty(g = "POW_PRECISION") && (E = p[g], y(E, 0, w, g), X = E), p.hasOwnProperty(g = "FORMAT")) if (E = p[g], typeof E == "object") le = E;
          else throw Error(a + g + " not an object: " + E);
          if (p.hasOwnProperty(g = "ALPHABET")) if (E = p[g], typeof E == "string" && !/^.?$|[+\-.\s]|(.).*\1/.test(E)) ze = E.slice(0, 10) == "0123456789", qe = E;
          else throw Error(a + g + " invalid: " + E);
        } else throw Error(a + "Object expected: " + p);
        return { DECIMAL_PLACES: he, ROUNDING_MODE: oe, EXPONENTIAL_AT: [ue, Z], RANGE: [ce, pe], CRYPTO: Te, MODULO_MODE: J, POW_PRECISION: X, FORMAT: le, ALPHABET: qe };
      }, H.isBigNumber = function(p) {
        if (!p || p._isBigNumber !== true) return false;
        if (!H.DEBUG) return true;
        var g, E, x = p.c, v = p.e, F = p.s;
        e: if ({}.toString.call(x) == "[object Array]") {
          if ((F === 1 || F === -1) && v >= -w && v <= w && v === o(v)) {
            if (x[0] === 0) {
              if (v === 0 && x.length === 1) return true;
              break e;
            }
            if (g = (v + 1) % f, g < 1 && (g += f), String(x[0]).length == g) {
              for (g = 0; g < x.length; g++) if (E = x[g], E < 0 || E >= l || E !== o(E)) break e;
              if (E !== 0) return true;
            }
          }
        } else if (x === null && v === null && (F === null || F === 1 || F === -1)) return true;
        throw Error(a + "Invalid BigNumber: " + p);
      }, H.maximum = H.max = function() {
        return Ae(arguments, -1);
      }, H.minimum = H.min = function() {
        return Ae(arguments, 1);
      }, H.random = function() {
        var p = 9007199254740992, g = Math.random() * p & 2097151 ? function() {
          return o(Math.random() * p);
        } : function() {
          return (Math.random() * 1073741824 | 0) * 8388608 + (Math.random() * 8388608 | 0);
        };
        return function(E) {
          var x, v, F, q, D, R = 0, B = [], O = new H(Ee);
          if (E == null ? E = he : y(E, 0, w), q = n(E / f), Te) if (crypto.getRandomValues) {
            for (x = crypto.getRandomValues(new Uint32Array(q *= 2)); R < q; ) D = x[R] * 131072 + (x[R + 1] >>> 11), D >= 9e15 ? (v = crypto.getRandomValues(new Uint32Array(2)), x[R] = v[0], x[R + 1] = v[1]) : (B.push(D % 1e14), R += 2);
            R = q / 2;
          } else if (crypto.randomBytes) {
            for (x = crypto.randomBytes(q *= 7); R < q; ) D = (x[R] & 31) * 281474976710656 + x[R + 1] * 1099511627776 + x[R + 2] * 4294967296 + x[R + 3] * 16777216 + (x[R + 4] << 16) + (x[R + 5] << 8) + x[R + 6], D >= 9e15 ? crypto.randomBytes(7).copy(x, R) : (B.push(D % 1e14), R += 7);
            R = q / 7;
          } else throw Te = false, Error(a + "crypto unavailable");
          if (!Te) for (; R < q; ) D = g(), D < 9e15 && (B[R++] = D % 1e14);
          for (q = B[--R], E %= f, q && E && (D = h[f - E], B[R] = o(q / D) * D); B[R] === 0; B.pop(), R--) ;
          if (R < 0) B = [F = 0];
          else {
            for (F = -1; B[0] === 0; B.splice(0, 1), F -= f) ;
            for (R = 1, D = B[0]; D >= 10; D /= 10, R++) ;
            R < f && (F -= f - R);
          }
          return O.e = F, O.c = B, O;
        };
      }(), H.sum = function() {
        for (var p = 1, g = arguments, E = new H(g[0]); p < g.length; ) E = E.plus(g[p++]);
        return E;
      }, G = /* @__PURE__ */ function() {
        var p = "0123456789";
        function g(E, x, v, F) {
          for (var q, D = [0], R, B = 0, O = E.length; B < O; ) {
            for (R = D.length; R--; D[R] *= x) ;
            for (D[0] += F.indexOf(E.charAt(B++)), q = 0; q < D.length; q++) D[q] > v - 1 && (D[q + 1] == null && (D[q + 1] = 0), D[q + 1] += D[q] / v | 0, D[q] %= v);
          }
          return D.reverse();
        }
        return function(E, x, v, F, q) {
          var D, R, B, O, M, K, Q, we, Oe = E.indexOf("."), Ie = he, be = oe;
          for (Oe >= 0 && (O = X, X = 0, E = E.replace(".", ""), we = new H(x), K = we.pow(E.length - Oe), X = O, we.c = g(L(b(K.c), K.e, "0"), 10, v, p), we.e = we.c.length), Q = g(E, x, v, q ? (D = qe, p) : (D = p, qe)), B = O = Q.length; Q[--O] == 0; Q.pop()) ;
          if (!Q[0]) return D.charAt(0);
          if (Oe < 0 ? --B : (K.c = Q, K.e = B, K.s = F, K = j(K, we, Ie, be, v), Q = K.c, M = K.r, B = K.e), R = B + Ie + 1, Oe = Q[R], O = v / 2, M = M || R < 0 || Q[R + 1] != null, M = be < 4 ? (Oe != null || M) && (be == 0 || be == (K.s < 0 ? 3 : 2)) : Oe > O || Oe == O && (be == 4 || M || be == 6 && Q[R - 1] & 1 || be == (K.s < 0 ? 8 : 7)), R < 1 || !Q[0]) E = M ? L(D.charAt(1), -Ie, D.charAt(0)) : D.charAt(0);
          else {
            if (Q.length = R, M) for (--v; ++Q[--R] > v; ) Q[R] = 0, R || (++B, Q = [1].concat(Q));
            for (O = Q.length; !Q[--O]; ) ;
            for (Oe = 0, E = ""; Oe <= O; E += D.charAt(Q[Oe++])) ;
            E = L(E, B, D.charAt(0));
          }
          return E;
        };
      }(), j = /* @__PURE__ */ function() {
        function p(x, v, F) {
          var q, D, R, B, O = 0, M = x.length, K = v % C, Q = v / C | 0;
          for (x = x.slice(); M--; ) R = x[M] % C, B = x[M] / C | 0, q = Q * R + B * K, D = K * R + q % C * C + O, O = (D / F | 0) + (q / C | 0) + Q * B, x[M] = D % F;
          return O && (x = [O].concat(x)), x;
        }
        function g(x, v, F, q) {
          var D, R;
          if (F != q) R = F > q ? 1 : -1;
          else for (D = R = 0; D < F; D++) if (x[D] != v[D]) {
            R = x[D] > v[D] ? 1 : -1;
            break;
          }
          return R;
        }
        function E(x, v, F, q) {
          for (var D = 0; F--; ) x[F] -= D, D = x[F] < v[F] ? 1 : 0, x[F] = D * q + x[F] - v[F];
          for (; !x[0] && x.length > 1; x.splice(0, 1)) ;
        }
        return function(x, v, F, q, D) {
          var R, B, O, M, K, Q, we, Oe, Ie, be, De, Le, on, an, un, ut, rr, Ke = x.s == v.s ? 1 : -1, Ue = x.c, Se = v.c;
          if (!Ue || !Ue[0] || !Se || !Se[0]) return new H(!x.s || !v.s || (Ue ? Se && Ue[0] == Se[0] : !Se) ? NaN : Ue && Ue[0] == 0 || !Se ? Ke * 0 : Ke / 0);
          for (Oe = new H(Ke), Ie = Oe.c = [], B = x.e - v.e, Ke = F + B + 1, D || (D = l, B = S(x.e / f) - S(v.e / f), Ke = Ke / f | 0), O = 0; Se[O] == (Ue[O] || 0); O++) ;
          if (Se[O] > (Ue[O] || 0) && B--, Ke < 0) Ie.push(1), M = true;
          else {
            for (an = Ue.length, ut = Se.length, O = 0, Ke += 2, K = o(D / (Se[0] + 1)), K > 1 && (Se = p(Se, K, D), Ue = p(Ue, K, D), ut = Se.length, an = Ue.length), on = ut, be = Ue.slice(0, ut), De = be.length; De < ut; be[De++] = 0) ;
            rr = Se.slice(), rr = [0].concat(rr), un = Se[0], Se[1] >= D / 2 && un++;
            do {
              if (K = 0, R = g(Se, be, ut, De), R < 0) {
                if (Le = be[0], ut != De && (Le = Le * D + (be[1] || 0)), K = o(Le / un), K > 1) for (K >= D && (K = D - 1), Q = p(Se, K, D), we = Q.length, De = be.length; g(Q, be, we, De) == 1; ) K--, E(Q, ut < we ? rr : Se, we, D), we = Q.length, R = 1;
                else K == 0 && (R = K = 1), Q = Se.slice(), we = Q.length;
                if (we < De && (Q = [0].concat(Q)), E(be, Q, De, D), De = be.length, R == -1) for (; g(Se, be, ut, De) < 1; ) K++, E(be, ut < De ? rr : Se, De, D), De = be.length;
              } else R === 0 && (K++, be = [0]);
              Ie[O++] = K, be[0] ? be[De++] = Ue[on] || 0 : (be = [Ue[on]], De = 1);
            } while ((on++ < an || be[0] != null) && Ke--);
            M = be[0] != null, Ie[0] || Ie.splice(0, 1);
          }
          if (D == l) {
            for (O = 1, Ke = Ie[0]; Ke >= 10; Ke /= 10, O++) ;
            Be(Oe, F + (Oe.e = O + B * f - 1) + 1, q, M);
          } else Oe.e = B, Oe.r = +M;
          return Oe;
        };
      }();
      function ye(p, g, E, x) {
        var v, F, q, D, R;
        if (E == null ? E = oe : y(E, 0, 8), !p.c) return p.toString();
        if (v = p.c[0], q = p.e, g == null) R = b(p.c), R = x == 1 || x == 2 && (q <= ue || q >= Z) ? k(R, q) : L(R, q, "0");
        else if (p = Be(new H(p), g, E), F = p.e, R = b(p.c), D = R.length, x == 1 || x == 2 && (g <= F || F <= ue)) {
          for (; D < g; R += "0", D++) ;
          R = k(R, F);
        } else if (g -= q + (x === 2 && F > q), R = L(R, F, "0"), F + 1 > D) {
          if (--g > 0) for (R += "."; g--; R += "0") ;
        } else if (g += F - D, g > 0) for (F + 1 == D && (R += "."); g--; R += "0") ;
        return p.s < 0 && v ? "-" + R : R;
      }
      function Ae(p, g) {
        for (var E, x, v = 1, F = new H(p[0]); v < p.length; v++) x = new H(p[v]), (!x.s || (E = _(F, x)) === g || E === 0 && F.s === g) && (F = x);
        return F;
      }
      function tr(p, g, E) {
        for (var x = 1, v = g.length; !g[--v]; g.pop()) ;
        for (v = g[0]; v >= 10; v /= 10, x++) ;
        return (E = x + E * f - 1) > pe ? p.c = p.e = null : E < ce ? p.c = [p.e = 0] : (p.e = E, p.c = g), p;
      }
      re = /* @__PURE__ */ function() {
        var p = /^(-?)0([xbo])(?=\w[\w.]*$)/i, g = /^([^.]+)\.$/, E = /^\.([^.]+)$/, x = /^-?(Infinity|NaN)$/, v = /^\s*\+(?=[\w.])|^\s+|\s+$/g;
        return function(F, q, D, R) {
          var B, O = D ? q : q.replace(v, "");
          if (x.test(O)) F.s = isNaN(O) ? null : O < 0 ? -1 : 1;
          else {
            if (!D && (O = O.replace(p, function(M, K, Q) {
              return B = (Q = Q.toLowerCase()) == "x" ? 16 : Q == "b" ? 2 : 8, !R || R == B ? K : M;
            }), R && (B = R, O = O.replace(g, "$1").replace(E, "0.$1")), q != O)) return new H(O, B);
            if (H.DEBUG) throw Error(a + "Not a" + (R ? " base " + R : "") + " number: " + q);
            F.s = null;
          }
          F.c = F.e = null;
        };
      }();
      function Be(p, g, E, x) {
        var v, F, q, D, R, B, O, M = p.c, K = h;
        if (M) {
          e: {
            for (v = 1, D = M[0]; D >= 10; D /= 10, v++) ;
            if (F = g - v, F < 0) F += f, q = g, R = M[B = 0], O = o(R / K[v - q - 1] % 10);
            else if (B = n((F + 1) / f), B >= M.length) if (x) {
              for (; M.length <= B; M.push(0)) ;
              R = O = 0, v = 1, F %= f, q = F - f + 1;
            } else break e;
            else {
              for (R = D = M[B], v = 1; D >= 10; D /= 10, v++) ;
              F %= f, q = F - f + v, O = q < 0 ? 0 : o(R / K[v - q - 1] % 10);
            }
            if (x = x || g < 0 || M[B + 1] != null || (q < 0 ? R : R % K[v - q - 1]), x = E < 4 ? (O || x) && (E == 0 || E == (p.s < 0 ? 3 : 2)) : O > 5 || O == 5 && (E == 4 || x || E == 6 && (F > 0 ? q > 0 ? R / K[v - q] : 0 : M[B - 1]) % 10 & 1 || E == (p.s < 0 ? 8 : 7)), g < 1 || !M[0]) return M.length = 0, x ? (g -= p.e + 1, M[0] = K[(f - g % f) % f], p.e = -g || 0) : M[0] = p.e = 0, p;
            if (F == 0 ? (M.length = B, D = 1, B--) : (M.length = B + 1, D = K[f - F], M[B] = q > 0 ? o(R / K[v - q] % K[q]) * D : 0), x) for (; ; ) if (B == 0) {
              for (F = 1, q = M[0]; q >= 10; q /= 10, F++) ;
              for (q = M[0] += D, D = 1; q >= 10; q /= 10, D++) ;
              F != D && (p.e++, M[0] == l && (M[0] = 1));
              break;
            } else {
              if (M[B] += D, M[B] != l) break;
              M[B--] = 0, D = 1;
            }
            for (F = M.length; M[--F] === 0; M.pop()) ;
          }
          p.e > pe ? p.c = p.e = null : p.e < ce && (p.c = [p.e = 0]);
        }
        return p;
      }
      function Ne(p) {
        var g, E = p.e;
        return E === null ? p.toString() : (g = b(p.c), g = E <= ue || E >= Z ? k(g, E) : L(g, E, "0"), p.s < 0 ? "-" + g : g);
      }
      return W.absoluteValue = W.abs = function() {
        var p = new H(this);
        return p.s < 0 && (p.s = 1), p;
      }, W.comparedTo = function(p, g) {
        return _(this, new H(p, g));
      }, W.decimalPlaces = W.dp = function(p, g) {
        var E, x, v, F = this;
        if (p != null) return y(p, 0, w), g == null ? g = oe : y(g, 0, 8), Be(new H(F), p + F.e + 1, g);
        if (!(E = F.c)) return null;
        if (x = ((v = E.length - 1) - S(this.e / f)) * f, v = E[v]) for (; v % 10 == 0; v /= 10, x--) ;
        return x < 0 && (x = 0), x;
      }, W.dividedBy = W.div = function(p, g) {
        return j(this, new H(p, g), he, oe);
      }, W.dividedToIntegerBy = W.idiv = function(p, g) {
        return j(this, new H(p, g), 0, 1);
      }, W.exponentiatedBy = W.pow = function(p, g) {
        var E, x, v, F, q, D, R, B, O, M = this;
        if (p = new H(p), p.c && !p.isInteger()) throw Error(a + "Exponent not an integer: " + Ne(p));
        if (g != null && (g = new H(g)), D = p.e > 14, !M.c || !M.c[0] || M.c[0] == 1 && !M.e && M.c.length == 1 || !p.c || !p.c[0]) return O = new H(Math.pow(+Ne(M), D ? p.s * (2 - T(p)) : +Ne(p))), g ? O.mod(g) : O;
        if (R = p.s < 0, g) {
          if (g.c ? !g.c[0] : !g.s) return new H(NaN);
          x = !R && M.isInteger() && g.isInteger(), x && (M = M.mod(g));
        } else {
          if (p.e > 9 && (M.e > 0 || M.e < -1 || (M.e == 0 ? M.c[0] > 1 || D && M.c[1] >= 24e7 : M.c[0] < 8e13 || D && M.c[0] <= 9999975e7))) return F = M.s < 0 && T(p) ? -0 : 0, M.e > -1 && (F = 1 / F), new H(R ? 1 / F : F);
          X && (F = n(X / f + 2));
        }
        for (D ? (E = new H(0.5), R && (p.s = 1), B = T(p)) : (v = Math.abs(+Ne(p)), B = v % 2), O = new H(Ee); ; ) {
          if (B) {
            if (O = O.times(M), !O.c) break;
            F ? O.c.length > F && (O.c.length = F) : x && (O = O.mod(g));
          }
          if (v) {
            if (v = o(v / 2), v === 0) break;
            B = v % 2;
          } else if (p = p.times(E), Be(p, p.e + 1, 1), p.e > 14) B = T(p);
          else {
            if (v = +Ne(p), v === 0) break;
            B = v % 2;
          }
          M = M.times(M), F ? M.c && M.c.length > F && (M.c.length = F) : x && (M = M.mod(g));
        }
        return x ? O : (R && (O = Ee.div(O)), g ? O.mod(g) : F ? Be(O, X, oe, q) : O);
      }, W.integerValue = function(p) {
        var g = new H(this);
        return p == null ? p = oe : y(p, 0, 8), Be(g, g.e + 1, p);
      }, W.isEqualTo = W.eq = function(p, g) {
        return _(this, new H(p, g)) === 0;
      }, W.isFinite = function() {
        return !!this.c;
      }, W.isGreaterThan = W.gt = function(p, g) {
        return _(this, new H(p, g)) > 0;
      }, W.isGreaterThanOrEqualTo = W.gte = function(p, g) {
        return (g = _(this, new H(p, g))) === 1 || g === 0;
      }, W.isInteger = function() {
        return !!this.c && S(this.e / f) > this.c.length - 2;
      }, W.isLessThan = W.lt = function(p, g) {
        return _(this, new H(p, g)) < 0;
      }, W.isLessThanOrEqualTo = W.lte = function(p, g) {
        return (g = _(this, new H(p, g))) === -1 || g === 0;
      }, W.isNaN = function() {
        return !this.s;
      }, W.isNegative = function() {
        return this.s < 0;
      }, W.isPositive = function() {
        return this.s > 0;
      }, W.isZero = function() {
        return !!this.c && this.c[0] == 0;
      }, W.minus = function(p, g) {
        var E, x, v, F, q = this, D = q.s;
        if (p = new H(p, g), g = p.s, !D || !g) return new H(NaN);
        if (D != g) return p.s = -g, q.plus(p);
        var R = q.e / f, B = p.e / f, O = q.c, M = p.c;
        if (!R || !B) {
          if (!O || !M) return O ? (p.s = -g, p) : new H(M ? q : NaN);
          if (!O[0] || !M[0]) return M[0] ? (p.s = -g, p) : new H(O[0] ? q : oe == 3 ? -0 : 0);
        }
        if (R = S(R), B = S(B), O = O.slice(), D = R - B) {
          for ((F = D < 0) ? (D = -D, v = O) : (B = R, v = M), v.reverse(), g = D; g--; v.push(0)) ;
          v.reverse();
        } else for (x = (F = (D = O.length) < (g = M.length)) ? D : g, D = g = 0; g < x; g++) if (O[g] != M[g]) {
          F = O[g] < M[g];
          break;
        }
        if (F && (v = O, O = M, M = v, p.s = -p.s), g = (x = M.length) - (E = O.length), g > 0) for (; g--; O[E++] = 0) ;
        for (g = l - 1; x > D; ) {
          if (O[--x] < M[x]) {
            for (E = x; E && !O[--E]; O[E] = g) ;
            --O[E], O[x] += l;
          }
          O[x] -= M[x];
        }
        for (; O[0] == 0; O.splice(0, 1), --B) ;
        return O[0] ? tr(p, O, B) : (p.s = oe == 3 ? -1 : 1, p.c = [p.e = 0], p);
      }, W.modulo = W.mod = function(p, g) {
        var E, x, v = this;
        return p = new H(p, g), !v.c || !p.s || p.c && !p.c[0] ? new H(NaN) : !p.c || v.c && !v.c[0] ? new H(v) : (J == 9 ? (x = p.s, p.s = 1, E = j(v, p, 0, 3), p.s = x, E.s *= x) : E = j(v, p, 0, J), p = v.minus(E.times(p)), !p.c[0] && J == 1 && (p.s = v.s), p);
      }, W.multipliedBy = W.times = function(p, g) {
        var E, x, v, F, q, D, R, B, O, M, K, Q, we, Oe, Ie, be = this, De = be.c, Le = (p = new H(p, g)).c;
        if (!De || !Le || !De[0] || !Le[0]) return !be.s || !p.s || De && !De[0] && !Le || Le && !Le[0] && !De ? p.c = p.e = p.s = null : (p.s *= be.s, !De || !Le ? p.c = p.e = null : (p.c = [0], p.e = 0)), p;
        for (x = S(be.e / f) + S(p.e / f), p.s *= be.s, R = De.length, M = Le.length, R < M && (we = De, De = Le, Le = we, v = R, R = M, M = v), v = R + M, we = []; v--; we.push(0)) ;
        for (Oe = l, Ie = C, v = M; --v >= 0; ) {
          for (E = 0, K = Le[v] % Ie, Q = Le[v] / Ie | 0, q = R, F = v + q; F > v; ) B = De[--q] % Ie, O = De[q] / Ie | 0, D = Q * B + O * K, B = K * B + D % Ie * Ie + we[F] + E, E = (B / Oe | 0) + (D / Ie | 0) + Q * O, we[F--] = B % Oe;
          we[F] = E;
        }
        return E ? ++x : we.splice(0, 1), tr(p, we, x);
      }, W.negated = function() {
        var p = new H(this);
        return p.s = -p.s || null, p;
      }, W.plus = function(p, g) {
        var E, x = this, v = x.s;
        if (p = new H(p, g), g = p.s, !v || !g) return new H(NaN);
        if (v != g) return p.s = -g, x.minus(p);
        var F = x.e / f, q = p.e / f, D = x.c, R = p.c;
        if (!F || !q) {
          if (!D || !R) return new H(v / 0);
          if (!D[0] || !R[0]) return R[0] ? p : new H(D[0] ? x : v * 0);
        }
        if (F = S(F), q = S(q), D = D.slice(), v = F - q) {
          for (v > 0 ? (q = F, E = R) : (v = -v, E = D), E.reverse(); v--; E.push(0)) ;
          E.reverse();
        }
        for (v = D.length, g = R.length, v - g < 0 && (E = R, R = D, D = E, g = v), v = 0; g; ) v = (D[--g] = D[g] + R[g] + v) / l | 0, D[g] = l === D[g] ? 0 : D[g] % l;
        return v && (D = [v].concat(D), ++q), tr(p, D, q);
      }, W.precision = W.sd = function(p, g) {
        var E, x, v, F = this;
        if (p != null && p !== !!p) return y(p, 1, w), g == null ? g = oe : y(g, 0, 8), Be(new H(F), p, g);
        if (!(E = F.c)) return null;
        if (v = E.length - 1, x = v * f + 1, v = E[v]) {
          for (; v % 10 == 0; v /= 10, x--) ;
          for (v = E[0]; v >= 10; v /= 10, x++) ;
        }
        return p && F.e + 1 > x && (x = F.e + 1), x;
      }, W.shiftedBy = function(p) {
        return y(p, -d, d), this.times("1e" + p);
      }, W.squareRoot = W.sqrt = function() {
        var p, g, E, x, v, F = this, q = F.c, D = F.s, R = F.e, B = he + 4, O = new H("0.5");
        if (D !== 1 || !q || !q[0]) return new H(!D || D < 0 && (!q || q[0]) ? NaN : q ? F : 1 / 0);
        if (D = Math.sqrt(+Ne(F)), D == 0 || D == 1 / 0 ? (g = b(q), (g.length + R) % 2 == 0 && (g += "0"), D = Math.sqrt(+g), R = S((R + 1) / 2) - (R < 0 || R % 2), D == 1 / 0 ? g = "5e" + R : (g = D.toExponential(), g = g.slice(0, g.indexOf("e") + 1) + R), E = new H(g)) : E = new H(D + ""), E.c[0]) {
          for (R = E.e, D = R + B, D < 3 && (D = 0); ; ) if (v = E, E = O.times(v.plus(j(F, v, B, 1))), b(v.c).slice(0, D) === (g = b(E.c)).slice(0, D)) if (E.e < R && --D, g = g.slice(D - 3, D + 1), g == "9999" || !x && g == "4999") {
            if (!x && (Be(v, v.e + he + 2, 0), v.times(v).eq(F))) {
              E = v;
              break;
            }
            B += 4, D += 4, x = 1;
          } else {
            (!+g || !+g.slice(1) && g.charAt(0) == "5") && (Be(E, E.e + he + 2, 1), p = !E.times(E).eq(F));
            break;
          }
        }
        return Be(E, E.e + he + 1, oe, p);
      }, W.toExponential = function(p, g) {
        return p != null && (y(p, 0, w), p++), ye(this, p, g, 1);
      }, W.toFixed = function(p, g) {
        return p != null && (y(p, 0, w), p = p + this.e + 1), ye(this, p, g);
      }, W.toFormat = function(p, g, E) {
        var x, v = this;
        if (E == null) p != null && g && typeof g == "object" ? (E = g, g = null) : p && typeof p == "object" ? (E = p, p = g = null) : E = le;
        else if (typeof E != "object") throw Error(a + "Argument not an object: " + E);
        if (x = v.toFixed(p, g), v.c) {
          var F, q = x.split("."), D = +E.groupSize, R = +E.secondaryGroupSize, B = E.groupSeparator || "", O = q[0], M = q[1], K = v.s < 0, Q = K ? O.slice(1) : O, we = Q.length;
          if (R && (F = D, D = R, R = F, we -= F), D > 0 && we > 0) {
            for (F = we % D || D, O = Q.substr(0, F); F < we; F += D) O += B + Q.substr(F, D);
            R > 0 && (O += B + Q.slice(F)), K && (O = "-" + O);
          }
          x = M ? O + (E.decimalSeparator || "") + ((R = +E.fractionGroupSize) ? M.replace(new RegExp("\\d{" + R + "}\\B", "g"), "$&" + (E.fractionGroupSeparator || "")) : M) : O;
        }
        return (E.prefix || "") + x + (E.suffix || "");
      }, W.toFraction = function(p) {
        var g, E, x, v, F, q, D, R, B, O, M, K, Q = this, we = Q.c;
        if (p != null && (D = new H(p), !D.isInteger() && (D.c || D.s !== 1) || D.lt(Ee))) throw Error(a + "Argument " + (D.isInteger() ? "out of range: " : "not an integer: ") + Ne(D));
        if (!we) return new H(Q);
        for (g = new H(Ee), B = E = new H(Ee), x = R = new H(Ee), K = b(we), F = g.e = K.length - Q.e - 1, g.c[0] = h[(q = F % f) < 0 ? f + q : q], p = !p || D.comparedTo(g) > 0 ? F > 0 ? g : B : D, q = pe, pe = 1 / 0, D = new H(K), R.c[0] = 0; O = j(D, g, 0, 1), v = E.plus(O.times(x)), v.comparedTo(p) != 1; ) E = x, x = v, B = R.plus(O.times(v = B)), R = v, g = D.minus(O.times(v = g)), D = v;
        return v = j(p.minus(E), x, 0, 1), R = R.plus(v.times(B)), E = E.plus(v.times(x)), R.s = B.s = Q.s, F = F * 2, M = j(B, x, F, oe).minus(Q).abs().comparedTo(j(R, E, F, oe).minus(Q).abs()) < 1 ? [B, x] : [R, E], pe = q, M;
      }, W.toNumber = function() {
        return +Ne(this);
      }, W.toPrecision = function(p, g) {
        return p != null && y(p, 1, w), ye(this, p, g, 2);
      }, W.toString = function(p) {
        var g, E = this, x = E.s, v = E.e;
        return v === null ? x ? (g = "Infinity", x < 0 && (g = "-" + g)) : g = "NaN" : (p == null ? g = v <= ue || v >= Z ? k(b(E.c), v) : L(b(E.c), v, "0") : p === 10 && ze ? (E = Be(new H(E), he + v + 1, oe), g = L(b(E.c), E.e, "0")) : (y(p, 2, qe.length, "Base"), g = G(L(b(E.c), v, "0"), 10, p, x, true)), x < 0 && E.c[0] && (g = "-" + g)), g;
      }, W.valueOf = W.toJSON = function() {
        return Ne(this);
      }, W._isBigNumber = true, P != null && H.set(P), H;
    }
    function S(P) {
      var j = P | 0;
      return P > 0 || P === j ? j : j - 1;
    }
    function b(P) {
      for (var j, G, re = 1, W = P.length, Ee = P[0] + ""; re < W; ) {
        for (j = P[re++] + "", G = f - j.length; G--; j = "0" + j) ;
        Ee += j;
      }
      for (W = Ee.length; Ee.charCodeAt(--W) === 48; ) ;
      return Ee.slice(0, W + 1 || 1);
    }
    function _(P, j) {
      var G, re, W = P.c, Ee = j.c, he = P.s, oe = j.s, ue = P.e, Z = j.e;
      if (!he || !oe) return null;
      if (G = W && !W[0], re = Ee && !Ee[0], G || re) return G ? re ? 0 : -oe : he;
      if (he != oe) return he;
      if (G = he < 0, re = ue == Z, !W || !Ee) return re ? 0 : !W ^ G ? 1 : -1;
      if (!re) return ue > Z ^ G ? 1 : -1;
      for (oe = (ue = W.length) < (Z = Ee.length) ? ue : Z, he = 0; he < oe; he++) if (W[he] != Ee[he]) return W[he] > Ee[he] ^ G ? 1 : -1;
      return ue == Z ? 0 : ue > Z ^ G ? 1 : -1;
    }
    function y(P, j, G, re) {
      if (P < j || P > G || P !== o(P)) throw Error(a + (re || "Argument") + (typeof P == "number" ? P < j || P > G ? " out of range: " : " not an integer: " : " not a primitive number: ") + String(P));
    }
    function T(P) {
      var j = P.c.length - 1;
      return S(P.e / f) == j && P.c[j] % 2 != 0;
    }
    function k(P, j) {
      return (P.length > 1 ? P.charAt(0) + "." + P.slice(1) : P) + (j < 0 ? "e" : "e+") + j;
    }
    function L(P, j, G) {
      var re, W;
      if (j < 0) {
        for (W = G + "."; ++j; W += G) ;
        P = W + P;
      } else if (re = P.length, ++j > re) {
        for (W = G, j -= re; --j; W += G) ;
        P += W;
      } else j < re && (P = P.slice(0, j) + "." + P.slice(j));
      return P;
    }
    e = I(), e.default = e.BigNumber = e, typeof define == "function" && define.amd ? define(function() {
      return e;
    }) : typeof Vo < "u" && Vo.exports ? Vo.exports = e : (r || (r = typeof self < "u" && self ? self : window), r.BigNumber = e);
  })(Sh);
});
var Fh = z((wS, Rh) => {
  var vh = mu(), Th = Rh.exports;
  (function() {
    "use strict";
    function r(d) {
      return d < 10 ? "0" + d : d;
    }
    var e = /[\u0000\u00ad\u0600-\u0604\u070f\u17b4\u17b5\u200c-\u200f\u2028-\u202f\u2060-\u206f\ufeff\ufff0-\uffff]/g, t = /[\\\"\x00-\x1f\x7f-\x9f\u00ad\u0600-\u0604\u070f\u17b4\u17b5\u200c-\u200f\u2028-\u202f\u2060-\u206f\ufeff\ufff0-\uffff]/g, n, o, a = { "\b": "\\b", "	": "\\t", "\n": "\\n", "\f": "\\f", "\r": "\\r", '"': '\\"', "\\": "\\\\" }, u;
    function l(d) {
      return t.lastIndex = 0, t.test(d) ? '"' + d.replace(t, function(h) {
        var C = a[h];
        return typeof C == "string" ? C : "\\u" + ("0000" + h.charCodeAt(0).toString(16)).slice(-4);
      }) + '"' : '"' + d + '"';
    }
    function f(d, h) {
      var C, w, I, S, b = n, _, y = h[d], T = y != null && (y instanceof vh || vh.isBigNumber(y));
      switch (y && typeof y == "object" && typeof y.toJSON == "function" && (y = y.toJSON(d)), typeof u == "function" && (y = u.call(h, d, y)), typeof y) {
        case "string":
          return T ? y : l(y);
        case "number":
          return isFinite(y) ? String(y) : "null";
        case "boolean":
        case "null":
        case "bigint":
          return String(y);
        case "object":
          if (!y) return "null";
          if (n += o, _ = [], Object.prototype.toString.apply(y) === "[object Array]") {
            for (S = y.length, C = 0; C < S; C += 1) _[C] = f(C, y) || "null";
            return I = _.length === 0 ? "[]" : n ? `[
` + n + _.join(`,
` + n) + `
` + b + "]" : "[" + _.join(",") + "]", n = b, I;
          }
          if (u && typeof u == "object") for (S = u.length, C = 0; C < S; C += 1) typeof u[C] == "string" && (w = u[C], I = f(w, y), I && _.push(l(w) + (n ? ": " : ":") + I));
          else Object.keys(y).forEach(function(k) {
            var L = f(k, y);
            L && _.push(l(k) + (n ? ": " : ":") + L);
          });
          return I = _.length === 0 ? "{}" : n ? `{
` + n + _.join(`,
` + n) + `
` + b + "}" : "{" + _.join(",") + "}", n = b, I;
      }
    }
    typeof Th.stringify != "function" && (Th.stringify = function(d, h, C) {
      var w;
      if (n = "", o = "", typeof C == "number") for (w = 0; w < C; w += 1) o += " ";
      else typeof C == "string" && (o = C);
      if (u = h, h && typeof h != "function" && (typeof h != "object" || typeof h.length != "number")) throw new Error("JSON.stringify");
      return f("", { "": d });
    });
  })();
});
var Oh = z((AS, kh) => {
  var Ko = null, K_ = /(?:_|\\u005[Ff])(?:_|\\u005[Ff])(?:p|\\u0070)(?:r|\\u0072)(?:o|\\u006[Ff])(?:t|\\u0074)(?:o|\\u006[Ff])(?:_|\\u005[Ff])(?:_|\\u005[Ff])/, Y_ = /(?:c|\\u0063)(?:o|\\u006[Ff])(?:n|\\u006[Ee])(?:s|\\u0073)(?:t|\\u0074)(?:r|\\u0072)(?:u|\\u0075)(?:c|\\u0063)(?:t|\\u0074)(?:o|\\u006[Ff])(?:r|\\u0072)/, X_ = function(r) {
    "use strict";
    var e = { strict: false, storeAsString: false, alwaysParseAsBig: false, useNativeBigInt: false, protoAction: "error", constructorAction: "error" };
    if (r != null) {
      if (r.strict === true && (e.strict = true), r.storeAsString === true && (e.storeAsString = true), e.alwaysParseAsBig = r.alwaysParseAsBig === true ? r.alwaysParseAsBig : false, e.useNativeBigInt = r.useNativeBigInt === true ? r.useNativeBigInt : false, typeof r.constructorAction < "u") if (r.constructorAction === "error" || r.constructorAction === "ignore" || r.constructorAction === "preserve") e.constructorAction = r.constructorAction;
      else throw new Error(`Incorrect value for constructorAction option, must be "error", "ignore" or undefined but passed ${r.constructorAction}`);
      if (typeof r.protoAction < "u") if (r.protoAction === "error" || r.protoAction === "ignore" || r.protoAction === "preserve") e.protoAction = r.protoAction;
      else throw new Error(`Incorrect value for protoAction option, must be "error", "ignore" or undefined but passed ${r.protoAction}`);
    }
    var t, n, o = { '"': '"', "\\": "\\", "/": "/", b: "\b", f: "\f", n: `
`, r: "\r", t: "	" }, a, u = function(b) {
      throw { name: "SyntaxError", message: b, at: t, text: a };
    }, l = function(b) {
      return b && b !== n && u("Expected '" + b + "' instead of '" + n + "'"), n = a.charAt(t), t += 1, n;
    }, f = function() {
      var b, _ = "";
      for (n === "-" && (_ = "-", l("-")); n >= "0" && n <= "9"; ) _ += n, l();
      if (n === ".") for (_ += "."; l() && n >= "0" && n <= "9"; ) _ += n;
      if (n === "e" || n === "E") for (_ += n, l(), (n === "-" || n === "+") && (_ += n, l()); n >= "0" && n <= "9"; ) _ += n, l();
      if (b = +_, !isFinite(b)) u("Bad number");
      else return Ko == null && (Ko = mu()), _.length > 15 ? e.storeAsString ? _ : e.useNativeBigInt ? BigInt(_) : new Ko(_) : e.alwaysParseAsBig ? e.useNativeBigInt ? BigInt(b) : new Ko(b) : b;
    }, d = function() {
      var b, _, y = "", T;
      if (n === '"') for (var k = t; l(); ) {
        if (n === '"') return t - 1 > k && (y += a.substring(k, t - 1)), l(), y;
        if (n === "\\") {
          if (t - 1 > k && (y += a.substring(k, t - 1)), l(), n === "u") {
            for (T = 0, _ = 0; _ < 4 && (b = parseInt(l(), 16), !!isFinite(b)); _ += 1) T = T * 16 + b;
            y += String.fromCharCode(T);
          } else if (typeof o[n] == "string") y += o[n];
          else break;
          k = t;
        }
      }
      u("Bad string");
    }, h = function() {
      for (; n && n <= " "; ) l();
    }, C = function() {
      switch (n) {
        case "t":
          return l("t"), l("r"), l("u"), l("e"), true;
        case "f":
          return l("f"), l("a"), l("l"), l("s"), l("e"), false;
        case "n":
          return l("n"), l("u"), l("l"), l("l"), null;
      }
      u("Unexpected '" + n + "'");
    }, w, I = function() {
      var b = [];
      if (n === "[") {
        if (l("["), h(), n === "]") return l("]"), b;
        for (; n; ) {
          if (b.push(w()), h(), n === "]") return l("]"), b;
          l(","), h();
        }
      }
      u("Bad array");
    }, S = function() {
      var b, _ = /* @__PURE__ */ Object.create(null);
      if (n === "{") {
        if (l("{"), h(), n === "}") return l("}"), _;
        for (; n; ) {
          if (b = d(), h(), l(":"), e.strict === true && Object.hasOwnProperty.call(_, b) && u('Duplicate key "' + b + '"'), K_.test(b) === true ? e.protoAction === "error" ? u("Object contains forbidden prototype property") : e.protoAction === "ignore" ? w() : _[b] = w() : Y_.test(b) === true ? e.constructorAction === "error" ? u("Object contains forbidden constructor property") : e.constructorAction === "ignore" ? w() : _[b] = w() : _[b] = w(), h(), n === "}") return l("}"), _;
          l(","), h();
        }
      }
      u("Bad object");
    };
    return w = function() {
      switch (h(), n) {
        case "{":
          return S();
        case "[":
          return I();
        case '"':
          return d();
        case "-":
          return f();
        default:
          return n >= "0" && n <= "9" ? f() : C();
      }
    }, function(b, _) {
      var y;
      return a = b + "", t = 0, n = " ", y = w(), h(), n && u("Syntax error"), typeof _ == "function" ? function T(k, L) {
        var P, j, G = k[L];
        return G && typeof G == "object" && Object.keys(G).forEach(function(re) {
          j = T(G, re), j !== void 0 ? G[re] = j : delete G[re];
        }), _.call(k, L, G);
      }({ "": y }, "") : y;
    };
  };
  kh.exports = X_;
});
var Bh = z((DS, Yo) => {
  var Ph = Fh().stringify, xh = Oh();
  Yo.exports = function(r) {
    return { parse: xh(r), stringify: Ph };
  };
  Yo.exports.parse = xh();
  Yo.exports.stringify = Ph;
});
var gu = z((qt) => {
  "use strict";
  Object.defineProperty(qt, "__esModule", { value: true });
  qt.GCE_LINUX_BIOS_PATHS = void 0;
  qt.isGoogleCloudServerless = qh;
  qt.isGoogleComputeEngineLinux = jh;
  qt.isGoogleComputeEngineMACAddress = Lh;
  qt.isGoogleComputeEngine = Uh;
  qt.detectGCPResidency = Z_;
  var Ih = Y("fs"), Nh = Y("os");
  qt.GCE_LINUX_BIOS_PATHS = { BIOS_DATE: "/sys/class/dmi/id/bios_date", BIOS_VENDOR: "/sys/class/dmi/id/bios_vendor" };
  var Q_ = /^42:01/;
  function qh() {
    return !!(process.env.CLOUD_RUN_JOB || process.env.FUNCTION_NAME || process.env.K_SERVICE);
  }
  function jh() {
    if ((0, Nh.platform)() !== "linux") return false;
    try {
      (0, Ih.statSync)(qt.GCE_LINUX_BIOS_PATHS.BIOS_DATE);
      let r = (0, Ih.readFileSync)(qt.GCE_LINUX_BIOS_PATHS.BIOS_VENDOR, "utf8");
      return /Google/.test(r);
    } catch {
      return false;
    }
  }
  function Lh() {
    let r = (0, Nh.networkInterfaces)();
    for (let e of Object.values(r)) if (e) {
      for (let { mac: t } of e) if (Q_.test(t)) return true;
    }
    return false;
  }
  function Uh() {
    return jh() || Lh();
  }
  function Z_() {
    return qh() || Uh();
  }
});
var Mh = z((Xo) => {
  "use strict";
  Object.defineProperty(Xo, "__esModule", { value: true });
  Xo.Colours = void 0;
  var Qe = class r {
    static isEnabled(e) {
      return e && e.isTTY && (typeof e.getColorDepth == "function" ? e.getColorDepth() > 2 : true);
    }
    static refresh() {
      r.enabled = r.isEnabled(process == null ? void 0 : process.stderr), this.enabled ? (r.reset = "\x1B[0m", r.bright = "\x1B[1m", r.dim = "\x1B[2m", r.red = "\x1B[31m", r.green = "\x1B[32m", r.yellow = "\x1B[33m", r.blue = "\x1B[34m", r.magenta = "\x1B[35m", r.cyan = "\x1B[36m", r.white = "\x1B[37m", r.grey = "\x1B[90m") : (r.reset = "", r.bright = "", r.dim = "", r.red = "", r.green = "", r.yellow = "", r.blue = "", r.magenta = "", r.cyan = "", r.white = "", r.grey = "");
    }
  };
  Xo.Colours = Qe;
  Qe.enabled = false;
  Qe.reset = "";
  Qe.bright = "";
  Qe.dim = "";
  Qe.red = "";
  Qe.green = "";
  Qe.yellow = "";
  Qe.blue = "";
  Qe.magenta = "";
  Qe.cyan = "";
  Qe.white = "";
  Qe.grey = "";
  Qe.refresh();
});
var Wh = z((ve) => {
  "use strict";
  var eC = ve && ve.__createBinding || (Object.create ? function(r, e, t, n) {
    n === void 0 && (n = t);
    var o = Object.getOwnPropertyDescriptor(e, t);
    (!o || ("get" in o ? !e.__esModule : o.writable || o.configurable)) && (o = { enumerable: true, get: function() {
      return e[t];
    } }), Object.defineProperty(r, n, o);
  } : function(r, e, t, n) {
    n === void 0 && (n = t), r[n] = e[t];
  }), tC = ve && ve.__setModuleDefault || (Object.create ? function(r, e) {
    Object.defineProperty(r, "default", { enumerable: true, value: e });
  } : function(r, e) {
    r.default = e;
  }), $h = ve && ve.__importStar || /* @__PURE__ */ function() {
    var r = function(e) {
      return r = Object.getOwnPropertyNames || function(t) {
        var n = [];
        for (var o in t) Object.prototype.hasOwnProperty.call(t, o) && (n[n.length] = o);
        return n;
      }, r(e);
    };
    return function(e) {
      if (e && e.__esModule) return e;
      var t = {};
      if (e != null) for (var n = r(e), o = 0; o < n.length; o++) n[o] !== "default" && eC(t, e, n[o]);
      return tC(t, e), t;
    };
  }();
  Object.defineProperty(ve, "__esModule", { value: true });
  ve.env = ve.DebugLogBackendBase = ve.placeholder = ve.AdhocDebugLogger = ve.LogSeverity = void 0;
  ve.getNodeBackend = _u;
  ve.getDebugBackend = nC;
  ve.getStructuredBackend = sC;
  ve.setBackend = oC;
  ve.log = Gh;
  var rC = Y("events"), ps = $h(Y("process")), Hh = $h(Y("util")), dt = Mh(), jt;
  (function(r) {
    r.DEFAULT = "DEFAULT", r.DEBUG = "DEBUG", r.INFO = "INFO", r.WARNING = "WARNING", r.ERROR = "ERROR";
  })(jt || (ve.LogSeverity = jt = {}));
  var ms = class extends rC.EventEmitter {
    constructor(e, t) {
      super(), this.namespace = e, this.upstream = t, this.func = Object.assign(this.invoke.bind(this), { instance: this, on: (n, o) => this.on(n, o) }), this.func.debug = (...n) => this.invokeSeverity(jt.DEBUG, ...n), this.func.info = (...n) => this.invokeSeverity(jt.INFO, ...n), this.func.warn = (...n) => this.invokeSeverity(jt.WARNING, ...n), this.func.error = (...n) => this.invokeSeverity(jt.ERROR, ...n), this.func.sublog = (n) => Gh(n, this.func);
    }
    invoke(e, ...t) {
      if (this.upstream) try {
        this.upstream(e, ...t);
      } catch {
      }
      try {
        this.emit("log", e, t);
      } catch {
      }
    }
    invokeSeverity(e, ...t) {
      this.invoke({ severity: e }, ...t);
    }
  };
  ve.AdhocDebugLogger = ms;
  ve.placeholder = new ms("", () => {
  }).func;
  var On = class {
    constructor() {
      var e;
      this.cached = /* @__PURE__ */ new Map(), this.filters = [], this.filtersSet = false;
      let t = (e = ps.env[ve.env.nodeEnables]) !== null && e !== void 0 ? e : "*";
      t === "all" && (t = "*"), this.filters = t.split(",");
    }
    log(e, t, ...n) {
      try {
        this.filtersSet || (this.setFilters(), this.filtersSet = true);
        let o = this.cached.get(e);
        o || (o = this.makeLogger(e), this.cached.set(e, o)), o(t, ...n);
      } catch (o) {
        console.error(o);
      }
    }
  };
  ve.DebugLogBackendBase = On;
  var yu = class extends On {
    constructor() {
      super(...arguments), this.enabledRegexp = /.*/g;
    }
    isEnabled(e) {
      return this.enabledRegexp.test(e);
    }
    makeLogger(e) {
      return this.enabledRegexp.test(e) ? (t, ...n) => {
        var o;
        let a = `${dt.Colours.green}${e}${dt.Colours.reset}`, u = `${dt.Colours.yellow}${ps.pid}${dt.Colours.reset}`, l;
        switch (t.severity) {
          case jt.ERROR:
            l = `${dt.Colours.red}${t.severity}${dt.Colours.reset}`;
            break;
          case jt.INFO:
            l = `${dt.Colours.magenta}${t.severity}${dt.Colours.reset}`;
            break;
          case jt.WARNING:
            l = `${dt.Colours.yellow}${t.severity}${dt.Colours.reset}`;
            break;
          default:
            l = (o = t.severity) !== null && o !== void 0 ? o : jt.DEFAULT;
            break;
        }
        let f = Hh.formatWithOptions({ colors: dt.Colours.enabled }, ...n), d = Object.assign({}, t);
        delete d.severity;
        let h = Object.getOwnPropertyNames(d).length ? JSON.stringify(d) : "", C = h ? `${dt.Colours.grey}${h}${dt.Colours.reset}` : "";
        console.error("%s [%s|%s] %s%s", u, a, l, f, h ? ` ${C}` : "");
      } : () => {
      };
    }
    setFilters() {
      let t = this.filters.join(",").replace(/[|\\{}()[\]^$+?.]/g, "\\$&").replace(/\*/g, ".*").replace(/,/g, "$|^");
      this.enabledRegexp = new RegExp(`^${t}$`, "i");
    }
  };
  function _u() {
    return new yu();
  }
  var Cu = class extends On {
    constructor(e) {
      super(), this.debugPkg = e;
    }
    makeLogger(e) {
      let t = this.debugPkg(e);
      return (n, ...o) => {
        t(o[0], ...o.slice(1));
      };
    }
    setFilters() {
      var e;
      let t = (e = ps.env.NODE_DEBUG) !== null && e !== void 0 ? e : "";
      ps.env.NODE_DEBUG = `${t}${t ? "," : ""}${this.filters.join(",")}`;
    }
  };
  function nC(r) {
    return new Cu(r);
  }
  var bu = class extends On {
    constructor(e) {
      var t;
      super(), this.upstream = (t = e) !== null && t !== void 0 ? t : void 0;
    }
    makeLogger(e) {
      var t;
      let n = (t = this.upstream) === null || t === void 0 ? void 0 : t.makeLogger(e);
      return (o, ...a) => {
        var u;
        let l = (u = o.severity) !== null && u !== void 0 ? u : jt.INFO, f = Object.assign({ severity: l, message: Hh.format(...a) }, o), d = JSON.stringify(f);
        n ? n(o, d) : console.log("%s", d);
      };
    }
    setFilters() {
      var e;
      (e = this.upstream) === null || e === void 0 || e.setFilters();
    }
  };
  function sC(r) {
    return new bu(r);
  }
  ve.env = { nodeEnables: "GOOGLE_SDK_NODE_LOGGING" };
  var Eu = /* @__PURE__ */ new Map(), ht;
  function oC(r) {
    ht = r, Eu.clear();
  }
  function Gh(r, e) {
    if (!ht && !ps.env[ve.env.nodeEnables] || !r) return ve.placeholder;
    e && (r = `${e.instance.namespace}:${r}`);
    let t = Eu.get(r);
    if (t) return t.func;
    if (ht === null) return ve.placeholder;
    ht === void 0 && (ht = _u());
    let n = (() => {
      let o;
      return new ms(r, (u, ...l) => {
        if (o !== ht) {
          if (ht === null) return;
          ht === void 0 && (ht = _u()), o = ht;
        }
        ht?.log(r, u, ...l);
      });
    })();
    return Eu.set(r, n), n.func;
  }
});
var wu = z((en) => {
  "use strict";
  var iC = en && en.__createBinding || (Object.create ? function(r, e, t, n) {
    n === void 0 && (n = t);
    var o = Object.getOwnPropertyDescriptor(e, t);
    (!o || ("get" in o ? !e.__esModule : o.writable || o.configurable)) && (o = { enumerable: true, get: function() {
      return e[t];
    } }), Object.defineProperty(r, n, o);
  } : function(r, e, t, n) {
    n === void 0 && (n = t), r[n] = e[t];
  }), aC = en && en.__exportStar || function(r, e) {
    for (var t in r) t !== "default" && !Object.prototype.hasOwnProperty.call(e, t) && iC(e, r, t);
  };
  Object.defineProperty(en, "__esModule", { value: true });
  aC(Wh(), en);
});
var ys = z((ie) => {
  "use strict";
  var Jh = ie && ie.__createBinding || (Object.create ? function(r, e, t, n) {
    n === void 0 && (n = t);
    var o = Object.getOwnPropertyDescriptor(e, t);
    (!o || ("get" in o ? !e.__esModule : o.writable || o.configurable)) && (o = { enumerable: true, get: function() {
      return e[t];
    } }), Object.defineProperty(r, n, o);
  } : function(r, e, t, n) {
    n === void 0 && (n = t), r[n] = e[t];
  }), uC = ie && ie.__setModuleDefault || (Object.create ? function(r, e) {
    Object.defineProperty(r, "default", { enumerable: true, value: e });
  } : function(r, e) {
    r.default = e;
  }), cC = ie && ie.__importStar || /* @__PURE__ */ function() {
    var r = function(e) {
      return r = Object.getOwnPropertyNames || function(t) {
        var n = [];
        for (var o in t) Object.prototype.hasOwnProperty.call(t, o) && (n[n.length] = o);
        return n;
      }, r(e);
    };
    return function(e) {
      if (e && e.__esModule) return e;
      var t = {};
      if (e != null) for (var n = r(e), o = 0; o < n.length; o++) n[o] !== "default" && Jh(t, e, n[o]);
      return uC(t, e), t;
    };
  }(), lC = ie && ie.__exportStar || function(r, e) {
    for (var t in r) t !== "default" && !Object.prototype.hasOwnProperty.call(e, t) && Jh(e, r, t);
  };
  Object.defineProperty(ie, "__esModule", { value: true });
  ie.gcpResidencyCache = ie.METADATA_SERVER_DETECTION = ie.HEADERS = ie.HEADER_VALUE = ie.HEADER_NAME = ie.SECONDARY_HOST_ADDRESS = ie.HOST_ADDRESS = ie.BASE_PATH = void 0;
  ie.instance = gC;
  ie.project = yC;
  ie.universe = _C;
  ie.bulk = CC;
  ie.isAvailable = EC;
  ie.resetIsAvailableCache = wC;
  ie.getGCPResidency = Su;
  ie.setGCPResidency = Vh;
  ie.requestTimeout = Kh;
  var Au = Ve(), fC = Bh(), dC = gu(), hC = cC(wu());
  ie.BASE_PATH = "/computeMetadata/v1";
  ie.HOST_ADDRESS = "http://169.254.169.254";
  ie.SECONDARY_HOST_ADDRESS = "http://metadata.google.internal.";
  ie.HEADER_NAME = "Metadata-Flavor";
  ie.HEADER_VALUE = "Google";
  ie.HEADERS = Object.freeze({ [ie.HEADER_NAME]: ie.HEADER_VALUE });
  var zh = hC.log("gcp-metadata");
  ie.METADATA_SERVER_DETECTION = Object.freeze({ "assume-present": "don't try to ping the metadata server, but assume it's present", none: "don't try to ping the metadata server, but don't try to use it either", "bios-only": "treat the result of a BIOS probe as canonical (don't fall back to pinging)", "ping-only": "skip the BIOS probe, and go straight to pinging" });
  function Du(r) {
    return r || (r = process.env.GCE_METADATA_IP || process.env.GCE_METADATA_HOST || ie.HOST_ADDRESS), /^https?:\/\//.test(r) || (r = `http://${r}`), new URL(ie.BASE_PATH, r).href;
  }
  function pC(r) {
    Object.keys(r).forEach((e) => {
      switch (e) {
        case "params":
        case "property":
        case "headers":
          break;
        case "qs":
          throw new Error("'qs' is not a valid configuration option. Please use 'params' instead.");
        default:
          throw new Error(`'${e}' is not a valid configuration option.`);
      }
    });
  }
  async function gs(r, e = {}, t = 3, n = false) {
    let o = new Headers(ie.HEADERS), a = "", u = {};
    if (typeof r == "object") {
      let C = r;
      new Headers(C.headers).forEach((w, I) => o.set(I, w)), a = C.metadataKey, u = C.params || u, t = C.noResponseRetries || t, n = C.fastFail || n;
    } else a = r;
    typeof e == "string" ? a += `/${e}` : (pC(e), e.property && (a += `/${e.property}`), new Headers(e.headers).forEach((C, w) => o.set(w, C)), u = e.params || u);
    let l = n ? mC : Au.request, f = { url: `${Du()}/${a}`, headers: o, retryConfig: { noResponseRetries: t }, params: u, responseType: "text", timeout: Kh() };
    zh.info("instance request %j", f);
    let d = await l(f);
    zh.info("instance metadata is %s", d.data);
    let h = d.headers.get(ie.HEADER_NAME);
    if (h !== ie.HEADER_VALUE) throw new RangeError(`Invalid response from metadata service: incorrect ${ie.HEADER_NAME} header. Expected '${ie.HEADER_VALUE}', got ${h ? `'${h}'` : "no header"}`);
    if (typeof d.data == "string") try {
      return fC.parse(d.data);
    } catch {
    }
    return d.data;
  }
  async function mC(r) {
    let e = { ...r, url: r.url?.toString().replace(Du(), Du(ie.SECONDARY_HOST_ADDRESS)) }, t = (0, Au.request)(r), n = (0, Au.request)(e);
    return Promise.any([t, n]);
  }
  function gC(r) {
    return gs("instance", r);
  }
  function yC(r) {
    return gs("project", r);
  }
  function _C(r) {
    return gs("universe", r);
  }
  async function CC(r) {
    let e = {};
    return await Promise.all(r.map((t) => (async () => {
      let n = await gs(t), o = t.metadataKey;
      e[o] = n;
    })())), e;
  }
  function bC() {
    return process.env.DETECT_GCP_RETRIES ? Number(process.env.DETECT_GCP_RETRIES) : 0;
  }
  var Qo;
  async function EC() {
    if (process.env.METADATA_SERVER_DETECTION) {
      let r = process.env.METADATA_SERVER_DETECTION.trim().toLocaleLowerCase();
      if (!(r in ie.METADATA_SERVER_DETECTION)) throw new RangeError(`Unknown \`METADATA_SERVER_DETECTION\` env variable. Got \`${r}\`, but it should be \`${Object.keys(ie.METADATA_SERVER_DETECTION).join("`, `")}\`, or unset`);
      switch (r) {
        case "assume-present":
          return true;
        case "none":
          return false;
        case "bios-only":
          return Su();
        case "ping-only":
      }
    }
    try {
      return Qo === void 0 && (Qo = gs("instance", void 0, bC(), !(process.env.GCE_METADATA_IP || process.env.GCE_METADATA_HOST))), await Qo, true;
    } catch (r) {
      let e = r;
      if (process.env.DEBUG_AUTH && console.info(e), e.type === "request-timeout" || e.response && e.response.status === 404) return false;
      if (!(e.response && e.response.status === 404) && (!e.code || !["EHOSTDOWN", "EHOSTUNREACH", "ENETUNREACH", "ENOENT", "ENOTFOUND", "ECONNREFUSED"].includes(e.code.toString()))) {
        let t = "UNKNOWN";
        e.code && (t = e.code.toString()), process.emitWarning(`received unexpected error = ${e.message} code = ${t}`, "MetadataLookupWarning");
      }
      return false;
    }
  }
  function wC() {
    Qo = void 0;
  }
  ie.gcpResidencyCache = null;
  function Su() {
    return ie.gcpResidencyCache === null && Vh(), ie.gcpResidencyCache;
  }
  function Vh(r = null) {
    ie.gcpResidencyCache = r !== null ? r : (0, dC.detectGCPResidency)();
  }
  function Kh() {
    return Su() ? 0 : 3e3;
  }
  lC(gu(), ie);
});
var Qh = z((Zo) => {
  "use strict";
  Zo.byteLength = DC;
  Zo.toByteArray = vC;
  Zo.fromByteArray = FC;
  var Vt = [], St = [], AC = typeof Uint8Array < "u" ? Uint8Array : Array, vu = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
  for (tn = 0, Yh = vu.length; tn < Yh; ++tn) Vt[tn] = vu[tn], St[vu.charCodeAt(tn)] = tn;
  var tn, Yh;
  St[45] = 62;
  St[95] = 63;
  function Xh(r) {
    var e = r.length;
    if (e % 4 > 0) throw new Error("Invalid string. Length must be a multiple of 4");
    var t = r.indexOf("=");
    t === -1 && (t = e);
    var n = t === e ? 0 : 4 - t % 4;
    return [t, n];
  }
  function DC(r) {
    var e = Xh(r), t = e[0], n = e[1];
    return (t + n) * 3 / 4 - n;
  }
  function SC(r, e, t) {
    return (e + t) * 3 / 4 - t;
  }
  function vC(r) {
    var e, t = Xh(r), n = t[0], o = t[1], a = new AC(SC(r, n, o)), u = 0, l = o > 0 ? n - 4 : n, f;
    for (f = 0; f < l; f += 4) e = St[r.charCodeAt(f)] << 18 | St[r.charCodeAt(f + 1)] << 12 | St[r.charCodeAt(f + 2)] << 6 | St[r.charCodeAt(f + 3)], a[u++] = e >> 16 & 255, a[u++] = e >> 8 & 255, a[u++] = e & 255;
    return o === 2 && (e = St[r.charCodeAt(f)] << 2 | St[r.charCodeAt(f + 1)] >> 4, a[u++] = e & 255), o === 1 && (e = St[r.charCodeAt(f)] << 10 | St[r.charCodeAt(f + 1)] << 4 | St[r.charCodeAt(f + 2)] >> 2, a[u++] = e >> 8 & 255, a[u++] = e & 255), a;
  }
  function TC(r) {
    return Vt[r >> 18 & 63] + Vt[r >> 12 & 63] + Vt[r >> 6 & 63] + Vt[r & 63];
  }
  function RC(r, e, t) {
    for (var n, o = [], a = e; a < t; a += 3) n = (r[a] << 16 & 16711680) + (r[a + 1] << 8 & 65280) + (r[a + 2] & 255), o.push(TC(n));
    return o.join("");
  }
  function FC(r) {
    for (var e, t = r.length, n = t % 3, o = [], a = 16383, u = 0, l = t - n; u < l; u += a) o.push(RC(r, u, u + a > l ? l : u + a));
    return n === 1 ? (e = r[t - 1], o.push(Vt[e >> 2] + Vt[e << 4 & 63] + "==")) : n === 2 && (e = (r[t - 2] << 8) + r[t - 1], o.push(Vt[e >> 10] + Vt[e >> 4 & 63] + Vt[e << 2 & 63] + "=")), o.join("");
  }
});
var Ru = z((Tu) => {
  "use strict";
  Object.defineProperty(Tu, "__esModule", { value: true });
  Tu.fromArrayBufferToHex = kC;
  function kC(r) {
    return Array.from(new Uint8Array(r)).map((t) => t.toString(16).padStart(2, "0")).join("");
  }
});
var Zh = z((ei) => {
  "use strict";
  Object.defineProperty(ei, "__esModule", { value: true });
  ei.BrowserCrypto = void 0;
  var Pn = Qh(), OC = Ru(), Fu = class r {
    constructor() {
      if (typeof window > "u" || window.crypto === void 0 || window.crypto.subtle === void 0) throw new Error("SubtleCrypto not found. Make sure it's an https:// website.");
    }
    async sha256DigestBase64(e) {
      let t = new TextEncoder().encode(e), n = await window.crypto.subtle.digest("SHA-256", t);
      return Pn.fromByteArray(new Uint8Array(n));
    }
    randomBytesBase64(e) {
      let t = new Uint8Array(e);
      return window.crypto.getRandomValues(t), Pn.fromByteArray(t);
    }
    static padBase64(e) {
      for (; e.length % 4 !== 0; ) e += "=";
      return e;
    }
    async verify(e, t, n) {
      let o = { name: "RSASSA-PKCS1-v1_5", hash: { name: "SHA-256" } }, a = new TextEncoder().encode(t), u = Pn.toByteArray(r.padBase64(n)), l = await window.crypto.subtle.importKey("jwk", e, o, true, ["verify"]);
      return await window.crypto.subtle.verify(o, l, u, a);
    }
    async sign(e, t) {
      let n = { name: "RSASSA-PKCS1-v1_5", hash: { name: "SHA-256" } }, o = new TextEncoder().encode(t), a = await window.crypto.subtle.importKey("jwk", e, n, true, ["sign"]), u = await window.crypto.subtle.sign(n, a, o);
      return Pn.fromByteArray(new Uint8Array(u));
    }
    decodeBase64StringUtf8(e) {
      let t = Pn.toByteArray(r.padBase64(e));
      return new TextDecoder().decode(t);
    }
    encodeBase64StringUtf8(e) {
      let t = new TextEncoder().encode(e);
      return Pn.fromByteArray(t);
    }
    async sha256DigestHex(e) {
      let t = new TextEncoder().encode(e), n = await window.crypto.subtle.digest("SHA-256", t);
      return (0, OC.fromArrayBufferToHex)(n);
    }
    async signWithHmacSha256(e, t) {
      let n = typeof e == "string" ? e : String.fromCharCode(...new Uint16Array(e)), o = new TextEncoder(), a = await window.crypto.subtle.importKey("raw", o.encode(n), { name: "HMAC", hash: { name: "SHA-256" } }, false, ["sign"]);
      return window.crypto.subtle.sign("HMAC", a, o.encode(t));
    }
  };
  ei.BrowserCrypto = Fu;
});
var ep = z((ti) => {
  "use strict";
  Object.defineProperty(ti, "__esModule", { value: true });
  ti.NodeCrypto = void 0;
  var xn = Y("crypto"), ku = class {
    async sha256DigestBase64(e) {
      return xn.createHash("sha256").update(e).digest("base64");
    }
    randomBytesBase64(e) {
      return xn.randomBytes(e).toString("base64");
    }
    async verify(e, t, n) {
      let o = xn.createVerify("RSA-SHA256");
      return o.update(t), o.end(), o.verify(e, n, "base64");
    }
    async sign(e, t) {
      let n = xn.createSign("RSA-SHA256");
      return n.update(t), n.end(), n.sign(e, "base64");
    }
    decodeBase64StringUtf8(e) {
      return Buffer.from(e, "base64").toString("utf-8");
    }
    encodeBase64StringUtf8(e) {
      return Buffer.from(e, "utf-8").toString("base64");
    }
    async sha256DigestHex(e) {
      return xn.createHash("sha256").update(e).digest("hex");
    }
    async signWithHmacSha256(e, t) {
      let n = typeof e == "string" ? e : xC(e);
      return PC(xn.createHmac("sha256", n).update(t).digest());
    }
  };
  ti.NodeCrypto = ku;
  function PC(r) {
    return r.buffer.slice(r.byteOffset, r.byteOffset + r.byteLength);
  }
  function xC(r) {
    return Buffer.from(r);
  }
});
var _s = z((hr) => {
  "use strict";
  var BC = hr && hr.__createBinding || (Object.create ? function(r, e, t, n) {
    n === void 0 && (n = t);
    var o = Object.getOwnPropertyDescriptor(e, t);
    (!o || ("get" in o ? !e.__esModule : o.writable || o.configurable)) && (o = { enumerable: true, get: function() {
      return e[t];
    } }), Object.defineProperty(r, n, o);
  } : function(r, e, t, n) {
    n === void 0 && (n = t), r[n] = e[t];
  }), IC = hr && hr.__exportStar || function(r, e) {
    for (var t in r) t !== "default" && !Object.prototype.hasOwnProperty.call(e, t) && BC(e, r, t);
  };
  Object.defineProperty(hr, "__esModule", { value: true });
  hr.createCrypto = jC;
  hr.hasBrowserCrypto = tp;
  var NC = Zh(), qC = ep();
  IC(Ru(), hr);
  function jC() {
    return tp() ? new NC.BrowserCrypto() : new qC.NodeCrypto();
  }
  function tp() {
    return typeof window < "u" && typeof window.crypto < "u" && typeof window.crypto.subtle < "u";
  }
});
var Bn = z((Ou, np) => {
  var ri = Y("buffer"), Kt = ri.Buffer;
  function rp(r, e) {
    for (var t in r) e[t] = r[t];
  }
  Kt.from && Kt.alloc && Kt.allocUnsafe && Kt.allocUnsafeSlow ? np.exports = ri : (rp(ri, Ou), Ou.Buffer = rn);
  function rn(r, e, t) {
    return Kt(r, e, t);
  }
  rn.prototype = Object.create(Kt.prototype);
  rp(Kt, rn);
  rn.from = function(r, e, t) {
    if (typeof r == "number") throw new TypeError("Argument must not be a number");
    return Kt(r, e, t);
  };
  rn.alloc = function(r, e, t) {
    if (typeof r != "number") throw new TypeError("Argument must be a number");
    var n = Kt(r);
    return e !== void 0 ? typeof t == "string" ? n.fill(e, t) : n.fill(e) : n.fill(0), n;
  };
  rn.allocUnsafe = function(r) {
    if (typeof r != "number") throw new TypeError("Argument must be a number");
    return Kt(r);
  };
  rn.allocUnsafeSlow = function(r) {
    if (typeof r != "number") throw new TypeError("Argument must be a number");
    return ri.SlowBuffer(r);
  };
});
var op = z((IS, sp) => {
  "use strict";
  function Pu(r) {
    var e = (r / 8 | 0) + (r % 8 === 0 ? 0 : 1);
    return e;
  }
  var LC = { ES256: Pu(256), ES384: Pu(384), ES512: Pu(521) };
  function UC(r) {
    var e = LC[r];
    if (e) return e;
    throw new Error('Unknown algorithm "' + r + '"');
  }
  sp.exports = UC;
});
var xu = z((NS, fp) => {
  "use strict";
  var ni = Bn().Buffer, ap = op(), si = 128, up = 0, MC = 32, $C = 16, HC = 2, cp = $C | MC | up << 6, oi = HC | up << 6;
  function GC(r) {
    return r.replace(/=/g, "").replace(/\+/g, "-").replace(/\//g, "_");
  }
  function lp(r) {
    if (ni.isBuffer(r)) return r;
    if (typeof r == "string") return ni.from(r, "base64");
    throw new TypeError("ECDSA signature must be a Base64 string or a Buffer");
  }
  function WC(r, e) {
    r = lp(r);
    var t = ap(e), n = t + 1, o = r.length, a = 0;
    if (r[a++] !== cp) throw new Error('Could not find expected "seq"');
    var u = r[a++];
    if (u === (si | 1) && (u = r[a++]), o - a < u) throw new Error('"seq" specified length of "' + u + '", only "' + (o - a) + '" remaining');
    if (r[a++] !== oi) throw new Error('Could not find expected "int" for "r"');
    var l = r[a++];
    if (o - a - 2 < l) throw new Error('"r" specified length of "' + l + '", only "' + (o - a - 2) + '" available');
    if (n < l) throw new Error('"r" specified length of "' + l + '", max of "' + n + '" is acceptable');
    var f = a;
    if (a += l, r[a++] !== oi) throw new Error('Could not find expected "int" for "s"');
    var d = r[a++];
    if (o - a !== d) throw new Error('"s" specified length of "' + d + '", expected "' + (o - a) + '"');
    if (n < d) throw new Error('"s" specified length of "' + d + '", max of "' + n + '" is acceptable');
    var h = a;
    if (a += d, a !== o) throw new Error('Expected to consume entire buffer, but "' + (o - a) + '" bytes remain');
    var C = t - l, w = t - d, I = ni.allocUnsafe(C + l + w + d);
    for (a = 0; a < C; ++a) I[a] = 0;
    r.copy(I, a, f + Math.max(-C, 0), f + l), a = t;
    for (var S = a; a < S + w; ++a) I[a] = 0;
    return r.copy(I, a, h + Math.max(-w, 0), h + d), I = I.toString("base64"), I = GC(I), I;
  }
  function ip(r, e, t) {
    for (var n = 0; e + n < t && r[e + n] === 0; ) ++n;
    var o = r[e + n] >= si;
    return o && --n, n;
  }
  function zC(r, e) {
    r = lp(r);
    var t = ap(e), n = r.length;
    if (n !== t * 2) throw new TypeError('"' + e + '" signatures must be "' + t * 2 + '" bytes, saw "' + n + '"');
    var o = ip(r, 0, t), a = ip(r, t, r.length), u = t - o, l = t - a, f = 2 + u + 1 + 1 + l, d = f < si, h = ni.allocUnsafe((d ? 2 : 3) + f), C = 0;
    return h[C++] = cp, d ? h[C++] = f : (h[C++] = si | 1, h[C++] = f & 255), h[C++] = oi, h[C++] = u, o < 0 ? (h[C++] = 0, C += r.copy(h, C, 0, t)) : C += r.copy(h, C, o, t), h[C++] = oi, h[C++] = l, a < 0 ? (h[C++] = 0, r.copy(h, C, t)) : r.copy(h, C, t + a), h;
  }
  fp.exports = { derToJose: WC, joseToDer: zC };
});
var Lt = z((pr) => {
  "use strict";
  Object.defineProperty(pr, "__esModule", { value: true });
  pr.LRUCache = void 0;
  pr.snakeToCamel = hp;
  pr.originalOrCamelOptions = YC;
  pr.removeUndefinedValuesInObject = XC;
  pr.isValidFile = QC;
  pr.getWellKnownCertificateConfigFileLocation = ZC;
  var JC = Y("fs"), VC = Y("os"), Bu = Y("path"), KC = "certificate_config.json", dp = "gcloud";
  function hp(r) {
    return r.replace(/([_][^_])/g, (e) => e.slice(1).toUpperCase());
  }
  function YC(r) {
    function e(t) {
      let n = r || {};
      return n[t] ?? n[hp(t)];
    }
    return { get: e };
  }
  var Iu = class {
    capacity;
    #e = /* @__PURE__ */ new Map();
    maxAge;
    constructor(e) {
      this.capacity = e.capacity, this.maxAge = e.maxAge;
    }
    #t(e, t) {
      this.#e.delete(e), this.#e.set(e, { value: t, lastAccessed: Date.now() });
    }
    set(e, t) {
      this.#t(e, t), this.#r();
    }
    get(e) {
      let t = this.#e.get(e);
      if (t) return this.#t(e, t.value), this.#r(), t.value;
    }
    #r() {
      let e = this.maxAge ? Date.now() - this.maxAge : 0, t = this.#e.entries().next();
      for (; !t.done && (this.#e.size > this.capacity || t.value[1].lastAccessed < e); ) this.#e.delete(t.value[0]), t = this.#e.entries().next();
    }
  };
  pr.LRUCache = Iu;
  function XC(r) {
    return Object.entries(r).forEach(([e, t]) => {
      (t === void 0 || t === "undefined") && delete r[e];
    }), r;
  }
  async function QC(r) {
    try {
      return (await JC.promises.lstat(r)).isFile();
    } catch {
      return false;
    }
  }
  function ZC() {
    let r = process.env.CLOUDSDK_CONFIG || (eb() ? Bu.join(process.env.APPDATA || "", dp) : Bu.join(process.env.HOME || "", ".config", dp));
    return Bu.join(r, KC);
  }
  function eb() {
    return VC.platform().startsWith("win");
  }
});
var pp = z((jS, tb) => {
  tb.exports = { name: "google-auth-library", version: "10.2.0", author: "Google Inc.", description: "Google APIs Authentication Client Library for Node.js", engines: { node: ">=18" }, main: "./build/src/index.js", types: "./build/src/index.d.ts", repository: "googleapis/google-auth-library-nodejs.git", keywords: ["google", "api", "google apis", "client", "client library"], dependencies: { "base64-js": "^1.3.0", "ecdsa-sig-formatter": "^1.0.11", gaxios: "^7.0.0", "gcp-metadata": "^7.0.0", "google-logging-utils": "^1.0.0", gtoken: "^8.0.0", jws: "^4.0.0" }, devDependencies: { "@types/base64-js": "^1.2.5", "@types/jws": "^3.1.0", "@types/mocha": "^10.0.10", "@types/mv": "^2.1.0", "@types/ncp": "^2.0.1", "@types/node": "^22.0.0", "@types/sinon": "^17.0.0", "assert-rejects": "^1.0.0", c8: "^10.0.0", codecov: "^3.0.2", gts: "^6.0.0", "is-docker": "^3.0.0", jsdoc: "^4.0.0", "jsdoc-fresh": "^4.0.0", "jsdoc-region-tag": "^3.0.0", karma: "^6.0.0", "karma-chrome-launcher": "^3.0.0", "karma-coverage": "^2.0.0", "karma-firefox-launcher": "^2.0.0", "karma-mocha": "^2.0.0", "karma-sourcemap-loader": "^0.4.0", "karma-webpack": "^5.0.1", keypair: "^1.0.4", linkinator: "^6.1.2", mocha: "^11.1.0", mv: "^2.1.1", ncp: "^2.0.0", nock: "^14.0.1", "null-loader": "^4.0.0", puppeteer: "^24.0.0", sinon: "^21.0.0", "ts-loader": "^8.0.0", typescript: "^5.1.6", webpack: "^5.21.2", "webpack-cli": "^4.0.0" }, files: ["build/src", "!build/src/**/*.map"], scripts: { test: "c8 mocha build/test", clean: "gts clean", prepare: "npm run compile", lint: "gts check --no-inline-config", compile: "tsc -p .", fix: "gts fix", pretest: "npm run compile -- --sourceMap", docs: "jsdoc -c .jsdoc.js", "samples-setup": "cd samples/ && npm link ../ && npm run setup && cd ../", "samples-test": "cd samples/ && npm link ../ && npm test && cd ../", "system-test": "mocha build/system-test --timeout 60000", "presystem-test": "npm run compile -- --sourceMap", webpack: "webpack", "browser-test": "karma start", "docs-test": "linkinator docs", "predocs-test": "npm run docs", prelint: "cd samples; npm link ../; npm install" }, license: "Apache-2.0" };
});
var Nu = z((Br) => {
  "use strict";
  Object.defineProperty(Br, "__esModule", { value: true });
  Br.USER_AGENT = Br.PRODUCT_NAME = Br.pkg = void 0;
  var mp = pp();
  Br.pkg = mp;
  var gp = "google-api-nodejs-client";
  Br.PRODUCT_NAME = gp;
  var rb = `${gp}/${mp.version}`;
  Br.USER_AGENT = rb;
});
var pt = z((Ut) => {
  "use strict";
  Object.defineProperty(Ut, "__esModule", { value: true });
  Ut.AuthClient = Ut.DEFAULT_EAGER_REFRESH_THRESHOLD_MILLIS = Ut.DEFAULT_UNIVERSE = void 0;
  var nb = Y("events"), qu = Ve(), sb = Lt(), ob = wu(), ju = Nu();
  Ut.DEFAULT_UNIVERSE = "googleapis.com";
  Ut.DEFAULT_EAGER_REFRESH_THRESHOLD_MILLIS = 5 * 60 * 1e3;
  var Lu = class r extends nb.EventEmitter {
    apiKey;
    projectId;
    quotaProjectId;
    transporter;
    credentials = {};
    eagerRefreshThresholdMillis = Ut.DEFAULT_EAGER_REFRESH_THRESHOLD_MILLIS;
    forceRefreshOnFailure = false;
    universeDomain = Ut.DEFAULT_UNIVERSE;
    static RequestMethodNameSymbol = Symbol("request method name");
    static RequestLogIdSymbol = Symbol("request log id");
    constructor(e = {}) {
      super();
      let t = (0, sb.originalOrCamelOptions)(e);
      this.apiKey = e.apiKey, this.projectId = t.get("project_id") ?? null, this.quotaProjectId = t.get("quota_project_id"), this.credentials = t.get("credentials") ?? {}, this.universeDomain = t.get("universe_domain") ?? Ut.DEFAULT_UNIVERSE, this.transporter = e.transporter ?? new qu.Gaxios(e.transporterOptions), t.get("useAuthRequestParameters") !== false && (this.transporter.interceptors.request.add(r.DEFAULT_REQUEST_INTERCEPTOR), this.transporter.interceptors.response.add(r.DEFAULT_RESPONSE_INTERCEPTOR)), e.eagerRefreshThresholdMillis && (this.eagerRefreshThresholdMillis = e.eagerRefreshThresholdMillis), this.forceRefreshOnFailure = e.forceRefreshOnFailure ?? false;
    }
    fetch(...e) {
      let t = e[0], n = e[1], o, a = new Headers();
      return typeof t == "string" ? o = new URL(t) : t instanceof URL ? o = t : t && t.url && (o = new URL(t.url)), t && typeof t == "object" && "headers" in t && qu.Gaxios.mergeHeaders(a, t.headers), n && qu.Gaxios.mergeHeaders(a, new Headers(n.headers)), typeof t == "object" && !(t instanceof URL) ? this.request({ ...n, ...t, headers: a, url: o }) : this.request({ ...n, headers: a, url: o });
    }
    setCredentials(e) {
      this.credentials = e;
    }
    addSharedMetadataHeaders(e) {
      return !e.has("x-goog-user-project") && this.quotaProjectId && e.set("x-goog-user-project", this.quotaProjectId), e;
    }
    addUserProjectAndAuthHeaders(e, t) {
      let n = t.get("x-goog-user-project"), o = t.get("authorization");
      return n && e.set("x-goog-user-project", n), o && e.set("authorization", o), e;
    }
    static log = (0, ob.log)("auth");
    static DEFAULT_REQUEST_INTERCEPTOR = { resolved: async (e) => {
      if (!e.headers.has("x-goog-api-client")) {
        let n = process.version.replace(/^v/, "");
        e.headers.set("x-goog-api-client", `gl-node/${n}`);
      }
      let t = e.headers.get("User-Agent");
      t ? t.includes(`${ju.PRODUCT_NAME}/`) || e.headers.set("User-Agent", `${t} ${ju.USER_AGENT}`) : e.headers.set("User-Agent", ju.USER_AGENT);
      try {
        let n = e, o = n[r.RequestMethodNameSymbol], a = `${Math.floor(Math.random() * 1e3)}`;
        n[r.RequestLogIdSymbol] = a;
        let u = { url: e.url, headers: e.headers };
        o ? r.log.info("%s [%s] request %j", o, a, u) : r.log.info("[%s] request %j", a, u);
      } catch {
      }
      return e;
    } };
    static DEFAULT_RESPONSE_INTERCEPTOR = { resolved: async (e) => {
      try {
        let t = e.config, n = t[r.RequestMethodNameSymbol], o = t[r.RequestLogIdSymbol];
        n ? r.log.info("%s [%s] response %j", n, o, e.data) : r.log.info("[%s] response %j", o, e.data);
      } catch {
      }
      return e;
    }, rejected: async (e) => {
      try {
        let t = e.config, n = t[r.RequestMethodNameSymbol], o = t[r.RequestLogIdSymbol];
        n ? r.log.info("%s [%s] error %j", n, o, e.response?.data) : r.log.error("[%s] error %j", o, e.response?.data);
      } catch {
      }
      throw e;
    } };
    static setMethodName(e, t) {
      try {
        let n = e;
        n[r.RequestMethodNameSymbol] = t;
      } catch {
      }
    }
    static get RETRY_CONFIG() {
      return { retry: true, retryConfig: { httpMethodsToRetry: ["GET", "PUT", "POST", "HEAD", "OPTIONS", "DELETE"] } };
    }
  };
  Ut.AuthClient = Lu;
});
var Mu = z((ii) => {
  "use strict";
  Object.defineProperty(ii, "__esModule", { value: true });
  ii.LoginTicket = void 0;
  var Uu = class {
    envelope;
    payload;
    constructor(e, t) {
      this.envelope = e, this.payload = t;
    }
    getEnvelope() {
      return this.envelope;
    }
    getPayload() {
      return this.payload;
    }
    getUserId() {
      let e = this.getPayload();
      return e && e.sub ? e.sub : null;
    }
    getAttributes() {
      return { envelope: this.getEnvelope(), payload: this.getPayload() };
    }
  };
  ii.LoginTicket = Uu;
});
var nn = z((Yt) => {
  "use strict";
  Object.defineProperty(Yt, "__esModule", { value: true });
  Yt.OAuth2Client = Yt.ClientAuthentication = Yt.CertificateFormat = Yt.CodeChallengeMethod = void 0;
  var yp = Ve(), ib = Y("querystring"), ab = Y("stream"), ub = xu(), _p = Lt(), $u = _s(), In = pt(), cb = Mu(), Cp;
  (function(r) {
    r.Plain = "plain", r.S256 = "S256";
  })(Cp || (Yt.CodeChallengeMethod = Cp = {}));
  var mr;
  (function(r) {
    r.PEM = "PEM", r.JWK = "JWK";
  })(mr || (Yt.CertificateFormat = mr = {}));
  var Cs;
  (function(r) {
    r.ClientSecretPost = "ClientSecretPost", r.ClientSecretBasic = "ClientSecretBasic", r.None = "None";
  })(Cs || (Yt.ClientAuthentication = Cs = {}));
  var Hu = class r extends In.AuthClient {
    redirectUri;
    certificateCache = {};
    certificateExpiry = null;
    certificateCacheFormat = mr.PEM;
    refreshTokenPromises = /* @__PURE__ */ new Map();
    endpoints;
    issuers;
    clientAuthentication;
    _clientId;
    _clientSecret;
    refreshHandler;
    constructor(e = {}, t, n) {
      super(typeof e == "object" ? e : {}), typeof e != "object" && (e = { clientId: e, clientSecret: t, redirectUri: n }), this._clientId = e.clientId || e.client_id, this._clientSecret = e.clientSecret || e.client_secret, this.redirectUri = e.redirectUri || e.redirect_uris?.[0], this.endpoints = { tokenInfoUrl: "https://oauth2.googleapis.com/tokeninfo", oauth2AuthBaseUrl: "https://accounts.google.com/o/oauth2/v2/auth", oauth2TokenUrl: "https://oauth2.googleapis.com/token", oauth2RevokeUrl: "https://oauth2.googleapis.com/revoke", oauth2FederatedSignonPemCertsUrl: "https://www.googleapis.com/oauth2/v1/certs", oauth2FederatedSignonJwkCertsUrl: "https://www.googleapis.com/oauth2/v3/certs", oauth2IapPublicKeyUrl: "https://www.gstatic.com/iap/verify/public_key", ...e.endpoints }, this.clientAuthentication = e.clientAuthentication || Cs.ClientSecretPost, this.issuers = e.issuers || ["accounts.google.com", "https://accounts.google.com", this.universeDomain];
    }
    static GOOGLE_TOKEN_INFO_URL = "https://oauth2.googleapis.com/tokeninfo";
    static CLOCK_SKEW_SECS_ = 300;
    static DEFAULT_MAX_TOKEN_LIFETIME_SECS_ = 86400;
    generateAuthUrl(e = {}) {
      if (e.code_challenge_method && !e.code_challenge) throw new Error("If a code_challenge_method is provided, code_challenge must be included.");
      return e.response_type = e.response_type || "code", e.client_id = e.client_id || this._clientId, e.redirect_uri = e.redirect_uri || this.redirectUri, Array.isArray(e.scope) && (e.scope = e.scope.join(" ")), this.endpoints.oauth2AuthBaseUrl.toString() + "?" + ib.stringify(e);
    }
    generateCodeVerifier() {
      throw new Error("generateCodeVerifier is removed, please use generateCodeVerifierAsync instead.");
    }
    async generateCodeVerifierAsync() {
      let e = (0, $u.createCrypto)(), n = e.randomBytesBase64(96).replace(/\+/g, "~").replace(/=/g, "_").replace(/\//g, "-"), a = (await e.sha256DigestBase64(n)).split("=")[0].replace(/\+/g, "-").replace(/\//g, "_");
      return { codeVerifier: n, codeChallenge: a };
    }
    getToken(e, t) {
      let n = typeof e == "string" ? { code: e } : e;
      if (t) this.getTokenAsync(n).then((o) => t(null, o.tokens, o.res), (o) => t(o, null, o.response));
      else return this.getTokenAsync(n);
    }
    async getTokenAsync(e) {
      let t = this.endpoints.oauth2TokenUrl.toString(), n = new Headers(), o = { client_id: e.client_id || this._clientId, code_verifier: e.codeVerifier, code: e.code, grant_type: "authorization_code", redirect_uri: e.redirect_uri || this.redirectUri };
      if (this.clientAuthentication === Cs.ClientSecretBasic) {
        let f = Buffer.from(`${this._clientId}:${this._clientSecret}`);
        n.set("authorization", `Basic ${f.toString("base64")}`);
      }
      this.clientAuthentication === Cs.ClientSecretPost && (o.client_secret = this._clientSecret);
      let a = { ...r.RETRY_CONFIG, method: "POST", url: t, data: new URLSearchParams((0, _p.removeUndefinedValuesInObject)(o)), headers: n };
      In.AuthClient.setMethodName(a, "getTokenAsync");
      let u = await this.transporter.request(a), l = u.data;
      return u.data && u.data.expires_in && (l.expiry_date = (/* @__PURE__ */ new Date()).getTime() + u.data.expires_in * 1e3, delete l.expires_in), this.emit("tokens", l), { tokens: l, res: u };
    }
    async refreshToken(e) {
      if (!e) return this.refreshTokenNoCache(e);
      if (this.refreshTokenPromises.has(e)) return this.refreshTokenPromises.get(e);
      let t = this.refreshTokenNoCache(e).then((n) => (this.refreshTokenPromises.delete(e), n), (n) => {
        throw this.refreshTokenPromises.delete(e), n;
      });
      return this.refreshTokenPromises.set(e, t), t;
    }
    async refreshTokenNoCache(e) {
      if (!e) throw new Error("No refresh token is set.");
      let t = this.endpoints.oauth2TokenUrl.toString(), n = { refresh_token: e, client_id: this._clientId, client_secret: this._clientSecret, grant_type: "refresh_token" }, o;
      try {
        let u = { ...r.RETRY_CONFIG, method: "POST", url: t, data: new URLSearchParams((0, _p.removeUndefinedValuesInObject)(n)) };
        In.AuthClient.setMethodName(u, "refreshTokenNoCache"), o = await this.transporter.request(u);
      } catch (u) {
        throw u instanceof yp.GaxiosError && u.message === "invalid_grant" && u.response?.data && /ReAuth/i.test(u.response.data.error_description) && (u.message = JSON.stringify(u.response.data)), u;
      }
      let a = o.data;
      return o.data && o.data.expires_in && (a.expiry_date = (/* @__PURE__ */ new Date()).getTime() + o.data.expires_in * 1e3, delete a.expires_in), this.emit("tokens", a), { tokens: a, res: o };
    }
    refreshAccessToken(e) {
      if (e) this.refreshAccessTokenAsync().then((t) => e(null, t.credentials, t.res), e);
      else return this.refreshAccessTokenAsync();
    }
    async refreshAccessTokenAsync() {
      let e = await this.refreshToken(this.credentials.refresh_token), t = e.tokens;
      return t.refresh_token = this.credentials.refresh_token, this.credentials = t, { credentials: this.credentials, res: e.res };
    }
    getAccessToken(e) {
      if (e) this.getAccessTokenAsync().then((t) => e(null, t.token, t.res), e);
      else return this.getAccessTokenAsync();
    }
    async getAccessTokenAsync() {
      if (!this.credentials.access_token || this.isTokenExpiring()) {
        if (!this.credentials.refresh_token) if (this.refreshHandler) {
          let n = await this.processAndValidateRefreshHandler();
          if (n?.access_token) return this.setCredentials(n), { token: this.credentials.access_token };
        } else throw new Error("No refresh token or refresh handler callback is set.");
        let t = await this.refreshAccessTokenAsync();
        if (!t.credentials || t.credentials && !t.credentials.access_token) throw new Error("Could not refresh access token.");
        return { token: t.credentials.access_token, res: t.res };
      } else return { token: this.credentials.access_token };
    }
    async getRequestHeaders(e) {
      return (await this.getRequestMetadataAsync(e)).headers;
    }
    async getRequestMetadataAsync(e) {
      let t = this.credentials;
      if (!t.access_token && !t.refresh_token && !this.apiKey && !this.refreshHandler) throw new Error("No access, refresh token, API key or refresh handler callback is set.");
      if (t.access_token && !this.isTokenExpiring()) {
        t.token_type = t.token_type || "Bearer";
        let l = new Headers({ authorization: t.token_type + " " + t.access_token });
        return { headers: this.addSharedMetadataHeaders(l) };
      }
      if (this.refreshHandler) {
        let l = await this.processAndValidateRefreshHandler();
        if (l?.access_token) {
          this.setCredentials(l);
          let f = new Headers({ authorization: "Bearer " + this.credentials.access_token });
          return { headers: this.addSharedMetadataHeaders(f) };
        }
      }
      if (this.apiKey) return { headers: new Headers({ "X-Goog-Api-Key": this.apiKey }) };
      let n = null, o = null;
      try {
        n = await this.refreshToken(t.refresh_token), o = n.tokens;
      } catch (l) {
        let f = l;
        throw f.response && (f.response.status === 403 || f.response.status === 404) && (f.message = `Could not refresh access token: ${f.message}`), f;
      }
      let a = this.credentials;
      a.token_type = a.token_type || "Bearer", o.refresh_token = a.refresh_token, this.credentials = o;
      let u = new Headers({ authorization: a.token_type + " " + o.access_token });
      return { headers: this.addSharedMetadataHeaders(u), res: n.res };
    }
    static getRevokeTokenUrl(e) {
      return new r().getRevokeTokenURL(e).toString();
    }
    getRevokeTokenURL(e) {
      let t = new URL(this.endpoints.oauth2RevokeUrl);
      return t.searchParams.append("token", e), t;
    }
    revokeToken(e, t) {
      let n = { ...r.RETRY_CONFIG, url: this.getRevokeTokenURL(e).toString(), method: "POST" };
      if (In.AuthClient.setMethodName(n, "revokeToken"), t) this.transporter.request(n).then((o) => t(null, o), t);
      else return this.transporter.request(n);
    }
    revokeCredentials(e) {
      if (e) this.revokeCredentialsAsync().then((t) => e(null, t), e);
      else return this.revokeCredentialsAsync();
    }
    async revokeCredentialsAsync() {
      let e = this.credentials.access_token;
      if (this.credentials = {}, e) return this.revokeToken(e);
      throw new Error("No access token to revoke.");
    }
    request(e, t) {
      if (t) this.requestAsync(e).then((n) => t(null, n), (n) => t(n, n.response));
      else return this.requestAsync(e);
    }
    async requestAsync(e, t = false) {
      try {
        let n = await this.getRequestMetadataAsync();
        return e.headers = yp.Gaxios.mergeHeaders(e.headers), this.addUserProjectAndAuthHeaders(e.headers, n.headers), this.apiKey && e.headers.set("X-Goog-Api-Key", this.apiKey), await this.transporter.request(e);
      } catch (n) {
        let o = n.response;
        if (o) {
          let a = o.status, u = this.credentials && this.credentials.access_token && this.credentials.refresh_token && (!this.credentials.expiry_date || this.forceRefreshOnFailure), l = this.credentials && this.credentials.access_token && !this.credentials.refresh_token && (!this.credentials.expiry_date || this.forceRefreshOnFailure) && this.refreshHandler, f = o.config.data instanceof ab.Readable, d = a === 401 || a === 403;
          if (!t && d && !f && u) return await this.refreshAccessTokenAsync(), this.requestAsync(e, true);
          if (!t && d && !f && l) {
            let h = await this.processAndValidateRefreshHandler();
            return h?.access_token && this.setCredentials(h), this.requestAsync(e, true);
          }
        }
        throw n;
      }
    }
    verifyIdToken(e, t) {
      if (t && typeof t != "function") throw new Error("This method accepts an options object as the first parameter, which includes the idToken, audience, and maxExpiry.");
      if (t) this.verifyIdTokenAsync(e).then((n) => t(null, n), t);
      else return this.verifyIdTokenAsync(e);
    }
    async verifyIdTokenAsync(e) {
      if (!e.idToken) throw new Error("The verifyIdToken method requires an ID Token");
      let t = await this.getFederatedSignonCertsAsync();
      return await this.verifySignedJwtWithCertsAsync(e.idToken, t.certs, e.audience, this.issuers, e.maxExpiry);
    }
    async getTokenInfo(e) {
      let { data: t } = await this.transporter.request({ ...r.RETRY_CONFIG, method: "POST", headers: { "content-type": "application/x-www-form-urlencoded;charset=UTF-8", authorization: `Bearer ${e}` }, url: this.endpoints.tokenInfoUrl.toString() }), n = Object.assign({ expiry_date: (/* @__PURE__ */ new Date()).getTime() + t.expires_in * 1e3, scopes: t.scope.split(" ") }, t);
      return delete n.expires_in, delete n.scope, n;
    }
    getFederatedSignonCerts(e) {
      if (e) this.getFederatedSignonCertsAsync().then((t) => e(null, t.certs, t.res), e);
      else return this.getFederatedSignonCertsAsync();
    }
    async getFederatedSignonCertsAsync() {
      let e = (/* @__PURE__ */ new Date()).getTime(), t = (0, $u.hasBrowserCrypto)() ? mr.JWK : mr.PEM;
      if (this.certificateExpiry && e < this.certificateExpiry.getTime() && this.certificateCacheFormat === t) return { certs: this.certificateCache, format: t };
      let n, o;
      switch (t) {
        case mr.PEM:
          o = this.endpoints.oauth2FederatedSignonPemCertsUrl.toString();
          break;
        case mr.JWK:
          o = this.endpoints.oauth2FederatedSignonJwkCertsUrl.toString();
          break;
        default:
          throw new Error(`Unsupported certificate format ${t}`);
      }
      try {
        let d = { ...r.RETRY_CONFIG, url: o };
        In.AuthClient.setMethodName(d, "getFederatedSignonCertsAsync"), n = await this.transporter.request(d);
      } catch (d) {
        throw d instanceof Error && (d.message = `Failed to retrieve verification certificates: ${d.message}`), d;
      }
      let a = n?.headers.get("cache-control"), u = -1;
      if (a) {
        let d = /max-age=(?<maxAge>[0-9]+)/.exec(a)?.groups?.maxAge;
        d && (u = Number(d) * 1e3);
      }
      let l = {};
      switch (t) {
        case mr.PEM:
          l = n.data;
          break;
        case mr.JWK:
          for (let d of n.data.keys) l[d.kid] = d;
          break;
        default:
          throw new Error(`Unsupported certificate format ${t}`);
      }
      let f = /* @__PURE__ */ new Date();
      return this.certificateExpiry = u === -1 ? null : new Date(f.getTime() + u), this.certificateCache = l, this.certificateCacheFormat = t, { certs: l, format: t, res: n };
    }
    getIapPublicKeys(e) {
      if (e) this.getIapPublicKeysAsync().then((t) => e(null, t.pubkeys, t.res), e);
      else return this.getIapPublicKeysAsync();
    }
    async getIapPublicKeysAsync() {
      let e, t = this.endpoints.oauth2IapPublicKeyUrl.toString();
      try {
        let n = { ...r.RETRY_CONFIG, url: t };
        In.AuthClient.setMethodName(n, "getIapPublicKeysAsync"), e = await this.transporter.request(n);
      } catch (n) {
        throw n instanceof Error && (n.message = `Failed to retrieve verification certificates: ${n.message}`), n;
      }
      return { pubkeys: e.data, res: e };
    }
    verifySignedJwtWithCerts() {
      throw new Error("verifySignedJwtWithCerts is removed, please use verifySignedJwtWithCertsAsync instead.");
    }
    async verifySignedJwtWithCertsAsync(e, t, n, o, a) {
      let u = (0, $u.createCrypto)();
      a || (a = r.DEFAULT_MAX_TOKEN_LIFETIME_SECS_);
      let l = e.split(".");
      if (l.length !== 3) throw new Error("Wrong number of segments in token: " + e);
      let f = l[0] + "." + l[1], d = l[2], h, C;
      try {
        h = JSON.parse(u.decodeBase64StringUtf8(l[0]));
      } catch (k) {
        throw k instanceof Error && (k.message = `Can't parse token envelope: ${l[0]}': ${k.message}`), k;
      }
      if (!h) throw new Error("Can't parse token envelope: " + l[0]);
      try {
        C = JSON.parse(u.decodeBase64StringUtf8(l[1]));
      } catch (k) {
        throw k instanceof Error && (k.message = `Can't parse token payload '${l[0]}`), k;
      }
      if (!C) throw new Error("Can't parse token payload: " + l[1]);
      if (!Object.prototype.hasOwnProperty.call(t, h.kid)) throw new Error("No pem found for envelope: " + JSON.stringify(h));
      let w = t[h.kid];
      if (h.alg === "ES256" && (d = ub.joseToDer(d, "ES256").toString("base64")), !await u.verify(w, f, d)) throw new Error("Invalid token signature: " + e);
      if (!C.iat) throw new Error("No issue time in token: " + JSON.stringify(C));
      if (!C.exp) throw new Error("No expiration time in token: " + JSON.stringify(C));
      let S = Number(C.iat);
      if (isNaN(S)) throw new Error("iat field using invalid format");
      let b = Number(C.exp);
      if (isNaN(b)) throw new Error("exp field using invalid format");
      let _ = (/* @__PURE__ */ new Date()).getTime() / 1e3;
      if (b >= _ + a) throw new Error("Expiration time too far in future: " + JSON.stringify(C));
      let y = S - r.CLOCK_SKEW_SECS_, T = b + r.CLOCK_SKEW_SECS_;
      if (_ < y) throw new Error("Token used too early, " + _ + " < " + y + ": " + JSON.stringify(C));
      if (_ > T) throw new Error("Token used too late, " + _ + " > " + T + ": " + JSON.stringify(C));
      if (o && o.indexOf(C.iss) < 0) throw new Error("Invalid issuer, expected one of [" + o + "], but got " + C.iss);
      if (typeof n < "u" && n !== null) {
        let k = C.aud, L = false;
        if (n.constructor === Array ? L = n.indexOf(k) > -1 : L = k === n, !L) throw new Error("Wrong recipient, payload audience != requiredAudience");
      }
      return new cb.LoginTicket(h, C);
    }
    async processAndValidateRefreshHandler() {
      if (this.refreshHandler) {
        let e = await this.refreshHandler();
        if (!e.access_token) throw new Error("No access token is returned by the refreshHandler callback.");
        return e;
      }
    }
    isTokenExpiring() {
      let e = this.credentials.expiry_date;
      return e ? e <= (/* @__PURE__ */ new Date()).getTime() + this.eagerRefreshThresholdMillis : false;
    }
  };
  Yt.OAuth2Client = Hu;
});
var Wu = z((ai) => {
  "use strict";
  Object.defineProperty(ai, "__esModule", { value: true });
  ai.Compute = void 0;
  var lb = Ve(), bp = ys(), fb = nn(), Gu = class extends fb.OAuth2Client {
    serviceAccountEmail;
    scopes;
    constructor(e = {}) {
      super(e), this.credentials = { expiry_date: 1, refresh_token: "compute-placeholder" }, this.serviceAccountEmail = e.serviceAccountEmail || "default", this.scopes = Array.isArray(e.scopes) ? e.scopes : e.scopes ? [e.scopes] : [];
    }
    async refreshTokenNoCache() {
      let e = `service-accounts/${this.serviceAccountEmail}/token`, t;
      try {
        let o = { property: e };
        this.scopes.length > 0 && (o.params = { scopes: this.scopes.join(",") }), t = await bp.instance(o);
      } catch (o) {
        throw o instanceof lb.GaxiosError && (o.message = `Could not refresh access token: ${o.message}`, this.wrapError(o)), o;
      }
      let n = t;
      return t && t.expires_in && (n.expiry_date = (/* @__PURE__ */ new Date()).getTime() + t.expires_in * 1e3, delete n.expires_in), this.emit("tokens", n), { tokens: n, res: null };
    }
    async fetchIdToken(e) {
      let t = `service-accounts/${this.serviceAccountEmail}/identity?format=full&audience=${e}`, n;
      try {
        let o = { property: t };
        n = await bp.instance(o);
      } catch (o) {
        throw o instanceof Error && (o.message = `Could not fetch ID token: ${o.message}`), o;
      }
      return n;
    }
    wrapError(e) {
      let t = e.response;
      t && t.status && (e.status = t.status, t.status === 403 ? e.message = "A Forbidden error was returned while attempting to retrieve an access token for the Compute Engine built-in service account. This may be because the Compute Engine instance does not have the correct permission scopes specified: " + e.message : t.status === 404 && (e.message = "A Not Found error was returned while attempting to retrieve an accesstoken for the Compute Engine built-in service account. This may be because the Compute Engine instance does not have any permission scopes specified: " + e.message));
    }
  };
  ai.Compute = Gu;
});
var Ju = z((ui) => {
  "use strict";
  Object.defineProperty(ui, "__esModule", { value: true });
  ui.IdTokenClient = void 0;
  var db = nn(), zu = class extends db.OAuth2Client {
    targetAudience;
    idTokenProvider;
    constructor(e) {
      super(e), this.targetAudience = e.targetAudience, this.idTokenProvider = e.idTokenProvider;
    }
    async getRequestMetadataAsync() {
      if (!this.credentials.id_token || !this.credentials.expiry_date || this.isTokenExpiring()) {
        let t = await this.idTokenProvider.fetchIdToken(this.targetAudience);
        this.credentials = { id_token: t, expiry_date: this.getIdTokenExpiryDate(t) };
      }
      return { headers: new Headers({ authorization: "Bearer " + this.credentials.id_token }) };
    }
    getIdTokenExpiryDate(e) {
      let t = e.split(".")[1];
      if (t) return JSON.parse(Buffer.from(t, "base64").toString("ascii")).exp * 1e3;
    }
  };
  ui.IdTokenClient = zu;
});
var Vu = z((Nn) => {
  "use strict";
  Object.defineProperty(Nn, "__esModule", { value: true });
  Nn.GCPEnv = void 0;
  Nn.clear = hb;
  Nn.getEnv = pb;
  var Ep = ys(), gr;
  (function(r) {
    r.APP_ENGINE = "APP_ENGINE", r.KUBERNETES_ENGINE = "KUBERNETES_ENGINE", r.CLOUD_FUNCTIONS = "CLOUD_FUNCTIONS", r.COMPUTE_ENGINE = "COMPUTE_ENGINE", r.CLOUD_RUN = "CLOUD_RUN", r.NONE = "NONE";
  })(gr || (Nn.GCPEnv = gr = {}));
  var bs;
  function hb() {
    bs = void 0;
  }
  async function pb() {
    return bs || (bs = mb(), bs);
  }
  async function mb() {
    let r = gr.NONE;
    return gb() ? r = gr.APP_ENGINE : yb() ? r = gr.CLOUD_FUNCTIONS : await bb() ? await Cb() ? r = gr.KUBERNETES_ENGINE : _b() ? r = gr.CLOUD_RUN : r = gr.COMPUTE_ENGINE : r = gr.NONE, r;
  }
  function gb() {
    return !!(process.env.GAE_SERVICE || process.env.GAE_MODULE_NAME);
  }
  function yb() {
    return !!(process.env.FUNCTION_NAME || process.env.FUNCTION_TARGET);
  }
  function _b() {
    return !!process.env.K_CONFIGURATION;
  }
  async function Cb() {
    try {
      return await Ep.instance("attributes/cluster-name"), true;
    } catch {
      return false;
    }
  }
  async function bb() {
    return Ep.isAvailable();
  }
});
var Ku = z((zS, wp) => {
  var ci = Bn().Buffer, Eb = Y("stream"), wb = Y("util");
  function li(r) {
    if (this.buffer = null, this.writable = true, this.readable = true, !r) return this.buffer = ci.alloc(0), this;
    if (typeof r.pipe == "function") return this.buffer = ci.alloc(0), r.pipe(this), this;
    if (r.length || typeof r == "object") return this.buffer = r, this.writable = false, process.nextTick(function() {
      this.emit("end", r), this.readable = false, this.emit("close");
    }.bind(this)), this;
    throw new TypeError("Unexpected data type (" + typeof r + ")");
  }
  wb.inherits(li, Eb);
  li.prototype.write = function(e) {
    this.buffer = ci.concat([this.buffer, ci.from(e)]), this.emit("data", e);
  };
  li.prototype.end = function(e) {
    e && this.write(e), this.emit("end", e), this.emit("close"), this.writable = false, this.readable = false;
  };
  wp.exports = li;
});
var Dp = z((JS, Ap) => {
  "use strict";
  var Es = Y("buffer").Buffer, Yu = Y("buffer").SlowBuffer;
  Ap.exports = fi;
  function fi(r, e) {
    if (!Es.isBuffer(r) || !Es.isBuffer(e) || r.length !== e.length) return false;
    for (var t = 0, n = 0; n < r.length; n++) t |= r[n] ^ e[n];
    return t === 0;
  }
  fi.install = function() {
    Es.prototype.equal = Yu.prototype.equal = function(e) {
      return fi(this, e);
    };
  };
  var Ab = Es.prototype.equal, Db = Yu.prototype.equal;
  fi.restore = function() {
    Es.prototype.equal = Ab, Yu.prototype.equal = Db;
  };
});
var ec = z((VS, xp) => {
  var jn = Bn().Buffer, vt = Y("crypto"), vp = xu(), Sp = Y("util"), Sb = `"%s" is not a valid algorithm.
  Supported algorithms are:
  "HS256", "HS384", "HS512", "RS256", "RS384", "RS512", "PS256", "PS384", "PS512", "ES256", "ES384", "ES512" and "none".`, ws = "secret must be a string or buffer", qn = "key must be a string or a buffer", vb = "key must be a string, a buffer or an object", Qu = typeof vt.createPublicKey == "function";
  Qu && (qn += " or a KeyObject", ws += "or a KeyObject");
  function Tp(r) {
    if (!jn.isBuffer(r) && typeof r != "string" && (!Qu || typeof r != "object" || typeof r.type != "string" || typeof r.asymmetricKeyType != "string" || typeof r.export != "function")) throw Mt(qn);
  }
  function Rp(r) {
    if (!jn.isBuffer(r) && typeof r != "string" && typeof r != "object") throw Mt(vb);
  }
  function Tb(r) {
    if (!jn.isBuffer(r)) {
      if (typeof r == "string") return r;
      if (!Qu || typeof r != "object" || r.type !== "secret" || typeof r.export != "function") throw Mt(ws);
    }
  }
  function Zu(r) {
    return r.replace(/=/g, "").replace(/\+/g, "-").replace(/\//g, "_");
  }
  function Fp(r) {
    r = r.toString();
    var e = 4 - r.length % 4;
    if (e !== 4) for (var t = 0; t < e; ++t) r += "=";
    return r.replace(/\-/g, "+").replace(/_/g, "/");
  }
  function Mt(r) {
    var e = [].slice.call(arguments, 1), t = Sp.format.bind(Sp, r).apply(null, e);
    return new TypeError(t);
  }
  function Rb(r) {
    return jn.isBuffer(r) || typeof r == "string";
  }
  function As(r) {
    return Rb(r) || (r = JSON.stringify(r)), r;
  }
  function kp(r) {
    return function(t, n) {
      Tb(n), t = As(t);
      var o = vt.createHmac("sha" + r, n), a = (o.update(t), o.digest("base64"));
      return Zu(a);
    };
  }
  var Xu, Fb = "timingSafeEqual" in vt ? function(e, t) {
    return e.byteLength !== t.byteLength ? false : vt.timingSafeEqual(e, t);
  } : function(e, t) {
    return Xu || (Xu = Dp()), Xu(e, t);
  };
  function kb(r) {
    return function(t, n, o) {
      var a = kp(r)(t, o);
      return Fb(jn.from(n), jn.from(a));
    };
  }
  function Op(r) {
    return function(t, n) {
      Rp(n), t = As(t);
      var o = vt.createSign("RSA-SHA" + r), a = (o.update(t), o.sign(n, "base64"));
      return Zu(a);
    };
  }
  function Pp(r) {
    return function(t, n, o) {
      Tp(o), t = As(t), n = Fp(n);
      var a = vt.createVerify("RSA-SHA" + r);
      return a.update(t), a.verify(o, n, "base64");
    };
  }
  function Ob(r) {
    return function(t, n) {
      Rp(n), t = As(t);
      var o = vt.createSign("RSA-SHA" + r), a = (o.update(t), o.sign({ key: n, padding: vt.constants.RSA_PKCS1_PSS_PADDING, saltLength: vt.constants.RSA_PSS_SALTLEN_DIGEST }, "base64"));
      return Zu(a);
    };
  }
  function Pb(r) {
    return function(t, n, o) {
      Tp(o), t = As(t), n = Fp(n);
      var a = vt.createVerify("RSA-SHA" + r);
      return a.update(t), a.verify({ key: o, padding: vt.constants.RSA_PKCS1_PSS_PADDING, saltLength: vt.constants.RSA_PSS_SALTLEN_DIGEST }, n, "base64");
    };
  }
  function xb(r) {
    var e = Op(r);
    return function() {
      var n = e.apply(null, arguments);
      return n = vp.derToJose(n, "ES" + r), n;
    };
  }
  function Bb(r) {
    var e = Pp(r);
    return function(n, o, a) {
      o = vp.joseToDer(o, "ES" + r).toString("base64");
      var u = e(n, o, a);
      return u;
    };
  }
  function Ib() {
    return function() {
      return "";
    };
  }
  function Nb() {
    return function(e, t) {
      return t === "";
    };
  }
  xp.exports = function(e) {
    var t = { hs: kp, rs: Op, ps: Ob, es: xb, none: Ib }, n = { hs: kb, rs: Pp, ps: Pb, es: Bb, none: Nb }, o = e.match(/^(RS|PS|ES|HS)(256|384|512)$|^(none)$/);
    if (!o) throw Mt(Sb, e);
    var a = (o[1] || o[3]).toLowerCase(), u = o[2];
    return { sign: t[a](u), verify: n[a](u) };
  };
});
var tc = z((KS, Bp) => {
  var qb = Y("buffer").Buffer;
  Bp.exports = function(e) {
    return typeof e == "string" ? e : typeof e == "number" || qb.isBuffer(e) ? e.toString() : JSON.stringify(e);
  };
});
var Up = z((YS, Lp) => {
  var jb = Bn().Buffer, Ip = Ku(), Lb = ec(), Ub = Y("stream"), Np = tc(), rc = Y("util");
  function qp(r, e) {
    return jb.from(r, e).toString("base64").replace(/=/g, "").replace(/\+/g, "-").replace(/\//g, "_");
  }
  function Mb(r, e, t) {
    t = t || "utf8";
    var n = qp(Np(r), "binary"), o = qp(Np(e), t);
    return rc.format("%s.%s", n, o);
  }
  function jp(r) {
    var e = r.header, t = r.payload, n = r.secret || r.privateKey, o = r.encoding, a = Lb(e.alg), u = Mb(e, t, o), l = a.sign(u, n);
    return rc.format("%s.%s", u, l);
  }
  function di(r) {
    var e = r.secret || r.privateKey || r.key, t = new Ip(e);
    this.readable = true, this.header = r.header, this.encoding = r.encoding, this.secret = this.privateKey = this.key = t, this.payload = new Ip(r.payload), this.secret.once("close", function() {
      !this.payload.writable && this.readable && this.sign();
    }.bind(this)), this.payload.once("close", function() {
      !this.secret.writable && this.readable && this.sign();
    }.bind(this));
  }
  rc.inherits(di, Ub);
  di.prototype.sign = function() {
    try {
      var e = jp({ header: this.header, payload: this.payload.buffer, secret: this.secret.buffer, encoding: this.encoding });
      return this.emit("done", e), this.emit("data", e), this.emit("end"), this.readable = false, e;
    } catch (t) {
      this.readable = false, this.emit("error", t), this.emit("close");
    }
  };
  di.sign = jp;
  Lp.exports = di;
});
var Yp = z((XS, Kp) => {
  var $p = Bn().Buffer, Mp = Ku(), $b = ec(), Hb = Y("stream"), Hp = tc(), Gb = Y("util"), Wb = /^[a-zA-Z0-9\-_]+?\.[a-zA-Z0-9\-_]+?\.([a-zA-Z0-9\-_]+)?$/;
  function zb(r) {
    return Object.prototype.toString.call(r) === "[object Object]";
  }
  function Jb(r) {
    if (zb(r)) return r;
    try {
      return JSON.parse(r);
    } catch {
      return;
    }
  }
  function Gp(r) {
    var e = r.split(".", 1)[0];
    return Jb($p.from(e, "base64").toString("binary"));
  }
  function Vb(r) {
    return r.split(".", 2).join(".");
  }
  function Wp(r) {
    return r.split(".")[2];
  }
  function Kb(r, e) {
    e = e || "utf8";
    var t = r.split(".")[1];
    return $p.from(t, "base64").toString(e);
  }
  function zp(r) {
    return Wb.test(r) && !!Gp(r);
  }
  function Jp(r, e, t) {
    if (!e) {
      var n = new Error("Missing algorithm parameter for jws.verify");
      throw n.code = "MISSING_ALGORITHM", n;
    }
    r = Hp(r);
    var o = Wp(r), a = Vb(r), u = $b(e);
    return u.verify(a, o, t);
  }
  function Vp(r, e) {
    if (e = e || {}, r = Hp(r), !zp(r)) return null;
    var t = Gp(r);
    if (!t) return null;
    var n = Kb(r);
    return (t.typ === "JWT" || e.json) && (n = JSON.parse(n, e.encoding)), { header: t, payload: n, signature: Wp(r) };
  }
  function Ln(r) {
    r = r || {};
    var e = r.secret || r.publicKey || r.key, t = new Mp(e);
    this.readable = true, this.algorithm = r.algorithm, this.encoding = r.encoding, this.secret = this.publicKey = this.key = t, this.signature = new Mp(r.signature), this.secret.once("close", function() {
      !this.signature.writable && this.readable && this.verify();
    }.bind(this)), this.signature.once("close", function() {
      !this.secret.writable && this.readable && this.verify();
    }.bind(this));
  }
  Gb.inherits(Ln, Hb);
  Ln.prototype.verify = function() {
    try {
      var e = Jp(this.signature.buffer, this.algorithm, this.key.buffer), t = Vp(this.signature.buffer, this.encoding);
      return this.emit("done", e, t), this.emit("data", e), this.emit("end"), this.readable = false, e;
    } catch (n) {
      this.readable = false, this.emit("error", n), this.emit("close");
    }
  };
  Ln.decode = Vp;
  Ln.isValid = zp;
  Ln.verify = Jp;
  Kp.exports = Ln;
});
var nc = z((Ir) => {
  var Xp = Up(), hi = Yp(), Yb = ["HS256", "HS384", "HS512", "RS256", "RS384", "RS512", "PS256", "PS384", "PS512", "ES256", "ES384", "ES512"];
  Ir.ALGORITHMS = Yb;
  Ir.sign = Xp.sign;
  Ir.verify = hi.verify;
  Ir.decode = hi.decode;
  Ir.isValid = hi.isValid;
  Ir.createSign = function(e) {
    return new Xp(e);
  };
  Ir.createVerify = function(e) {
    return new hi(e);
  };
});
var dm = z((mi) => {
  "use strict";
  Object.defineProperty(mi, "__esModule", { value: true });
  mi.GoogleToken = void 0;
  var Qp = pi(Y("fs")), Xb = Ve(), Qb = pi(nc()), Zb = pi(Y("path")), eE = Y("util");
  function pi(r, e) {
    if (typeof WeakMap == "function") var t = /* @__PURE__ */ new WeakMap(), n = /* @__PURE__ */ new WeakMap();
    return (pi = function(a, u) {
      if (!u && a && a.__esModule) return a;
      var l, f, d = { __proto__: null, default: a };
      if (a === null || yr(a) != "object" && typeof a != "function") return d;
      if (l = u ? n : t) {
        if (l.has(a)) return l.get(a);
        l.set(a, d);
      }
      for (var h in a) h !== "default" && {}.hasOwnProperty.call(a, h) && ((f = (l = Object.defineProperty) && Object.getOwnPropertyDescriptor(a, h)) && (f.get || f.set) ? l(d, h, f) : d[h] = a[h]);
      return d;
    })(r, e);
  }
  function yr(r) {
    "@babel/helpers - typeof";
    return yr = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(e) {
      return typeof e;
    } : function(e) {
      return e && typeof Symbol == "function" && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e;
    }, yr(r);
  }
  function tE(r, e) {
    am(r, e), e.add(r);
  }
  function rE(r, e, t) {
    am(r, e), e.set(r, t);
  }
  function am(r, e) {
    if (e.has(r)) throw new TypeError("Cannot initialize the same private elements twice on an object");
  }
  function Zp(r, e, t) {
    return r.set($t(r, e), t), t;
  }
  function em(r, e) {
    return r.get($t(r, e));
  }
  function $t(r, e, t) {
    if (typeof r == "function" ? r === e : r.has(e)) return arguments.length < 3 ? e : t;
    throw new TypeError("Private element is not present on this object");
  }
  function tm(r, e) {
    for (var t = 0; t < e.length; t++) {
      var n = e[t];
      n.enumerable = n.enumerable || false, n.configurable = true, "value" in n && (n.writable = true), Object.defineProperty(r, lm(n.key), n);
    }
  }
  function um(r, e, t) {
    return e && tm(r.prototype, e), t && tm(r, t), Object.defineProperty(r, "prototype", { writable: false }), r;
  }
  function cm(r, e) {
    if (!(r instanceof e)) throw new TypeError("Cannot call a class as a function");
  }
  function nE(r, e, t) {
    return e = Ts(e), sE(r, cc() ? Reflect.construct(e, t || [], Ts(r).constructor) : e.apply(r, t));
  }
  function sE(r, e) {
    if (e && (yr(e) == "object" || typeof e == "function")) return e;
    if (e !== void 0) throw new TypeError("Derived constructors may only return object or undefined");
    return oE(r);
  }
  function oE(r) {
    if (r === void 0) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    return r;
  }
  function iE(r, e) {
    if (typeof e != "function" && e !== null) throw new TypeError("Super expression must either be null or a function");
    r.prototype = Object.create(e && e.prototype, { constructor: { value: r, writable: true, configurable: true } }), Object.defineProperty(r, "prototype", { writable: false }), e && vs(r, e);
  }
  function sc(r) {
    var e = typeof Map == "function" ? /* @__PURE__ */ new Map() : void 0;
    return sc = function(n) {
      if (n === null || !uE(n)) return n;
      if (typeof n != "function") throw new TypeError("Super expression must either be null or a function");
      if (e !== void 0) {
        if (e.has(n)) return e.get(n);
        e.set(n, o);
      }
      function o() {
        return aE(n, arguments, Ts(this).constructor);
      }
      return o.prototype = Object.create(n.prototype, { constructor: { value: o, enumerable: false, writable: true, configurable: true } }), vs(o, n);
    }, sc(r);
  }
  function aE(r, e, t) {
    if (cc()) return Reflect.construct.apply(null, arguments);
    var n = [null];
    n.push.apply(n, e);
    var o = new (r.bind.apply(r, n))();
    return t && vs(o, t.prototype), o;
  }
  function cc() {
    try {
      var r = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
      }));
    } catch {
    }
    return (cc = function() {
      return !!r;
    })();
  }
  function uE(r) {
    try {
      return Function.toString.call(r).indexOf("[native code]") !== -1;
    } catch {
      return typeof r == "function";
    }
  }
  function vs(r, e) {
    return vs = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(t, n) {
      return t.__proto__ = n, t;
    }, vs(r, e);
  }
  function Ts(r) {
    return Ts = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function(e) {
      return e.__proto__ || Object.getPrototypeOf(e);
    }, Ts(r);
  }
  function mt(r, e, t) {
    return (e = lm(e)) in r ? Object.defineProperty(r, e, { value: t, enumerable: true, configurable: true, writable: true }) : r[e] = t, r;
  }
  function lm(r) {
    var e = cE(r, "string");
    return yr(e) == "symbol" ? e : e + "";
  }
  function cE(r, e) {
    if (yr(r) != "object" || !r) return r;
    var t = r[Symbol.toPrimitive];
    if (t !== void 0) {
      var n = t.call(r, e || "default");
      if (yr(n) != "object") return n;
      throw new TypeError("@@toPrimitive must return a primitive value.");
    }
    return (e === "string" ? String : Number)(r);
  }
  function yt() {
    var r, e, t = typeof Symbol == "function" ? Symbol : {}, n = t.iterator || "@@iterator", o = t.toStringTag || "@@toStringTag";
    function a(I, S, b, _) {
      var y = S && S.prototype instanceof l ? S : l, T = Object.create(y.prototype);
      return gt(T, "_invoke", function(k, L, P) {
        var j, G, re, W = 0, Ee = P || [], he = false, oe = { p: 0, n: 0, v: r, a: ue, f: ue.bind(r, 4), d: function(ce, pe) {
          return j = ce, G = 0, re = r, oe.n = pe, u;
        } };
        function ue(Z, ce) {
          for (G = Z, re = ce, e = 0; !he && W && !pe && e < Ee.length; e++) {
            var pe, Te = Ee[e], J = oe.p, X = Te[2];
            Z > 3 ? (pe = X === ce) && (re = Te[(G = Te[4]) ? 5 : (G = 3, 3)], Te[4] = Te[5] = r) : Te[0] <= J && ((pe = Z < 2 && J < Te[1]) ? (G = 0, oe.v = ce, oe.n = Te[1]) : J < X && (pe = Z < 3 || Te[0] > ce || ce > X) && (Te[4] = Z, Te[5] = ce, oe.n = X, G = 0));
          }
          if (pe || Z > 1) return u;
          throw he = true, ce;
        }
        return function(Z, ce, pe) {
          if (W > 1) throw TypeError("Generator is already running");
          for (he && ce === 1 && ue(ce, pe), G = ce, re = pe; (e = G < 2 ? r : re) || !he; ) {
            j || (G ? G < 3 ? (G > 1 && (oe.n = -1), ue(G, re)) : oe.n = re : oe.v = re);
            try {
              if (W = 2, j) {
                if (G || (Z = "next"), e = j[Z]) {
                  if (!(e = e.call(j, re))) throw TypeError("iterator result is not an object");
                  if (!e.done) return e;
                  re = e.value, G < 2 && (G = 0);
                } else G === 1 && (e = j.return) && e.call(j), G < 2 && (re = TypeError("The iterator does not provide a '" + Z + "' method"), G = 1);
                j = r;
              } else if ((e = (he = oe.n < 0) ? re : k.call(L, oe)) !== u) break;
            } catch (Te) {
              j = r, G = 1, re = Te;
            } finally {
              W = 1;
            }
          }
          return { value: e, done: he };
        };
      }(I, b, _), true), T;
    }
    var u = {};
    function l() {
    }
    function f() {
    }
    function d() {
    }
    e = Object.getPrototypeOf;
    var h = [][n] ? e(e([][n]())) : (gt(e = {}, n, function() {
      return this;
    }), e), C = d.prototype = l.prototype = Object.create(h);
    function w(I) {
      return Object.setPrototypeOf ? Object.setPrototypeOf(I, d) : (I.__proto__ = d, gt(I, o, "GeneratorFunction")), I.prototype = Object.create(C), I;
    }
    return f.prototype = d, gt(C, "constructor", d), gt(d, "constructor", f), f.displayName = "GeneratorFunction", gt(d, o, "GeneratorFunction"), gt(C), gt(C, o, "Generator"), gt(C, n, function() {
      return this;
    }), gt(C, "toString", function() {
      return "[object Generator]";
    }), (yt = function() {
      return { w: a, m: w };
    })();
  }
  function gt(r, e, t, n) {
    var o = Object.defineProperty;
    try {
      o({}, "", {});
    } catch {
      o = 0;
    }
    gt = function(u, l, f, d) {
      if (l) o ? o(u, l, { value: f, enumerable: !d, configurable: !d, writable: !d }) : u[l] = f;
      else {
        var h = function(w, I) {
          gt(u, w, function(S) {
            return this._invoke(w, I, S);
          });
        };
        h("next", 0), h("throw", 1), h("return", 2);
      }
    }, gt(r, e, t, n);
  }
  function rm(r, e, t, n, o, a, u) {
    try {
      var l = r[a](u), f = l.value;
    } catch (d) {
      return void t(d);
    }
    l.done ? e(f) : Promise.resolve(f).then(n, o);
  }
  function Un(r) {
    return function() {
      var e = this, t = arguments;
      return new Promise(function(n, o) {
        var a = r.apply(e, t);
        function u(f) {
          rm(a, n, o, u, l, "next", f);
        }
        function l(f) {
          rm(a, n, o, u, l, "throw", f);
        }
        u(void 0);
      });
    };
  }
  var nm = Qp.readFile ? (0, eE.promisify)(Qp.readFile) : Un(yt().m(function r() {
    return yt().w(function(e) {
      for (; ; ) switch (e.n) {
        case 0:
          throw new Ss("use key rather than keyFile.", "MISSING_CREDENTIALS");
        case 1:
          return e.a(2);
      }
    }, r);
  })), sm = "https://oauth2.googleapis.com/token", lE = "https://oauth2.googleapis.com/revoke?token=", Ss = function(r) {
    function e(t, n) {
      var o;
      return cm(this, e), o = nE(this, e, [t]), mt(o, "code", void 0), o.code = n, o;
    }
    return iE(e, r), um(e);
  }(sc(Error)), Ds = /* @__PURE__ */ new WeakMap(), Xt = /* @__PURE__ */ new WeakSet(), ZS = mi.GoogleToken = function() {
    function r(e) {
      cm(this, r), tE(this, Xt), mt(this, "expiresAt", void 0), mt(this, "key", void 0), mt(this, "keyFile", void 0), mt(this, "iss", void 0), mt(this, "sub", void 0), mt(this, "scope", void 0), mt(this, "rawToken", void 0), mt(this, "tokenExpires", void 0), mt(this, "email", void 0), mt(this, "additionalClaims", void 0), mt(this, "eagerRefreshThresholdMillis", void 0), mt(this, "transporter", { request: function(n) {
        return (0, Xb.request)(n);
      } }), rE(this, Ds, void 0), $t(Xt, this, fm).call(this, e);
    }
    return um(r, [{ key: "accessToken", get: function() {
      return this.rawToken ? this.rawToken.access_token : void 0;
    } }, { key: "idToken", get: function() {
      return this.rawToken ? this.rawToken.id_token : void 0;
    } }, { key: "tokenType", get: function() {
      return this.rawToken ? this.rawToken.token_type : void 0;
    } }, { key: "refreshToken", get: function() {
      return this.rawToken ? this.rawToken.refresh_token : void 0;
    } }, { key: "hasExpired", value: function() {
      var t = (/* @__PURE__ */ new Date()).getTime();
      return this.rawToken && this.expiresAt ? t >= this.expiresAt : true;
    } }, { key: "isTokenExpiring", value: function() {
      var t, n = (/* @__PURE__ */ new Date()).getTime(), o = (t = this.eagerRefreshThresholdMillis) !== null && t !== void 0 ? t : 0;
      return this.rawToken && this.expiresAt ? this.expiresAt <= n + o : true;
    } }, { key: "getToken", value: function(t) {
      var n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
      if (yr(t) === "object" && (n = t, t = void 0), n = Object.assign({ forceRefresh: false }, n), t) {
        var o = t;
        $t(Xt, this, om).call(this, n).then(function(a) {
          return o(null, a);
        }, t);
        return;
      }
      return $t(Xt, this, om).call(this, n);
    } }, { key: "getCredentials", value: function() {
      var e = Un(yt().m(function n(o) {
        var a, u, l, f, d, h, C;
        return yt().w(function(w) {
          for (; ; ) switch (w.n) {
            case 0:
              a = Zb.extname(o), C = a, w.n = C === ".json" ? 1 : C === ".der" || C === ".crt" || C === ".pem" ? 4 : C === ".p12" || C === ".pfx" ? 6 : 7;
              break;
            case 1:
              return w.n = 2, nm(o, "utf8");
            case 2:
              if (u = w.v, l = JSON.parse(u), f = l.private_key, d = l.client_email, !(!f || !d)) {
                w.n = 3;
                break;
              }
              throw new Ss("private_key and client_email are required.", "MISSING_CREDENTIALS");
            case 3:
              return w.a(2, { privateKey: f, clientEmail: d });
            case 4:
              return w.n = 5, nm(o, "utf8");
            case 5:
              return h = w.v, w.a(2, { privateKey: h });
            case 6:
              throw new Ss("*.p12 certificates are not supported after v6.1.2. Consider utilizing *.json format or converting *.p12 to *.pem using the OpenSSL CLI.", "UNKNOWN_CERTIFICATE_TYPE");
            case 7:
              throw new Ss("Unknown certificate type. Type is determined based on file extension. Current supported extensions are *.json, and *.pem.", "UNKNOWN_CERTIFICATE_TYPE");
            case 8:
              return w.a(2);
          }
        }, n);
      }));
      function t(n) {
        return e.apply(this, arguments);
      }
      return t;
    }() }, { key: "revokeToken", value: function(t) {
      if (t) {
        $t(Xt, this, im).call(this).then(function() {
          return t();
        }, t);
        return;
      }
      return $t(Xt, this, im).call(this);
    } }]);
  }();
  function om(r) {
    return oc.apply(this, arguments);
  }
  function oc() {
    return oc = Un(yt().m(function r(e) {
      return yt().w(function(t) {
        for (; ; ) switch (t.n) {
          case 0:
            if (!(em(Ds, this) && !e.forceRefresh)) {
              t.n = 1;
              break;
            }
            return t.a(2, em(Ds, this));
          case 1:
            return t.p = 1, t.n = 2, Zp(Ds, this, $t(Xt, this, fE).call(this, e));
          case 2:
            return t.a(2, t.v);
          case 3:
            return t.p = 3, Zp(Ds, this, void 0), t.f(3);
          case 4:
            return t.a(2);
        }
      }, r, this, [[1, , 3, 4]]);
    })), oc.apply(this, arguments);
  }
  function fE(r) {
    return ic.apply(this, arguments);
  }
  function ic() {
    return ic = Un(yt().m(function r(e) {
      var t;
      return yt().w(function(n) {
        for (; ; ) switch (n.n) {
          case 0:
            if (!(this.isTokenExpiring() === false && e.forceRefresh === false)) {
              n.n = 1;
              break;
            }
            return n.a(2, Promise.resolve(this.rawToken));
          case 1:
            if (!(!this.key && !this.keyFile)) {
              n.n = 2;
              break;
            }
            throw new Error("No key or keyFile set.");
          case 2:
            if (!(!this.key && this.keyFile)) {
              n.n = 4;
              break;
            }
            return n.n = 3, this.getCredentials(this.keyFile);
          case 3:
            t = n.v, this.key = t.privateKey, this.iss = t.clientEmail || this.iss, t.clientEmail || $t(Xt, this, dE).call(this);
          case 4:
            return n.a(2, $t(Xt, this, hE).call(this));
        }
      }, r, this);
    })), ic.apply(this, arguments);
  }
  function dE() {
    if (!this.iss) throw new Ss("email is required.", "MISSING_CREDENTIALS");
  }
  function im() {
    return ac.apply(this, arguments);
  }
  function ac() {
    return ac = Un(yt().m(function r() {
      var e;
      return yt().w(function(t) {
        for (; ; ) switch (t.n) {
          case 0:
            if (this.accessToken) {
              t.n = 1;
              break;
            }
            throw new Error("No token to revoke.");
          case 1:
            return e = lE + this.accessToken, t.n = 2, this.transporter.request({ url: e, retry: true });
          case 2:
            $t(Xt, this, fm).call(this, { email: this.iss, sub: this.sub, key: this.key, keyFile: this.keyFile, scope: this.scope, additionalClaims: this.additionalClaims });
          case 3:
            return t.a(2);
        }
      }, r, this);
    })), ac.apply(this, arguments);
  }
  function fm() {
    var r = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    this.keyFile = r.keyFile, this.key = r.key, this.rawToken = void 0, this.iss = r.email || r.iss, this.sub = r.sub, this.additionalClaims = r.additionalClaims, yr(r.scope) === "object" ? this.scope = r.scope.join(" ") : this.scope = r.scope, this.eagerRefreshThresholdMillis = r.eagerRefreshThresholdMillis, r.transporter && (this.transporter = r.transporter);
  }
  function hE() {
    return uc.apply(this, arguments);
  }
  function uc() {
    return uc = Un(yt().m(function r() {
      var e, t, n, o, a, u, l, f, d, h;
      return yt().w(function(C) {
        for (; ; ) switch (C.n) {
          case 0:
            return e = Math.floor((/* @__PURE__ */ new Date()).getTime() / 1e3), t = this.additionalClaims || {}, n = Object.assign({ iss: this.iss, scope: this.scope, aud: sm, exp: e + 3600, iat: e, sub: this.sub }, t), o = Qb.sign({ header: { alg: "RS256" }, payload: n, secret: this.key }), C.p = 1, C.n = 2, this.transporter.request({ method: "POST", url: sm, data: new URLSearchParams({ grant_type: "urn:ietf:params:oauth:grant-type:jwt-bearer", assertion: o }), responseType: "json", retryConfig: { httpMethodsToRetry: ["POST"] } });
          case 2:
            return a = C.v, this.rawToken = a.data, this.expiresAt = a.data.expires_in === null || a.data.expires_in === void 0 ? void 0 : (e + a.data.expires_in) * 1e3, C.a(2, this.rawToken);
          case 3:
            throw C.p = 3, h = C.v, this.rawToken = void 0, this.tokenExpires = void 0, f = h.response && (u = h.response) !== null && u !== void 0 && u.data ? (l = h.response) === null || l === void 0 ? void 0 : l.data : {}, f.error && (d = f.error_description ? ": ".concat(f.error_description) : "", h.message = "".concat(f.error).concat(d)), h;
          case 4:
            return C.a(2);
        }
      }, r, this, [[1, 3]]);
    })), uc.apply(this, arguments);
  }
});
var fc = z((gi) => {
  "use strict";
  Object.defineProperty(gi, "__esModule", { value: true });
  gi.JWTAccess = void 0;
  var pE = nc(), mE = Lt(), hm = { alg: "RS256", typ: "JWT" }, lc = class r {
    email;
    key;
    keyId;
    projectId;
    eagerRefreshThresholdMillis;
    cache = new mE.LRUCache({ capacity: 500, maxAge: 60 * 60 * 1e3 });
    constructor(e, t, n, o) {
      this.email = e, this.key = t, this.keyId = n, this.eagerRefreshThresholdMillis = o ?? 5 * 60 * 1e3;
    }
    getCachedKey(e, t) {
      let n = e;
      if (t && Array.isArray(t) && t.length ? n = e ? `${e}_${t.join("_")}` : `${t.join("_")}` : typeof t == "string" && (n = e ? `${e}_${t}` : t), !n) throw Error("Scopes or url must be provided");
      return n;
    }
    getRequestHeaders(e, t, n) {
      let o = this.getCachedKey(e, n), a = this.cache.get(o), u = Date.now();
      if (a && a.expiration - u > this.eagerRefreshThresholdMillis) return new Headers(a.headers);
      let l = Math.floor(Date.now() / 1e3), f = r.getExpirationTime(l), d;
      if (Array.isArray(n) && (n = n.join(" ")), n ? d = { iss: this.email, sub: this.email, scope: n, exp: f, iat: l } : d = { iss: this.email, sub: this.email, aud: e, exp: f, iat: l }, t) {
        for (let S in d) if (t[S]) throw new Error(`The '${S}' property is not allowed when passing additionalClaims. This claim is included in the JWT by default.`);
      }
      let h = this.keyId ? { ...hm, kid: this.keyId } : hm, C = Object.assign(d, t), w = pE.sign({ header: h, payload: C, secret: this.key }), I = new Headers({ authorization: `Bearer ${w}` });
      return this.cache.set(o, { expiration: f * 1e3, headers: I }), I;
    }
    static getExpirationTime(e) {
      return e + 3600;
    }
    fromJSON(e) {
      if (!e) throw new Error("Must pass in a JSON object containing the service account auth settings.");
      if (!e.client_email) throw new Error("The incoming JSON object does not contain a client_email field");
      if (!e.private_key) throw new Error("The incoming JSON object does not contain a private_key field");
      this.email = e.client_email, this.key = e.private_key, this.keyId = e.private_key_id, this.projectId = e.project_id;
    }
    fromStream(e, t) {
      if (t) this.fromStreamAsync(e).then(() => t(), t);
      else return this.fromStreamAsync(e);
    }
    fromStreamAsync(e) {
      return new Promise((t, n) => {
        e || n(new Error("Must pass in a stream containing the service account auth settings."));
        let o = "";
        e.setEncoding("utf8").on("data", (a) => o += a).on("error", n).on("end", () => {
          try {
            let a = JSON.parse(o);
            this.fromJSON(a), t();
          } catch (a) {
            n(a);
          }
        });
      });
    }
  };
  gi.JWTAccess = lc;
});
var hc = z((_i) => {
  "use strict";
  Object.defineProperty(_i, "__esModule", { value: true });
  _i.JWT = void 0;
  var pm = dm(), gE = fc(), yE = nn(), yi = pt(), dc = class r extends yE.OAuth2Client {
    email;
    keyFile;
    key;
    keyId;
    defaultScopes;
    scopes;
    scope;
    subject;
    gtoken;
    additionalClaims;
    useJWTAccessWithScope;
    defaultServicePath;
    access;
    constructor(e = {}) {
      super(e), this.email = e.email, this.keyFile = e.keyFile, this.key = e.key, this.keyId = e.keyId, this.scopes = e.scopes, this.subject = e.subject, this.additionalClaims = e.additionalClaims, this.credentials = { refresh_token: "jwt-placeholder", expiry_date: 1 };
    }
    createScoped(e) {
      let t = new r(this);
      return t.scopes = e, t;
    }
    async getRequestMetadataAsync(e) {
      e = this.defaultServicePath ? `https://${this.defaultServicePath}/` : e;
      let t = !this.hasUserScopes() && e || this.useJWTAccessWithScope && this.hasAnyScopes() || this.universeDomain !== yi.DEFAULT_UNIVERSE;
      if (this.subject && this.universeDomain !== yi.DEFAULT_UNIVERSE) throw new RangeError(`Service Account user is configured for the credential. Domain-wide delegation is not supported in universes other than ${yi.DEFAULT_UNIVERSE}`);
      if (!this.apiKey && t) if (this.additionalClaims && this.additionalClaims.target_audience) {
        let { tokens: n } = await this.refreshToken();
        return { headers: this.addSharedMetadataHeaders(new Headers({ authorization: `Bearer ${n.id_token}` })) };
      } else {
        this.access || (this.access = new gE.JWTAccess(this.email, this.key, this.keyId, this.eagerRefreshThresholdMillis));
        let n;
        this.hasUserScopes() ? n = this.scopes : e || (n = this.defaultScopes);
        let o = this.useJWTAccessWithScope || this.universeDomain !== yi.DEFAULT_UNIVERSE, a = await this.access.getRequestHeaders(e ?? void 0, this.additionalClaims, o ? n : void 0);
        return { headers: this.addSharedMetadataHeaders(a) };
      }
      else return this.hasAnyScopes() || this.apiKey ? super.getRequestMetadataAsync(e) : { headers: new Headers() };
    }
    async fetchIdToken(e) {
      let t = new pm.GoogleToken({ iss: this.email, sub: this.subject, scope: this.scopes || this.defaultScopes, keyFile: this.keyFile, key: this.key, additionalClaims: { target_audience: e }, transporter: this.transporter });
      if (await t.getToken({ forceRefresh: true }), !t.idToken) throw new Error("Unknown error: Failed to fetch ID token");
      return t.idToken;
    }
    hasUserScopes() {
      return this.scopes ? this.scopes.length > 0 : false;
    }
    hasAnyScopes() {
      return !!(this.scopes && this.scopes.length > 0 || this.defaultScopes && this.defaultScopes.length > 0);
    }
    authorize(e) {
      if (e) this.authorizeAsync().then((t) => e(null, t), e);
      else return this.authorizeAsync();
    }
    async authorizeAsync() {
      let e = await this.refreshToken();
      if (!e) throw new Error("No result returned");
      return this.credentials = e.tokens, this.credentials.refresh_token = "jwt-placeholder", this.key = this.gtoken.key, this.email = this.gtoken.iss, e.tokens;
    }
    async refreshTokenNoCache() {
      let e = this.createGToken(), n = { access_token: (await e.getToken({ forceRefresh: this.isTokenExpiring() })).access_token, token_type: "Bearer", expiry_date: e.expiresAt, id_token: e.idToken };
      return this.emit("tokens", n), { res: null, tokens: n };
    }
    createGToken() {
      return this.gtoken || (this.gtoken = new pm.GoogleToken({ iss: this.email, sub: this.subject, scope: this.scopes || this.defaultScopes, keyFile: this.keyFile, key: this.key, additionalClaims: this.additionalClaims, transporter: this.transporter })), this.gtoken;
    }
    fromJSON(e) {
      if (!e) throw new Error("Must pass in a JSON object containing the service account auth settings.");
      if (!e.client_email) throw new Error("The incoming JSON object does not contain a client_email field");
      if (!e.private_key) throw new Error("The incoming JSON object does not contain a private_key field");
      this.email = e.client_email, this.key = e.private_key, this.keyId = e.private_key_id, this.projectId = e.project_id, this.quotaProjectId = e.quota_project_id, this.universeDomain = e.universe_domain || this.universeDomain;
    }
    fromStream(e, t) {
      if (t) this.fromStreamAsync(e).then(() => t(), t);
      else return this.fromStreamAsync(e);
    }
    fromStreamAsync(e) {
      return new Promise((t, n) => {
        if (!e) throw new Error("Must pass in a stream containing the service account auth settings.");
        let o = "";
        e.setEncoding("utf8").on("error", n).on("data", (a) => o += a).on("end", () => {
          try {
            let a = JSON.parse(o);
            this.fromJSON(a), t();
          } catch (a) {
            n(a);
          }
        });
      });
    }
    fromAPIKey(e) {
      if (typeof e != "string") throw new Error("Must provide an API Key string.");
      this.apiKey = e;
    }
    async getCredentials() {
      if (this.key) return { private_key: this.key, client_email: this.email };
      if (this.keyFile) {
        let t = await this.createGToken().getCredentials(this.keyFile);
        return { private_key: t.privateKey, client_email: t.clientEmail };
      }
      throw new Error("A key or a keyFile must be provided to getCredentials.");
    }
  };
  _i.JWT = dc;
});
var mc = z((Mn) => {
  "use strict";
  Object.defineProperty(Mn, "__esModule", { value: true });
  Mn.UserRefreshClient = Mn.USER_REFRESH_ACCOUNT_TYPE = void 0;
  var _E = nn(), CE = pt();
  Mn.USER_REFRESH_ACCOUNT_TYPE = "authorized_user";
  var pc = class r extends _E.OAuth2Client {
    _refreshToken;
    constructor(e, t, n, o, a) {
      let u = e && typeof e == "object" ? e : { clientId: e, clientSecret: t, refreshToken: n, eagerRefreshThresholdMillis: o, forceRefreshOnFailure: a };
      super(u), this._refreshToken = u.refreshToken, this.credentials.refresh_token = u.refreshToken;
    }
    async refreshTokenNoCache() {
      return super.refreshTokenNoCache(this._refreshToken);
    }
    async fetchIdToken(e) {
      let t = { ...r.RETRY_CONFIG, url: this.endpoints.oauth2TokenUrl, method: "POST", data: new URLSearchParams({ client_id: this._clientId, client_secret: this._clientSecret, grant_type: "refresh_token", refresh_token: this._refreshToken, target_audience: e }) };
      return CE.AuthClient.setMethodName(t, "fetchIdToken"), (await this.transporter.request(t)).data.id_token;
    }
    fromJSON(e) {
      if (!e) throw new Error("Must pass in a JSON object containing the user refresh token");
      if (e.type !== "authorized_user") throw new Error('The incoming JSON object does not have the "authorized_user" type');
      if (!e.client_id) throw new Error("The incoming JSON object does not contain a client_id field");
      if (!e.client_secret) throw new Error("The incoming JSON object does not contain a client_secret field");
      if (!e.refresh_token) throw new Error("The incoming JSON object does not contain a refresh_token field");
      this._clientId = e.client_id, this._clientSecret = e.client_secret, this._refreshToken = e.refresh_token, this.credentials.refresh_token = e.refresh_token, this.quotaProjectId = e.quota_project_id, this.universeDomain = e.universe_domain || this.universeDomain;
    }
    fromStream(e, t) {
      if (t) this.fromStreamAsync(e).then(() => t(), t);
      else return this.fromStreamAsync(e);
    }
    async fromStreamAsync(e) {
      return new Promise((t, n) => {
        if (!e) return n(new Error("Must pass in a stream containing the user refresh token."));
        let o = "";
        e.setEncoding("utf8").on("error", n).on("data", (a) => o += a).on("end", () => {
          try {
            let a = JSON.parse(o);
            return this.fromJSON(a), t();
          } catch (a) {
            return n(a);
          }
        });
      });
    }
    static fromJSON(e) {
      let t = new r();
      return t.fromJSON(e), t;
    }
  };
  Mn.UserRefreshClient = pc;
});
var yc = z(($n) => {
  "use strict";
  Object.defineProperty($n, "__esModule", { value: true });
  $n.Impersonated = $n.IMPERSONATED_ACCOUNT_TYPE = void 0;
  var mm = nn(), bE = Ve(), EE = Lt();
  $n.IMPERSONATED_ACCOUNT_TYPE = "impersonated_service_account";
  var gc = class r extends mm.OAuth2Client {
    sourceClient;
    targetPrincipal;
    targetScopes;
    delegates;
    lifetime;
    endpoint;
    constructor(e = {}) {
      if (super(e), this.credentials = { expiry_date: 1, refresh_token: "impersonated-placeholder" }, this.sourceClient = e.sourceClient ?? new mm.OAuth2Client(), this.targetPrincipal = e.targetPrincipal ?? "", this.delegates = e.delegates ?? [], this.targetScopes = e.targetScopes ?? [], this.lifetime = e.lifetime ?? 3600, !!!(0, EE.originalOrCamelOptions)(e).get("universe_domain")) this.universeDomain = this.sourceClient.universeDomain;
      else if (this.sourceClient.universeDomain !== this.universeDomain) throw new RangeError(`Universe domain ${this.sourceClient.universeDomain} in source credentials does not match ${this.universeDomain} universe domain set for impersonated credentials.`);
      this.endpoint = e.endpoint ?? `https://iamcredentials.${this.universeDomain}`;
    }
    async sign(e) {
      await this.sourceClient.getAccessToken();
      let t = `projects/-/serviceAccounts/${this.targetPrincipal}`, n = `${this.endpoint}/v1/${t}:signBlob`, o = { delegates: this.delegates, payload: Buffer.from(e).toString("base64") };
      return (await this.sourceClient.request({ ...r.RETRY_CONFIG, url: n, data: o, method: "POST" })).data;
    }
    getTargetPrincipal() {
      return this.targetPrincipal;
    }
    async refreshToken() {
      try {
        await this.sourceClient.getAccessToken();
        let e = "projects/-/serviceAccounts/" + this.targetPrincipal, t = `${this.endpoint}/v1/${e}:generateAccessToken`, n = { delegates: this.delegates, scope: this.targetScopes, lifetime: this.lifetime + "s" }, o = await this.sourceClient.request({ ...r.RETRY_CONFIG, url: t, data: n, method: "POST" }), a = o.data;
        return this.credentials.access_token = a.accessToken, this.credentials.expiry_date = Date.parse(a.expireTime), { tokens: this.credentials, res: o };
      } catch (e) {
        if (!(e instanceof Error)) throw e;
        let t = 0, n = "";
        throw e instanceof bE.GaxiosError && (t = e?.response?.data?.error?.status, n = e?.response?.data?.error?.message), t && n ? (e.message = `${t}: unable to impersonate: ${n}`, e) : (e.message = `unable to impersonate: ${e}`, e);
      }
    }
    async fetchIdToken(e, t) {
      await this.sourceClient.getAccessToken();
      let n = `projects/-/serviceAccounts/${this.targetPrincipal}`, o = `${this.endpoint}/v1/${n}:generateIdToken`, a = { delegates: this.delegates, audience: e, includeEmail: t?.includeEmail ?? true, useEmailAzp: t?.includeEmail ?? true };
      return (await this.sourceClient.request({ ...r.RETRY_CONFIG, url: o, data: a, method: "POST" })).data.token;
    }
  };
  $n.Impersonated = gc;
});
var Cc = z((Rs) => {
  "use strict";
  Object.defineProperty(Rs, "__esModule", { value: true });
  Rs.OAuthClientAuthHandler = void 0;
  Rs.getErrorFromOAuthErrorResponse = DE;
  var Hn = Ve(), wE = _s(), AE = ["PUT", "POST", "PATCH"], _c = class {
    #e = (0, wE.createCrypto)();
    #t;
    transporter;
    constructor(e) {
      e && "clientId" in e ? (this.#t = e, this.transporter = new Hn.Gaxios()) : (this.#t = e?.clientAuthentication, this.transporter = e?.transporter || new Hn.Gaxios());
    }
    applyClientAuthenticationOptions(e, t) {
      e.headers = Hn.Gaxios.mergeHeaders(e.headers), this.injectAuthenticatedHeaders(e, t), t || this.injectAuthenticatedRequestBody(e);
    }
    injectAuthenticatedHeaders(e, t) {
      if (t) e.headers = Hn.Gaxios.mergeHeaders(e.headers, { authorization: `Bearer ${t}` });
      else if (this.#t?.confidentialClientType === "basic") {
        e.headers = Hn.Gaxios.mergeHeaders(e.headers);
        let n = this.#t.clientId, o = this.#t.clientSecret || "", a = this.#e.encodeBase64StringUtf8(`${n}:${o}`);
        Hn.Gaxios.mergeHeaders(e.headers, { authorization: `Basic ${a}` });
      }
    }
    injectAuthenticatedRequestBody(e) {
      if (this.#t?.confidentialClientType === "request-body") {
        let t = (e.method || "GET").toUpperCase();
        if (!AE.includes(t)) throw new Error(`${t} HTTP method does not support ${this.#t.confidentialClientType} client authentication`);
        let o = new Headers(e.headers).get("content-type");
        if (o?.startsWith("application/x-www-form-urlencoded") || e.data instanceof URLSearchParams) {
          let a = new URLSearchParams(e.data ?? "");
          a.append("client_id", this.#t.clientId), a.append("client_secret", this.#t.clientSecret || ""), e.data = a;
        } else if (o?.startsWith("application/json")) e.data = e.data || {}, Object.assign(e.data, { client_id: this.#t.clientId, client_secret: this.#t.clientSecret || "" });
        else throw new Error(`${o} content-types are not supported with ${this.#t.confidentialClientType} client authentication`);
      }
    }
    static get RETRY_CONFIG() {
      return { retry: true, retryConfig: { httpMethodsToRetry: ["GET", "PUT", "POST", "HEAD", "OPTIONS", "DELETE"] } };
    }
  };
  Rs.OAuthClientAuthHandler = _c;
  function DE(r, e) {
    let t = r.error, n = r.error_description, o = r.error_uri, a = `Error code ${t}`;
    typeof n < "u" && (a += `: ${n}`), typeof o < "u" && (a += ` - ${o}`);
    let u = new Error(a);
    if (e) {
      let l = Object.keys(e);
      e.stack && l.push("stack"), l.forEach((f) => {
        f !== "message" && Object.defineProperty(u, f, { value: e[f], writable: false, enumerable: true });
      });
    }
    return u;
  }
});
var bi = z((Ci) => {
  "use strict";
  Object.defineProperty(Ci, "__esModule", { value: true });
  Ci.StsCredentials = void 0;
  var SE = Ve(), vE = pt(), gm = Cc(), TE = Lt(), bc = class r extends gm.OAuthClientAuthHandler {
    #e;
    constructor(e = { tokenExchangeEndpoint: "" }, t) {
      (typeof e != "object" || e instanceof URL) && (e = { tokenExchangeEndpoint: e, clientAuthentication: t }), super(e), this.#e = e.tokenExchangeEndpoint;
    }
    async exchangeToken(e, t, n) {
      let o = { grant_type: e.grantType, resource: e.resource, audience: e.audience, scope: e.scope?.join(" "), requested_token_type: e.requestedTokenType, subject_token: e.subjectToken, subject_token_type: e.subjectTokenType, actor_token: e.actingParty?.actorToken, actor_token_type: e.actingParty?.actorTokenType, options: n && JSON.stringify(n) }, a = { ...r.RETRY_CONFIG, url: this.#e.toString(), method: "POST", headers: t, data: new URLSearchParams((0, TE.removeUndefinedValuesInObject)(o)) };
      vE.AuthClient.setMethodName(a, "exchangeToken"), this.applyClientAuthenticationOptions(a);
      try {
        let u = await this.transporter.request(a), l = u.data;
        return l.res = u, l;
      } catch (u) {
        throw u instanceof SE.GaxiosError && u.response ? (0, gm.getErrorFromOAuthErrorResponse)(u.response.data, u) : u;
      }
    }
  };
  Ci.StsCredentials = bc;
});
var Nr = z((Tt) => {
  "use strict";
  Object.defineProperty(Tt, "__esModule", { value: true });
  Tt.BaseExternalAccountClient = Tt.CLOUD_RESOURCE_MANAGER = Tt.EXTERNAL_ACCOUNT_TYPE = Tt.EXPIRATION_TIME_OFFSET = void 0;
  var RE = Ve(), FE = Y("stream"), Ec = pt(), kE = bi(), ym = Lt(), OE = Nu(), PE = "urn:ietf:params:oauth:grant-type:token-exchange", xE = "urn:ietf:params:oauth:token-type:access_token", wc = "https://www.googleapis.com/auth/cloud-platform", BE = 3600;
  Tt.EXPIRATION_TIME_OFFSET = 5 * 60 * 1e3;
  Tt.EXTERNAL_ACCOUNT_TYPE = "external_account";
  Tt.CLOUD_RESOURCE_MANAGER = "https://cloudresourcemanager.googleapis.com/v1/projects/";
  var IE = "//iam\\.googleapis\\.com/locations/[^/]+/workforcePools/[^/]+/providers/.+", NE = "https://sts.{universeDomain}/v1/token", Ac = class r extends Ec.AuthClient {
    scopes;
    projectNumber;
    audience;
    subjectTokenType;
    stsCredential;
    clientAuth;
    credentialSourceType;
    cachedAccessToken;
    serviceAccountImpersonationUrl;
    serviceAccountImpersonationLifetime;
    workforcePoolUserProject;
    configLifetimeRequested;
    tokenUrl;
    cloudResourceManagerURL;
    supplierContext;
    #e = null;
    constructor(e) {
      super(e);
      let t = (0, ym.originalOrCamelOptions)(e), n = t.get("type");
      if (n && n !== Tt.EXTERNAL_ACCOUNT_TYPE) throw new Error(`Expected "${Tt.EXTERNAL_ACCOUNT_TYPE}" type but received "${e.type}"`);
      let o = t.get("client_id"), a = t.get("client_secret");
      this.tokenUrl = t.get("token_url") ?? NE.replace("{universeDomain}", this.universeDomain);
      let u = t.get("subject_token_type"), l = t.get("workforce_pool_user_project"), f = t.get("service_account_impersonation_url"), d = t.get("service_account_impersonation"), h = (0, ym.originalOrCamelOptions)(d).get("token_lifetime_seconds");
      this.cloudResourceManagerURL = new URL(t.get("cloud_resource_manager_url") || `https://cloudresourcemanager.${this.universeDomain}/v1/projects/`), o && (this.clientAuth = { confidentialClientType: "basic", clientId: o, clientSecret: a }), this.stsCredential = new kE.StsCredentials({ tokenExchangeEndpoint: this.tokenUrl, clientAuthentication: this.clientAuth }), this.scopes = t.get("scopes") || [wc], this.cachedAccessToken = null, this.audience = t.get("audience"), this.subjectTokenType = u, this.workforcePoolUserProject = l;
      let C = new RegExp(IE);
      if (this.workforcePoolUserProject && !this.audience.match(C)) throw new Error("workforcePoolUserProject should not be set for non-workforce pool credentials.");
      this.serviceAccountImpersonationUrl = f, this.serviceAccountImpersonationLifetime = h, this.serviceAccountImpersonationLifetime ? this.configLifetimeRequested = true : (this.configLifetimeRequested = false, this.serviceAccountImpersonationLifetime = BE), this.projectNumber = this.getProjectNumber(this.audience), this.supplierContext = { audience: this.audience, subjectTokenType: this.subjectTokenType, transporter: this.transporter };
    }
    getServiceAccountEmail() {
      if (this.serviceAccountImpersonationUrl) {
        if (this.serviceAccountImpersonationUrl.length > 256) throw new RangeError(`URL is too long: ${this.serviceAccountImpersonationUrl}`);
        return /serviceAccounts\/(?<email>[^:]+):generateAccessToken$/.exec(this.serviceAccountImpersonationUrl)?.groups?.email || null;
      }
      return null;
    }
    setCredentials(e) {
      super.setCredentials(e), this.cachedAccessToken = e;
    }
    async getAccessToken() {
      return (!this.cachedAccessToken || this.isExpired(this.cachedAccessToken)) && await this.refreshAccessTokenAsync(), { token: this.cachedAccessToken.access_token, res: this.cachedAccessToken.res };
    }
    async getRequestHeaders() {
      let e = await this.getAccessToken(), t = new Headers({ authorization: `Bearer ${e.token}` });
      return this.addSharedMetadataHeaders(t);
    }
    request(e, t) {
      if (t) this.requestAsync(e).then((n) => t(null, n), (n) => t(n, n.response));
      else return this.requestAsync(e);
    }
    async getProjectId() {
      let e = this.projectNumber || this.workforcePoolUserProject;
      if (this.projectId) return this.projectId;
      if (e) {
        let t = await this.getRequestHeaders(), n = { ...r.RETRY_CONFIG, headers: t, url: `${this.cloudResourceManagerURL.toString()}${e}` };
        Ec.AuthClient.setMethodName(n, "getProjectId");
        let o = await this.transporter.request(n);
        return this.projectId = o.data.projectId, this.projectId;
      }
      return null;
    }
    async requestAsync(e, t = false) {
      let n;
      try {
        let o = await this.getRequestHeaders();
        e.headers = RE.Gaxios.mergeHeaders(e.headers), this.addUserProjectAndAuthHeaders(e.headers, o), n = await this.transporter.request(e);
      } catch (o) {
        let a = o.response;
        if (a) {
          let u = a.status, l = a.config.data instanceof FE.Readable;
          if (!t && (u === 401 || u === 403) && !l && this.forceRefreshOnFailure) return await this.refreshAccessTokenAsync(), await this.requestAsync(e, true);
        }
        throw o;
      }
      return n;
    }
    async refreshAccessTokenAsync() {
      this.#e = this.#e || this.#t();
      try {
        return await this.#e;
      } finally {
        this.#e = null;
      }
    }
    async #t() {
      let e = await this.retrieveSubjectToken(), t = { grantType: PE, audience: this.audience, requestedTokenType: xE, subjectToken: e, subjectTokenType: this.subjectTokenType, scope: this.serviceAccountImpersonationUrl ? [wc] : this.getScopesArray() }, n = !this.clientAuth && this.workforcePoolUserProject ? { userProject: this.workforcePoolUserProject } : void 0, o = new Headers({ "x-goog-api-client": this.getMetricsHeaderValue() }), a = await this.stsCredential.exchangeToken(t, o, n);
      return this.serviceAccountImpersonationUrl ? this.cachedAccessToken = await this.getImpersonatedAccessToken(a.access_token) : a.expires_in ? this.cachedAccessToken = { access_token: a.access_token, expiry_date: (/* @__PURE__ */ new Date()).getTime() + a.expires_in * 1e3, res: a.res } : this.cachedAccessToken = { access_token: a.access_token, res: a.res }, this.credentials = {}, Object.assign(this.credentials, this.cachedAccessToken), delete this.credentials.res, this.emit("tokens", { refresh_token: null, expiry_date: this.cachedAccessToken.expiry_date, access_token: this.cachedAccessToken.access_token, token_type: "Bearer", id_token: null }), this.cachedAccessToken;
    }
    getProjectNumber(e) {
      let t = e.match(/\/projects\/([^/]+)/);
      return t ? t[1] : null;
    }
    async getImpersonatedAccessToken(e) {
      let t = { ...r.RETRY_CONFIG, url: this.serviceAccountImpersonationUrl, method: "POST", headers: { "content-type": "application/json", authorization: `Bearer ${e}` }, data: { scope: this.getScopesArray(), lifetime: this.serviceAccountImpersonationLifetime + "s" } };
      Ec.AuthClient.setMethodName(t, "getImpersonatedAccessToken");
      let n = await this.transporter.request(t), o = n.data;
      return { access_token: o.accessToken, expiry_date: new Date(o.expireTime).getTime(), res: n };
    }
    isExpired(e) {
      let t = (/* @__PURE__ */ new Date()).getTime();
      return e.expiry_date ? t >= e.expiry_date - this.eagerRefreshThresholdMillis : false;
    }
    getScopesArray() {
      return typeof this.scopes == "string" ? [this.scopes] : this.scopes || [wc];
    }
    getMetricsHeaderValue() {
      let e = process.version.replace(/^v/, ""), t = this.serviceAccountImpersonationUrl !== void 0, n = this.credentialSourceType ? this.credentialSourceType : "unknown";
      return `gl-node/${e} auth/${OE.pkg.version} google-byoid-sdk source/${n} sa-impersonation/${t} config-lifetime/${this.configLifetimeRequested}`;
    }
    getTokenUrl() {
      return this.tokenUrl;
    }
  };
  Tt.BaseExternalAccountClient = Ac;
});
var _m = z((Ei) => {
  "use strict";
  Object.defineProperty(Ei, "__esModule", { value: true });
  Ei.FileSubjectTokenSupplier = void 0;
  var Sc = Y("util"), vc = Y("fs"), qE = (0, Sc.promisify)(vc.readFile ?? (() => {
  })), jE = (0, Sc.promisify)(vc.realpath ?? (() => {
  })), LE = (0, Sc.promisify)(vc.lstat ?? (() => {
  })), Dc = class {
    filePath;
    formatType;
    subjectTokenFieldName;
    constructor(e) {
      this.filePath = e.filePath, this.formatType = e.formatType, this.subjectTokenFieldName = e.subjectTokenFieldName;
    }
    async getSubjectToken() {
      let e = this.filePath;
      try {
        if (e = await jE(e), !(await LE(e)).isFile()) throw new Error();
      } catch (o) {
        throw o instanceof Error && (o.message = `The file at ${e} does not exist, or it is not a file. ${o.message}`), o;
      }
      let t, n = await qE(e, { encoding: "utf8" });
      if (this.formatType === "text" ? t = n : this.formatType === "json" && this.subjectTokenFieldName && (t = JSON.parse(n)[this.subjectTokenFieldName]), !t) throw new Error("Unable to parse the subject_token from the credential_source file");
      return t;
    }
  };
  Ei.FileSubjectTokenSupplier = Dc;
});
var Cm = z((wi) => {
  "use strict";
  Object.defineProperty(wi, "__esModule", { value: true });
  wi.UrlSubjectTokenSupplier = void 0;
  var UE = pt(), Tc = class {
    url;
    headers;
    formatType;
    subjectTokenFieldName;
    additionalGaxiosOptions;
    constructor(e) {
      this.url = e.url, this.formatType = e.formatType, this.subjectTokenFieldName = e.subjectTokenFieldName, this.headers = e.headers, this.additionalGaxiosOptions = e.additionalGaxiosOptions;
    }
    async getSubjectToken(e) {
      let t = { ...this.additionalGaxiosOptions, url: this.url, method: "GET", headers: this.headers };
      UE.AuthClient.setMethodName(t, "getSubjectToken");
      let n;
      if (this.formatType === "text" ? n = (await e.transporter.request(t)).data : this.formatType === "json" && this.subjectTokenFieldName && (n = (await e.transporter.request(t)).data[this.subjectTokenFieldName]), !n) throw new Error("Unable to parse the subject_token from the credential_source URL");
      return n;
    }
  };
  wi.UrlSubjectTokenSupplier = Tc;
});
var bm = z((_t) => {
  "use strict";
  Object.defineProperty(_t, "__esModule", { value: true });
  _t.CertificateSubjectTokenSupplier = _t.InvalidConfigurationError = _t.CertificateSourceUnavailableError = _t.CERTIFICATE_CONFIGURATION_ENV_VARIABLE = void 0;
  var Ai = Lt(), Di = Y("fs"), Si = Y("crypto"), ME = Y("https");
  _t.CERTIFICATE_CONFIGURATION_ENV_VARIABLE = "GOOGLE_API_CERTIFICATE_CONFIG";
  var Qt = class extends Error {
    constructor(e) {
      super(e), this.name = "CertificateSourceUnavailableError";
    }
  };
  _t.CertificateSourceUnavailableError = Qt;
  var Rt = class extends Error {
    constructor(e) {
      super(e), this.name = "InvalidConfigurationError";
    }
  };
  _t.InvalidConfigurationError = Rt;
  var Rc = class {
    certificateConfigPath;
    trustChainPath;
    cert;
    key;
    constructor(e) {
      if (!e.useDefaultCertificateConfig && !e.certificateConfigLocation) throw new Rt("Either `useDefaultCertificateConfig` must be true or a `certificateConfigLocation` must be provided.");
      if (e.useDefaultCertificateConfig && e.certificateConfigLocation) throw new Rt("Both `useDefaultCertificateConfig` and `certificateConfigLocation` cannot be provided.");
      this.trustChainPath = e.trustChainPath, this.certificateConfigPath = e.certificateConfigLocation ?? "";
    }
    async createMtlsHttpsAgent() {
      if (!this.key || !this.cert) throw new Rt("Cannot create mTLS Agent with missing certificate or key");
      return new ME.Agent({ key: this.key, cert: this.cert });
    }
    async getSubjectToken() {
      this.certificateConfigPath = await this.#e();
      let { certPath: e, keyPath: t } = await this.#t();
      return { cert: this.cert, key: this.key } = await this.#r(e, t), await this.#n(this.cert);
    }
    async #e() {
      let e = this.certificateConfigPath;
      if (e) {
        if (await (0, Ai.isValidFile)(e)) return e;
        throw new Qt(`Provided certificate config path is invalid: ${e}`);
      }
      let t = process.env[_t.CERTIFICATE_CONFIGURATION_ENV_VARIABLE];
      if (t) {
        if (await (0, Ai.isValidFile)(t)) return t;
        throw new Qt(`Path from environment variable "${_t.CERTIFICATE_CONFIGURATION_ENV_VARIABLE}" is invalid: ${t}`);
      }
      let n = (0, Ai.getWellKnownCertificateConfigFileLocation)();
      if (await (0, Ai.isValidFile)(n)) return n;
      throw new Qt(`Could not find certificate configuration file. Searched override path, the "${_t.CERTIFICATE_CONFIGURATION_ENV_VARIABLE}" env var, and the gcloud path (${n}).`);
    }
    async #t() {
      let e = this.certificateConfigPath, t;
      try {
        t = await Di.promises.readFile(e, "utf8");
      } catch {
        throw new Qt(`Failed to read certificate config file at: ${e}`);
      }
      try {
        let n = JSON.parse(t), o = n?.cert_configs?.workload?.cert_path, a = n?.cert_configs?.workload?.key_path;
        if (!o || !a) throw new Rt(`Certificate config file (${e}) is missing required "cert_path" or "key_path" in the workload config.`);
        return { certPath: o, keyPath: a };
      } catch (n) {
        throw n instanceof Rt ? n : new Rt(`Failed to parse certificate config from ${e}: ${n.message}`);
      }
    }
    async #r(e, t) {
      let n, o;
      try {
        n = await Di.promises.readFile(e), new Si.X509Certificate(n);
      } catch (a) {
        let u = a instanceof Error ? a.message : String(a);
        throw new Qt(`Failed to read certificate file at ${e}: ${u}`);
      }
      try {
        o = await Di.promises.readFile(t), (0, Si.createPrivateKey)(o);
      } catch (a) {
        let u = a instanceof Error ? a.message : String(a);
        throw new Qt(`Failed to read private key file at ${t}: ${u}`);
      }
      return { cert: n, key: o };
    }
    async #n(e) {
      let t = new Si.X509Certificate(e);
      if (!this.trustChainPath) return JSON.stringify([t.raw.toString("base64")]);
      try {
        let a = ((await Di.promises.readFile(this.trustChainPath, "utf8")).match(/-----BEGIN CERTIFICATE-----[^-]+-----END CERTIFICATE-----/g) ?? []).map((f, d) => {
          try {
            return new Si.X509Certificate(f);
          } catch (h) {
            let C = h instanceof Error ? h.message : String(h);
            throw new Rt(`Failed to parse certificate at index ${d} in trust chain file ${this.trustChainPath}: ${C}`);
          }
        }), u = a.findIndex((f) => t.raw.equals(f.raw)), l;
        if (u === -1) l = [t, ...a];
        else if (u === 0) l = a;
        else throw new Rt(`Leaf certificate exists in the trust chain but is not the first entry (found at index ${u}).`);
        return JSON.stringify(l.map((f) => f.raw.toString("base64")));
      } catch (n) {
        if (n instanceof Rt) throw n;
        let o = n instanceof Error ? n.message : String(n);
        throw new Qt(`Failed to process certificate chain from ${this.trustChainPath}: ${o}`);
      }
    }
  };
  _t.CertificateSubjectTokenSupplier = Rc;
});
var Oc = z((vi) => {
  "use strict";
  Object.defineProperty(vi, "__esModule", { value: true });
  vi.IdentityPoolClient = void 0;
  var $E = Nr(), Fc = Lt(), HE = _m(), GE = Cm(), Em = bm(), WE = bi(), wm = Ve(), kc = class r extends $E.BaseExternalAccountClient {
    subjectTokenSupplier;
    constructor(e) {
      super(e);
      let t = (0, Fc.originalOrCamelOptions)(e), n = t.get("credential_source"), o = t.get("subject_token_supplier");
      if (!n && !o) throw new Error("A credential source or subject token supplier must be specified.");
      if (n && o) throw new Error("Only one of credential source or subject token supplier can be specified.");
      if (o) this.subjectTokenSupplier = o, this.credentialSourceType = "programmatic";
      else {
        let a = (0, Fc.originalOrCamelOptions)(n), u = (0, Fc.originalOrCamelOptions)(a.get("format")), l = u.get("type") || "text", f = u.get("subject_token_field_name");
        if (l !== "json" && l !== "text") throw new Error(`Invalid credential_source format "${l}"`);
        if (l === "json" && !f) throw new Error("Missing subject_token_field_name for JSON credential_source format");
        let d = a.get("file"), h = a.get("url"), C = a.get("certificate"), w = a.get("headers");
        if (d && h || h && C || d && C) throw new Error('No valid Identity Pool "credential_source" provided, must be either file, url, or certificate.');
        if (d) this.credentialSourceType = "file", this.subjectTokenSupplier = new HE.FileSubjectTokenSupplier({ filePath: d, formatType: l, subjectTokenFieldName: f });
        else if (h) this.credentialSourceType = "url", this.subjectTokenSupplier = new GE.UrlSubjectTokenSupplier({ url: h, formatType: l, subjectTokenFieldName: f, headers: w, additionalGaxiosOptions: r.RETRY_CONFIG });
        else if (C) {
          this.credentialSourceType = "certificate";
          let I = new Em.CertificateSubjectTokenSupplier({ useDefaultCertificateConfig: C.use_default_certificate_config, certificateConfigLocation: C.certificate_config_location, trustChainPath: C.trust_chain_path });
          this.subjectTokenSupplier = I;
        } else throw new Error('No valid Identity Pool "credential_source" provided, must be either file, url, or certificate.');
      }
    }
    async retrieveSubjectToken() {
      let e = await this.subjectTokenSupplier.getSubjectToken(this.supplierContext);
      if (this.subjectTokenSupplier instanceof Em.CertificateSubjectTokenSupplier) {
        let t = await this.subjectTokenSupplier.createMtlsHttpsAgent();
        this.stsCredential = new WE.StsCredentials({ tokenExchangeEndpoint: this.getTokenUrl(), clientAuthentication: this.clientAuth, transporter: new wm.Gaxios({ agent: t }) }), this.transporter = new wm.Gaxios({ ...this.transporter.defaults || {}, agent: t });
      }
      return e;
    }
  };
  vi.IdentityPoolClient = kc;
});
var xc = z((Ri) => {
  "use strict";
  Object.defineProperty(Ri, "__esModule", { value: true });
  Ri.AwsRequestSigner = void 0;
  var Ti = Ve(), Dm = _s(), Am = "AWS4-HMAC-SHA256", zE = "aws4_request", Pc = class {
    getCredentials;
    region;
    crypto;
    constructor(e, t) {
      this.getCredentials = e, this.region = t, this.crypto = (0, Dm.createCrypto)();
    }
    async getRequestOptions(e) {
      if (!e.url) throw new RangeError('"url" is required in "amzOptions"');
      let t = typeof e.data == "object" ? JSON.stringify(e.data) : e.data, n = e.url, o = e.method || "GET", a = e.body || t, u = e.headers, l = await this.getCredentials(), f = new URL(n);
      if (typeof a != "string" && a !== void 0) throw new TypeError(`'requestPayload' is expected to be a string if provided. Got: ${a}`);
      let d = await VE({ crypto: this.crypto, host: f.host, canonicalUri: f.pathname, canonicalQuerystring: f.search.slice(1), method: o, region: this.region, securityCredentials: l, requestPayload: a, additionalAmzHeaders: u }), h = Ti.Gaxios.mergeHeaders(d.amzDate ? { "x-amz-date": d.amzDate } : {}, { authorization: d.authorizationHeader, host: f.host }, u || {});
      l.token && Ti.Gaxios.mergeHeaders(h, { "x-amz-security-token": l.token });
      let C = { url: n, method: o, headers: h };
      return a !== void 0 && (C.body = a), C;
    }
  };
  Ri.AwsRequestSigner = Pc;
  async function Fs(r, e, t) {
    return await r.signWithHmacSha256(e, t);
  }
  async function JE(r, e, t, n, o) {
    let a = await Fs(r, `AWS4${e}`, t), u = await Fs(r, a, n), l = await Fs(r, u, o);
    return await Fs(r, l, "aws4_request");
  }
  async function VE(r) {
    let e = Ti.Gaxios.mergeHeaders(r.additionalAmzHeaders), t = r.requestPayload || "", n = r.host.split(".")[0], o = /* @__PURE__ */ new Date(), a = o.toISOString().replace(/[-:]/g, "").replace(/\.[0-9]+/, ""), u = o.toISOString().replace(/[-]/g, "").replace(/T.*/, "");
    r.securityCredentials.token && e.set("x-amz-security-token", r.securityCredentials.token);
    let l = Ti.Gaxios.mergeHeaders({ host: r.host }, e.has("date") ? {} : { "x-amz-date": a }, e), f = "", d = [...l.keys()].sort();
    d.forEach((T) => {
      f += `${T}:${l.get(T)}
`;
    });
    let h = d.join(";"), C = await r.crypto.sha256DigestHex(t), w = `${r.method.toUpperCase()}
${r.canonicalUri}
${r.canonicalQuerystring}
${f}
${h}
${C}`, I = `${u}/${r.region}/${n}/${zE}`, S = `${Am}
${a}
${I}
` + await r.crypto.sha256DigestHex(w), b = await JE(r.crypto, r.securityCredentials.secretAccessKey, u, r.region, n), _ = await Fs(r.crypto, b, S), y = `${Am} Credential=${r.securityCredentials.accessKeyId}/${I}, SignedHeaders=${h}, Signature=${(0, Dm.fromArrayBufferToHex)(_)}`;
    return { amzDate: e.has("date") ? void 0 : a, authorizationHeader: y, canonicalQuerystring: r.canonicalQuerystring };
  }
});
var Sm = z((ki) => {
  "use strict";
  Object.defineProperty(ki, "__esModule", { value: true });
  ki.DefaultAwsSecurityCredentialsSupplier = void 0;
  var Fi = pt(), Bc = class {
    regionUrl;
    securityCredentialsUrl;
    imdsV2SessionTokenUrl;
    additionalGaxiosOptions;
    constructor(e) {
      this.regionUrl = e.regionUrl, this.securityCredentialsUrl = e.securityCredentialsUrl, this.imdsV2SessionTokenUrl = e.imdsV2SessionTokenUrl, this.additionalGaxiosOptions = e.additionalGaxiosOptions;
    }
    async getAwsRegion(e) {
      if (this.#n) return this.#n;
      let t = new Headers();
      if (!this.#n && this.imdsV2SessionTokenUrl && t.set("x-aws-ec2-metadata-token", await this.#e(e.transporter)), !this.regionUrl) throw new RangeError('Unable to determine AWS region due to missing "options.credential_source.region_url"');
      let n = { ...this.additionalGaxiosOptions, url: this.regionUrl, method: "GET", headers: t };
      Fi.AuthClient.setMethodName(n, "getAwsRegion");
      let o = await e.transporter.request(n);
      return o.data.substr(0, o.data.length - 1);
    }
    async getAwsSecurityCredentials(e) {
      if (this.#s) return this.#s;
      let t = new Headers();
      this.imdsV2SessionTokenUrl && t.set("x-aws-ec2-metadata-token", await this.#e(e.transporter));
      let n = await this.#t(t, e.transporter), o = await this.#r(n, t, e.transporter);
      return { accessKeyId: o.AccessKeyId, secretAccessKey: o.SecretAccessKey, token: o.Token };
    }
    async #e(e) {
      let t = { ...this.additionalGaxiosOptions, url: this.imdsV2SessionTokenUrl, method: "PUT", headers: { "x-aws-ec2-metadata-token-ttl-seconds": "300" } };
      return Fi.AuthClient.setMethodName(t, "#getImdsV2SessionToken"), (await e.request(t)).data;
    }
    async #t(e, t) {
      if (!this.securityCredentialsUrl) throw new Error('Unable to determine AWS role name due to missing "options.credential_source.url"');
      let n = { ...this.additionalGaxiosOptions, url: this.securityCredentialsUrl, method: "GET", headers: e };
      return Fi.AuthClient.setMethodName(n, "#getAwsRoleName"), (await t.request(n)).data;
    }
    async #r(e, t, n) {
      let o = { ...this.additionalGaxiosOptions, url: `${this.securityCredentialsUrl}/${e}`, headers: t };
      return Fi.AuthClient.setMethodName(o, "#retrieveAwsSecurityCredentials"), (await n.request(o)).data;
    }
    get #n() {
      return process.env.AWS_REGION || process.env.AWS_DEFAULT_REGION || null;
    }
    get #s() {
      return process.env.AWS_ACCESS_KEY_ID && process.env.AWS_SECRET_ACCESS_KEY ? { accessKeyId: process.env.AWS_ACCESS_KEY_ID, secretAccessKey: process.env.AWS_SECRET_ACCESS_KEY, token: process.env.AWS_SESSION_TOKEN } : null;
    }
  };
  ki.DefaultAwsSecurityCredentialsSupplier = Bc;
});
var Nc = z((Oi) => {
  "use strict";
  Object.defineProperty(Oi, "__esModule", { value: true });
  Oi.AwsClient = void 0;
  var KE = xc(), YE = Nr(), XE = Sm(), vm = Lt(), QE = Ve(), Ic = class r extends YE.BaseExternalAccountClient {
    environmentId;
    awsSecurityCredentialsSupplier;
    regionalCredVerificationUrl;
    awsRequestSigner;
    region;
    static #e = "https://sts.{region}.amazonaws.com?Action=GetCallerIdentity&Version=2011-06-15";
    static AWS_EC2_METADATA_IPV4_ADDRESS = "169.254.169.254";
    static AWS_EC2_METADATA_IPV6_ADDRESS = "fd00:ec2::254";
    constructor(e) {
      super(e);
      let t = (0, vm.originalOrCamelOptions)(e), n = t.get("credential_source"), o = t.get("aws_security_credentials_supplier");
      if (!n && !o) throw new Error("A credential source or AWS security credentials supplier must be specified.");
      if (n && o) throw new Error("Only one of credential source or AWS security credentials supplier can be specified.");
      if (o) this.awsSecurityCredentialsSupplier = o, this.regionalCredVerificationUrl = r.#e, this.credentialSourceType = "programmatic";
      else {
        let a = (0, vm.originalOrCamelOptions)(n);
        this.environmentId = a.get("environment_id");
        let u = a.get("region_url"), l = a.get("url"), f = a.get("imdsv2_session_token_url");
        this.awsSecurityCredentialsSupplier = new XE.DefaultAwsSecurityCredentialsSupplier({ regionUrl: u, securityCredentialsUrl: l, imdsV2SessionTokenUrl: f }), this.regionalCredVerificationUrl = a.get("regional_cred_verification_url"), this.credentialSourceType = "aws", this.validateEnvironmentId();
      }
      this.awsRequestSigner = null, this.region = "";
    }
    validateEnvironmentId() {
      let e = this.environmentId?.match(/^(aws)(\d+)$/);
      if (!e || !this.regionalCredVerificationUrl) throw new Error('No valid AWS "credential_source" provided');
      if (parseInt(e[2], 10) !== 1) throw new Error(`aws version "${e[2]}" is not supported in the current build.`);
    }
    async retrieveSubjectToken() {
      this.awsRequestSigner || (this.region = await this.awsSecurityCredentialsSupplier.getAwsRegion(this.supplierContext), this.awsRequestSigner = new KE.AwsRequestSigner(async () => this.awsSecurityCredentialsSupplier.getAwsSecurityCredentials(this.supplierContext), this.region));
      let e = await this.awsRequestSigner.getRequestOptions({ ...r.RETRY_CONFIG, url: this.regionalCredVerificationUrl.replace("{region}", this.region), method: "POST" }), t = [];
      return QE.Gaxios.mergeHeaders({ "x-goog-cloud-target-resource": this.audience }, e.headers).forEach((o, a) => t.push({ key: a, value: o })), encodeURIComponent(JSON.stringify({ url: e.url, method: e.method, headers: t }));
    }
  };
  Oi.AwsClient = Ic;
});
var Mc = z((je) => {
  "use strict";
  Object.defineProperty(je, "__esModule", { value: true });
  je.InvalidSubjectTokenError = je.InvalidMessageFieldError = je.InvalidCodeFieldError = je.InvalidTokenTypeFieldError = je.InvalidExpirationTimeFieldError = je.InvalidSuccessFieldError = je.InvalidVersionFieldError = je.ExecutableResponseError = je.ExecutableResponse = void 0;
  var Pi = "urn:ietf:params:oauth:token-type:saml2", qc = "urn:ietf:params:oauth:token-type:id_token", jc = "urn:ietf:params:oauth:token-type:jwt", Lc = class {
    version;
    success;
    expirationTime;
    tokenType;
    errorCode;
    errorMessage;
    subjectToken;
    constructor(e) {
      if (!e.version) throw new xi("Executable response must contain a 'version' field.");
      if (e.success === void 0) throw new Bi("Executable response must contain a 'success' field.");
      if (this.version = e.version, this.success = e.success, this.success) {
        if (this.expirationTime = e.expiration_time, this.tokenType = e.token_type, this.tokenType !== Pi && this.tokenType !== qc && this.tokenType !== jc) throw new Ii(`Executable response must contain a 'token_type' field when successful and it must be one of ${qc}, ${jc}, or ${Pi}.`);
        if (this.tokenType === Pi) {
          if (!e.saml_response) throw new ks(`Executable response must contain a 'saml_response' field when token_type=${Pi}.`);
          this.subjectToken = e.saml_response;
        } else {
          if (!e.id_token) throw new ks(`Executable response must contain a 'id_token' field when token_type=${qc} or ${jc}.`);
          this.subjectToken = e.id_token;
        }
      } else {
        if (!e.code) throw new Ni("Executable response must contain a 'code' field when unsuccessful.");
        if (!e.message) throw new qi("Executable response must contain a 'message' field when unsuccessful.");
        this.errorCode = e.code, this.errorMessage = e.message;
      }
    }
    isValid() {
      return !this.isExpired() && this.success;
    }
    isExpired() {
      return this.expirationTime !== void 0 && this.expirationTime < Math.round(Date.now() / 1e3);
    }
  };
  je.ExecutableResponse = Lc;
  var Zt = class extends Error {
    constructor(e) {
      super(e), Object.setPrototypeOf(this, new.target.prototype);
    }
  };
  je.ExecutableResponseError = Zt;
  var xi = class extends Zt {
  };
  je.InvalidVersionFieldError = xi;
  var Bi = class extends Zt {
  };
  je.InvalidSuccessFieldError = Bi;
  var Uc = class extends Zt {
  };
  je.InvalidExpirationTimeFieldError = Uc;
  var Ii = class extends Zt {
  };
  je.InvalidTokenTypeFieldError = Ii;
  var Ni = class extends Zt {
  };
  je.InvalidCodeFieldError = Ni;
  var qi = class extends Zt {
  };
  je.InvalidMessageFieldError = qi;
  var ks = class extends Zt {
  };
  je.InvalidSubjectTokenError = ks;
});
var Gc = z((Gn) => {
  "use strict";
  Object.defineProperty(Gn, "__esModule", { value: true });
  Gn.PluggableAuthHandler = Gn.ExecutableError = void 0;
  var sn = Mc(), ZE = Y("child_process"), $c = Y("fs"), ji = class extends Error {
    code;
    constructor(e, t) {
      super(`The executable failed with exit code: ${t} and error message: ${e}.`), this.code = t, Object.setPrototypeOf(this, new.target.prototype);
    }
  };
  Gn.ExecutableError = ji;
  var Hc = class r {
    commandComponents;
    timeoutMillis;
    outputFile;
    constructor(e) {
      if (!e.command) throw new Error("No command provided.");
      if (this.commandComponents = r.parseCommand(e.command), this.timeoutMillis = e.timeoutMillis, !this.timeoutMillis) throw new Error("No timeoutMillis provided.");
      this.outputFile = e.outputFile;
    }
    retrieveResponseFromExecutable(e) {
      return new Promise((t, n) => {
        let o = ZE.spawn(this.commandComponents[0], this.commandComponents.slice(1), { env: { ...process.env, ...Object.fromEntries(e) } }), a = "";
        o.stdout.on("data", (l) => {
          a += l;
        }), o.stderr.on("data", (l) => {
          a += l;
        });
        let u = setTimeout(() => (o.removeAllListeners(), o.kill(), n(new Error("The executable failed to finish within the timeout specified."))), this.timeoutMillis);
        o.on("close", (l) => {
          if (clearTimeout(u), l === 0) try {
            let f = JSON.parse(a), d = new sn.ExecutableResponse(f);
            return t(d);
          } catch (f) {
            return f instanceof sn.ExecutableResponseError ? n(f) : n(new sn.ExecutableResponseError(`The executable returned an invalid response: ${a}`));
          }
          else return n(new ji(a, l.toString()));
        });
      });
    }
    async retrieveCachedResponse() {
      if (!this.outputFile || this.outputFile.length === 0) return;
      let e;
      try {
        e = await $c.promises.realpath(this.outputFile);
      } catch {
        return;
      }
      if (!(await $c.promises.lstat(e)).isFile()) return;
      let t = await $c.promises.readFile(e, { encoding: "utf8" });
      if (t !== "") try {
        let n = JSON.parse(t);
        return new sn.ExecutableResponse(n).isValid() ? new sn.ExecutableResponse(n) : void 0;
      } catch (n) {
        throw n instanceof sn.ExecutableResponseError ? n : new sn.ExecutableResponseError(`The output file contained an invalid response: ${t}`);
      }
    }
    static parseCommand(e) {
      let t = e.match(/(?:[^\s"]+|"[^"]*")+/g);
      if (!t) throw new Error(`Provided command: "${e}" could not be parsed.`);
      for (let n = 0; n < t.length; n++) t[n][0] === '"' && t[n].slice(-1) === '"' && (t[n] = t[n].slice(1, -1));
      return t;
    }
  };
  Gn.PluggableAuthHandler = Hc;
});
var zc = z((Wn) => {
  "use strict";
  Object.defineProperty(Wn, "__esModule", { value: true });
  Wn.PluggableAuthClient = Wn.ExecutableError = void 0;
  var ew = Nr(), tw = Mc(), Tm = Gc(), rw = Gc();
  Object.defineProperty(Wn, "ExecutableError", { enumerable: true, get: function() {
    return rw.ExecutableError;
  } });
  var nw = 30 * 1e3, Rm = 5 * 1e3, Fm = 120 * 1e3, sw = "GOOGLE_EXTERNAL_ACCOUNT_ALLOW_EXECUTABLES", km = 1, Wc = class extends ew.BaseExternalAccountClient {
    command;
    timeoutMillis;
    outputFile;
    handler;
    constructor(e) {
      if (super(e), !e.credential_source.executable) throw new Error('No valid Pluggable Auth "credential_source" provided.');
      if (this.command = e.credential_source.executable.command, !this.command) throw new Error('No valid Pluggable Auth "credential_source" provided.');
      if (e.credential_source.executable.timeout_millis === void 0) this.timeoutMillis = nw;
      else if (this.timeoutMillis = e.credential_source.executable.timeout_millis, this.timeoutMillis < Rm || this.timeoutMillis > Fm) throw new Error(`Timeout must be between ${Rm} and ${Fm} milliseconds.`);
      this.outputFile = e.credential_source.executable.output_file, this.handler = new Tm.PluggableAuthHandler({ command: this.command, timeoutMillis: this.timeoutMillis, outputFile: this.outputFile }), this.credentialSourceType = "executable";
    }
    async retrieveSubjectToken() {
      if (process.env[sw] !== "1") throw new Error("Pluggable Auth executables need to be explicitly allowed to run by setting the GOOGLE_EXTERNAL_ACCOUNT_ALLOW_EXECUTABLES environment Variable to 1.");
      let e;
      if (this.outputFile && (e = await this.handler.retrieveCachedResponse()), !e) {
        let t = /* @__PURE__ */ new Map();
        t.set("GOOGLE_EXTERNAL_ACCOUNT_AUDIENCE", this.audience), t.set("GOOGLE_EXTERNAL_ACCOUNT_TOKEN_TYPE", this.subjectTokenType), t.set("GOOGLE_EXTERNAL_ACCOUNT_INTERACTIVE", "0"), this.outputFile && t.set("GOOGLE_EXTERNAL_ACCOUNT_OUTPUT_FILE", this.outputFile);
        let n = this.getServiceAccountEmail();
        n && t.set("GOOGLE_EXTERNAL_ACCOUNT_IMPERSONATED_EMAIL", n), e = await this.handler.retrieveResponseFromExecutable(t);
      }
      if (e.version > km) throw new Error(`Version of executable is not currently supported, maximum supported version is ${km}.`);
      if (!e.success) throw new Tm.ExecutableError(e.errorMessage, e.errorCode);
      if (this.outputFile && !e.expirationTime) throw new tw.InvalidExpirationTimeFieldError("The executable response must contain the `expiration_time` field for successful responses when an output_file has been specified in the configuration.");
      if (e.isExpired()) throw new Error("Executable response is expired.");
      return e.subjectToken;
    }
  };
  Wn.PluggableAuthClient = Wc;
});
var Vc = z((Li) => {
  "use strict";
  Object.defineProperty(Li, "__esModule", { value: true });
  Li.ExternalAccountClient = void 0;
  var ow = Nr(), iw = Oc(), aw = Nc(), uw = zc(), Jc = class {
    constructor() {
      throw new Error("ExternalAccountClients should be initialized via: ExternalAccountClient.fromJSON(), directly via explicit constructors, eg. new AwsClient(options), new IdentityPoolClient(options), newPluggableAuthClientOptions, or via new GoogleAuth(options).getClient()");
    }
    static fromJSON(e) {
      return e && e.type === ow.EXTERNAL_ACCOUNT_TYPE ? e.credential_source?.environment_id ? new aw.AwsClient(e) : e.credential_source?.executable ? new uw.PluggableAuthClient(e) : new iw.IdentityPoolClient(e) : null;
    }
  };
  Li.ExternalAccountClient = Jc;
});
var Bm = z((zn) => {
  "use strict";
  Object.defineProperty(zn, "__esModule", { value: true });
  zn.ExternalAccountAuthorizedUserClient = zn.EXTERNAL_ACCOUNT_AUTHORIZED_USER_TYPE = void 0;
  var Pm = pt(), Om = Cc(), xm = Ve(), cw = Y("stream"), lw = Nr();
  zn.EXTERNAL_ACCOUNT_AUTHORIZED_USER_TYPE = "external_account_authorized_user";
  var fw = "https://sts.{universeDomain}/v1/oauthtoken", Kc = class r extends Om.OAuthClientAuthHandler {
    #e;
    constructor(e) {
      super(e), this.#e = e.tokenRefreshEndpoint;
    }
    async refreshToken(e, t) {
      let n = { ...r.RETRY_CONFIG, url: this.#e, method: "POST", headers: t, data: new URLSearchParams({ grant_type: "refresh_token", refresh_token: e }) };
      Pm.AuthClient.setMethodName(n, "refreshToken"), this.applyClientAuthenticationOptions(n);
      try {
        let o = await this.transporter.request(n), a = o.data;
        return a.res = o, a;
      } catch (o) {
        throw o instanceof xm.GaxiosError && o.response ? (0, Om.getErrorFromOAuthErrorResponse)(o.response.data, o) : o;
      }
    }
  }, Yc = class extends Pm.AuthClient {
    cachedAccessToken;
    externalAccountAuthorizedUserHandler;
    refreshToken;
    constructor(e) {
      super(e), e.universe_domain && (this.universeDomain = e.universe_domain), this.refreshToken = e.refresh_token;
      let t = { confidentialClientType: "basic", clientId: e.client_id, clientSecret: e.client_secret };
      this.externalAccountAuthorizedUserHandler = new Kc({ tokenRefreshEndpoint: e.token_url ?? fw.replace("{universeDomain}", this.universeDomain), transporter: this.transporter, clientAuthentication: t }), this.cachedAccessToken = null, this.quotaProjectId = e.quota_project_id, typeof e?.eagerRefreshThresholdMillis != "number" ? this.eagerRefreshThresholdMillis = lw.EXPIRATION_TIME_OFFSET : this.eagerRefreshThresholdMillis = e.eagerRefreshThresholdMillis, this.forceRefreshOnFailure = !!e?.forceRefreshOnFailure;
    }
    async getAccessToken() {
      return (!this.cachedAccessToken || this.isExpired(this.cachedAccessToken)) && await this.refreshAccessTokenAsync(), { token: this.cachedAccessToken.access_token, res: this.cachedAccessToken.res };
    }
    async getRequestHeaders() {
      let e = await this.getAccessToken(), t = new Headers({ authorization: `Bearer ${e.token}` });
      return this.addSharedMetadataHeaders(t);
    }
    request(e, t) {
      if (t) this.requestAsync(e).then((n) => t(null, n), (n) => t(n, n.response));
      else return this.requestAsync(e);
    }
    async requestAsync(e, t = false) {
      let n;
      try {
        let o = await this.getRequestHeaders();
        e.headers = xm.Gaxios.mergeHeaders(e.headers), this.addUserProjectAndAuthHeaders(e.headers, o), n = await this.transporter.request(e);
      } catch (o) {
        let a = o.response;
        if (a) {
          let u = a.status, l = a.config.data instanceof cw.Readable;
          if (!t && (u === 401 || u === 403) && !l && this.forceRefreshOnFailure) return await this.refreshAccessTokenAsync(), await this.requestAsync(e, true);
        }
        throw o;
      }
      return n;
    }
    async refreshAccessTokenAsync() {
      let e = await this.externalAccountAuthorizedUserHandler.refreshToken(this.refreshToken);
      return this.cachedAccessToken = { access_token: e.access_token, expiry_date: (/* @__PURE__ */ new Date()).getTime() + e.expires_in * 1e3, res: e.res }, e.refresh_token !== void 0 && (this.refreshToken = e.refresh_token), this.cachedAccessToken;
    }
    isExpired(e) {
      let t = (/* @__PURE__ */ new Date()).getTime();
      return e.expiry_date ? t >= e.expiry_date - this.eagerRefreshThresholdMillis : false;
    }
  };
  zn.ExternalAccountAuthorizedUserClient = Yc;
});
var jm = z((Ht) => {
  "use strict";
  Object.defineProperty(Ht, "__esModule", { value: true });
  Ht.GoogleAuth = Ht.GoogleAuthExceptionMessages = void 0;
  var dw = Y("child_process"), Os = Y("fs"), hw = Ve(), Ps = ys(), pw = Y("os"), Xc = Y("path"), mw = _s(), gw = Wu(), yw = Ju(), _w = Vu(), Jn = hc(), Im = mc(), Vn = yc(), Cw = Vc(), xs = Nr(), Qc = pt(), Nm = Bm(), qm = Lt();
  Ht.GoogleAuthExceptionMessages = { API_KEY_WITH_CREDENTIALS: "API Keys and Credentials are mutually exclusive authentication methods and cannot be used together.", NO_PROJECT_ID_FOUND: `Unable to detect a Project Id in the current environment. 
To learn more about authentication and Google APIs, visit: 
https://cloud.google.com/docs/authentication/getting-started`, NO_CREDENTIALS_FOUND: `Unable to find credentials in current environment. 
To learn more about authentication and Google APIs, visit: 
https://cloud.google.com/docs/authentication/getting-started`, NO_ADC_FOUND: "Could not load the default credentials. Browse to https://cloud.google.com/docs/authentication/getting-started for more information.", NO_UNIVERSE_DOMAIN_FOUND: `Unable to detect a Universe Domain in the current environment.
To learn more about Universe Domain retrieval, visit: 
https://cloud.google.com/compute/docs/metadata/predefined-metadata-keys` };
  var Zc = class {
    checkIsGCE = void 0;
    useJWTAccessWithScope;
    defaultServicePath;
    get isGCE() {
      return this.checkIsGCE;
    }
    _findProjectIdPromise;
    _cachedProjectId;
    jsonContent = null;
    apiKey;
    cachedCredential = null;
    #e = null;
    defaultScopes;
    keyFilename;
    scopes;
    clientOptions = {};
    constructor(e = {}) {
      if (this._cachedProjectId = e.projectId || null, this.cachedCredential = e.authClient || null, this.keyFilename = e.keyFilename || e.keyFile, this.scopes = e.scopes, this.clientOptions = e.clientOptions || {}, this.jsonContent = e.credentials || null, this.apiKey = e.apiKey || this.clientOptions.apiKey || null, this.apiKey && (this.jsonContent || this.clientOptions.credentials)) throw new RangeError(Ht.GoogleAuthExceptionMessages.API_KEY_WITH_CREDENTIALS);
      e.universeDomain && (this.clientOptions.universeDomain = e.universeDomain);
    }
    setGapicJWTValues(e) {
      e.defaultServicePath = this.defaultServicePath, e.useJWTAccessWithScope = this.useJWTAccessWithScope, e.defaultScopes = this.defaultScopes;
    }
    getProjectId(e) {
      if (e) this.getProjectIdAsync().then((t) => e(null, t), e);
      else return this.getProjectIdAsync();
    }
    async getProjectIdOptional() {
      try {
        return await this.getProjectId();
      } catch (e) {
        if (e instanceof Error && e.message === Ht.GoogleAuthExceptionMessages.NO_PROJECT_ID_FOUND) return null;
        throw e;
      }
    }
    async findAndCacheProjectId() {
      let e = null;
      if (e ||= await this.getProductionProjectId(), e ||= await this.getFileProjectId(), e ||= await this.getDefaultServiceProjectId(), e ||= await this.getGCEProjectId(), e ||= await this.getExternalAccountClientProjectId(), e) return this._cachedProjectId = e, e;
      throw new Error(Ht.GoogleAuthExceptionMessages.NO_PROJECT_ID_FOUND);
    }
    async getProjectIdAsync() {
      return this._cachedProjectId ? this._cachedProjectId : (this._findProjectIdPromise || (this._findProjectIdPromise = this.findAndCacheProjectId()), this._findProjectIdPromise);
    }
    async getUniverseDomainFromMetadataServer() {
      let e;
      try {
        e = await Ps.universe("universe-domain"), e ||= Qc.DEFAULT_UNIVERSE;
      } catch (t) {
        if (t && t?.response?.status === 404) e = Qc.DEFAULT_UNIVERSE;
        else throw t;
      }
      return e;
    }
    async getUniverseDomain() {
      let e = (0, qm.originalOrCamelOptions)(this.clientOptions).get("universe_domain");
      try {
        e ??= (await this.getClient()).universeDomain;
      } catch {
        e ??= Qc.DEFAULT_UNIVERSE;
      }
      return e;
    }
    getAnyScopes() {
      return this.scopes || this.defaultScopes;
    }
    getApplicationDefault(e = {}, t) {
      let n;
      if (typeof e == "function" ? t = e : n = e, t) this.getApplicationDefaultAsync(n).then((o) => t(null, o.credential, o.projectId), t);
      else return this.getApplicationDefaultAsync(n);
    }
    async getApplicationDefaultAsync(e = {}) {
      if (this.cachedCredential) return await this.#t(this.cachedCredential, null);
      let t;
      if (t = await this._tryGetApplicationCredentialsFromEnvironmentVariable(e), t) return t instanceof Jn.JWT ? t.scopes = this.scopes : t instanceof xs.BaseExternalAccountClient && (t.scopes = this.getAnyScopes()), await this.#t(t);
      if (t = await this._tryGetApplicationCredentialsFromWellKnownFile(e), t) return t instanceof Jn.JWT ? t.scopes = this.scopes : t instanceof xs.BaseExternalAccountClient && (t.scopes = this.getAnyScopes()), await this.#t(t);
      if (await this._checkIsGCE()) return e.scopes = this.getAnyScopes(), await this.#t(new gw.Compute(e));
      throw new Error(Ht.GoogleAuthExceptionMessages.NO_ADC_FOUND);
    }
    async #t(e, t = process.env.GOOGLE_CLOUD_QUOTA_PROJECT || null) {
      let n = await this.getProjectIdOptional();
      return t && (e.quotaProjectId = t), this.cachedCredential = e, { credential: e, projectId: n };
    }
    async _checkIsGCE() {
      return this.checkIsGCE === void 0 && (this.checkIsGCE = Ps.getGCPResidency() || await Ps.isAvailable()), this.checkIsGCE;
    }
    async _tryGetApplicationCredentialsFromEnvironmentVariable(e) {
      let t = process.env.GOOGLE_APPLICATION_CREDENTIALS || process.env.google_application_credentials;
      if (!t || t.length === 0) return null;
      try {
        return this._getApplicationCredentialsFromFilePath(t, e);
      } catch (n) {
        throw n instanceof Error && (n.message = `Unable to read the credential file specified by the GOOGLE_APPLICATION_CREDENTIALS environment variable: ${n.message}`), n;
      }
    }
    async _tryGetApplicationCredentialsFromWellKnownFile(e) {
      let t = null;
      if (this._isWindows()) t = process.env.APPDATA;
      else {
        let o = process.env.HOME;
        o && (t = Xc.join(o, ".config"));
      }
      return t && (t = Xc.join(t, "gcloud", "application_default_credentials.json"), Os.existsSync(t) || (t = null)), t ? await this._getApplicationCredentialsFromFilePath(t, e) : null;
    }
    async _getApplicationCredentialsFromFilePath(e, t = {}) {
      if (!e || e.length === 0) throw new Error("The file path is invalid.");
      try {
        if (e = Os.realpathSync(e), !Os.lstatSync(e).isFile()) throw new Error();
      } catch (o) {
        throw o instanceof Error && (o.message = `The file at ${e} does not exist, or it is not a file. ${o.message}`), o;
      }
      let n = Os.createReadStream(e);
      return this.fromStream(n, t);
    }
    fromImpersonatedJSON(e) {
      if (!e) throw new Error("Must pass in a JSON object containing an  impersonated refresh token");
      if (e.type !== Vn.IMPERSONATED_ACCOUNT_TYPE) throw new Error(`The incoming JSON object does not have the "${Vn.IMPERSONATED_ACCOUNT_TYPE}" type`);
      if (!e.source_credentials) throw new Error("The incoming JSON object does not contain a source_credentials field");
      if (!e.service_account_impersonation_url) throw new Error("The incoming JSON object does not contain a service_account_impersonation_url field");
      let t = this.fromJSON(e.source_credentials);
      if (e.service_account_impersonation_url?.length > 256) throw new RangeError(`Target principal is too long: ${e.service_account_impersonation_url}`);
      let n = /(?<target>[^/]+):(generateAccessToken|generateIdToken)$/.exec(e.service_account_impersonation_url)?.groups?.target;
      if (!n) throw new RangeError(`Cannot extract target principal from ${e.service_account_impersonation_url}`);
      let o = this.getAnyScopes() ?? [];
      return new Vn.Impersonated({ ...e, sourceClient: t, targetPrincipal: n, targetScopes: Array.isArray(o) ? o : [o] });
    }
    fromJSON(e, t = {}) {
      let n, o = (0, qm.originalOrCamelOptions)(t).get("universe_domain");
      return e.type === Im.USER_REFRESH_ACCOUNT_TYPE ? (n = new Im.UserRefreshClient(t), n.fromJSON(e)) : e.type === Vn.IMPERSONATED_ACCOUNT_TYPE ? n = this.fromImpersonatedJSON(e) : e.type === xs.EXTERNAL_ACCOUNT_TYPE ? (n = Cw.ExternalAccountClient.fromJSON({ ...e, ...t }), n.scopes = this.getAnyScopes()) : e.type === Nm.EXTERNAL_ACCOUNT_AUTHORIZED_USER_TYPE ? n = new Nm.ExternalAccountAuthorizedUserClient({ ...e, ...t }) : (t.scopes = this.scopes, n = new Jn.JWT(t), this.setGapicJWTValues(n), n.fromJSON(e)), o && (n.universeDomain = o), n;
    }
    _cacheClientFromJSON(e, t) {
      let n = this.fromJSON(e, t);
      return this.jsonContent = e, this.cachedCredential = n, n;
    }
    fromStream(e, t = {}, n) {
      let o = {};
      if (typeof t == "function" ? n = t : o = t, n) this.fromStreamAsync(e, o).then((a) => n(null, a), n);
      else return this.fromStreamAsync(e, o);
    }
    fromStreamAsync(e, t) {
      return new Promise((n, o) => {
        if (!e) throw new Error("Must pass in a stream containing the Google auth settings.");
        let a = [];
        e.setEncoding("utf8").on("error", o).on("data", (u) => a.push(u)).on("end", () => {
          try {
            try {
              let u = JSON.parse(a.join("")), l = this._cacheClientFromJSON(u, t);
              return n(l);
            } catch (u) {
              if (!this.keyFilename) throw u;
              let l = new Jn.JWT({ ...this.clientOptions, keyFile: this.keyFilename });
              return this.cachedCredential = l, this.setGapicJWTValues(l), n(l);
            }
          } catch (u) {
            return o(u);
          }
        });
      });
    }
    fromAPIKey(e, t = {}) {
      return new Jn.JWT({ ...t, apiKey: e });
    }
    _isWindows() {
      let e = pw.platform();
      return !!(e && e.length >= 3 && e.substring(0, 3).toLowerCase() === "win");
    }
    async getDefaultServiceProjectId() {
      return new Promise((e) => {
        (0, dw.exec)("gcloud config config-helper --format json", (t, n) => {
          if (!t && n) try {
            let o = JSON.parse(n).configuration.properties.core.project;
            e(o);
            return;
          } catch {
          }
          e(null);
        });
      });
    }
    getProductionProjectId() {
      return process.env.GCLOUD_PROJECT || process.env.GOOGLE_CLOUD_PROJECT || process.env.gcloud_project || process.env.google_cloud_project;
    }
    async getFileProjectId() {
      if (this.cachedCredential) return this.cachedCredential.projectId;
      if (this.keyFilename) {
        let t = await this.getClient();
        if (t && t.projectId) return t.projectId;
      }
      let e = await this._tryGetApplicationCredentialsFromEnvironmentVariable();
      return e ? e.projectId : null;
    }
    async getExternalAccountClientProjectId() {
      return !this.jsonContent || this.jsonContent.type !== xs.EXTERNAL_ACCOUNT_TYPE ? null : await (await this.getClient()).getProjectId();
    }
    async getGCEProjectId() {
      try {
        return await Ps.project("project-id");
      } catch {
        return null;
      }
    }
    getCredentials(e) {
      if (e) this.getCredentialsAsync().then((t) => e(null, t), e);
      else return this.getCredentialsAsync();
    }
    async getCredentialsAsync() {
      let e = await this.getClient();
      if (e instanceof Vn.Impersonated) return { client_email: e.getTargetPrincipal() };
      if (e instanceof xs.BaseExternalAccountClient) {
        let t = e.getServiceAccountEmail();
        if (t) return { client_email: t, universe_domain: e.universeDomain };
      }
      if (this.jsonContent) return { client_email: this.jsonContent.client_email, private_key: this.jsonContent.private_key, universe_domain: this.jsonContent.universe_domain };
      if (await this._checkIsGCE()) {
        let [t, n] = await Promise.all([Ps.instance("service-accounts/default/email"), this.getUniverseDomain()]);
        return { client_email: t, universe_domain: n };
      }
      throw new Error(Ht.GoogleAuthExceptionMessages.NO_CREDENTIALS_FOUND);
    }
    async getClient() {
      if (this.cachedCredential) return this.cachedCredential;
      this.#e = this.#e || this.#r();
      try {
        return await this.#e;
      } finally {
        this.#e = null;
      }
    }
    async #r() {
      if (this.jsonContent) return this._cacheClientFromJSON(this.jsonContent, this.clientOptions);
      if (this.keyFilename) {
        let e = Xc.resolve(this.keyFilename), t = Os.createReadStream(e);
        return await this.fromStreamAsync(t, this.clientOptions);
      } else if (this.apiKey) {
        let e = await this.fromAPIKey(this.apiKey, this.clientOptions);
        e.scopes = this.scopes;
        let { credential: t } = await this.#t(e);
        return t;
      } else {
        let { credential: e } = await this.getApplicationDefaultAsync(this.clientOptions);
        return e;
      }
    }
    async getIdTokenClient(e) {
      let t = await this.getClient();
      if (!("fetchIdToken" in t)) throw new Error("Cannot fetch ID token in this environment, use GCE or set the GOOGLE_APPLICATION_CREDENTIALS environment variable to a service account credentials JSON file.");
      return new yw.IdTokenClient({ targetAudience: e, idTokenProvider: t });
    }
    async getAccessToken() {
      return (await (await this.getClient()).getAccessToken()).token;
    }
    async getRequestHeaders(e) {
      return (await this.getClient()).getRequestHeaders(e);
    }
    async authorizeRequest(e = {}) {
      let t = e.url, o = await (await this.getClient()).getRequestHeaders(t);
      return e.headers = hw.Gaxios.mergeHeaders(e.headers, o), e;
    }
    async fetch(...e) {
      return (await this.getClient()).fetch(...e);
    }
    async request(e) {
      return (await this.getClient()).request(e);
    }
    getEnv() {
      return (0, _w.getEnv)();
    }
    async sign(e, t) {
      let n = await this.getClient(), o = await this.getUniverseDomain();
      if (t = t || `https://iamcredentials.${o}/v1/projects/-/serviceAccounts/`, n instanceof Vn.Impersonated) return (await n.sign(e)).signedBlob;
      let a = (0, mw.createCrypto)();
      if (n instanceof Jn.JWT && n.key) return await a.sign(n.key, e);
      let u = await this.getCredentials();
      if (!u.client_email) throw new Error("Cannot sign data without `client_email`.");
      return this.signBlob(a, u.client_email, e, t);
    }
    async signBlob(e, t, n, o) {
      let a = new URL(o + `${t}:signBlob`);
      return (await this.request({ method: "POST", url: a.href, data: { payload: e.encodeBase64StringUtf8(n) }, retry: true, retryConfig: { httpMethodsToRetry: ["POST"] } })).data.signedBlob;
    }
  };
  Ht.GoogleAuth = Zc;
});
var Lm = z((Ui) => {
  "use strict";
  Object.defineProperty(Ui, "__esModule", { value: true });
  Ui.IAMAuth = void 0;
  var el = class {
    selector;
    token;
    constructor(e, t) {
      this.selector = e, this.token = t, this.selector = e, this.token = t;
    }
    getRequestHeaders() {
      return { "x-goog-iam-authority-selector": this.selector, "x-goog-iam-authorization-token": this.token };
    }
  };
  Ui.IAMAuth = el;
});
var Um = z((er) => {
  "use strict";
  Object.defineProperty(er, "__esModule", { value: true });
  er.DownscopedClient = er.EXPIRATION_TIME_OFFSET = er.MAX_ACCESS_BOUNDARY_RULES_COUNT = void 0;
  var bw = Ve(), Ew = Y("stream"), tl = pt(), ww = bi(), Aw = "urn:ietf:params:oauth:grant-type:token-exchange", Dw = "urn:ietf:params:oauth:token-type:access_token", Sw = "urn:ietf:params:oauth:token-type:access_token";
  er.MAX_ACCESS_BOUNDARY_RULES_COUNT = 10;
  er.EXPIRATION_TIME_OFFSET = 5 * 60 * 1e3;
  var rl = class extends tl.AuthClient {
    authClient;
    credentialAccessBoundary;
    cachedDownscopedAccessToken;
    stsCredential;
    constructor(e, t = { accessBoundary: { accessBoundaryRules: [] } }) {
      if (super(e instanceof tl.AuthClient ? {} : e), e instanceof tl.AuthClient ? (this.authClient = e, this.credentialAccessBoundary = t) : (this.authClient = e.authClient, this.credentialAccessBoundary = e.credentialAccessBoundary), this.credentialAccessBoundary.accessBoundary.accessBoundaryRules.length === 0) throw new Error("At least one access boundary rule needs to be defined.");
      if (this.credentialAccessBoundary.accessBoundary.accessBoundaryRules.length > er.MAX_ACCESS_BOUNDARY_RULES_COUNT) throw new Error(`The provided access boundary has more than ${er.MAX_ACCESS_BOUNDARY_RULES_COUNT} access boundary rules.`);
      for (let n of this.credentialAccessBoundary.accessBoundary.accessBoundaryRules) if (n.availablePermissions.length === 0) throw new Error("At least one permission should be defined in access boundary rules.");
      this.stsCredential = new ww.StsCredentials({ tokenExchangeEndpoint: `https://sts.${this.universeDomain}/v1/token` }), this.cachedDownscopedAccessToken = null;
    }
    setCredentials(e) {
      if (!e.expiry_date) throw new Error("The access token expiry_date field is missing in the provided credentials.");
      super.setCredentials(e), this.cachedDownscopedAccessToken = e;
    }
    async getAccessToken() {
      return (!this.cachedDownscopedAccessToken || this.isExpired(this.cachedDownscopedAccessToken)) && await this.refreshAccessTokenAsync(), { token: this.cachedDownscopedAccessToken.access_token, expirationTime: this.cachedDownscopedAccessToken.expiry_date, res: this.cachedDownscopedAccessToken.res };
    }
    async getRequestHeaders() {
      let e = await this.getAccessToken(), t = new Headers({ authorization: `Bearer ${e.token}` });
      return this.addSharedMetadataHeaders(t);
    }
    request(e, t) {
      if (t) this.requestAsync(e).then((n) => t(null, n), (n) => t(n, n.response));
      else return this.requestAsync(e);
    }
    async requestAsync(e, t = false) {
      let n;
      try {
        let o = await this.getRequestHeaders();
        e.headers = bw.Gaxios.mergeHeaders(e.headers), this.addUserProjectAndAuthHeaders(e.headers, o), n = await this.transporter.request(e);
      } catch (o) {
        let a = o.response;
        if (a) {
          let u = a.status, l = a.config.data instanceof Ew.Readable;
          if (!t && (u === 401 || u === 403) && !l && this.forceRefreshOnFailure) return await this.refreshAccessTokenAsync(), await this.requestAsync(e, true);
        }
        throw o;
      }
      return n;
    }
    async refreshAccessTokenAsync() {
      let e = (await this.authClient.getAccessToken()).token, t = { grantType: Aw, requestedTokenType: Dw, subjectToken: e, subjectTokenType: Sw }, n = await this.stsCredential.exchangeToken(t, void 0, this.credentialAccessBoundary), o = this.authClient.credentials?.expiry_date || null, a = n.expires_in ? (/* @__PURE__ */ new Date()).getTime() + n.expires_in * 1e3 : o;
      return this.cachedDownscopedAccessToken = { access_token: n.access_token, expiry_date: a, res: n.res }, this.credentials = {}, Object.assign(this.credentials, this.cachedDownscopedAccessToken), delete this.credentials.res, this.emit("tokens", { refresh_token: null, expiry_date: this.cachedDownscopedAccessToken.expiry_date, access_token: this.cachedDownscopedAccessToken.access_token, token_type: "Bearer", id_token: null }), this.cachedDownscopedAccessToken;
    }
    isExpired(e) {
      let t = (/* @__PURE__ */ new Date()).getTime();
      return e.expiry_date ? t >= e.expiry_date - this.eagerRefreshThresholdMillis : false;
    }
  };
  er.DownscopedClient = rl;
});
var Mm = z((Mi) => {
  "use strict";
  Object.defineProperty(Mi, "__esModule", { value: true });
  Mi.PassThroughClient = void 0;
  var vw = pt(), nl = class extends vw.AuthClient {
    async request(e) {
      return this.transporter.request(e);
    }
    async getAccessToken() {
      return {};
    }
    async getRequestHeaders() {
      return new Headers();
    }
  };
  Mi.PassThroughClient = nl;
});
var ol = z((ee) => {
  "use strict";
  Object.defineProperty(ee, "__esModule", { value: true });
  ee.GoogleAuth = ee.auth = ee.PassThroughClient = ee.ExecutableError = ee.PluggableAuthClient = ee.DownscopedClient = ee.BaseExternalAccountClient = ee.ExternalAccountClient = ee.IdentityPoolClient = ee.AwsRequestSigner = ee.AwsClient = ee.UserRefreshClient = ee.LoginTicket = ee.ClientAuthentication = ee.OAuth2Client = ee.CodeChallengeMethod = ee.Impersonated = ee.JWT = ee.JWTAccess = ee.IdTokenClient = ee.IAMAuth = ee.GCPEnv = ee.Compute = ee.DEFAULT_UNIVERSE = ee.AuthClient = ee.gaxios = ee.gcpMetadata = void 0;
  var $m = jm();
  Object.defineProperty(ee, "GoogleAuth", { enumerable: true, get: function() {
    return $m.GoogleAuth;
  } });
  ee.gcpMetadata = ys();
  ee.gaxios = Ve();
  var Hm = pt();
  Object.defineProperty(ee, "AuthClient", { enumerable: true, get: function() {
    return Hm.AuthClient;
  } });
  Object.defineProperty(ee, "DEFAULT_UNIVERSE", { enumerable: true, get: function() {
    return Hm.DEFAULT_UNIVERSE;
  } });
  var Tw = Wu();
  Object.defineProperty(ee, "Compute", { enumerable: true, get: function() {
    return Tw.Compute;
  } });
  var Rw = Vu();
  Object.defineProperty(ee, "GCPEnv", { enumerable: true, get: function() {
    return Rw.GCPEnv;
  } });
  var Fw = Lm();
  Object.defineProperty(ee, "IAMAuth", { enumerable: true, get: function() {
    return Fw.IAMAuth;
  } });
  var kw = Ju();
  Object.defineProperty(ee, "IdTokenClient", { enumerable: true, get: function() {
    return kw.IdTokenClient;
  } });
  var Ow = fc();
  Object.defineProperty(ee, "JWTAccess", { enumerable: true, get: function() {
    return Ow.JWTAccess;
  } });
  var Pw = hc();
  Object.defineProperty(ee, "JWT", { enumerable: true, get: function() {
    return Pw.JWT;
  } });
  var xw = yc();
  Object.defineProperty(ee, "Impersonated", { enumerable: true, get: function() {
    return xw.Impersonated;
  } });
  var sl = nn();
  Object.defineProperty(ee, "CodeChallengeMethod", { enumerable: true, get: function() {
    return sl.CodeChallengeMethod;
  } });
  Object.defineProperty(ee, "OAuth2Client", { enumerable: true, get: function() {
    return sl.OAuth2Client;
  } });
  Object.defineProperty(ee, "ClientAuthentication", { enumerable: true, get: function() {
    return sl.ClientAuthentication;
  } });
  var Bw = Mu();
  Object.defineProperty(ee, "LoginTicket", { enumerable: true, get: function() {
    return Bw.LoginTicket;
  } });
  var Iw = mc();
  Object.defineProperty(ee, "UserRefreshClient", { enumerable: true, get: function() {
    return Iw.UserRefreshClient;
  } });
  var Nw = Nc();
  Object.defineProperty(ee, "AwsClient", { enumerable: true, get: function() {
    return Nw.AwsClient;
  } });
  var qw = xc();
  Object.defineProperty(ee, "AwsRequestSigner", { enumerable: true, get: function() {
    return qw.AwsRequestSigner;
  } });
  var jw = Oc();
  Object.defineProperty(ee, "IdentityPoolClient", { enumerable: true, get: function() {
    return jw.IdentityPoolClient;
  } });
  var Lw = Vc();
  Object.defineProperty(ee, "ExternalAccountClient", { enumerable: true, get: function() {
    return Lw.ExternalAccountClient;
  } });
  var Uw = Nr();
  Object.defineProperty(ee, "BaseExternalAccountClient", { enumerable: true, get: function() {
    return Uw.BaseExternalAccountClient;
  } });
  var Mw = Um();
  Object.defineProperty(ee, "DownscopedClient", { enumerable: true, get: function() {
    return Mw.DownscopedClient;
  } });
  var Gm = zc();
  Object.defineProperty(ee, "PluggableAuthClient", { enumerable: true, get: function() {
    return Gm.PluggableAuthClient;
  } });
  Object.defineProperty(ee, "ExecutableError", { enumerable: true, get: function() {
    return Gm.ExecutableError;
  } });
  var $w = Mm();
  Object.defineProperty(ee, "PassThroughClient", { enumerable: true, get: function() {
    return $w.PassThroughClient;
  } });
  var Hw = new $m.GoogleAuth();
  ee.auth = Hw;
});
var If = Jr(ja(), 1);
var po = class {
  config = {};
  options;
  constructor(e = { jsonPath: "./config.json" }) {
    this.options = { envPath: e.envPath || ".env", jsonPath: e.jsonPath, useEnvFile: false, useJsonFile: e.useJsonFile !== false, useEnvironmentVariables: e.useEnvironmentVariables !== false, ...e }, this.loadConfig();
  }
  loadConfig() {
    this.options.useJsonFile && this.options.jsonPath && this.loadJsonConfig(), this.options.initialConfig && (this.config = { ...this.config, ...this.options.initialConfig }), this.options.useEnvFile && this.loadEnvConfig(), this.config.LOG_FILE && (process.env.LOG_FILE = this.config.LOG_FILE), this.config.LOG && (process.env.LOG = this.config.LOG);
  }
  loadJsonConfig() {
    if (!this.options.jsonPath) return;
    let e = this.isAbsolutePath(this.options.jsonPath) ? this.options.jsonPath : (0, import_path.join)(process.cwd(), this.options.jsonPath);
    if ((0, import_fs.existsSync)(e)) try {
      let t = (0, import_fs.readFileSync)(e, "utf-8"), n = If.default.parse(t);
      this.config = { ...this.config, ...n }, console.log(`Loaded JSON config from: ${e}`);
    } catch (t) {
      console.warn(`Failed to load JSON config from ${e}:`, t);
    }
    else console.warn(`JSON config file not found: ${e}`);
  }
  loadEnvConfig() {
    let e = this.isAbsolutePath(this.options.envPath) ? this.options.envPath : (0, import_path.join)(process.cwd(), this.options.envPath);
    if ((0, import_fs.existsSync)(e)) try {
      let t = (0, import_dotenv.config)({ path: e });
      t.parsed && (this.config = { ...this.config, ...this.parseEnvConfig(t.parsed) });
    } catch (t) {
      console.warn(`Failed to load .env config from ${e}:`, t);
    }
  }
  loadEnvironmentVariables() {
    let e = this.parseEnvConfig(process.env);
    this.config = { ...this.config, ...e };
  }
  parseEnvConfig(e) {
    let t = {};
    return Object.assign(t, e), t;
  }
  isAbsolutePath(e) {
    return e.startsWith("/") || e.includes(":");
  }
  get(e, t) {
    let n = this.config[e];
    return n !== void 0 ? n : t;
  }
  getAll() {
    return { ...this.config };
  }
  getHttpsProxy() {
    return this.get("HTTPS_PROXY") || this.get("https_proxy") || this.get("httpsProxy") || this.get("PROXY_URL");
  }
  has(e) {
    return this.config[e] !== void 0;
  }
  set(e, t) {
    this.config[e] = t;
  }
  reload() {
    this.config = {}, this.loadConfig();
  }
  getConfigSummary() {
    let e = [];
    return this.options.initialConfig && e.push("Initial Config"), this.options.useJsonFile && this.options.jsonPath && e.push(`JSON: ${this.options.jsonPath}`), this.options.useEnvFile && e.push(`ENV: ${this.options.envPath}`), this.options.useEnvironmentVariables && e.push("Environment Variables"), `Config sources: ${e.join(", ")}`;
  }
};
function ne(...r) {
  if (console.log(...r), !(process.env.LOG === "true")) return;
  let n = `[${(/* @__PURE__ */ new Date()).toISOString()}] ${Array.isArray(r) ? r.map((a) => typeof a == "object" ? JSON.stringify(a) : String(a)).join(" ") : ""}
`, o = process.env.LOG_FILE || "app.log";
  import_node_fs2.default.appendFileSync(o, n, "utf8");
}
function Et(r, e = 500, t = "internal_error", n = "api_error") {
  let o = new Error(r);
  return o.statusCode = e, o.code = t, o.type = n, o;
}
async function Nf(r, e, t) {
  e.log.error(r);
  let n = r.statusCode || 500, o = { error: { message: r.message + r.stack || "Internal Server Error", type: r.type || "api_error", code: r.code || "internal_error" } };
  return t.code(n).send(o);
}
function qf(r, e, t) {
  let n = new Headers({ "Content-Type": "application/json" });
  t.headers && Object.entries(t.headers).forEach(([l, f]) => {
    n.set(l, f);
  });
  let o, a = AbortSignal.timeout(t.TIMEOUT ?? 60 * 1e3 * 60);
  if (t.signal) {
    let l = new AbortController(), f = () => l.abort();
    t.signal.addEventListener("abort", f), a.addEventListener("abort", f), o = l.signal;
  } else o = a;
  let u = { method: "POST", headers: n, body: JSON.stringify(e), signal: o };
  return t.httpsProxy && (u.dispatcher = new import_undici.ProxyAgent(new URL(t.httpsProxy).toString())), ne("final request:", typeof r == "string" ? r : r.toString(), t.httpsProxy, u), fetch(typeof r == "string" ? r : r.toString(), u);
}
var jf = "1.0.18";
async function n0(r, e, t, n) {
  let o = r.body, a = r.provider, u = t._server.providerService.getProvider(a);
  if (!u) throw Et(`Provider '${a}' not found`, 404, "provider_not_found");
  let { requestBody: l, config: f, bypass: d } = await s0(o, u, n), h = await i0(l, f, u, t, d, n), C = await a0(h, u, n, d);
  return u0(C, e, o);
}
async function s0(r, e, t) {
  let n = r, o = {}, a = false;
  if (a = o0(e, t, r), !a && typeof t.transformRequestOut == "function") {
    let u = await t.transformRequestOut(n);
    u.body ? (n = u.body, o = u.config || {}) : n = u;
  }
  if (!a && e.transformer?.use?.length) {
    !a && ne("use transformers:", e.transformer?.use);
    for (let u of e.transformer.use) {
      if (!u || typeof u.transformRequestIn != "function") continue;
      let l = await u.transformRequestIn(n, e);
      l.body ? (n = l.body, o = { ...o, ...l.config }) : n = l;
    }
  }
  if (!a && e.transformer?.[r.model]?.use?.length) for (let u of e.transformer[r.model].use) !u || typeof u.transformRequestIn != "function" || (n = await u.transformRequestIn(n, e));
  return { requestBody: n, config: o, bypass: a };
}
function o0(r, e, t) {
  return r.transformer?.use?.length === 1 && r.transformer.use[0].name === e.name && (!r.transformer?.[t.model]?.use.length || r.transformer?.[t.model]?.use.length === 1 && r.transformer?.[t.model]?.use[0].name === e.name);
}
async function i0(r, e, t, n, o, a) {
  let u = e.url || new URL(t.baseUrl);
  if (o && typeof a.auth == "function") {
    let f = await a.auth(r, t);
    f.body ? (r = f.body, e = { ...e, ...f.config }) : r = f;
  }
  let l = await qf(u, r, { httpsProxy: n._server.configService.getHttpsProxy(), ...e, headers: { Authorization: `Bearer ${t.apiKey}`, ...e?.headers || {} } });
  if (!l.ok) {
    let f = await l.text();
    throw ne(`Error response from ${u}: ${f}`), Et(`Error from provider: ${f}`, l.status, "provider_response_error");
  }
  return l;
}
async function a0(r, e, t, n) {
  let o = r;
  if (!n && e.transformer?.use?.length) for (let a of e.transformer.use) !a || typeof a.transformResponseOut != "function" || (o = await a.transformResponseOut(o));
  if (!n && e.transformer?.[r.body?.model]?.use?.length) for (let a of e.transformer[r.body?.model].use) !a || typeof a.transformResponseOut != "function" || (o = await a.transformResponseOut(o));
  return !n && t.transformResponseIn && (o = await t.transformResponseIn(o)), o;
}
function u0(r, e, t) {
  return r.ok || e.code(r.status), t?.stream === true ? (e.header("Content-Type", "text/event-stream"), e.header("Cache-Control", "no-cache"), e.header("Connection", "keep-alive"), e.send(r.body)) : r.json();
}
var Lf = async (r) => {
  r.get("/", async () => ({ message: "LLMs API", version: jf })), r.get("/health", async () => ({ status: "ok", timestamp: (/* @__PURE__ */ new Date()).toISOString() }));
  let e = r._server.transformerService.getTransformersWithEndpoint();
  for (let { transformer: t } of e) t.endPoint && r.post(t.endPoint, async (n, o) => n0(n, o, r, t));
  r.post("/providers", { schema: { body: { type: "object", properties: { id: { type: "string" }, name: { type: "string" }, type: { type: "string", enum: ["openai", "anthropic"] }, baseUrl: { type: "string" }, apiKey: { type: "string" }, models: { type: "array", items: { type: "string" } } }, required: ["id", "name", "type", "baseUrl", "apiKey", "models"] } } }, async (t, n) => {
    let { name: o, baseUrl: a, apiKey: u, models: l } = t.body;
    if (!o?.trim()) throw Et("Provider name is required", 400, "invalid_request");
    if (!a || !c0(a)) throw Et("Valid base URL is required", 400, "invalid_request");
    if (!u?.trim()) throw Et("API key is required", 400, "invalid_request");
    if (!l || !Array.isArray(l) || l.length === 0) throw Et("At least one model is required", 400, "invalid_request");
    if (r._server.providerService.getProvider(t.body.name)) throw Et(`Provider with name '${t.body.name}' already exists`, 400, "provider_exists");
    return r._server.providerService.registerProvider(t.body);
  }), r.get("/providers", async () => r._server.providerService.getProviders()), r.get("/providers/:id", { schema: { params: { type: "object", properties: { id: { type: "string" } }, required: ["id"] } } }, async (t) => {
    let n = r._server.providerService.getProvider(t.params.id);
    if (!n) throw Et("Provider not found", 404, "provider_not_found");
    return n;
  }), r.put("/providers/:id", { schema: { params: { type: "object", properties: { id: { type: "string" } }, required: ["id"] }, body: { type: "object", properties: { name: { type: "string" }, type: { type: "string", enum: ["openai", "anthropic"] }, baseUrl: { type: "string" }, apiKey: { type: "string" }, models: { type: "array", items: { type: "string" } }, enabled: { type: "boolean" } } } } }, async (t, n) => {
    let o = r._server.providerService.updateProvider(t.params.id, t.body);
    if (!o) throw Et("Provider not found", 404, "provider_not_found");
    return o;
  }), r.delete("/providers/:id", { schema: { params: { type: "object", properties: { id: { type: "string" } }, required: ["id"] } } }, async (t) => {
    if (!r._server.providerService.deleteProvider(t.params.id)) throw Et("Provider not found", 404, "provider_not_found");
    return { message: "Provider deleted successfully" };
  }), r.patch("/providers/:id/toggle", { schema: { params: { type: "object", properties: { id: { type: "string" } }, required: ["id"] }, body: { type: "object", properties: { enabled: { type: "boolean" } }, required: ["enabled"] } } }, async (t, n) => {
    if (!r._server.providerService.toggleProvider(t.params.id, t.body.enabled)) throw Et("Provider not found", 404, "provider_not_found");
    return { message: `Provider ${t.body.enabled ? "enabled" : "disabled"} successfully` };
  });
};
function c0(r) {
  try {
    return new URL(r), true;
  } catch {
    return false;
  }
}
var mo = class {
  constructor(e) {
    this.providerService = e;
  }
  registerProvider(e) {
    return this.providerService.registerProvider(e);
  }
  getProviders() {
    return this.providerService.getProviders();
  }
  getProvider(e) {
    return this.providerService.getProvider(e);
  }
  updateProvider(e, t) {
    return this.providerService.updateProvider(e, t);
  }
  deleteProvider(e) {
    return this.providerService.deleteProvider(e);
  }
  toggleProvider(e, t) {
    return this.providerService.toggleProvider(e, t);
  }
  resolveRoute(e) {
    let t = this.providerService.resolveModelRoute(e);
    if (!t) throw new Error(`Model ${e} not found. Available models: ${this.getAvailableModelNames().join(", ")}`);
    return t;
  }
  async getAvailableModels() {
    return { object: "list", data: this.providerService.getAvailableModels().flatMap((t) => t.models.map((n) => ({ id: n, object: "model", provider: t.provider, created: Math.floor(Date.now() / 1e3), owned_by: t.provider }))) };
  }
  getAvailableModelNames() {
    return this.providerService.getModelRoutes().map((e) => e.fullModel);
  }
  getModelRoutes() {
    return this.providerService.getModelRoutes();
  }
};
var go = class {
  constructor(e, t) {
    this.configService = e;
    this.transformerService = t;
    this.initializeCustomProviders();
  }
  providers = /* @__PURE__ */ new Map();
  modelRoutes = /* @__PURE__ */ new Map();
  initializeCustomProviders() {
    let e = this.configService.get("providers");
    if (e && Array.isArray(e)) {
      this.initializeFromProvidersArray(e);
      return;
    }
  }
  initializeFromProvidersArray(e) {
    e.forEach((t) => {
      try {
        if (!t.name || !t.api_base_url || !t.api_key) return;
        let n = {};
        t.transformer && Object.keys(t.transformer).forEach((o) => {
          o === "use" ? Array.isArray(t.transformer.use) && (n.use = t.transformer.use.map((a) => {
            if (Array.isArray(a) && typeof a[0] == "string") {
              let u = this.transformerService.getTransformer(a[0]);
              if (u) return new u(a[1]);
            }
            if (typeof a == "string") {
              let u = this.transformerService.getTransformer(a);
              return typeof u == "function" ? new u() : u;
            }
          }).filter((a) => typeof a < "u")) : Array.isArray(t.transformer[o]?.use) && (n[o] = { use: t.transformer[o].use.map((a) => {
            if (Array.isArray(a) && typeof a[0] == "string") {
              let u = this.transformerService.getTransformer(a[0]);
              if (u) return new u(a[1]);
            }
            if (typeof a == "string") {
              let u = this.transformerService.getTransformer(a);
              return typeof u == "function" ? new u() : this.transformerService.getTransformer(a);
            }
          }).filter((a) => typeof a < "u") });
        }), this.registerProvider({ name: t.name, baseUrl: t.api_base_url, apiKey: t.api_key, models: t.models || [], transformer: t.transformer ? n : void 0 }), ne(`${t.name} provider registered`);
      } catch (n) {
        ne(`${t.name} provider registered error: ${n}`);
      }
    });
  }
  registerProvider(e) {
    let t = { ...e };
    return this.providers.set(t.name, t), e.models.forEach((n) => {
      let o = `${t.name},${n}`, a = { provider: t.name, model: n, fullModel: o };
      this.modelRoutes.set(o, a), this.modelRoutes.has(n) || this.modelRoutes.set(n, a);
    }), t;
  }
  getProviders() {
    return Array.from(this.providers.values());
  }
  getProvider(e) {
    return this.providers.get(e);
  }
  updateProvider(e, t) {
    let n = this.providers.get(e);
    if (!n) return null;
    let o = { ...n, ...t, updatedAt: /* @__PURE__ */ new Date() };
    return this.providers.set(e, o), t.models && (n.models.forEach((a) => {
      let u = `${n.id},${a}`;
      this.modelRoutes.delete(u), this.modelRoutes.delete(a);
    }), t.models.forEach((a) => {
      let u = `${n.name},${a}`, l = { provider: n.name, model: a, fullModel: u };
      this.modelRoutes.set(u, l), this.modelRoutes.has(a) || this.modelRoutes.set(a, l);
    })), o;
  }
  deleteProvider(e) {
    let t = this.providers.get(e);
    return t ? (t.models.forEach((n) => {
      let o = `${t.name},${n}`;
      this.modelRoutes.delete(o), this.modelRoutes.delete(n);
    }), this.providers.delete(e), true) : false;
  }
  toggleProvider(e, t) {
    return !!this.providers.get(e);
  }
  resolveModelRoute(e) {
    let t = this.modelRoutes.get(e);
    if (!t) return null;
    let n = this.providers.get(t.provider);
    return n ? { provider: n, originalModel: e, targetModel: t.model } : null;
  }
  getAvailableModelNames() {
    let e = [];
    return this.providers.forEach((t) => {
      t.models.forEach((n) => {
        e.push(n), e.push(`${t.name},${n}`);
      });
    }), e;
  }
  getModelRoutes() {
    return Array.from(this.modelRoutes.values());
  }
  parseTransformerConfig(e) {
    return e ? Array.isArray(e) ? e.reduce((t, n) => {
      if (Array.isArray(n)) {
        let [o, a = {}] = n;
        t[o] = a;
      } else t[n] = {};
      return t;
    }, {}) : e : {};
  }
  async getAvailableModels() {
    let e = [];
    return this.providers.forEach((t) => {
      t.models.forEach((n) => {
        e.push({ id: n, object: "model", owned_by: t.name, provider: t.name }), e.push({ id: `${t.name},${n}`, object: "model", owned_by: t.name, provider: t.name });
      });
    }), { object: "list", data: e };
  }
};
var Je = [];
for (let r = 0; r < 256; ++r) Je.push((r + 256).toString(16).slice(1));
function Uf(r, e = 0) {
  return (Je[r[e + 0]] + Je[r[e + 1]] + Je[r[e + 2]] + Je[r[e + 3]] + "-" + Je[r[e + 4]] + Je[r[e + 5]] + "-" + Je[r[e + 6]] + Je[r[e + 7]] + "-" + Je[r[e + 8]] + Je[r[e + 9]] + "-" + Je[r[e + 10]] + Je[r[e + 11]] + Je[r[e + 12]] + Je[r[e + 13]] + Je[r[e + 14]] + Je[r[e + 15]]).toLowerCase();
}
var _o = new Uint8Array(256);
var yo = _o.length;
function La() {
  return yo > _o.length - 16 && ((0, import_crypto.randomFillSync)(_o), yo = 0), _o.slice(yo, yo += 16);
}
var Ua = { randomUUID: import_crypto2.randomUUID };
function d0(r, e, t) {
  if (Ua.randomUUID && !e && !r) return Ua.randomUUID();
  r = r || {};
  let n = r.random ?? r.rng?.() ?? La();
  if (n.length < 16) throw new Error("Random bytes length must be >= 16");
  if (n[6] = n[6] & 15 | 64, n[8] = n[8] & 63 | 128, e) {
    if (t = t || 0, t < 0 || t + 16 > e.length) throw new RangeError(`UUID byte range ${t}:${t + 15} is out of buffer bounds`);
    for (let o = 0; o < 16; ++o) e[t + o] = n[o];
    return e;
  }
  return Uf(n);
}
var Rr = d0;
var Co = class {
  name = "Anthropic";
  endPoint = "/v1/messages";
  async auth(e, t) {
    return { body: e, config: { headers: { "x-api-key": t.apiKey } } };
  }
  async transformRequestOut(e) {
    if (ne("Anthropic Request:", JSON.stringify(e, null, 2)), e.passthrough === true) {
      ne("AnthropicTransformer: Detected passthrough mode, returning original request");
      let { passthrough: a, ...u } = e;
      return { ...u };
    }
    let t = [];
    if (e.system) {
      if (typeof e.system == "string") t.push({ role: "system", content: e.system });
      else if (Array.isArray(e.system) && e.system.length) {
        let a = e.system.filter((u) => u.type === "text" && u.text).map((u) => ({ type: "text", text: u.text, cache_control: u.cache_control }));
        t.push({ role: "system", content: a });
      }
    }
    return JSON.parse(JSON.stringify(e.messages || []))?.forEach((a, u) => {
      if (a.role === "user" || a.role === "assistant") {
        if (typeof a.content == "string") {
          t.push({ role: a.role, content: a.content });
          return;
        }
        if (Array.isArray(a.content)) {
          if (a.role === "user") {
            let l = a.content.filter((d) => d.type === "tool_result" && d.tool_use_id);
            l.length && l.forEach((d, h) => {
              let C = { role: "tool", content: typeof d.content == "string" ? d.content : JSON.stringify(d.content), tool_call_id: d.tool_use_id, cache_control: d.cache_control };
              t.push(C);
            });
            let f = a.content.filter((d) => d.type === "text" && d.text || d.type === "image" && d.source);
            f.length && t.push({ role: "user", content: f.map((d) => d?.type === "image" ? { type: "image_url", image_url: { url: d.source?.type === "base64" ? d.source.data : d.source.url }, media_type: d.source.media_type } : d) });
          } else if (a.role === "assistant") {
            let l = { role: "assistant", content: null }, f = a.content.filter((h) => h.type === "text" && h.text);
            f.length && (l.content = f.map((h) => h.text).join(`
`));
            let d = a.content.filter((h) => h.type === "tool_use" && h.id);
            d.length && (l.tool_calls = d.map((h) => ({ id: h.id, type: "function", function: { name: h.name, arguments: JSON.stringify(h.input || {}) } }))), t.push(l);
          }
          return;
        }
      }
    }), { messages: t, model: e.model, max_tokens: e.max_tokens, temperature: e.temperature, stream: e.stream, tools: e.tools?.length ? this.convertAnthropicToolsToUnified(e.tools) : void 0, tool_choice: e.tool_choice };
  }
  async transformResponseIn(e, t) {
    if (e.headers.get("Content-Type")?.includes("text/event-stream")) {
      if (!e.body) throw new Error("Stream response body is null");
      let o = await this.convertOpenAIStreamToAnthropic(e.body);
      return new Response(o, { headers: { "Content-Type": "text/event-stream", "Cache-Control": "no-cache", Connection: "keep-alive" } });
    } else {
      let o = await e.json(), a = this.convertOpenAIResponseToAnthropic(o);
      return new Response(JSON.stringify(a), { headers: { "Content-Type": "application/json" } });
    }
  }
  convertAnthropicToolsToUnified(e) {
    return e.map((t) => ({ type: "function", function: { name: t.name, description: t.description || "", parameters: t.input_schema } }));
  }
  async convertOpenAIStreamToAnthropic(e) {
    return new ReadableStream({ async start(n) {
      let o = new TextEncoder(), a = `msg_${Date.now()}`, u = "unknown", l = false, f = false, d = false, h = /* @__PURE__ */ new Map(), C = /* @__PURE__ */ new Map(), w = 0, I = 0, S = 0, b = false, _ = false, y = 0, T = (P) => {
        if (!b) try {
          n.enqueue(P);
          let j = new TextDecoder().decode(P);
          ne("send data:", j.trim());
        } catch (j) {
          if (j instanceof TypeError && j.message.includes("Controller is already closed")) b = true;
          else throw ne(`send data error: ${j.message}`), j;
        }
      }, k = () => {
        if (!b) try {
          n.close(), b = true;
        } catch (P) {
          if (P instanceof TypeError && P.message.includes("Controller is already closed")) b = true;
          else throw P;
        }
      }, L = null;
      try {
        L = e.getReader();
        let P = new TextDecoder(), j = "";
        for (; !b; ) {
          let { done: G, value: re } = await L.read();
          if (G) break;
          j += P.decode(re, { stream: true });
          let W = j.split(`
`);
          j = W.pop() || "";
          for (let Ee of W) {
            if (b || d) break;
            if (!Ee.startsWith("data: ")) continue;
            let he = Ee.slice(6);
            if (he !== "[DONE]") try {
              let oe = JSON.parse(he);
              if (w++, ne("Original Response:", JSON.stringify(oe, null, 2)), oe.error) {
                let Z = { type: "error", message: { type: "api_error", message: JSON.stringify(oe.error) } };
                T(o.encode(`event: error
data: ${JSON.stringify(Z)}

`));
                continue;
              }
              if (u = oe.model || u, !l && !b && !d) {
                l = true;
                let Z = { type: "message_start", message: { id: a, type: "message", role: "assistant", content: [], model: u, stop_reason: null, stop_sequence: null, usage: { input_tokens: 1, output_tokens: 1 } } };
                T(o.encode(`event: message_start
data: ${JSON.stringify(Z)}

`));
              }
              let ue = oe.choices?.[0];
              if (!ue) continue;
              if (ue?.delta?.thinking && !b && !d) {
                if (!_) {
                  let Z = { type: "content_block_start", index: y, content_block: { type: "thinking", thinking: "" } };
                  T(o.encode(`event: content_block_start
data: ${JSON.stringify(Z)}

`)), _ = true;
                }
                if (ue.delta.thinking.signature) {
                  let Z = { type: "content_block_delta", index: y, delta: { type: "signature_delta", signature: ue.delta.thinking.signature } };
                  T(o.encode(`event: content_block_delta
data: ${JSON.stringify(Z)}

`));
                  let ce = { type: "content_block_stop", index: y };
                  T(o.encode(`event: content_block_stop
data: ${JSON.stringify(ce)}

`)), y++;
                } else if (ue.delta.thinking.content) {
                  let Z = { type: "content_block_delta", index: y, delta: { type: "thinking_delta", thinking: ue.delta.thinking.content || "" } };
                  T(o.encode(`event: content_block_delta
data: ${JSON.stringify(Z)}

`));
                }
              }
              if (ue?.delta?.content && !b && !d) {
                if (I++, !f && !d) {
                  f = true;
                  let Z = { type: "content_block_start", index: y, content_block: { type: "text", text: "" } };
                  T(o.encode(`event: content_block_start
data: ${JSON.stringify(Z)}

`));
                }
                if (!b && !d) {
                  let Z = { type: "content_block_delta", index: y, delta: { type: "text_delta", text: ue.delta.content } };
                  T(o.encode(`event: content_block_delta
data: ${JSON.stringify(Z)}

`));
                }
              }
              if (ue?.delta?.annotations?.length && !b && !d) {
                let Z = { type: "content_block_stop", index: y };
                T(o.encode(`event: content_block_stop
data: ${JSON.stringify(Z)}

`)), f = false, ue?.delta?.annotations.forEach((ce, pe, Te) => {
                  y++;
                  let J = { type: "content_block_start", index: y, content_block: { type: "web_search_tool_result", tool_use_id: `srvtoolu_${Rr()}`, content: [{ type: "web_search_result", title: ce.url_citation.title, url: ce.url_citation.url }] } };
                  T(o.encode(`event: content_block_start
data: ${JSON.stringify(J)}

`));
                  let X = { type: "content_block_stop", index: y };
                  T(o.encode(`event: content_block_stop
data: ${JSON.stringify(X)}

`));
                });
              }
              if (ue?.delta?.tool_calls && !b && !d) {
                S++;
                let Z = /* @__PURE__ */ new Set();
                for (let ce of ue.delta.tool_calls) {
                  if (b) break;
                  let pe = ce.index ?? 0;
                  if (Z.has(pe)) continue;
                  if (Z.add(pe), !C.has(pe)) {
                    let J = f ? C.size + 1 : C.size;
                    if (J !== 0) {
                      ne("content_block_stop2");
                      let H = { type: "content_block_stop", index: y };
                      T(o.encode(`event: content_block_stop
data: ${JSON.stringify(H)}

`)), y++;
                    }
                    C.set(pe, J);
                    let X = ce.id || `call_${Date.now()}_${pe}`, le = ce.function?.name || `tool_${pe}`, qe = { type: "content_block_start", index: y, content_block: { type: "tool_use", id: X, name: le, input: {} } };
                    T(o.encode(`event: content_block_start
data: ${JSON.stringify(qe)}

`));
                    let ze = { id: X, name: le, arguments: "", contentBlockIndex: J };
                    h.set(pe, ze);
                  } else if (ce.id && ce.function?.name) {
                    let J = h.get(pe);
                    J.id.startsWith("call_") && J.name.startsWith("tool_") && (J.id = ce.id, J.name = ce.function.name);
                  }
                  if (ce.function?.arguments && !b && !d) {
                    if (C.get(pe) === void 0) continue;
                    let X = h.get(pe);
                    X && (X.arguments += ce.function.arguments);
                    try {
                      let le = { type: "content_block_delta", index: y, delta: { type: "input_json_delta", partial_json: ce.function.arguments } };
                      T(o.encode(`event: content_block_delta
data: ${JSON.stringify(le)}

`));
                    } catch {
                      try {
                        let qe = ce.function.arguments.replace(/[\x00-\x1F\x7F-\x9F]/g, "").replace(/\\/g, "\\\\").replace(/"/g, '\\"'), ze = { type: "content_block_delta", index: y, delta: { type: "input_json_delta", partial_json: qe } };
                        T(o.encode(`event: content_block_delta
data: ${JSON.stringify(ze)}

`));
                      } catch (qe) {
                        console.error(qe);
                      }
                    }
                  }
                }
              }
              if (ue?.finish_reason && !b && !d) {
                if (d = true, I === 0 && S === 0 && console.error("Warning: No content in the stream response!"), (f || S > 0) && !b) {
                  ne("content_block_stop hasTextContentStarted");
                  let Z = { type: "content_block_stop", index: y };
                  T(o.encode(`event: content_block_stop
data: ${JSON.stringify(Z)}

`));
                }
                if (!b) {
                  let pe = { type: "message_delta", delta: { stop_reason: { stop: "end_turn", length: "max_tokens", tool_calls: "tool_use", content_filter: "stop_sequence" }[ue.finish_reason] || "end_turn", stop_sequence: null }, usage: { input_tokens: oe.usage?.prompt_tokens || 0, output_tokens: oe.usage?.completion_tokens || 0 } };
                  T(o.encode(`event: message_delta
data: ${JSON.stringify(pe)}

`));
                }
                if (!b) {
                  let Z = { type: "message_stop" };
                  T(o.encode(`event: message_stop
data: ${JSON.stringify(Z)}

`));
                }
                break;
              }
            } catch (oe) {
              ne(`parseError: ${oe.name} message: ${oe.message} stack: ${oe.stack} data: ${he}`);
            }
          }
        }
        k();
      } catch (P) {
        if (!b) try {
          n.error(P);
        } catch (j) {
          console.error(j);
        }
      } finally {
        if (L) try {
          L.releaseLock();
        } catch (P) {
          console.error(P);
        }
      }
    }, cancel(n) {
      ne("cancle stream:", n);
    } });
  }
  convertOpenAIResponseToAnthropic(e) {
    ne("Original OpenAI response:", JSON.stringify(e, null, 2));
    let t = e.choices[0];
    if (!t) throw new Error("No choices found in OpenAI response");
    let n = [];
    if (t.message.annotations) {
      let a = `srvtoolu_${Rr()}`;
      n.push({ type: "server_tool_use", id: a, name: "web_search", input: { query: "" } }), n.push({ type: "web_search_tool_result", tool_use_id: a, content: t.message.annotations.map((u) => ({ type: "web_search_result", url: u.url_citation.url, title: u.url_citation.title })) });
    }
    t.message.content && n.push({ type: "text", text: t.message.content }), t.message.tool_calls && t.message.tool_calls.length > 0 && t.message.tool_calls.forEach((a, u) => {
      let l = {};
      try {
        let f = a.function.arguments || "{}";
        typeof f == "object" ? l = f : typeof f == "string" && (l = JSON.parse(f));
      } catch {
        l = { text: a.function.arguments || "" };
      }
      n.push({ type: "tool_use", id: a.id, name: a.function.name, input: l });
    });
    let o = { id: e.id, type: "message", role: "assistant", model: e.model, content: n, stop_reason: t.finish_reason === "stop" ? "end_turn" : t.finish_reason === "length" ? "max_tokens" : t.finish_reason === "tool_calls" ? "tool_use" : t.finish_reason === "content_filter" ? "stop_sequence" : "end_turn", stop_sequence: null, usage: { input_tokens: e.usage?.prompt_tokens || 0, output_tokens: e.usage?.completion_tokens || 0 } };
    return ne("Conversion complete, final Anthropic response:", JSON.stringify(o, null, 2)), o;
  }
};
function Ma(r) {
  if (!(!r || typeof r != "object")) {
    if (Array.isArray(r)) {
      r.forEach(Ma);
      return;
    }
    delete r.$schema, delete r.additionalProperties, delete r.const, r.type === "string" && r.format && !["enum", "date-time"].includes(r.format) && delete r.format, Object.keys(r).forEach((e) => {
      Ma(r[e]);
    });
  }
}
function bo(r) {
  let e = [], t = r.tools?.filter((a) => a.function.name !== "web_search")?.map((a) => (a.function.parameters && Ma(a.function.parameters), { name: a.function.name, description: a.function.description, parameters: a.function.parameters }));
  return t?.length && e.push({ functionDeclarations: t }), r.tools?.find((a) => a.function.name === "web_search") && e.push({ googleSearch: {} }), { contents: r.messages.map((a) => {
    let u;
    a.role === "assistant" ? u = "model" : (["user", "system", "tool"].includes(a.role), u = "user");
    let l = [];
    return typeof a.content == "string" ? l.push({ text: a.content }) : Array.isArray(a.content) && l.push(...a.content.map((f) => {
      if (f.type === "text") return { text: f.text || "" };
      if (f.type === "image_url") return f.image_url.url.startsWith("http") ? { file_data: { mime_type: f.media_type, file_uri: f.image_url.url } } : { inlineData: { mime_type: f.media_type, data: f.image_url.url } };
    })), Array.isArray(a.tool_calls) && l.push(...a.tool_calls.map((f) => ({ functionCall: { id: f.id || `tool_${Math.random().toString(36).substring(2, 15)}`, name: f.function.name, args: JSON.parse(f.function.arguments || "{}") } }))), { role: u, parts: l };
  }), tools: e.length ? e : void 0 };
}
function Eo(r) {
  let e = r.contents, t = r.tools, n = r.model, o = r.max_tokens, a = r.temperature, u = r.stream, l = r.tool_choice, f = { messages: [], model: n, max_tokens: o, temperature: a, stream: u, tool_choice: l };
  return Array.isArray(e) && e.forEach((d) => {
    typeof d == "string" ? f.messages.push({ role: "user", content: d }) : typeof d.text == "string" ? f.messages.push({ role: "user", content: d.text || null }) : d.role === "user" ? f.messages.push({ role: "user", content: d?.parts?.map((h) => ({ type: "text", text: h.text || "" })) || [] }) : d.role === "model" && f.messages.push({ role: "assistant", content: d?.parts?.map((h) => ({ type: "text", text: h.text || "" })) || [] });
  }), Array.isArray(t) && (f.tools = [], t.forEach((d) => {
    Array.isArray(d.functionDeclarations) && d.functionDeclarations.forEach((h) => {
      f.tools.push({ type: "function", function: { name: h.name, description: h.description, parameters: h.parameters } });
    });
  })), f;
}
async function wo(r, e) {
  if (r.headers.get("Content-Type")?.includes("application/json")) {
    let t = await r.json(), n = t.candidates[0].content?.parts?.filter((a) => a.functionCall)?.map((a) => ({ id: a.functionCall?.id || `tool_${Math.random().toString(36).substring(2, 15)}`, type: "function", function: { name: a.functionCall?.name, arguments: JSON.stringify(a.functionCall?.args || {}) } })) || [], o = { id: t.responseId, choices: [{ finish_reason: t.candidates[0].finishReason?.toLowerCase() || null, index: 0, message: { content: t.candidates[0].content?.parts?.filter((a) => a.text)?.map((a) => a.text)?.join(`
`), role: "assistant", tool_calls: n.length > 0 ? n : void 0 } }], created: parseInt((/* @__PURE__ */ new Date()).getTime() / 1e3 + "", 10), model: t.modelVersion, object: "chat.completion", usage: { completion_tokens: t.usageMetadata.candidatesTokenCount, prompt_tokens: t.usageMetadata.promptTokenCount, cached_content_token_count: t.usageMetadata.cachedContentTokenCount || null, total_tokens: t.usageMetadata.totalTokenCount } };
    return new Response(JSON.stringify(o), { status: r.status, statusText: r.statusText, headers: r.headers });
  } else if (r.headers.get("Content-Type")?.includes("stream")) {
    if (!r.body) return r;
    let t = new TextDecoder(), n = new TextEncoder(), o = (u, l) => {
      if (u.startsWith("data: ")) {
        let f = u.slice(6).trim();
        if (f) {
          ne(`${e} chunk:`, f);
          try {
            let d = JSON.parse(f), h = d.candidates[0].content?.parts?.filter((w) => w.functionCall)?.map((w) => ({ id: w.functionCall?.id || `tool_${Math.random().toString(36).substring(2, 15)}`, type: "function", function: { name: w.functionCall?.name, arguments: JSON.stringify(w.functionCall?.args || {}) } })), C = { choices: [{ delta: { role: "assistant", content: d.candidates[0].content?.parts?.filter((w) => w.text)?.map((w) => w.text)?.join(`
`), tool_calls: h.length > 0 ? h : void 0 }, finish_reason: d.candidates[0].finishReason?.toLowerCase() || null, index: d.candidates[0].index || h.length > 0 ? 1 : 0, logprobs: null }], created: parseInt((/* @__PURE__ */ new Date()).getTime() / 1e3 + "", 10), id: d.responseId || "", model: d.modelVersion || "", object: "chat.completion.chunk", system_fingerprint: "fp_a49d71b8a1", usage: { completion_tokens: d.usageMetadata.candidatesTokenCount, prompt_tokens: d.usageMetadata.promptTokenCount, cached_content_token_count: d.usageMetadata.cachedContentTokenCount || null, total_tokens: d.usageMetadata.totalTokenCount } };
            d.candidates[0]?.groundingMetadata?.groundingChunks?.length && (C.choices[0].delta.annotations = d.candidates[0].groundingMetadata.groundingChunks.map((w, I) => {
              let S = d.candidates[0]?.groundingMetadata?.groundingSupports?.filter((b) => b.groundingChunkIndices.includes(I));
              return { type: "url_citation", url_citation: { url: w.web.uri, title: w.web.title, content: S?.[0].segment.text, start_index: S?.[0].segment.startIndex, end_index: S?.[0].segment.endIndex } };
            })), l.enqueue(n.encode(`data: ${JSON.stringify(C)}

`));
          } catch (d) {
            ne(`Error parsing ${e} stream chunk`, f, d.message);
          }
        }
      }
    }, a = new ReadableStream({ async start(u) {
      let l = r.body.getReader(), f = "";
      try {
        for (; ; ) {
          let { done: d, value: h } = await l.read();
          if (d) {
            f && o(f, u);
            break;
          }
          f += t.decode(h, { stream: true });
          let C = f.split(`
`);
          f = C.pop() || "";
          for (let w of C) o(w, u);
        }
      } catch (d) {
        u.error(d);
      } finally {
        u.close();
      }
    } });
    return new Response(a, { status: r.status, statusText: r.statusText, headers: r.headers });
  }
  return r;
}
var Ao = class {
  name = "gemini";
  endPoint = "/v1beta/models/:modelAndAction";
  async transformRequestIn(e, t) {
    return { body: bo(e), config: { url: new URL(`./${e.model}:${e.stream ? "streamGenerateContent?alt=sse" : "generateContent"}`, t.baseUrl), headers: { "x-goog-api-key": t.apiKey, Authorization: void 0 } } };
  }
  transformRequestOut = Eo;
  async transformResponseOut(e) {
    return wo(e, this.name);
  }
};
async function Gw() {
  try {
    let { GoogleAuth: r } = await Promise.resolve().then(() => Jr(ol(), 1));
    return (await (await new r({ scopes: ["https://www.googleapis.com/auth/cloud-platform"] }).getClient()).getAccessToken()).token || "";
  } catch (r) {
    throw ne("Error getting access token:", r), new Error(`Failed to get access token for Vertex AI. Please ensure you have set up authentication using one of these methods:
1. Set GOOGLE_APPLICATION_CREDENTIALS to point to service account key file
2. Run "gcloud auth application-default login"
3. Use Google Cloud environment with default service account`);
  }
}
var $i = class {
  name = "vertex-gemini";
  endPoint = "/v1/projects/:projectId/locations/:location/publishers/google/models/:modelAndAction";
  async transformRequestIn(e, t) {
    let n = process.env.GOOGLE_CLOUD_PROJECT, o = process.env.GOOGLE_CLOUD_LOCATION || "us-central1";
    if (!n && process.env.GOOGLE_APPLICATION_CREDENTIALS) try {
      let l = (await import("fs")).readFileSync(process.env.GOOGLE_APPLICATION_CREDENTIALS, "utf8"), f = JSON.parse(l);
      f && f.project_id && (n = f.project_id);
    } catch (u) {
      ne("Error extracting project_id from GOOGLE_APPLICATION_CREDENTIALS:", u);
    }
    if (!n) throw new Error("Project ID is required for Vertex AI. Set GOOGLE_CLOUD_PROJECT environment variable or ensure project_id is in GOOGLE_APPLICATION_CREDENTIALS file.");
    let a = await Gw();
    return { body: bo(e), config: { url: new URL(`./v1beta1/projects/${n}/locations/${o}/publishers/google/models/${e.model}:${e.stream ? "streamGenerateContent" : "generateContent"}`, t.baseUrl.endsWith("/") ? t.baseUrl : t.baseUrl + "/" || `https://${o}-aiplatform.googleapis.com`), headers: { Authorization: `Bearer ${a}`, "x-goog-api-key": void 0 } } };
  }
  transformRequestOut = Eo;
  async transformResponseOut(e) {
    return wo(e, this.name);
  }
};
var Hi = class {
  name = "deepseek";
  async transformRequestIn(e) {
    return e.max_tokens && e.max_tokens > 8192 && (e.max_tokens = 8192), e;
  }
  async transformResponseOut(e) {
    if (e.headers.get("Content-Type")?.includes("application/json")) {
      let t = await e.json();
      return new Response(JSON.stringify(t), { status: e.status, statusText: e.statusText, headers: e.headers });
    } else if (e.headers.get("Content-Type")?.includes("stream")) {
      if (!e.body) return e;
      let t = new TextDecoder(), n = new TextEncoder(), o = "", a = false, u = "", l = new ReadableStream({ async start(f) {
        let d = e.body.getReader(), h = (w, I, S) => {
          let b = w.split(`
`);
          for (let _ of b) _.trim() && I.enqueue(S.encode(_ + `
`));
        }, C = (w, I) => {
          let { controller: S, encoder: b } = I;
          if (w.startsWith("data: ") && w.trim() !== "data: [DONE]") try {
            let _ = JSON.parse(w.slice(6));
            if (_.choices?.[0]?.delta?.reasoning_content) {
              I.appendReasoningContent(_.choices[0].delta.reasoning_content);
              let y = { ..._, choices: [{ ..._.choices[0], delta: { ..._.choices[0].delta, thinking: { content: _.choices[0].delta.reasoning_content } } }] };
              delete y.choices[0].delta.reasoning_content;
              let T = `data: ${JSON.stringify(y)}

`;
              S.enqueue(b.encode(T));
              return;
            }
            if (_.choices?.[0]?.delta?.content && I.reasoningContent() && !I.isReasoningComplete()) {
              I.setReasoningComplete(true);
              let y = Date.now().toString(), T = { ..._, choices: [{ ..._.choices[0], delta: { ..._.choices[0].delta, content: null, thinking: { content: I.reasoningContent(), signature: y } } }] };
              delete T.choices[0].delta.reasoning_content;
              let k = `data: ${JSON.stringify(T)}

`;
              S.enqueue(b.encode(k));
            }
            if (_.choices[0]?.delta?.reasoning_content && delete _.choices[0].delta.reasoning_content, _.choices?.[0]?.delta && Object.keys(_.choices[0].delta).length > 0) {
              I.isReasoningComplete() && _.choices[0].index++;
              let y = `data: ${JSON.stringify(_)}

`;
              S.enqueue(b.encode(y));
            }
          } catch {
            S.enqueue(b.encode(w + `
`));
          }
          else S.enqueue(b.encode(w + `
`));
        };
        try {
          for (; ; ) {
            let { done: w, value: I } = await d.read();
            if (w) {
              u.trim() && h(u, f, n);
              break;
            }
            let S = t.decode(I, { stream: true });
            u += S;
            let b = u.split(`
`);
            u = b.pop() || "";
            for (let _ of b) if (_.trim()) try {
              C(_, { controller: f, encoder: n, reasoningContent: () => o, appendReasoningContent: (y) => o += y, isReasoningComplete: () => a, setReasoningComplete: (y) => a = y });
            } catch (y) {
              console.error("Error processing line:", _, y), f.enqueue(n.encode(_ + `
`));
            }
          }
        } catch (w) {
          console.error("Stream error:", w), f.error(w);
        } finally {
          try {
            d.releaseLock();
          } catch (w) {
            console.error("Error releasing reader lock:", w);
          }
          f.close();
        }
      } });
      return new Response(l, { status: e.status, statusText: e.statusText, headers: { "Content-Type": e.headers.get("Content-Type") || "text/plain", "Cache-Control": "no-cache", Connection: "keep-alive" } });
    }
    return e;
  }
};
var Gi = class {
  name = "tooluse";
  transformRequestIn(e) {
    return e.messages.push({ role: "system", content: "<system-reminder>Tool mode is active. The user expects you to proactively execute the most suitable tool to help complete the task. \nBefore invoking a tool, you must carefully evaluate whether it matches the current task. If no available tool is appropriate for the task, you MUST call the `ExitTool` to exit tool mode \u2014 this is the only valid way to terminate tool mode.\nAlways prioritize completing the user's task effectively and efficiently by using tools whenever appropriate.</system-reminder>" }), e.tools?.length && (e.tool_choice = "required", e.tools.unshift({ type: "function", function: { name: "ExitTool", description: `Use this tool when you are in tool mode and have completed the task. This is the only valid way to exit tool mode.
IMPORTANT: Before using this tool, ensure that none of the available tools are applicable to the current task. You must evaluate all available options \u2014 only if no suitable tool can help you complete the task should you use ExitTool to terminate tool mode.
Examples:
1. Task: "Use a tool to summarize this document" \u2014 Do not use ExitTool if a summarization tool is available.
2. Task: "What\u2019s the weather today?" \u2014 If no tool is available to answer, use ExitTool after reasoning that none can fulfill the task.`, parameters: { type: "object", properties: { response: { type: "string", description: "Your response will be forwarded to the user exactly as returned \u2014 the tool will not modify or post-process it in any way." } }, required: ["response"] } } })), e;
  }
  async transformResponseOut(e) {
    if (e.headers.get("Content-Type")?.includes("application/json")) {
      let t = await e.json();
      if (t?.choices[0]?.message.tool_calls?.length && t?.choices[0]?.message.tool_calls[0]?.function?.name === "ExitTool") {
        let n = t?.choices[0]?.message.tool_calls[0], o = JSON.parse(n.function.arguments || "{}");
        t.choices[0].message.content = o.response || "", delete t.choices[0].message.tool_calls;
      }
      return new Response(JSON.stringify(t), { status: e.status, statusText: e.statusText, headers: e.headers });
    } else if (e.headers.get("Content-Type")?.includes("stream")) {
      if (!e.body) return e;
      let t = new TextDecoder(), n = new TextEncoder(), o = -1, a = "", u = "", l = new ReadableStream({ async start(f) {
        let d = e.body.getReader(), h = (w, I, S) => {
          let b = w.split(`
`);
          for (let _ of b) _.trim() && I.enqueue(S.encode(_ + `
`));
        }, C = (w, I) => {
          let { controller: S, encoder: b, exitToolIndex: _, setExitToolIndex: y, appendExitToolResponse: T } = I;
          if (w.startsWith("data: ") && w.trim() !== "data: [DONE]") try {
            let k = JSON.parse(w.slice(6));
            if (k.choices[0]?.delta?.tool_calls?.length) {
              let L = k.choices[0].delta.tool_calls[0];
              if (L.function?.name === "ExitTool") {
                y(L.index);
                return;
              } else if (_() > -1 && L.index === _() && L.function.arguments) {
                T(L.function.arguments);
                try {
                  let P = JSON.parse(I.exitToolResponse());
                  k.choices = [{ delta: { role: "assistant", content: P.response || "" } }];
                  let j = `data: ${JSON.stringify(k)}

`;
                  S.enqueue(b.encode(j));
                } catch {
                }
                return;
              }
            }
            if (k.choices?.[0]?.delta && Object.keys(k.choices[0].delta).length > 0) {
              let L = `data: ${JSON.stringify(k)}

`;
              S.enqueue(b.encode(L));
            }
          } catch {
            S.enqueue(b.encode(w + `
`));
          }
          else S.enqueue(b.encode(w + `
`));
        };
        try {
          for (; ; ) {
            let { done: w, value: I } = await d.read();
            if (w) {
              u.trim() && h(u, f, n);
              break;
            }
            let S = t.decode(I, { stream: true });
            u += S;
            let b = u.split(`
`);
            u = b.pop() || "";
            for (let _ of b) if (_.trim()) try {
              C(_, { controller: f, encoder: n, exitToolIndex: () => o, setExitToolIndex: (y) => o = y, exitToolResponse: () => a, appendExitToolResponse: (y) => a += y });
            } catch (y) {
              console.error("Error processing line:", _, y), f.enqueue(n.encode(_ + `
`));
            }
          }
        } catch (w) {
          console.error("Stream error:", w), f.error(w);
        } finally {
          try {
            d.releaseLock();
          } catch (w) {
            console.error("Error releasing reader lock:", w);
          }
          f.close();
        }
      } });
      return new Response(l, { status: e.status, statusText: e.statusText, headers: { "Content-Type": e.headers.get("Content-Type") || "text/plain", "Cache-Control": "no-cache", Connection: "keep-alive" } });
    }
    return e;
  }
};
var Wi = class {
  constructor(e) {
    this.options = e;
  }
  static TransformerName = "openrouter";
  async transformRequestIn(e) {
    return e.model.includes("claude") ? e.messages.forEach((t) => {
      Array.isArray(t.content) && t.content.forEach((n) => {
        n.type === "image_url" && (n.image_url.url.startsWith("http") || (n.image_url.url = `data:${n.media_type};base64,${n.image_url.url}`), delete n.media_type);
      });
    }) : e.messages.forEach((t) => {
      Array.isArray(t.content) ? t.content.forEach((n) => {
        n.cache_control && delete n.cache_control, n.type === "image_url" && (n.image_url.url.startsWith("http") || (n.image_url.url = `data:${n.media_type};base64,${n.image_url.url}`), delete n.media_type);
      }) : t.cache_control && delete t.cache_control;
    }), Object.assign(e, this.options || {}), e;
  }
  async transformResponseOut(e) {
    if (e.headers.get("Content-Type")?.includes("application/json")) {
      let t = await e.json();
      return new Response(JSON.stringify(t), { status: e.status, statusText: e.statusText, headers: e.headers });
    } else if (e.headers.get("Content-Type")?.includes("stream")) {
      if (!e.body) return e;
      let t = new TextDecoder(), n = new TextEncoder(), o = false, a = "", u = false, l = false, f = "", d = new ReadableStream({ async start(h) {
        let C = e.body.getReader(), w = (S, b, _) => {
          let y = S.split(`
`);
          for (let T of y) T.trim() && b.enqueue(_.encode(T + `
`));
        }, I = (S, b) => {
          let { controller: _, encoder: y } = b;
          if (S.startsWith("data: ") && S.trim() !== "data: [DONE]") {
            let T = S.slice(6);
            try {
              let k = JSON.parse(T);
              if (k.usage && (ne("usage", k.usage, l), k.choices[0].finish_reason = l ? "tool_calls" : "stop"), k.choices?.[0]?.finish_reason === "error" && _.enqueue(y.encode(`data: ${JSON.stringify({ error: k.choices?.[0].error })}

`)), k.choices?.[0]?.delta?.content && !b.hasTextContent() && b.setHasTextContent(true), k.choices?.[0]?.delta?.reasoning) {
                b.appendReasoningContent(k.choices[0].delta.reasoning);
                let P = { ...k, choices: [{ ...k.choices?.[0], delta: { ...k.choices[0].delta, thinking: { content: k.choices[0].delta.reasoning } } }] };
                P.choices?.[0]?.delta && delete P.choices[0].delta.reasoning;
                let j = `data: ${JSON.stringify(P)}

`;
                _.enqueue(y.encode(j));
                return;
              }
              if (k.choices?.[0]?.delta?.content && b.reasoningContent() && !b.isReasoningComplete()) {
                b.setReasoningComplete(true);
                let P = Date.now().toString(), j = { ...k, choices: [{ ...k.choices?.[0], delta: { ...k.choices[0].delta, content: null, thinking: { content: b.reasoningContent(), signature: P } } }] };
                j.choices?.[0]?.delta && delete j.choices[0].delta.reasoning;
                let G = `data: ${JSON.stringify(j)}

`;
                _.enqueue(y.encode(G));
              }
              k.choices?.[0]?.delta?.reasoning && delete k.choices[0].delta.reasoning, k.choices?.[0]?.delta?.tool_calls?.length && !Number.isNaN(parseInt(k.choices?.[0]?.delta?.tool_calls[0].id, 10)) && k.choices?.[0]?.delta?.tool_calls.forEach((P) => {
                P.id = `call_${Rr()}`;
              }), k.choices?.[0]?.delta?.tool_calls?.length && !l && (ne("hasToolCall", true), l = true), k.choices?.[0]?.delta?.tool_calls?.length && b.hasTextContent() && (typeof k.choices[0].index == "number" ? k.choices[0].index += 1 : k.choices[0].index = 1);
              let L = `data: ${JSON.stringify(k)}

`;
              _.enqueue(y.encode(L));
            } catch {
              _.enqueue(y.encode(S + `
`));
            }
          } else _.enqueue(y.encode(S + `
`));
        };
        try {
          for (; ; ) {
            let { done: S, value: b } = await C.read();
            if (S) {
              f.trim() && w(f, h, n);
              break;
            }
            if (!b || b.length === 0) continue;
            let _;
            try {
              _ = t.decode(b, { stream: true });
            } catch (T) {
              console.warn("Failed to decode chunk", T);
              continue;
            }
            if (_.length === 0) continue;
            if (f += _, f.length > 1e6) {
              console.warn("Buffer size exceeds limit, processing partial data");
              let T = f.split(`
`);
              f = T.pop() || "";
              for (let k of T) if (k.trim()) try {
                I(k, { controller: h, encoder: n, hasTextContent: () => o, setHasTextContent: (L) => o = L, reasoningContent: () => a, appendReasoningContent: (L) => a += L, isReasoningComplete: () => u, setReasoningComplete: (L) => u = L });
              } catch (L) {
                console.error("Error processing line:", k, L), h.enqueue(n.encode(k + `
`));
              }
              continue;
            }
            let y = f.split(`
`);
            f = y.pop() || "";
            for (let T of y) if (T.trim()) try {
              I(T, { controller: h, encoder: n, hasTextContent: () => o, setHasTextContent: (k) => o = k, reasoningContent: () => a, appendReasoningContent: (k) => a += k, isReasoningComplete: () => u, setReasoningComplete: (k) => u = k });
            } catch (k) {
              console.error("Error processing line:", T, k), h.enqueue(n.encode(T + `
`));
            }
          }
        } catch (S) {
          console.error("Stream error:", S), h.error(S);
        } finally {
          try {
            C.releaseLock();
          } catch (S) {
            console.error("Error releasing reader lock:", S);
          }
          h.close();
        }
      } });
      return new Response(d, { status: e.status, statusText: e.statusText, headers: { "Content-Type": e.headers.get("Content-Type") || "text/plain", "Cache-Control": "no-cache", Connection: "keep-alive" } });
    }
    return e;
  }
};
var zi = class {
  constructor(e) {
    this.options = e;
    this.max_tokens = this.options?.max_tokens;
  }
  static TransformerName = "maxtoken";
  max_tokens;
  async transformRequestIn(e) {
    return e.max_tokens && e.max_tokens > this.max_tokens && (e.max_tokens = this.max_tokens), e;
  }
};
var Ji = class {
  name = "groq";
  async transformRequestIn(e) {
    return e.messages.forEach((t) => {
      Array.isArray(t.content) ? t.content.forEach((n) => {
        n.cache_control && delete n.cache_control;
      }) : t.cache_control && delete t.cache_control;
    }), Array.isArray(e.tools) && e.tools.forEach((t) => {
      delete t.function.parameters.$schema;
    }), e;
  }
  async transformResponseOut(e) {
    if (e.headers.get("Content-Type")?.includes("application/json")) {
      let t = await e.json();
      return new Response(JSON.stringify(t), { status: e.status, statusText: e.statusText, headers: e.headers });
    } else if (e.headers.get("Content-Type")?.includes("stream")) {
      if (!e.body) return e;
      let t = new TextDecoder(), n = new TextEncoder(), o = false, a = "", u = false, l = "", f = new ReadableStream({ async start(d) {
        let h = e.body.getReader(), C = (I, S, b) => {
          let _ = I.split(`
`);
          for (let y of _) y.trim() && S.enqueue(b.encode(y + `
`));
        }, w = (I, S) => {
          let { controller: b, encoder: _ } = S;
          if (I.startsWith("data: ") && I.trim() !== "data: [DONE]") {
            let y = I.slice(6);
            try {
              let T = JSON.parse(y);
              if (T.error) throw new Error(JSON.stringify(T));
              T.choices?.[0]?.delta?.content && !S.hasTextContent() && S.setHasTextContent(true), T.choices?.[0]?.delta?.tool_calls?.length && T.choices?.[0]?.delta?.tool_calls.forEach((L) => {
                L.id = `call_${Rr()}`;
              }), T.choices?.[0]?.delta?.tool_calls?.length && S.hasTextContent() && (typeof T.choices[0].index == "number" ? T.choices[0].index += 1 : T.choices[0].index = 1);
              let k = `data: ${JSON.stringify(T)}

`;
              b.enqueue(_.encode(k));
            } catch {
              b.enqueue(_.encode(I + `
`));
            }
          } else b.enqueue(_.encode(I + `
`));
        };
        try {
          for (; ; ) {
            let { done: I, value: S } = await h.read();
            if (I) {
              l.trim() && C(l, d, n);
              break;
            }
            if (!S || S.length === 0) continue;
            let b;
            try {
              b = t.decode(S, { stream: true });
            } catch (y) {
              console.warn("Failed to decode chunk", y);
              continue;
            }
            if (b.length === 0) continue;
            if (l += b, l.length > 1e6) {
              console.warn("Buffer size exceeds limit, processing partial data");
              let y = l.split(`
`);
              l = y.pop() || "";
              for (let T of y) if (T.trim()) try {
                w(T, { controller: d, encoder: n, hasTextContent: () => o, setHasTextContent: (k) => o = k, reasoningContent: () => a, appendReasoningContent: (k) => a += k, isReasoningComplete: () => u, setReasoningComplete: (k) => u = k });
              } catch (k) {
                console.error("Error processing line:", T, k), d.enqueue(n.encode(T + `
`));
              }
              continue;
            }
            let _ = l.split(`
`);
            l = _.pop() || "";
            for (let y of _) if (y.trim()) try {
              w(y, { controller: d, encoder: n, hasTextContent: () => o, setHasTextContent: (T) => o = T, reasoningContent: () => a, appendReasoningContent: (T) => a += T, isReasoningComplete: () => u, setReasoningComplete: (T) => u = T });
            } catch (T) {
              console.error("Error processing line:", y, T), d.enqueue(n.encode(y + `
`));
            }
          }
        } catch (I) {
          console.error("Stream error:", I), d.error(I);
        } finally {
          try {
            h.releaseLock();
          } catch (I) {
            console.error("Error releasing reader lock:", I);
          }
          d.close();
        }
      } });
      return new Response(f, { status: e.status, statusText: e.statusText, headers: { "Content-Type": e.headers.get("Content-Type") || "text/plain", "Cache-Control": "no-cache", Connection: "keep-alive" } });
    }
    return e;
  }
};
var Vi = class {
  name = "cleancache";
  async transformRequestIn(e) {
    return Array.isArray(e.messages) && e.messages.forEach((t) => {
      Array.isArray(t.content) ? t.content.forEach((n) => {
        n.cache_control && delete n.cache_control;
      }) : t.cache_control && delete t.cache_control;
    }), e;
  }
};
var Qm = Jr(ja(), 1);
var _r = class extends Error {
  constructor(e, t) {
    super(`${e} at position ${t}`), this.position = t;
  }
};
function Wm(r) {
  return /^[0-9A-Fa-f]$/.test(r);
}
function jr(r) {
  return r >= "0" && r <= "9";
}
function zm(r) {
  return r >= " ";
}
function Bs(r) {
  return `,:[]/{}()
+`.includes(r);
}
function il(r) {
  return r >= "a" && r <= "z" || r >= "A" && r <= "Z" || r === "_" || r === "$";
}
function al(r) {
  return r >= "a" && r <= "z" || r >= "A" && r <= "Z" || r === "_" || r === "$" || r >= "0" && r <= "9";
}
var ul = /^(http|https|ftp|mailto|file|data|irc):\/\/$/;
var cl = /^[A-Za-z0-9-._~:/?#@!$&'()*+;=]$/;
function ll(r) {
  return `,[]/{}
+`.includes(r);
}
function fl(r) {
  return Is(r) || Ww.test(r);
}
var Ww = /^[[{\w-]$/;
function Jm(r) {
  return r === `
` || r === "\r" || r === "	" || r === "\b" || r === "\f";
}
function qr(r, e) {
  let t = r.charCodeAt(e);
  return t === 32 || t === 10 || t === 9 || t === 13;
}
function Vm(r, e) {
  let t = r.charCodeAt(e);
  return t === 32 || t === 9 || t === 13;
}
function Km(r, e) {
  let t = r.charCodeAt(e);
  return t === 160 || t >= 8192 && t <= 8202 || t === 8239 || t === 8287 || t === 12288;
}
function Is(r) {
  return dl(r) || Ki(r);
}
function dl(r) {
  return r === '"' || r === "\u201C" || r === "\u201D";
}
function hl(r) {
  return r === '"';
}
function Ki(r) {
  return r === "'" || r === "\u2018" || r === "\u2019" || r === "`" || r === "\xB4";
}
function pl(r) {
  return r === "'";
}
function Kn(r, e) {
  let t = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false, n = r.lastIndexOf(e);
  return n !== -1 ? r.substring(0, n) + (t ? "" : r.substring(n + 1)) : r;
}
function Ft(r, e) {
  let t = r.length;
  if (!qr(r, t - 1)) return r + e;
  for (; qr(r, t - 1); ) t--;
  return r.substring(0, t) + e + r.substring(t);
}
function Ym(r, e, t) {
  return r.substring(0, e) + r.substring(e + t);
}
function Xm(r) {
  return /[,\n][ \t\r]*$/.test(r);
}
var zw = { "\b": "\\b", "\f": "\\f", "\n": "\\n", "\r": "\\r", "	": "\\t" };
var Jw = { '"': '"', "\\": "\\", "/": "/", b: "\b", f: "\f", n: `
`, r: "\r", t: "	" };
function ml(r) {
  let e = 0, t = "";
  d(["```", "[```", "{```"]), a() || Z(), d(["```", "```]", "```}"]);
  let o = C(",");
  for (o && u(), fl(r[e]) && Xm(t) ? (o || (t = Ft(t, ",")), y()) : o && (t = Kn(t, ",")); r[e] === "}" || r[e] === "]"; ) e++, u();
  if (e >= r.length) return t;
  ue();
  function a() {
    u();
    let J = b() || _() || T() || L() || P() || G(false) || re();
    return u(), J;
  }
  function u() {
    let J = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : true, X = e, le = l(J);
    do
      le = f(), le && (le = l(J));
    while (le);
    return e > X;
  }
  function l(J) {
    let X = J ? qr : Vm, le = "";
    for (; ; ) if (X(r, e)) le += r[e], e++;
    else if (Km(r, e)) le += " ", e++;
    else break;
    return le.length > 0 ? (t += le, true) : false;
  }
  function f() {
    if (r[e] === "/" && r[e + 1] === "*") {
      for (; e < r.length && !Vw(r, e); ) e++;
      return e += 2, true;
    }
    if (r[e] === "/" && r[e + 1] === "/") {
      for (; e < r.length && r[e] !== `
`; ) e++;
      return true;
    }
    return false;
  }
  function d(J) {
    if (h(J)) {
      if (il(r[e])) for (; e < r.length && al(r[e]); ) e++;
      return u(), true;
    }
    return false;
  }
  function h(J) {
    for (let X of J) {
      let le = e + X.length;
      if (r.slice(e, le) === X) return e = le, true;
    }
    return false;
  }
  function C(J) {
    return r[e] === J ? (t += r[e], e++, true) : false;
  }
  function w(J) {
    return r[e] === J ? (e++, true) : false;
  }
  function I() {
    return w("\\");
  }
  function S() {
    return u(), r[e] === "." && r[e + 1] === "." && r[e + 2] === "." ? (e += 3, u(), w(","), true) : false;
  }
  function b() {
    if (r[e] === "{") {
      t += "{", e++, u(), w(",") && u();
      let J = true;
      for (; e < r.length && r[e] !== "}"; ) {
        let X;
        if (J ? (X = true, J = false) : (X = C(","), X || (t = Ft(t, ",")), u()), S(), !(T() || G(true))) {
          r[e] === "}" || r[e] === "{" || r[e] === "]" || r[e] === "[" || r[e] === void 0 ? t = Kn(t, ",") : ce();
          break;
        }
        u();
        let qe = C(":"), ze = e >= r.length;
        qe || (fl(r[e]) || ze ? t = Ft(t, ":") : pe()), a() || (qe || ze ? t += "null" : pe());
      }
      return r[e] === "}" ? (t += "}", e++) : t = Ft(t, "}"), true;
    }
    return false;
  }
  function _() {
    if (r[e] === "[") {
      t += "[", e++, u(), w(",") && u();
      let J = true;
      for (; e < r.length && r[e] !== "]"; ) if (J ? J = false : C(",") || (t = Ft(t, ",")), S(), !a()) {
        t = Kn(t, ",");
        break;
      }
      return r[e] === "]" ? (t += "]", e++) : t = Ft(t, "]"), true;
    }
    return false;
  }
  function y() {
    let J = true, X = true;
    for (; X; ) J ? J = false : C(",") || (t = Ft(t, ",")), X = a();
    X || (t = Kn(t, ",")), t = `[
${t}
]`;
  }
  function T() {
    let J = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : false, X = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : -1, le = r[e] === "\\";
    if (le && (e++, le = true), Is(r[e])) {
      let qe = hl(r[e]) ? hl : pl(r[e]) ? pl : Ki(r[e]) ? Ki : dl, ze = e, H = t.length, ye = '"';
      for (e++; ; ) {
        if (e >= r.length) {
          let Ae = W(e - 1);
          return !J && Bs(r.charAt(Ae)) ? (e = ze, t = t.substring(0, H), T(true)) : (ye = Ft(ye, '"'), t += ye, true);
        }
        if (e === X) return ye = Ft(ye, '"'), t += ye, true;
        if (qe(r[e])) {
          let Ae = e, tr = ye.length;
          if (ye += '"', e++, t += ye, u(false), J || e >= r.length || Bs(r[e]) || Is(r[e]) || jr(r[e])) return k(), true;
          let Be = W(Ae - 1), Ne = r.charAt(Be);
          if (Ne === ",") return e = ze, t = t.substring(0, H), T(false, Be);
          if (Bs(Ne)) return e = ze, t = t.substring(0, H), T(true);
          t = t.substring(0, H), e = Ae + 1, ye = `${ye.substring(0, tr)}\\${ye.substring(tr)}`;
        } else if (J && ll(r[e])) {
          if (r[e - 1] === ":" && ul.test(r.substring(ze + 1, e + 2))) for (; e < r.length && cl.test(r[e]); ) ye += r[e], e++;
          return ye = Ft(ye, '"'), t += ye, k(), true;
        } else if (r[e] === "\\") {
          let Ae = r.charAt(e + 1);
          if (Jw[Ae] !== void 0) ye += r.slice(e, e + 2), e += 2;
          else if (Ae === "u") {
            let Be = 2;
            for (; Be < 6 && Wm(r[e + Be]); ) Be++;
            Be === 6 ? (ye += r.slice(e, e + 6), e += 6) : e + Be >= r.length ? e = r.length : Te();
          } else ye += Ae, e += 2;
        } else {
          let Ae = r.charAt(e);
          Ae === '"' && r[e - 1] !== "\\" ? (ye += `\\${Ae}`, e++) : Jm(Ae) ? (ye += zw[Ae], e++) : (zm(Ae) || oe(Ae), ye += Ae, e++);
        }
        le && I();
      }
    }
    return false;
  }
  function k() {
    let J = false;
    for (u(); r[e] === "+"; ) {
      J = true, e++, u(), t = Kn(t, '"', true);
      let X = t.length;
      T() ? t = Ym(t, X, 1) : t = Ft(t, '"');
    }
    return J;
  }
  function L() {
    let J = e;
    if (r[e] === "-") {
      if (e++, Ee()) return he(J), true;
      if (!jr(r[e])) return e = J, false;
    }
    for (; jr(r[e]); ) e++;
    if (r[e] === ".") {
      if (e++, Ee()) return he(J), true;
      if (!jr(r[e])) return e = J, false;
      for (; jr(r[e]); ) e++;
    }
    if (r[e] === "e" || r[e] === "E") {
      if (e++, (r[e] === "-" || r[e] === "+") && e++, Ee()) return he(J), true;
      if (!jr(r[e])) return e = J, false;
      for (; jr(r[e]); ) e++;
    }
    if (!Ee()) return e = J, false;
    if (e > J) {
      let X = r.slice(J, e), le = /^0\d/.test(X);
      return t += le ? `"${X}"` : X, true;
    }
    return false;
  }
  function P() {
    return j("true", "true") || j("false", "false") || j("null", "null") || j("True", "true") || j("False", "false") || j("None", "null");
  }
  function j(J, X) {
    return r.slice(e, e + J.length) === J ? (t += X, e += J.length, true) : false;
  }
  function G(J) {
    let X = e;
    if (il(r[e])) {
      for (; e < r.length && al(r[e]); ) e++;
      let le = e;
      for (; qr(r, le); ) le++;
      if (r[le] === "(") return e = le + 1, a(), r[e] === ")" && (e++, r[e] === ";" && e++), true;
    }
    for (; e < r.length && !ll(r[e]) && !Is(r[e]) && (!J || r[e] !== ":"); ) e++;
    if (r[e - 1] === ":" && ul.test(r.substring(X, e + 2))) for (; e < r.length && cl.test(r[e]); ) e++;
    if (e > X) {
      for (; qr(r, e - 1) && e > 0; ) e--;
      let le = r.slice(X, e);
      return t += le === "undefined" ? "null" : JSON.stringify(le), r[e] === '"' && e++, true;
    }
  }
  function re() {
    if (r[e] === "/") {
      let J = e;
      for (e++; e < r.length && (r[e] !== "/" || r[e - 1] === "\\"); ) e++;
      return e++, t += `"${r.substring(J, e)}"`, true;
    }
  }
  function W(J) {
    let X = J;
    for (; X > 0 && qr(r, X); ) X--;
    return X;
  }
  function Ee() {
    return e >= r.length || Bs(r[e]) || qr(r, e);
  }
  function he(J) {
    t += `${r.slice(J, e)}0`;
  }
  function oe(J) {
    throw new _r(`Invalid character ${JSON.stringify(J)}`, e);
  }
  function ue() {
    throw new _r(`Unexpected character ${JSON.stringify(r[e])}`, e);
  }
  function Z() {
    throw new _r("Unexpected end of json string", r.length);
  }
  function ce() {
    throw new _r("Object key expected", e);
  }
  function pe() {
    throw new _r("Colon expected", e);
  }
  function Te() {
    let J = r.slice(e, e + 6);
    throw new _r(`Invalid unicode character "${J}"`, e);
  }
}
function Vw(r, e) {
  return r[e] === "*" && r[e + 1] === "/";
}
function gl(r) {
  if (!r || r.trim() === "" || r === "{}") return "{}";
  try {
    return JSON.parse(r), ne("\u5DE5\u5177\u8C03\u7528\u53C2\u6570\u6807\u51C6JSON\u89E3\u6790\u6210\u529F / Tool arguments standard JSON parsing successful"), r;
  } catch (e) {
    try {
      let t = Qm.default.parse(r);
      return ne("\u5DE5\u5177\u8C03\u7528\u53C2\u6570JSON5\u89E3\u6790\u6210\u529F / Tool arguments JSON5 parsing successful"), JSON.stringify(t);
    } catch (t) {
      try {
        let n = ml(r);
        return ne("\u5DE5\u5177\u8C03\u7528\u53C2\u6570\u5B89\u5168\u4FEE\u590D\u6210\u529F / Tool arguments safely repaired"), n;
      } catch (n) {
        return ne(`JSON\u89E3\u6790\u5931\u8D25 / JSON parsing failed: ${e.message}. JSON5\u89E3\u6790\u5931\u8D25 / JSON5 parsing failed: ${t.message}. JSON\u4FEE\u590D\u5931\u8D25 / JSON repair failed: ${n.message}. \u8F93\u5165\u6570\u636E / Input data: ${JSON.stringify(r)}`), ne("\u8FD4\u56DE\u5B89\u5168\u7684\u7A7A\u5BF9\u8C61\u4F5C\u4E3A\u540E\u5907\u65B9\u6848 / Returning safe empty object as fallback"), "{}";
      }
    }
  }
}
var Yi = class {
  name = "enhancetool";
  async transformResponseOut(e) {
    if (e.headers.get("Content-Type")?.includes("application/json")) {
      let t = await e.json();
      if (t?.choices?.[0]?.message?.tool_calls?.length) for (let n of t.choices[0].message.tool_calls) n.function?.arguments && (n.function.arguments = gl(n.function.arguments));
      return new Response(JSON.stringify(t), { status: e.status, statusText: e.statusText, headers: e.headers });
    } else if (e.headers.get("Content-Type")?.includes("stream")) {
      if (!e.body) return e;
      let t = new TextDecoder(), n = new TextEncoder(), o = {}, a = false, u = "", l = false, f = false, d = "", h = new ReadableStream({ async start(C) {
        let w = e.body.getReader(), I = (_, y, T) => {
          let k = _.split(`
`);
          for (let L of k) L.trim() && y.enqueue(T.encode(L + `
`));
        }, S = (_, y, T) => {
          let k = "";
          try {
            k = gl(o.arguments || "");
          } catch (G) {
            ne(`${G.message} ${G.stack}  \u5DE5\u5177\u8C03\u7528\u53C2\u6570\u89E3\u6790\u5931\u8D25: ${JSON.stringify(o)}`), k = o.arguments || "";
          }
          let L = { role: "assistant", tool_calls: [{ function: { name: o.name, arguments: k }, id: o.id, index: o.index, type: "function" }] }, P = { ..._, choices: [{ ..._.choices[0], delta: L }] };
          P.choices[0].delta.content !== void 0 && delete P.choices[0].delta.content;
          let j = `data: ${JSON.stringify(P)}

`;
          y.enqueue(T.encode(j));
        }, b = (_, y) => {
          let { controller: T, encoder: k } = y;
          if (_.startsWith("data: ") && _.trim() !== "data: [DONE]") {
            let L = _.slice(6);
            try {
              let P = JSON.parse(L);
              if (P.choices?.[0]?.delta?.tool_calls?.length) {
                let G = P.choices[0].delta.tool_calls[0];
                if (typeof o.index > "u") {
                  o = { index: G.index, name: G.function?.name || "", id: G.id || "", arguments: G.function?.arguments || "" }, G.function?.arguments && (G.function.arguments = "");
                  let re = `data: ${JSON.stringify(P)}

`;
                  T.enqueue(k.encode(re));
                  return;
                } else if (o.index === G.index) {
                  G.function?.arguments && (o.arguments += G.function.arguments);
                  return;
                } else {
                  S(P, T, k), o = { index: G.index, name: G.function?.name || "", id: G.id || "", arguments: G.function?.arguments || "" };
                  return;
                }
              }
              if (P.choices?.[0]?.finish_reason === "tool_calls" && o.index !== void 0) {
                S(P, T, k), o = {};
                return;
              }
              P.choices?.[0]?.delta?.tool_calls?.length && y.hasTextContent() && (typeof P.choices[0].index == "number" ? P.choices[0].index += 1 : P.choices[0].index = 1);
              let j = `data: ${JSON.stringify(P)}

`;
              T.enqueue(k.encode(j));
            } catch {
              T.enqueue(k.encode(_ + `
`));
            }
          } else T.enqueue(k.encode(_ + `
`));
        };
        try {
          for (; ; ) {
            let { done: _, value: y } = await w.read();
            if (_) {
              d.trim() && I(d, C, n);
              break;
            }
            if (!y || y.length === 0) continue;
            let T;
            try {
              T = t.decode(y, { stream: true });
            } catch (L) {
              console.warn("Failed to decode chunk", L);
              continue;
            }
            if (T.length === 0) continue;
            if (d += T, d.length > 1e6) {
              console.warn("Buffer size exceeds limit, processing partial data");
              let L = d.split(`
`);
              d = L.pop() || "";
              for (let P of L) if (P.trim()) try {
                b(P, { controller: C, encoder: n, hasTextContent: () => a, setHasTextContent: (j) => a = j, reasoningContent: () => u, appendReasoningContent: (j) => u += j, isReasoningComplete: () => l, setReasoningComplete: (j) => l = j });
              } catch (j) {
                console.error("Error processing line:", P, j), C.enqueue(n.encode(P + `
`));
              }
              continue;
            }
            let k = d.split(`
`);
            d = k.pop() || "";
            for (let L of k) if (L.trim()) try {
              b(L, { controller: C, encoder: n, hasTextContent: () => a, setHasTextContent: (P) => a = P, reasoningContent: () => u, appendReasoningContent: (P) => u += P, isReasoningComplete: () => l, setReasoningComplete: (P) => l = P });
            } catch (P) {
              console.error("Error processing line:", L, P), C.enqueue(n.encode(L + `
`));
            }
          }
        } catch (_) {
          console.error("Stream error:", _), C.error(_);
        } finally {
          try {
            w.releaseLock();
          } catch (_) {
            console.error("Error releasing reader lock:", _);
          }
          C.close();
        }
      } });
      return new Response(h, { status: e.status, statusText: e.statusText, headers: { "Content-Type": e.headers.get("Content-Type") || "text/plain", "Cache-Control": "no-cache", Connection: "keep-alive" } });
    }
    return e;
  }
};
var Xi = class {
  name = "reasoning";
  async transformResponseOut(e) {
    if (e.headers.get("Content-Type")?.includes("application/json")) {
      let t = await e.json();
      return new Response(JSON.stringify(t), { status: e.status, statusText: e.statusText, headers: e.headers });
    } else if (e.headers.get("Content-Type")?.includes("stream")) {
      if (!e.body) return e;
      let t = new TextDecoder(), n = new TextEncoder(), o = "", a = false, u = "", l = new ReadableStream({ async start(f) {
        let d = e.body.getReader(), h = (w, I, S) => {
          let b = w.split(`
`);
          for (let _ of b) _.trim() && I.enqueue(S.encode(_ + `
`));
        }, C = (w, I) => {
          let { controller: S, encoder: b } = I;
          if (w.startsWith("data: ") && w.trim() !== "data: [DONE]") try {
            let _ = JSON.parse(w.slice(6));
            if (_.choices?.[0]?.delta?.reasoning_content) {
              I.appendReasoningContent(_.choices[0].delta.reasoning_content);
              let y = { ..._, choices: [{ ..._.choices[0], delta: { ..._.choices[0].delta, thinking: { content: _.choices[0].delta.reasoning_content } } }] };
              delete y.choices[0].delta.reasoning_content;
              let T = `data: ${JSON.stringify(y)}

`;
              S.enqueue(b.encode(T));
              return;
            }
            if ((_.choices?.[0]?.delta?.content || _.choices?.[0]?.delta?.tool_calls) && I.reasoningContent() && !I.isReasoningComplete()) {
              I.setReasoningComplete(true);
              let y = Date.now().toString(), T = { ..._, choices: [{ ..._.choices[0], delta: { ..._.choices[0].delta, content: null, thinking: { content: I.reasoningContent(), signature: y } } }] };
              delete T.choices[0].delta.reasoning_content;
              let k = `data: ${JSON.stringify(T)}

`;
              S.enqueue(b.encode(k));
            }
            if (_.choices?.[0]?.delta?.reasoning_content && delete _.choices[0].delta.reasoning_content, _.choices?.[0]?.delta && Object.keys(_.choices[0].delta).length > 0) {
              I.isReasoningComplete() && _.choices[0].index++;
              let y = `data: ${JSON.stringify(_)}

`;
              S.enqueue(b.encode(y));
            }
          } catch {
            S.enqueue(b.encode(w + `
`));
          }
          else S.enqueue(b.encode(w + `
`));
        };
        try {
          for (; ; ) {
            let { done: w, value: I } = await d.read();
            if (w) {
              u.trim() && h(u, f, n);
              break;
            }
            let S = t.decode(I, { stream: true });
            u += S;
            let b = u.split(`
`);
            u = b.pop() || "";
            for (let _ of b) if (_.trim()) try {
              C(_, { controller: f, encoder: n, reasoningContent: () => o, appendReasoningContent: (y) => o += y, isReasoningComplete: () => a, setReasoningComplete: (y) => a = y });
            } catch (y) {
              console.error("Error processing line:", _, y), f.enqueue(n.encode(_ + `
`));
            }
          }
        } catch (w) {
          console.error("Stream error:", w), f.error(w);
        } finally {
          try {
            d.releaseLock();
          } catch (w) {
            console.error("Error releasing reader lock:", w);
          }
          f.close();
        }
      } });
      return new Response(l, { status: e.status, statusText: e.statusText, headers: { "Content-Type": e.headers.get("Content-Type") || "text/plain", "Cache-Control": "no-cache", Connection: "keep-alive" } });
    }
    return e;
  }
};
var Qi = class {
  constructor(e) {
    this.options = e;
    this.max_tokens = this.options?.max_tokens, this.temperature = this.options?.temperature, this.top_p = this.options?.top_p, this.top_k = this.options?.top_k, this.repetition_penalty = this.options?.repetition_penalty;
  }
  name = "sampling";
  max_tokens;
  temperature;
  top_p;
  top_k;
  repetition_penalty;
  async transformRequestIn(e) {
    return e.max_tokens && e.max_tokens > this.max_tokens && (e.max_tokens = this.max_tokens), typeof this.temperature < "u" && (e.temperature = this.temperature), typeof this.top_p < "u" && (e.top_p = this.top_p), typeof this.top_k < "u" && (e.top_k = this.top_k), typeof this.repetition_penalty < "u" && (e.repetition_penalty = this.repetition_penalty), e;
  }
};
var Zi = class {
  constructor(e) {
    this.options = e;
    this.max_completion_tokens = this.options?.max_completion_tokens;
  }
  static TransformerName = "maxcompletiontokens";
  max_completion_tokens;
  async transformRequestIn(e) {
    return e.max_tokens && delete e.max_tokens, e.max_tokens = this.max_completion_tokens, e;
  }
};
function Zm(r) {
  let e = [];
  for (let n = 0; n < r.messages.length; n++) {
    let o = r.messages[n], a = n === r.messages.length - 1, u = o.role === "assistant", l = [];
    typeof o.content == "string" ? l.push({ type: "text", text: o.content }) : Array.isArray(o.content) && o.content.forEach((f) => {
      f.type === "text" ? l.push({ type: "text", text: f.text || "" }) : f.type === "image_url" && l.push({ type: "image", source: { type: "base64", media_type: f.media_type || "image/jpeg", data: f.image_url.url } });
    }), !(!a && l.length === 0 && !o.tool_calls && !o.content) && (a && u && l.length === 0 && o.tool_calls && l.push({ type: "text", text: "" }), e.push({ role: o.role === "assistant" ? "assistant" : "user", content: l }));
  }
  let t = { anthropic_version: "vertex-2023-10-16", messages: e, max_tokens: r.max_tokens || 1e3, stream: r.stream || false, ...r.temperature && { temperature: r.temperature } };
  return r.tools && r.tools.length > 0 && (t.tools = r.tools.map((n) => ({ name: n.function.name, description: n.function.description, input_schema: n.function.parameters }))), r.tool_choice && (r.tool_choice === "auto" || r.tool_choice === "none" ? t.tool_choice = r.tool_choice : typeof r.tool_choice == "string" && (t.tool_choice = { type: "tool", name: r.tool_choice })), t;
}
function eg(r) {
  let e = r, n = { messages: e.messages.map((o) => {
    let a = o.content.map((u) => u.type === "text" ? { type: "text", text: u.text || "" } : u.type === "image" && u.source ? { type: "image_url", image_url: { url: u.source.data }, media_type: u.source.media_type } : { type: "text", text: "" });
    return { role: o.role, content: a };
  }), model: r.model || "claude-sonnet-4@20250514", max_tokens: e.max_tokens, temperature: e.temperature, stream: e.stream };
  return e.tools && e.tools.length > 0 && (n.tools = e.tools.map((o) => ({ type: "function", function: { name: o.name, description: o.description, parameters: { type: "object", properties: o.input_schema.properties, required: o.input_schema.required, additionalProperties: o.input_schema.additionalProperties, $schema: o.input_schema.$schema } } }))), e.tool_choice && (typeof e.tool_choice == "string" ? n.tool_choice = e.tool_choice : e.tool_choice.type === "tool" && (n.tool_choice = e.tool_choice.name)), n;
}
async function tg(r, e) {
  if (r.headers.get("Content-Type")?.includes("application/json")) {
    let t = await r.json(), n;
    t.tool_use && t.tool_use.length > 0 && (n = t.tool_use.map((a) => ({ id: a.id, type: "function", function: { name: a.name, arguments: JSON.stringify(a.input) } })));
    let o = { id: t.id, choices: [{ finish_reason: t.stop_reason || null, index: 0, message: { content: t.content[0]?.text || "", role: "assistant", ...n && { tool_calls: n } } }], created: parseInt((/* @__PURE__ */ new Date()).getTime() / 1e3 + "", 10), model: t.model, object: "chat.completion", usage: { completion_tokens: t.usage.output_tokens, prompt_tokens: t.usage.input_tokens, total_tokens: t.usage.input_tokens + t.usage.output_tokens } };
    return new Response(JSON.stringify(o), { status: r.status, statusText: r.statusText, headers: r.headers });
  } else if (r.headers.get("Content-Type")?.includes("stream")) {
    if (!r.body) return r;
    let t = new TextDecoder(), n = new TextEncoder(), o = (u, l) => {
      if (u.startsWith("data: ")) {
        let f = u.slice(6).trim();
        if (f) {
          ne(`${e} chunk:`, f);
          try {
            let d = JSON.parse(f);
            if (d.type === "content_block_delta" && d.delta?.type === "text_delta") {
              let h = { choices: [{ delta: { role: "assistant", content: d.delta.text || "" }, finish_reason: null, index: 0, logprobs: null }], created: parseInt((/* @__PURE__ */ new Date()).getTime() / 1e3 + "", 10), id: d.id || "", model: d.model || "", object: "chat.completion.chunk", system_fingerprint: "fp_a49d71b8a1", usage: { completion_tokens: d.usage?.output_tokens || 0, prompt_tokens: d.usage?.input_tokens || 0, total_tokens: (d.usage?.input_tokens || 0) + (d.usage?.output_tokens || 0) } };
              l.enqueue(n.encode(`data: ${JSON.stringify(h)}

`));
            } else if (d.type === "content_block_delta" && d.delta?.type === "input_json_delta") {
              let h = { choices: [{ delta: { tool_calls: [{ index: d.index || 0, function: { arguments: d.delta.partial_json || "" } }] }, finish_reason: null, index: 0, logprobs: null }], created: parseInt((/* @__PURE__ */ new Date()).getTime() / 1e3 + "", 10), id: d.id || "", model: d.model || "", object: "chat.completion.chunk", system_fingerprint: "fp_a49d71b8a1", usage: { completion_tokens: d.usage?.output_tokens || 0, prompt_tokens: d.usage?.input_tokens || 0, total_tokens: (d.usage?.input_tokens || 0) + (d.usage?.output_tokens || 0) } };
              l.enqueue(n.encode(`data: ${JSON.stringify(h)}

`));
            } else if (d.type === "content_block_start" && d.content_block?.type === "tool_use") {
              let h = { choices: [{ delta: { tool_calls: [{ index: d.index || 0, id: d.content_block.id, type: "function", function: { name: d.content_block.name, arguments: "" } }] }, finish_reason: null, index: 0, logprobs: null }], created: parseInt((/* @__PURE__ */ new Date()).getTime() / 1e3 + "", 10), id: d.id || "", model: d.model || "", object: "chat.completion.chunk", system_fingerprint: "fp_a49d71b8a1", usage: { completion_tokens: d.usage?.output_tokens || 0, prompt_tokens: d.usage?.input_tokens || 0, total_tokens: (d.usage?.input_tokens || 0) + (d.usage?.output_tokens || 0) } };
              l.enqueue(n.encode(`data: ${JSON.stringify(h)}

`));
            } else if (d.type === "message_delta") {
              let h = { choices: [{ delta: {}, finish_reason: d.delta?.stop_reason === "tool_use" ? "tool_calls" : d.delta?.stop_reason === "max_tokens" ? "length" : d.delta?.stop_reason === "stop_sequence" ? "content_filter" : "stop", index: 0, logprobs: null }], created: parseInt((/* @__PURE__ */ new Date()).getTime() / 1e3 + "", 10), id: d.id || "", model: d.model || "", object: "chat.completion.chunk", system_fingerprint: "fp_a49d71b8a1", usage: { completion_tokens: d.usage?.output_tokens || 0, prompt_tokens: d.usage?.input_tokens || 0, total_tokens: (d.usage?.input_tokens || 0) + (d.usage?.output_tokens || 0) } };
              l.enqueue(n.encode(`data: ${JSON.stringify(h)}

`));
            } else if (d.type === "message_stop") l.enqueue(n.encode(`data: [DONE]

`));
            else {
              let h = { choices: [{ delta: { role: "assistant", content: d.content?.[0]?.text || "" }, finish_reason: d.stop_reason?.toLowerCase() || null, index: 0, logprobs: null }], created: parseInt((/* @__PURE__ */ new Date()).getTime() / 1e3 + "", 10), id: d.id || "", model: d.model || "", object: "chat.completion.chunk", system_fingerprint: "fp_a49d71b8a1", usage: { completion_tokens: d.usage?.output_tokens || 0, prompt_tokens: d.usage?.input_tokens || 0, total_tokens: (d.usage?.input_tokens || 0) + (d.usage?.output_tokens || 0) } };
              l.enqueue(n.encode(`data: ${JSON.stringify(h)}

`));
            }
          } catch (d) {
            ne(`Error parsing ${e} stream chunk`, f, d.message);
          }
        }
      }
    }, a = new ReadableStream({ async start(u) {
      let l = r.body.getReader(), f = "";
      try {
        for (; ; ) {
          let { done: d, value: h } = await l.read();
          if (d) {
            f && o(f, u);
            break;
          }
          f += t.decode(h, { stream: true });
          let C = f.split(`
`);
          f = C.pop() || "";
          for (let w of C) o(w, u);
        }
      } catch (d) {
        u.error(d);
      } finally {
        u.close();
      }
    } });
    return new Response(a, { status: r.status, statusText: r.statusText, headers: r.headers });
  }
  return r;
}
async function Kw() {
  try {
    let { GoogleAuth: r } = await Promise.resolve().then(() => Jr(ol(), 1));
    return (await (await new r({ scopes: ["https://www.googleapis.com/auth/cloud-platform"] }).getClient()).getAccessToken()).token || "";
  } catch (r) {
    throw ne("Error getting access token:", r), new Error(`Failed to get access token for Vertex AI. Please ensure you have set up authentication using one of these methods:
1. Set GOOGLE_APPLICATION_CREDENTIALS to point to service account key file
2. Run "gcloud auth application-default login"
3. Use Google Cloud environment with default service account`);
  }
}
var ea = class {
  name = "vertex-claude";
  endPoint = "/v1/projects/:projectId/locations/:location/publishers/anthropic/models/:modelAndAction";
  async transformRequestIn(e, t) {
    let n = process.env.GOOGLE_CLOUD_PROJECT, o = process.env.GOOGLE_CLOUD_LOCATION || "us-east5";
    if (!n && process.env.GOOGLE_APPLICATION_CREDENTIALS) try {
      let l = (await import("fs")).readFileSync(process.env.GOOGLE_APPLICATION_CREDENTIALS, "utf8"), f = JSON.parse(l);
      f && f.project_id && (n = f.project_id);
    } catch (u) {
      ne("Error extracting project_id from GOOGLE_APPLICATION_CREDENTIALS:", u);
    }
    if (!n) throw new Error("Project ID is required for Vertex AI. Set GOOGLE_CLOUD_PROJECT environment variable or ensure project_id is in GOOGLE_APPLICATION_CREDENTIALS file.");
    let a = await Kw();
    return { body: Zm(e), config: { url: new URL(`/v1/projects/${n}/locations/${o}/publishers/anthropic/models/${e.model}:${e.stream ? "streamRawPredict" : "rawPredict"}`, `https://${o}-aiplatform.googleapis.com`).toString(), headers: { Authorization: `Bearer ${a}`, "Content-Type": "application/json" } } };
  }
  async transformRequestOut(e) {
    return eg(e);
  }
  async transformResponseOut(e) {
    return tg(e, this.name);
  }
};
var rg = { AnthropicTransformer: Co, GeminiTransformer: Ao, VertexGeminiTransformer: $i, VertexClaudeTransformer: ea, DeepseekTransformer: Hi, TooluseTransformer: Gi, OpenrouterTransformer: Wi, MaxTokenTransformer: zi, GroqTransformer: Ji, CleancacheTransformer: Vi, EnhanceToolTransformer: Yi, ReasoningTransformer: Xi, SamplingTransformer: Qi, MaxCompletionTokens: Zi };
var ta = class {
  constructor(e) {
    this.configService = e;
  }
  transformers = /* @__PURE__ */ new Map();
  registerTransformer(e, t) {
    this.transformers.set(e, t), ne(`register transformer: ${e}${t.endPoint ? ` (endpoint: ${t.endPoint})` : " (no endpoint)"}`);
  }
  getTransformer(e) {
    return this.transformers.get(e);
  }
  getAllTransformers() {
    return new Map(this.transformers);
  }
  getTransformersWithEndpoint() {
    let e = [];
    return this.transformers.forEach((t, n) => {
      t.endPoint && e.push({ name: n, transformer: t });
    }), e;
  }
  getTransformersWithoutEndpoint() {
    let e = [];
    return this.transformers.forEach((t, n) => {
      t.endPoint || e.push({ name: n, transformer: t });
    }), e;
  }
  removeTransformer(e) {
    return this.transformers.delete(e);
  }
  hasTransformer(e) {
    return this.transformers.has(e);
  }
  async registerTransformerFromConfig(e) {
    try {
      let t = import_node_module.default._load;
      if (import_node_module.default._load = function(n, o, a) {
        return n === "claude-code-router" ? { log: ne } : t.apply(import_node_module.default, arguments);
      }, e.path) {
        let n = Y(Y.resolve(e.path));
        if (n) {
          let o = new n(e.options);
          if (!o.name) throw new Error(`Transformer instance from ${e.path} does not have a name property.`);
          return this.registerTransformer(o.name, o), true;
        }
      }
      return false;
    } catch (t) {
      return ne(`load transformer (${e.path}) error:`, t.message, t.stack), false;
    }
  }
  async initialize() {
    try {
      await this.registerDefaultTransformersInternal(), await this.loadFromConfig();
    } catch (e) {
      ne("TransformerService init error:", e);
    }
  }
  async registerDefaultTransformersInternal() {
    try {
      Object.values(rg).forEach((e) => {
        if ("TransformerName" in e && typeof e.TransformerName == "string") this.registerTransformer(e.TransformerName, e);
        else {
          let t = new e();
          this.registerTransformer(t.name, t);
        }
      });
    } catch (e) {
      ne("transformer regist error:", e);
    }
  }
  async loadFromConfig() {
    let e = this.configService.get("transformers", []);
    for (let t of e) await this.registerTransformerFromConfig(t);
  }
};
function Qw() {
  let r = (0, import_fastify.default)({ bodyLimit: 52428800 });
  return r.setErrorHandler(Nf), r.register(import_cors.default), r;
}
var _l = class {
  app;
  configService;
  llmService;
  providerService;
  transformerService;
  constructor(e = {}) {
    this.configService = new po(e), this.transformerService = new ta(this.configService), this.transformerService.initialize().finally(() => {
      this.providerService = new go(this.configService, this.transformerService), this.llmService = new mo(this.providerService);
    }), this.app = Qw();
  }
  async register(e, t) {
    await this.app.register(e, t);
  }
  addHook(e, t) {
    this.app.addHook(e, t);
  }
  async start() {
    try {
      this.app._server = this, this.app.addHook("preHandler", async (n, o) => {
        if (!(n.url.startsWith("/api") || n.method !== "POST")) try {
          let a = n.body;
          if (!a || !a.model) return o.code(400).send({ error: "Missing model in request body" });
          let [u, l] = a.model.split(",");
          a.model = l, n.provider = u;
          return;
        } catch (a) {
          return n.log.error("Error in modelProviderMiddleware:", a), o.code(500).send({ error: "Internal server error" });
        }
      }), this.app.register(Lf);
      let e = await this.app.listen({ port: parseInt(this.configService.get("PORT") || "3000", 10), host: this.configService.get("HOST") || "127.0.0.1" });
      ne(`\u{1F680} LLMs API server listening on ${e}`);
      let t = async (n) => {
        ne(`Received ${n}, shutting down gracefully...`), await this.app.close(), process.exit(0);
      };
      process.on("SIGINT", () => t("SIGINT")), process.on("SIGTERM", () => t("SIGTERM"));
    } catch (e) {
      ne(`Error starting server: ${e}`), process.exit(1);
    }
  }
};
var tR = _l;

// src/server.ts
init_utils();
var import_path2 = require("path");
var import_static = __toESM(require_static());
var createServer = (config) => {
  const server = new tR(config);
  server.app.get("/api/config", async () => {
    return await readConfigFile();
  });
  server.app.get("/api/transformers", async () => {
    const transformers = server.app._server.transformerService.getAllTransformers();
    const transformerList = Array.from(transformers.entries()).map(
      ([name, transformer]) => ({
        name,
        endpoint: transformer.endPoint || null
      })
    );
    return { transformers: transformerList };
  });
  server.app.post("/api/config", async (req) => {
    const newConfig = req.body;
    const { backupConfigFile: backupConfigFile2 } = await Promise.resolve().then(() => (init_utils(), utils_exports));
    const backupPath = await backupConfigFile2();
    if (backupPath) {
      console.log(`Backed up existing configuration file to ${backupPath}`);
    }
    await writeConfigFile(newConfig);
    return { success: true, message: "Config saved successfully" };
  });
  server.app.post("/api/restart", async (_, reply) => {
    reply.send({ success: true, message: "Service restart initiated" });
    setTimeout(() => {
      const { spawn: spawn3 } = require("child_process");
      spawn3("ccr", ["restart"], { detached: true, stdio: "ignore" });
    }, 1e3);
  });
  server.app.register(import_static.default, {
    root: (0, import_path2.join)(__dirname, "..", "dist"),
    prefix: "/ui/",
    maxAge: "1h"
  });
  server.app.get("/ui", async (_, reply) => {
    return reply.redirect("/ui/");
  });
  return server;
};

// src/utils/router.ts
var import_tiktoken = __toESM(require_tiktoken());

// src/utils/log.ts
var import_node_fs3 = __toESM(require("node:fs"));
var import_node_path4 = __toESM(require("node:path"));
init_constants();
var LOG_FILE = import_node_path4.default.join(HOME_DIR, "claude-code-router.log");
if (!import_node_fs3.default.existsSync(HOME_DIR)) {
  import_node_fs3.default.mkdirSync(HOME_DIR, { recursive: true });
}
function log(...args) {
  const isLogEnabled = process.env.LOG === "true";
  if (!isLogEnabled) {
    return;
  }
  const timestamp = (/* @__PURE__ */ new Date()).toISOString();
  const logMessage = `[${timestamp}] ${Array.isArray(args) ? args.map(
    (arg) => typeof arg === "object" ? JSON.stringify(arg) : String(arg)
  ).join(" ") : ""}
`;
  import_node_fs3.default.appendFileSync(LOG_FILE, logMessage, "utf8");
}

// src/utils/router.ts
var enc = (0, import_tiktoken.get_encoding)("cl100k_base");
var calculateTokenCount = (messages, system, tools) => {
  let tokenCount = 0;
  if (Array.isArray(messages)) {
    messages.forEach((message) => {
      if (typeof message.content === "string") {
        tokenCount += enc.encode(message.content).length;
      } else if (Array.isArray(message.content)) {
        message.content.forEach((contentPart) => {
          if (contentPart.type === "text") {
            tokenCount += enc.encode(contentPart.text).length;
          } else if (contentPart.type === "tool_use") {
            tokenCount += enc.encode(JSON.stringify(contentPart.input)).length;
          } else if (contentPart.type === "tool_result") {
            tokenCount += enc.encode(
              typeof contentPart.content === "string" ? contentPart.content : JSON.stringify(contentPart.content)
            ).length;
          }
        });
      }
    });
  }
  if (typeof system === "string") {
    tokenCount += enc.encode(system).length;
  } else if (Array.isArray(system)) {
    system.forEach((item) => {
      if (item.type !== "text") return;
      if (typeof item.text === "string") {
        tokenCount += enc.encode(item.text).length;
      } else if (Array.isArray(item.text)) {
        item.text.forEach((textPart) => {
          tokenCount += enc.encode(textPart || "").length;
        });
      }
    });
  }
  if (tools) {
    tools.forEach((tool) => {
      if (tool.description) {
        tokenCount += enc.encode(tool.name + tool.description).length;
      }
      if (tool.input_schema) {
        tokenCount += enc.encode(JSON.stringify(tool.input_schema)).length;
      }
    });
  }
  return tokenCount;
};
var getUseModel = async (req, tokenCount, config) => {
  if (req.body.model.includes(",")) {
    const [provider, model] = req.body.model.split(",");
    const finalProvider = config.Providers.find(
      (p) => p.name.toLowerCase() === provider
    );
    const finalModel = finalProvider?.models?.find(
      (m) => m.name.toLowerCase() === model
    );
    if (finalProvider && finalModel) {
      return `${finalProvider.name},${finalModel}`;
    }
    return req.body.model;
  }
  const longContextThreshold = config.Router.longContextThreshold || 6e4;
  if (tokenCount > longContextThreshold && config.Router.longContext) {
    log(
      "Using long context model due to token count:",
      tokenCount,
      "threshold:",
      longContextThreshold
    );
    return config.Router.longContext;
  }
  if (req.body?.system?.length > 1 && req.body?.system[1]?.text?.startsWith("<CCR-SUBAGENT-MODEL>")) {
    const model = req.body?.system[1].text.match(
      /<CCR-SUBAGENT-MODEL>(.*?)<\/CCR-SUBAGENT-MODEL>/s
    );
    if (model) {
      log("\u68C0\u6D4B\u5230CCR-SUBAGENT-MODEL:", model[1]);
      req.body.system[1].text = req.body.system[1].text.replace(
        `<CCR-SUBAGENT-MODEL>${model[1]}</CCR-SUBAGENT-MODEL>`,
        ""
      );
      return model[1];
    }
  }
  if (req.body.model?.startsWith("claude-3-5-haiku") && config.Router.background) {
    log("Using background model for ", req.body.model);
    return config.Router.background;
  }
  if (req.body.thinking && config.Router.think) {
    log("Using think model for ", req.body.thinking);
    return config.Router.think;
  }
  if (Array.isArray(req.body.tools) && req.body.tools.some((tool) => tool.type?.startsWith("web_search")) && config.Router.webSearch) {
    return config.Router.webSearch;
  }
  return config.Router.default;
};
var router = async (req, _res, config) => {
  const { messages, system = [], tools } = req.body;
  try {
    if (config.SYSTEM_PROMPT) {
      messages.unshift({
        role: "user",
        content: config.SYSTEM_PROMPT
      });
    }
    const tokenCount = calculateTokenCount(
      messages,
      system,
      tools
    );
    let model;
    if (config.CUSTOM_ROUTER_PATH) {
      try {
        const customRouter = require(config.CUSTOM_ROUTER_PATH);
        req.tokenCount = tokenCount;
        model = await customRouter(req, config);
      } catch (e) {
        log("failed to load custom router", e.message);
      }
    }
    if (!model) {
      model = await getUseModel(req, tokenCount, config);
    }
    req.body.model = model;
  } catch (error) {
    log("Error in router middleware:", error.message);
    req.body.model = config.Router.default;
  }
  return;
};

// src/middleware/auth.ts
var apiKeyAuth = (config) => (req, reply, done) => {
  if (["/", "/health"].includes(req.url) || req.url.startsWith("/ui")) {
    return done();
  }
  const apiKey = config.APIKEY;
  if (!apiKey) {
    return done();
  }
  const authKey = req.headers.authorization || req.headers["x-api-key"];
  if (!authKey) {
    reply.status(401).send("APIKEY is missing");
    return;
  }
  let token = "";
  if (authKey.startsWith("Bearer")) {
    token = authKey.split(" ")[1];
  } else {
    token = authKey;
  }
  if (token !== apiKey) {
    reply.status(401).send("Invalid API key");
    return;
  }
  done();
};

// src/utils/processCheck.ts
var import_fs2 = require("fs");
init_constants();
init_utils();
function incrementReferenceCount() {
  let count = 0;
  if ((0, import_fs2.existsSync)(REFERENCE_COUNT_FILE)) {
    count = parseInt((0, import_fs2.readFileSync)(REFERENCE_COUNT_FILE, "utf-8")) || 0;
  }
  count++;
  (0, import_fs2.writeFileSync)(REFERENCE_COUNT_FILE, count.toString());
}
function decrementReferenceCount() {
  let count = 0;
  if ((0, import_fs2.existsSync)(REFERENCE_COUNT_FILE)) {
    count = parseInt((0, import_fs2.readFileSync)(REFERENCE_COUNT_FILE, "utf-8")) || 0;
  }
  count = Math.max(0, count - 1);
  (0, import_fs2.writeFileSync)(REFERENCE_COUNT_FILE, count.toString());
}
function getReferenceCount() {
  if (!(0, import_fs2.existsSync)(REFERENCE_COUNT_FILE)) {
    return 0;
  }
  return parseInt((0, import_fs2.readFileSync)(REFERENCE_COUNT_FILE, "utf-8")) || 0;
}
function isServiceRunning() {
  if (!(0, import_fs2.existsSync)(PID_FILE)) {
    return false;
  }
  try {
    const pid = parseInt((0, import_fs2.readFileSync)(PID_FILE, "utf-8"));
    process.kill(pid, 0);
    return true;
  } catch (e) {
    cleanupPidFile();
    return false;
  }
}
function savePid(pid) {
  (0, import_fs2.writeFileSync)(PID_FILE, pid.toString());
}
function cleanupPidFile() {
  if ((0, import_fs2.existsSync)(PID_FILE)) {
    try {
      const fs5 = require("fs");
      fs5.unlinkSync(PID_FILE);
    } catch (e) {
    }
  }
}
function getServicePid() {
  if (!(0, import_fs2.existsSync)(PID_FILE)) {
    return null;
  }
  try {
    const pid = parseInt((0, import_fs2.readFileSync)(PID_FILE, "utf-8"));
    return isNaN(pid) ? null : pid;
  } catch (e) {
    return null;
  }
}
async function getServiceInfo() {
  const pid = getServicePid();
  const running = isServiceRunning();
  const config = await readConfigFile();
  const port = config.PORT || 3456;
  return {
    running,
    pid,
    port,
    endpoint: `http://127.0.0.1:${port}`,
    pidFile: PID_FILE,
    referenceCount: getReferenceCount()
  };
}

// src/index.ts
init_constants();
async function initializeClaudeConfig() {
  const homeDir = (0, import_os.homedir)();
  const configPath = (0, import_path3.join)(homeDir, ".claude.json");
  if (!(0, import_fs3.existsSync)(configPath)) {
    const userID = Array.from(
      { length: 64 },
      () => Math.random().toString(16)[2]
    ).join("");
    const configContent = {
      numStartups: 184,
      autoUpdaterStatus: "enabled",
      userID,
      hasCompletedOnboarding: true,
      lastOnboardingVersion: "1.0.17",
      projects: {}
    };
    await (0, import_promises2.writeFile)(configPath, JSON.stringify(configContent, null, 2));
  }
}
async function run(options = {}) {
  if (isServiceRunning()) {
    console.log("\u2705 Service is already running in the background.");
    return;
  }
  await initializeClaudeConfig();
  await initDir();
  const config = await initConfig();
  let HOST = config.HOST;
  if (config.HOST && !config.APIKEY) {
    HOST = "127.0.0.1";
    console.warn(
      "\u26A0\uFE0F API key is not set. HOST is forced to 127.0.0.1."
    );
  }
  const port = config.PORT || 3456;
  savePid(process.pid);
  process.on("SIGINT", () => {
    console.log("Received SIGINT, cleaning up...");
    cleanupPidFile();
    process.exit(0);
  });
  process.on("SIGTERM", () => {
    cleanupPidFile();
    process.exit(0);
  });
  console.log(HOST);
  const servicePort = process.env.SERVICE_PORT ? parseInt(process.env.SERVICE_PORT) : port;
  const server = createServer({
    jsonPath: CONFIG_FILE,
    initialConfig: {
      // ...config,
      providers: config.Providers || config.providers,
      HOST,
      PORT: servicePort,
      LOG_FILE: (0, import_path3.join)(
        (0, import_os.homedir)(),
        "claude-code",
        "claude-code-router.log"
      )
    }
  });
  server.addHook("preHandler", apiKeyAuth(config));
  server.addHook("preHandler", async (req, reply) => {
    if (req.url.startsWith("/v1/messages")) {
      router(req, reply, config);
    }
  });
  server.start();
}

// src/utils/status.ts
async function showStatus() {
  const info = await getServiceInfo();
  console.log("\n\u{1F4CA} Claude Code Router Status");
  console.log("\u2550".repeat(40));
  if (info.running) {
    console.log("\u2705 Status: Running");
    console.log(`\u{1F194} Process ID: ${info.pid}`);
    console.log(`\u{1F310} Port: ${info.port}`);
    console.log(`\u{1F4E1} API Endpoint: ${info.endpoint}`);
    console.log(`\u{1F4C4} PID File: ${info.pidFile}`);
    console.log("");
    console.log("\u{1F680} Ready to use! Run the following commands:");
    console.log("   ccr code    # Start coding with Claude");
    console.log("   ccr stop   # Stop the service");
  } else {
    console.log("\u274C Status: Not Running");
    console.log("");
    console.log("\u{1F4A1} To start the service:");
    console.log("   ccr start");
  }
  console.log("");
}

// src/utils/codeCommand.ts
var import_child_process = require("child_process");

// src/utils/close.ts
var import_fs4 = require("fs");
init_constants();
var import_path4 = require("path");
async function closeService() {
  const PID_FILE2 = (0, import_path4.join)(HOME_DIR, ".claude-code-router.pid");
  if (!isServiceRunning()) {
    console.log("No service is currently running.");
    return;
  }
  if (getReferenceCount() > 0) {
    return;
  }
  try {
    const pid = parseInt((0, import_fs4.readFileSync)(PID_FILE2, "utf-8"));
    process.kill(pid);
    cleanupPidFile();
    console.log("claude code router service has been successfully stopped.");
  } catch (e) {
    console.log("Failed to stop the service. It may have already been stopped.");
    cleanupPidFile();
  }
}

// src/utils/codeCommand.ts
init_utils();
var import_os2 = require("os");
async function executeCodeCommand(args = []) {
  const config = await readConfigFile();
  const env = {
    ...process.env,
    ANTHROPIC_AUTH_TOKEN: "test",
    ANTHROPIC_BASE_URL: `http://127.0.0.1:${config.PORT || 3456}`,
    API_TIMEOUT_MS: String(config.API_TIMEOUT_MS ?? 6e5)
    // Default to 10 minutes if not set
  };
  if (config?.ANTHROPIC_SMALL_FAST_MODEL) {
    env.ANTHROPIC_SMALL_FAST_MODEL = config.ANTHROPIC_SMALL_FAST_MODEL;
  }
  if (config?.APIKEY) {
    env.ANTHROPIC_API_KEY = config.APIKEY;
    delete env.ANTHROPIC_AUTH_TOKEN;
  }
  incrementReferenceCount();
  const homeDir = (0, import_os2.homedir)();
  const configPath = homeDir + "/claude-code/claude-code_cli.js";
  const nodePath = homeDir + "/claude-code/node";
  const claudePath = process.env.CLAUDE_PATH || nodePath + " " + configPath;
  const claudeProcess = (0, import_child_process.spawn)(claudePath, args, {
    env,
    stdio: "inherit",
    shell: true
  });
  claudeProcess.on("error", (error) => {
    console.error("Failed to start claude command:", error.message);
    console.log(
      "Make sure Claude Code is installed: npm install -g @anthropic-ai/claude-code"
    );
    decrementReferenceCount();
    process.exit(1);
  });
  claudeProcess.on("close", (code) => {
    decrementReferenceCount();
    closeService();
    process.exit(code || 0);
  });
}

// package.json
var version = "1.0.32";

// src/cli.ts
var import_child_process2 = require("child_process");
init_constants();
var import_fs5 = __toESM(require("fs"));
var import_path5 = require("path");
var command = process.argv[2];
var HELP_TEXT = `
Usage: ccr [command]

Commands:
  start         Start server 
  stop          Stop server
  restart       Restart server
  status        Show server status
  code          Execute claude command
  -v, version   Show version information
  -h, help      Show help information

Example:
  ccr start
  ccr code "Write a Hello World"
`;
async function waitForService(timeout = 1e4, initialDelay = 1e3) {
  await new Promise((resolve) => setTimeout(resolve, initialDelay));
  const startTime = Date.now();
  while (Date.now() - startTime < timeout) {
    if (isServiceRunning()) {
      await new Promise((resolve) => setTimeout(resolve, 500));
      return true;
    }
    await new Promise((resolve) => setTimeout(resolve, 100));
  }
  return false;
}
async function main() {
  switch (command) {
    case "start":
      run();
      break;
    case "stop":
      try {
        const pid = parseInt((0, import_fs5.readFileSync)(PID_FILE, "utf-8"));
        process.kill(pid);
        cleanupPidFile();
        if ((0, import_fs5.existsSync)(REFERENCE_COUNT_FILE)) {
          try {
            import_fs5.default.unlinkSync(REFERENCE_COUNT_FILE);
          } catch (e) {
          }
        }
        console.log(
          "claude code router service has been successfully stopped."
        );
      } catch (e) {
        console.log(
          "Failed to stop the service. It may have already been stopped."
        );
        cleanupPidFile();
      }
      break;
    case "status":
      await showStatus();
      break;
    case "code":
      if (!isServiceRunning()) {
        console.log("Service not running, starting service...");
        const cliPath2 = (0, import_path5.join)(__dirname, "cli.js");
        const startProcess2 = (0, import_child_process2.spawn)("node", [cliPath2, "start"], {
          detached: true,
          stdio: "ignore"
        });
        startProcess2.on("error", (error) => {
          console.error("Failed to start service:", error.message);
          process.exit(1);
        });
        startProcess2.unref();
        if (await waitForService()) {
          const codeArgs = process.argv.slice(3);
          executeCodeCommand(codeArgs);
        } else {
          console.error(
            "Service startup timeout, please manually run `ccr start` to start the service"
          );
          process.exit(1);
        }
      } else {
        const codeArgs = process.argv.slice(3);
        executeCodeCommand(codeArgs);
      }
      break;
    case "-v":
    case "version":
      console.log(`claude-code-router version: ${version}`);
      break;
    case "restart":
      try {
        const pid = parseInt((0, import_fs5.readFileSync)(PID_FILE, "utf-8"));
        process.kill(pid);
        cleanupPidFile();
        if ((0, import_fs5.existsSync)(REFERENCE_COUNT_FILE)) {
          try {
            import_fs5.default.unlinkSync(REFERENCE_COUNT_FILE);
          } catch (e) {
          }
        }
        console.log("claude code router service has been stopped.");
      } catch (e) {
        console.log("Service was not running or failed to stop.");
        cleanupPidFile();
      }
      console.log("Starting claude code router service...");
      const cliPath = (0, import_path5.join)(__dirname, "cli.js");
      const startProcess = (0, import_child_process2.spawn)("node", [cliPath, "start"], {
        detached: true,
        stdio: "ignore"
      });
      startProcess.on("error", (error) => {
        console.error("Failed to start service:", error);
        process.exit(1);
      });
      startProcess.unref();
      console.log("\u2705 Service started successfully in the background.");
      break;
    case "-h":
    case "help":
      console.log(HELP_TEXT);
      break;
    default:
      console.log(HELP_TEXT);
      process.exit(1);
  }
}
main().catch(console.error);
/*! Bundled license information:

@fastify/forwarded/index.js:
  (*!
   * forwarded
   * Copyright(c) 2014-2017 Douglas Christopher Wilson
   * MIT Licensed
   *)

@fastify/proxy-addr/index.js:
  (*!
   * proxy-addr
   * Copyright(c) 2021 Fastify collaborators
   * Copyright(c) 2014-2016 Douglas Christopher Wilson
   * MIT Licensed
   *)

toad-cache/dist/toad-cache.cjs:
  (**
   * toad-cache
   *
   * @copyright 2024 Igor Savin <kibertoad@gmail.com>
   * @license MIT
   * @version 3.7.0
   *)

light-my-request/lib/form-data.js:
undici/lib/web/fetch/body.js:
  (*! formdata-polyfill. MIT License. Jimmy Wrting <https://jimmy.warting.se/opensource> *)

undici/lib/web/websocket/frame.js:
  (*! ws. MIT License. Einar Otto Stangvik <einaros@gmail.com> *)

escape-html/index.js:
  (*!
   * escape-html
   * Copyright(c) 2012-2013 TJ Holowaychuk
   * Copyright(c) 2015 Andreas Lubbe
   * Copyright(c) 2015 Tiancheng "Timothy" Gu
   * MIT Licensed
   *)

@fastify/send/lib/containsDotFile.js:
@fastify/send/lib/contentRange.js:
@fastify/send/lib/createHtmlDocument.js:
@fastify/send/index.js:
  (*!
   * send
   * Copyright(c) 2012 TJ Holowaychuk
   * Copyright(c) 2014-2022 Douglas Christopher Wilson
   * MIT Licensed
   *)

@fastify/send/lib/parseBytesRange.js:
  (*!
   * Based on range-parser
   *
   * Copyright(c) 2012-2014 TJ Holowaychuk
   * Copyright(c) 2015-2016 Douglas Christopher Wilson
   * MIT Licensed
   *)

depd/index.js:
  (*!
   * depd
   * Copyright(c) 2014-2018 Douglas Christopher Wilson
   * MIT Licensed
   *)

statuses/index.js:
  (*!
   * statuses
   * Copyright(c) 2014 Jonathan Ong
   * Copyright(c) 2016 Douglas Christopher Wilson
   * MIT Licensed
   *)

toidentifier/index.js:
  (*!
   * toidentifier
   * Copyright(c) 2016 Douglas Christopher Wilson
   * MIT Licensed
   *)

http-errors/index.js:
  (*!
   * http-errors
   * Copyright(c) 2014 Jonathan Ong
   * Copyright(c) 2016 Douglas Christopher Wilson
   * MIT Licensed
   *)

safe-buffer/index.js:
  (*! safe-buffer. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> *)

content-disposition/index.js:
  (*!
   * content-disposition
   * Copyright(c) 2014-2017 Douglas Christopher Wilson
   * MIT Licensed
   *)

@musistudio/llms/dist/esm/server.mjs:
  (*! Bundled license information:
  
  web-streams-polyfill/dist/ponyfill.es2018.js:
    (**
     * @license
     * web-streams-polyfill v3.3.3
     * Copyright 2024 Mattias Buelens, Diwank Singh Tomer and other contributors.
     * This code is released under the MIT license.
     * SPDX-License-Identifier: MIT
     *)
  
  fetch-blob/index.js:
    (*! fetch-blob. MIT License. Jimmy Wrting <https://jimmy.warting.se/opensource> *)
  
  formdata-polyfill/esm.min.js:
    (*! formdata-polyfill. MIT License. Jimmy Wrting <https://jimmy.warting.se/opensource> *)
  
  node-domexception/index.js:
    (*! node-domexception. MIT License. Jimmy Wrting <https://jimmy.warting.se/opensource> *)
  
  safe-buffer/index.js:
    (*! safe-buffer. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> *)
  
  gtoken/build/cjs/src/index.cjs:
    (*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/babel/babel/blob/main/packages/babel-helpers/LICENSE *)
  *)
*/
